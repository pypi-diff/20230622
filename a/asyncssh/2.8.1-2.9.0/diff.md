# Comparing `tmp/asyncssh-2.8.1.tar.gz` & `tmp/asyncssh-2.9.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/asyncssh-2.8.1.tar", last modified: Mon Nov  8 14:59:31 2021, max compression
+gzip compressed data, was "dist/asyncssh-2.9.0.tar", last modified: Sun Jan 23 16:54:38 2022, max compression
```

## Comparing `asyncssh-2.8.1.tar` & `asyncssh-2.9.0.tar`

### file list

```diff
@@ -1,182 +1,184 @@
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/
--rw-r--r--   0 ronf       (501) staff       (20)     8448 2021-11-08 14:59:31.000000 asyncssh-2.8.1/PKG-INFO
--rw-r--r--   0 ronf       (501) staff       (20)    14198 2018-09-08 21:52:10.000000 asyncssh-2.8.1/LICENSE
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/asyncssh/
--rw-r--r--   0 ronf       (501) staff       (20)    10008 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/auth_keys.py
--rw-r--r--   0 ronf       (501) staff       (20)    29646 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/auth.py
--rw-r--r--   0 ronf       (501) staff       (20)     6745 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/logging.py
--rw-r--r--   0 ronf       (501) staff       (20)    20118 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/misc.py
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/asyncssh/crypto/
--rw-r--r--   0 ronf       (501) staff       (20)     1267 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/misc.py
--rw-r--r--   0 ronf       (501) staff       (20)     5934 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/ec.py
--rw-r--r--   0 ronf       (501) staff       (20)     5055 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/chacha.py
--rw-r--r--   0 ronf       (501) staff       (20)    13740 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/x509.py
--rw-r--r--   0 ronf       (501) staff       (20)     4575 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/rsa.py
--rw-r--r--   0 ronf       (501) staff       (20)     1790 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/__init__.py
--rw-r--r--   0 ronf       (501) staff       (20)     4671 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/ec_params.py
--rw-r--r--   0 ronf       (501) staff       (20)     5290 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/cipher.py
--rw-r--r--   0 ronf       (501) staff       (20)     3464 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/dsa.py
--rw-r--r--   0 ronf       (501) staff       (20)     1181 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/kdf.py
--rw-r--r--   0 ronf       (501) staff       (20)     9755 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/ed.py
--rw-r--r--   0 ronf       (501) staff       (20)     3577 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/crypto/umac.py
--rw-r--r--   0 ronf       (501) staff       (20)     1733 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/gss.py
--rw-r--r--   0 ronf       (501) staff       (20)    38675 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/server.py
--rw-r--r--   0 ronf       (501) staff       (20)     9105 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/encryption.py
--rw-r--r--   0 ronf       (501) staff       (20)    20130 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/config.py
--rw-r--r--   0 ronf       (501) staff       (20)      898 2021-11-08 14:36:03.000000 asyncssh-2.8.1/asyncssh/version.py
--rw-r--r--   0 ronf       (501) staff       (20)     7812 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/rsa.py
--rw-r--r--   0 ronf       (501) staff       (20)    16000 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/client.py
--rw-r--r--   0 ronf       (501) staff       (20)     9681 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/subprocess.py
--rw-r--r--   0 ronf       (501) staff       (20)     3309 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/compression.py
--rw-r--r--   0 ronf       (501) staff       (20)    69845 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/channel.py
--rw-r--r--   0 ronf       (501) staff       (20)     8298 2021-07-02 13:28:16.000000 asyncssh-2.8.1/asyncssh/constants.py
--rw-r--r--   0 ronf       (501) staff       (20)    19612 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/session.py
--rw-r--r--   0 ronf       (501) staff       (20)     4048 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/__init__.py
--rw-r--r--   0 ronf       (501) staff       (20)     4180 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/pattern.py
--rw-r--r--   0 ronf       (501) staff       (20)     5026 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/kex_rsa.py
--rw-r--r--   0 ronf       (501) staff       (20)    11967 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/known_hosts.py
--rw-r--r--   0 ronf       (501) staff       (20)    23180 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/stream.py
--rw-r--r--   0 ronf       (501) staff       (20)     3561 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/kex.py
--rw-r--r--   0 ronf       (501) staff       (20)   297290 2021-11-08 14:35:51.000000 asyncssh-2.8.1/asyncssh/connection.py
--rw-r--r--   0 ronf       (501) staff       (20)    28487 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/kex_dh.py
--rw-r--r--   0 ronf       (501) staff       (20)     9738 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/pkcs11.py
--rw-r--r--   0 ronf       (501) staff       (20)     3354 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/keysign.py
--rw-r--r--   0 ronf       (501) staff       (20)     3465 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/saslprep.py
--rw-r--r--   0 ronf       (501) staff       (20)     4174 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/gss_unix.py
--rw-r--r--   0 ronf       (501) staff       (20)     6872 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/socks.py
--rw-r--r--   0 ronf       (501) staff       (20)    11041 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/ecdsa.py
--rw-r--r--   0 ronf       (501) staff       (20)    18769 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/pbe.py
--rw-r--r--   0 ronf       (501) staff       (20)     7407 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/dsa.py
--rw-r--r--   0 ronf       (501) staff       (20)    20779 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/agent.py
--rw-r--r--   0 ronf       (501) staff       (20)     6206 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/sk_eddsa.py
--rw-r--r--   0 ronf       (501) staff       (20)     7752 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/sk.py
--rw-r--r--   0 ronf       (501) staff       (20)     4991 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/forward.py
--rw-r--r--   0 ronf       (501) staff       (20)     5575 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/packet.py
--rw-r--r--   0 ronf       (501) staff       (20)    48151 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/process.py
--rw-r--r--   0 ronf       (501) staff       (20)     1008 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/agent_unix.py
--rw-r--r--   0 ronf       (501) staff       (20)     7109 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/sk_ecdsa.py
--rw-r--r--   0 ronf       (501) staff       (20)   167641 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/sftp.py
--rw-r--r--   0 ronf       (501) staff       (20)    26649 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/editor.py
--rw-r--r--   0 ronf       (501) staff       (20)   117985 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/public_key.py
--rw-r--r--   0 ronf       (501) staff       (20)     4632 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/agent_win32.py
--rw-r--r--   0 ronf       (501) staff       (20)     6528 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/eddsa.py
--rw-r--r--   0 ronf       (501) staff       (20)    32416 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/scp.py
--rw-r--r--   0 ronf       (501) staff       (20)     5040 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/gss_win32.py
--rw-r--r--   0 ronf       (501) staff       (20)    15286 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/x11.py
--rw-r--r--   0 ronf       (501) staff       (20)     9949 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/listener.py
--rw-r--r--   0 ronf       (501) staff       (20)    21865 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/asn1.py
--rw-r--r--   0 ronf       (501) staff       (20)     6428 2021-11-08 14:35:20.000000 asyncssh-2.8.1/asyncssh/mac.py
--rw-r--r--   0 ronf       (501) staff       (20)     3836 2018-09-08 21:52:10.000000 asyncssh-2.8.1/CONTRIBUTING.rst
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/tests/
--rw-r--r--   0 ronf       (501) staff       (20)    10186 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_x509.py
--rw-r--r--   0 ronf       (501) staff       (20)    99586 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_public_key.py
--rw-r--r--   0 ronf       (501) staff       (20)     1540 2019-10-19 22:44:51.000000 asyncssh-2.8.1/tests/test_compression.py
--rw-r--r--   0 ronf       (501) staff       (20)     6268 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_pkcs11.py
--rw-r--r--   0 ronf       (501) staff       (20)    12560 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/server.py
--rw-r--r--   0 ronf       (501) staff       (20)    15378 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_agent.py
--rw-r--r--   0 ronf       (501) staff       (20)     6225 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/test_logging.py
--rw-r--r--   0 ronf       (501) staff       (20)     6864 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_packet.py
--rw-r--r--   0 ronf       (501) staff       (20)    22015 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/test_kex.py
--rw-r--r--   0 ronf       (501) staff       (20)    25501 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_auth.py
--rw-r--r--   0 ronf       (501) staff       (20)    11530 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_known_hosts.py
--rw-r--r--   0 ronf       (501) staff       (20)    10990 2021-09-16 01:32:20.000000 asyncssh-2.8.1/tests/util.py
--rw-r--r--   0 ronf       (501) staff       (20)    16138 2021-08-03 13:30:54.000000 asyncssh-2.8.1/tests/test_editor.py
--rw-r--r--   0 ronf       (501) staff       (20)    72009 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_connection.py
--rw-r--r--   0 ronf       (501) staff       (20)     1545 2019-10-19 22:44:51.000000 asyncssh-2.8.1/tests/gss_stub.py
--rw-r--r--   0 ronf       (501) staff       (20)      756 2019-10-19 22:44:51.000000 asyncssh-2.8.1/tests/__init__.py
--rw-r--r--   0 ronf       (501) staff       (20)    10355 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/sk_stub.py
--rw-r--r--   0 ronf       (501) staff       (20)     6994 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/pkcs11_stub.py
--rw-r--r--   0 ronf       (501) staff       (20)    55976 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_channel.py
--rw-r--r--   0 ronf       (501) staff       (20)    70701 2021-11-08 14:35:51.000000 asyncssh-2.8.1/tests/test_connection_auth.py
--rw-r--r--   0 ronf       (501) staff       (20)     8563 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/test_subprocess.py
--rw-r--r--   0 ronf       (501) staff       (20)    41364 2021-11-08 14:35:51.000000 asyncssh-2.8.1/tests/test_forward.py
--rw-r--r--   0 ronf       (501) staff       (20)     3523 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/gssapi_stub.py
--rw-r--r--   0 ronf       (501) staff       (20)    42362 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_process.py
--rw-r--r--   0 ronf       (501) staff       (20)    13472 2021-08-24 03:37:32.000000 asyncssh-2.8.1/tests/test_sk.py
--rw-r--r--   0 ronf       (501) staff       (20)    17022 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_config.py
--rw-r--r--   0 ronf       (501) staff       (20)     8739 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/test_auth_keys.py
--rw-r--r--   0 ronf       (501) staff       (20)     2324 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_mac.py
--rw-r--r--   0 ronf       (501) staff       (20)    20852 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_x11.py
--rw-r--r--   0 ronf       (501) staff       (20)     8564 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_asn1.py
--rw-r--r--   0 ronf       (501) staff       (20)     3356 2019-10-19 22:44:51.000000 asyncssh-2.8.1/tests/test_saslprep.py
--rw-r--r--   0 ronf       (501) staff       (20)     3783 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/sspi_stub.py
--rw-r--r--   0 ronf       (501) staff       (20)     1838 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/keysign_stub.py
--rw-r--r--   0 ronf       (501) staff       (20)    12242 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/test_stream.py
--rw-r--r--   0 ronf       (501) staff       (20)     2748 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tests/test_encryption.py
--rw-r--r--   0 ronf       (501) staff       (20)   118425 2021-11-08 14:35:20.000000 asyncssh-2.8.1/tests/test_sftp.py
--rw-r--r--   0 ronf       (501) staff       (20)      104 2021-07-02 13:28:16.000000 asyncssh-2.8.1/MANIFEST.in
--rw-r--r--   0 ronf       (501) staff       (20)      167 2021-11-08 14:35:20.000000 asyncssh-2.8.1/.coveragerc
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/docs/
--rw-r--r--   0 ronf       (501) staff       (20)    23158 2021-07-02 13:28:16.000000 asyncssh-2.8.1/docs/index.rst
--rw-r--r--   0 ronf       (501) staff       (20)       33 2020-05-23 18:41:04.000000 asyncssh-2.8.1/docs/contributing.rst
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/docs/_templates/
--rw-r--r--   0 ronf       (501) staff       (20)      492 2021-07-02 13:28:16.000000 asyncssh-2.8.1/docs/_templates/sidebarbottom.html
--rw-r--r--   0 ronf       (501) staff       (20)       83 2013-09-15 03:03:23.000000 asyncssh-2.8.1/docs/_templates/sidebartop.html
--rw-r--r--   0 ronf       (501) staff       (20)       22 2015-05-18 03:37:23.000000 asyncssh-2.8.1/docs/rtd-req.txt
--rw-r--r--   0 ronf       (501) staff       (20)     7916 2021-11-08 14:35:20.000000 asyncssh-2.8.1/docs/conf.py
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/docs/rftheme/
--rw-r--r--   0 ronf       (501) staff       (20)      179 2013-09-14 15:04:13.000000 asyncssh-2.8.1/docs/rftheme/layout.html
--rw-r--r--   0 ronf       (501) staff       (20)       75 2015-04-11 20:44:46.000000 asyncssh-2.8.1/docs/rftheme/theme.conf
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/docs/rftheme/static/
--rw-r--r--   0 ronf       (501) staff       (20)      396 2015-04-11 20:44:46.000000 asyncssh-2.8.1/docs/rftheme/static/rftheme.css_t
--rw-r--r--   0 ronf       (501) staff       (20)    89005 2021-11-08 14:40:13.000000 asyncssh-2.8.1/docs/changes.rst
--rw-r--r--   0 ronf       (501) staff       (20)    74104 2021-09-26 15:38:12.000000 asyncssh-2.8.1/docs/api.rst
--rw-r--r--   0 ronf       (501) staff       (20)      413 2021-07-02 13:28:16.000000 asyncssh-2.8.1/appveyor.yml
--rwxr-xr-x   0 ronf       (501) staff       (20)     2842 2021-11-08 14:35:20.000000 asyncssh-2.8.1/setup.py
--rw-r--r--   0 ronf       (501) staff       (20)       98 2020-05-16 15:38:29.000000 asyncssh-2.8.1/.gitignore
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/examples/
--rwxr-xr-x   0 ronf       (501) staff       (20)     1507 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/remote_forwarding_client2.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2077 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/simple_keyed_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1021 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/scp_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1200 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/local_forwarding_client2.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1097 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/redirect_input.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1946 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/show_environment.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1384 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/callback_client2.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1284 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/redirect_local_pipe.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1505 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/callback_client3.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2589 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/chat_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2560 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/callback_math_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1771 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/chroot_sftp_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1225 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/set_terminal.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1723 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/simple_cert_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1925 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/redirect_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1659 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/callback_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1505 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/stream_listening_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1117 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/sftp_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1638 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/listening_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1321 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/check_exit_status.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2102 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/direct_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2401 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/show_terminal.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1136 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/remote_forwarding_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1184 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/set_environment.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1912 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/local_forwarding_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1556 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/simple_scp_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1623 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/gather_results.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1280 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/math_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1384 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/stream_direct_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2305 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/reverse_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2466 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/simple_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1195 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/redirect_remote_pipe.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2083 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/editor.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1660 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/direct_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1140 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/local_forwarding_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1540 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/simple_sftp_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1684 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/remote_forwarding_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2145 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/stream_direct_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2072 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/math_server.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     1113 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/simple_client.py
--rwxr-xr-x   0 ronf       (501) staff       (20)     2414 2021-11-08 14:35:20.000000 asyncssh-2.8.1/examples/reverse_server.py
--rw-r--r--   0 ronf       (501) staff       (20)      514 2021-07-02 13:28:16.000000 asyncssh-2.8.1/tox.ini
--rw-r--r--   0 ronf       (501) staff       (20)    11593 2021-11-08 14:35:20.000000 asyncssh-2.8.1/pylintrc
--rw-r--r--   0 ronf       (501) staff       (20)       38 2021-11-08 14:59:31.000000 asyncssh-2.8.1/setup.cfg
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/.travis/
--rwxr-xr-x   0 ronf       (501) staff       (20)      591 2019-08-10 22:48:24.000000 asyncssh-2.8.1/.travis/install.sh
-drwxr-xr-x   0 ronf       (501) staff       (20)        0 2021-11-08 14:59:31.000000 asyncssh-2.8.1/asyncssh.egg-info/
--rw-r--r--   0 ronf       (501) staff       (20)     8448 2021-11-08 14:59:30.000000 asyncssh-2.8.1/asyncssh.egg-info/PKG-INFO
--rw-r--r--   0 ronf       (501) staff       (20)     3806 2021-11-08 14:59:31.000000 asyncssh-2.8.1/asyncssh.egg-info/SOURCES.txt
--rw-r--r--   0 ronf       (501) staff       (20)      200 2021-11-08 14:59:30.000000 asyncssh-2.8.1/asyncssh.egg-info/requires.txt
--rw-r--r--   0 ronf       (501) staff       (20)        9 2021-11-08 14:59:30.000000 asyncssh-2.8.1/asyncssh.egg-info/top_level.txt
--rw-r--r--   0 ronf       (501) staff       (20)        1 2021-11-08 14:59:30.000000 asyncssh-2.8.1/asyncssh.egg-info/dependency_links.txt
--rw-r--r--   0 ronf       (501) staff       (20)      611 2018-09-08 21:52:10.000000 asyncssh-2.8.1/COPYRIGHT
--rw-r--r--   0 ronf       (501) staff       (20)     7372 2021-07-02 13:28:16.000000 asyncssh-2.8.1/README.rst
--rw-r--r--   0 ronf       (501) staff       (20)     2001 2021-07-02 13:28:16.000000 asyncssh-2.8.1/.travis.yml
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/
+-rw-r--r--   0 ronf       (501) staff       (20)     8515 2022-01-23 16:54:38.000000 asyncssh-2.9.0/PKG-INFO
+-rw-r--r--   0 ronf       (501) staff       (20)    14198 2018-09-08 21:52:10.000000 asyncssh-2.9.0/LICENSE
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh/
+-rw-r--r--   0 ronf       (501) staff       (20)    11821 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/auth_keys.py
+-rw-r--r--   0 ronf       (501) staff       (20)    33035 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/auth.py
+-rw-r--r--   0 ronf       (501) staff       (20)     7515 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/logging.py
+-rw-r--r--   0 ronf       (501) staff       (20)    23649 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/misc.py
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh/crypto/
+-rw-r--r--   0 ronf       (501) staff       (20)     2231 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/misc.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6472 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/ec.py
+-rw-r--r--   0 ronf       (501) staff       (20)     5573 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/chacha.py
+-rw-r--r--   0 ronf       (501) staff       (20)    15358 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/x509.py
+-rw-r--r--   0 ronf       (501) staff       (20)     5026 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/rsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1845 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/__init__.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4804 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/ec_params.py
+-rw-r--r--   0 ronf       (501) staff       (20)     5706 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/cipher.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3784 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/dsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1159 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/kdf.py
+-rw-r--r--   0 ronf       (501) staff       (20)    10772 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/ed.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4329 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/crypto/umac.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1972 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/gss.py
+-rw-r--r--   0 ronf       (501) staff       (20)    40780 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/server.py
+-rw-r--r--   0 ronf       (501) staff       (20)    11004 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/encryption.py
+-rw-r--r--   0 ronf       (501) staff       (20)    21272 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/config.py
+-rw-r--r--   0 ronf       (501) staff       (20)      898 2022-01-23 16:16:04.000000 asyncssh-2.9.0/asyncssh/version.py
+-rw-r--r--   0 ronf       (501) staff       (20)     9258 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/rsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)    16866 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/client.py
+-rw-r--r--   0 ronf       (501) staff       (20)    10872 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/subprocess.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4162 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/compression.py
+-rw-r--r--   0 ronf       (501) staff       (20)    77893 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/channel.py
+-rw-r--r--   0 ronf       (501) staff       (20)    13385 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/constants.py
+-rw-r--r--   0 ronf       (501) staff       (20)    21523 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/session.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4851 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/__init__.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4662 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/pattern.py
+-rw-r--r--   0 ronf       (501) staff       (20)     5953 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/kex_rsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)    14087 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/known_hosts.py
+-rw-r--r--   0 ronf       (501) staff       (20)    27703 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/stream.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4468 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/kex.py
+-rw-r--r--   0 ronf       (501) staff       (20)   336047 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/connection.py
+-rw-r--r--   0 ronf       (501) staff       (20)    30698 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/kex_dh.py
+-rw-r--r--   0 ronf       (501) staff       (20)    11370 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/pkcs11.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3749 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/keysign.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3547 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/saslprep.py
+-rw-r--r--   0 ronf       (501) staff       (20)     4741 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/gss_unix.py
+-rw-r--r--   0 ronf       (501) staff       (20)     7514 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/socks.py
+-rw-r--r--   0 ronf       (501) staff       (20)    12211 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/ecdsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)    20674 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/pbe.py
+-rw-r--r--   0 ronf       (501) staff       (20)     8412 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/dsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)    23179 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/agent.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6882 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/sk_eddsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)     9167 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/sk.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6091 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/forward.py
+-rw-r--r--   0 ronf       (501) staff       (20)        0 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/py.typed
+-rw-r--r--   0 ronf       (501) staff       (20)     6655 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/packet.py
+-rw-r--r--   0 ronf       (501) staff       (20)    58350 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/process.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1226 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/agent_unix.py
+-rw-r--r--   0 ronf       (501) staff       (20)     7859 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/sk_ecdsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)   260641 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/sftp.py
+-rw-r--r--   0 ronf       (501) staff       (20)    29092 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/editor.py
+-rw-r--r--   0 ronf       (501) staff       (20)   133707 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/public_key.py
+-rw-r--r--   0 ronf       (501) staff       (20)     5213 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/agent_win32.py
+-rw-r--r--   0 ronf       (501) staff       (20)     7319 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/eddsa.py
+-rw-r--r--   0 ronf       (501) staff       (20)    37697 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/scp.py
+-rw-r--r--   0 ronf       (501) staff       (20)     5684 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/gss_win32.py
+-rw-r--r--   0 ronf       (501) staff       (20)    16985 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/x11.py
+-rw-r--r--   0 ronf       (501) staff       (20)    12650 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/listener.py
+-rw-r--r--   0 ronf       (501) staff       (20)    24462 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/asn1.py
+-rw-r--r--   0 ronf       (501) staff       (20)     7140 2022-01-23 16:15:42.000000 asyncssh-2.9.0/asyncssh/mac.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3836 2018-09-08 21:52:10.000000 asyncssh-2.9.0/CONTRIBUTING.rst
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/tests/
+-rw-r--r--   0 ronf       (501) staff       (20)    10245 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_x509.py
+-rw-r--r--   0 ronf       (501) staff       (20)    99843 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_public_key.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1540 2019-10-19 22:44:51.000000 asyncssh-2.9.0/tests/test_compression.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6273 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_pkcs11.py
+-rw-r--r--   0 ronf       (501) staff       (20)    12560 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/server.py
+-rw-r--r--   0 ronf       (501) staff       (20)    15831 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_agent.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6225 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/test_logging.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6864 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_packet.py
+-rw-r--r--   0 ronf       (501) staff       (20)    22015 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/test_kex.py
+-rw-r--r--   0 ronf       (501) staff       (20)    25501 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_auth.py
+-rw-r--r--   0 ronf       (501) staff       (20)    11526 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_known_hosts.py
+-rw-r--r--   0 ronf       (501) staff       (20)    10990 2021-09-16 01:32:20.000000 asyncssh-2.9.0/tests/util.py
+-rw-r--r--   0 ronf       (501) staff       (20)    16138 2021-08-03 13:30:54.000000 asyncssh-2.9.0/tests/test_editor.py
+-rw-r--r--   0 ronf       (501) staff       (20)    72941 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_connection.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1545 2019-10-19 22:44:51.000000 asyncssh-2.9.0/tests/gss_stub.py
+-rw-r--r--   0 ronf       (501) staff       (20)      756 2019-10-19 22:44:51.000000 asyncssh-2.9.0/tests/__init__.py
+-rw-r--r--   0 ronf       (501) staff       (20)    10355 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/sk_stub.py
+-rw-r--r--   0 ronf       (501) staff       (20)     6999 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/pkcs11_stub.py
+-rw-r--r--   0 ronf       (501) staff       (20)    55977 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_channel.py
+-rw-r--r--   0 ronf       (501) staff       (20)    70701 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_connection_auth.py
+-rw-r--r--   0 ronf       (501) staff       (20)     8563 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/test_subprocess.py
+-rw-r--r--   0 ronf       (501) staff       (20)    42359 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_forward.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3523 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/gssapi_stub.py
+-rw-r--r--   0 ronf       (501) staff       (20)    42362 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_process.py
+-rw-r--r--   0 ronf       (501) staff       (20)    13472 2021-08-24 03:37:32.000000 asyncssh-2.9.0/tests/test_sk.py
+-rw-r--r--   0 ronf       (501) staff       (20)    17011 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_config.py
+-rw-r--r--   0 ronf       (501) staff       (20)     8739 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/test_auth_keys.py
+-rw-r--r--   0 ronf       (501) staff       (20)     2324 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_mac.py
+-rw-r--r--   0 ronf       (501) staff       (20)    21383 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_x11.py
+-rw-r--r--   0 ronf       (501) staff       (20)     8564 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_asn1.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3356 2019-10-19 22:44:51.000000 asyncssh-2.9.0/tests/test_saslprep.py
+-rw-r--r--   0 ronf       (501) staff       (20)     3783 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/sspi_stub.py
+-rw-r--r--   0 ronf       (501) staff       (20)     1838 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/keysign_stub.py
+-rw-r--r--   0 ronf       (501) staff       (20)    12242 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/test_stream.py
+-rw-r--r--   0 ronf       (501) staff       (20)     2748 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tests/test_encryption.py
+-rw-r--r--   0 ronf       (501) staff       (20)   173149 2022-01-23 16:15:42.000000 asyncssh-2.9.0/tests/test_sftp.py
+-rw-r--r--   0 ronf       (501) staff       (20)      104 2021-07-02 13:28:16.000000 asyncssh-2.9.0/MANIFEST.in
+-rw-r--r--   0 ronf       (501) staff       (20)      189 2022-01-23 16:15:42.000000 asyncssh-2.9.0/.coveragerc
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/docs/
+-rw-r--r--   0 ronf       (501) staff       (20)    23158 2021-07-02 13:28:16.000000 asyncssh-2.9.0/docs/index.rst
+-rw-r--r--   0 ronf       (501) staff       (20)       33 2020-05-23 18:41:04.000000 asyncssh-2.9.0/docs/contributing.rst
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/docs/_templates/
+-rw-r--r--   0 ronf       (501) staff       (20)      492 2021-07-02 13:28:16.000000 asyncssh-2.9.0/docs/_templates/sidebarbottom.html
+-rw-r--r--   0 ronf       (501) staff       (20)       83 2013-09-15 03:03:23.000000 asyncssh-2.9.0/docs/_templates/sidebartop.html
+-rw-r--r--   0 ronf       (501) staff       (20)       32 2022-01-23 16:15:42.000000 asyncssh-2.9.0/docs/rtd-req.txt
+-rw-r--r--   0 ronf       (501) staff       (20)     7944 2022-01-23 16:15:42.000000 asyncssh-2.9.0/docs/conf.py
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/docs/rftheme/
+-rw-r--r--   0 ronf       (501) staff       (20)      179 2013-09-14 15:04:13.000000 asyncssh-2.9.0/docs/rftheme/layout.html
+-rw-r--r--   0 ronf       (501) staff       (20)       75 2015-04-11 20:44:46.000000 asyncssh-2.9.0/docs/rftheme/theme.conf
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/docs/rftheme/static/
+-rw-r--r--   0 ronf       (501) staff       (20)      396 2015-04-11 20:44:46.000000 asyncssh-2.9.0/docs/rftheme/static/rftheme.css_t
+-rw-r--r--   0 ronf       (501) staff       (20)    90305 2022-01-23 16:35:21.000000 asyncssh-2.9.0/docs/changes.rst
+-rw-r--r--   0 ronf       (501) staff       (20)    78909 2022-01-23 16:15:42.000000 asyncssh-2.9.0/docs/api.rst
+-rw-r--r--   0 ronf       (501) staff       (20)       63 2022-01-23 16:15:42.000000 asyncssh-2.9.0/mypy.ini
+-rw-r--r--   0 ronf       (501) staff       (20)      394 2022-01-23 16:15:42.000000 asyncssh-2.9.0/appveyor.yml
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2919 2022-01-23 16:15:42.000000 asyncssh-2.9.0/setup.py
+-rw-r--r--   0 ronf       (501) staff       (20)       98 2020-05-16 15:38:29.000000 asyncssh-2.9.0/.gitignore
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/examples/
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1645 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/remote_forwarding_client2.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2171 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/simple_keyed_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1029 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/scp_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1208 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/local_forwarding_client2.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1105 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/redirect_input.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1989 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/show_environment.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1481 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/callback_client2.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1292 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/redirect_local_pipe.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1602 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/callback_client3.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2815 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/chat_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2721 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/callback_math_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1806 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/chroot_sftp_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1233 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/set_terminal.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1766 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/simple_cert_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1968 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/redirect_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1802 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/callback_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1505 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/stream_listening_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1125 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/sftp_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1765 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/listening_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1327 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/check_exit_status.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2253 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/direct_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2444 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/show_terminal.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1144 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/remote_forwarding_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1192 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/set_environment.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1977 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/local_forwarding_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1564 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/simple_scp_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1668 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/gather_results.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1288 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/math_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1392 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/stream_direct_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2388 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/reverse_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2643 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/simple_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1203 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/redirect_remote_pipe.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2188 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/editor.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1759 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/direct_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1148 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/local_forwarding_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1548 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/simple_sftp_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1710 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/remote_forwarding_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2328 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/stream_direct_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2115 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/math_server.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     1121 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/simple_client.py
+-rwxr-xr-x   0 ronf       (501) staff       (20)     2460 2022-01-23 16:15:42.000000 asyncssh-2.9.0/examples/reverse_server.py
+-rw-r--r--   0 ronf       (501) staff       (20)      514 2021-07-02 13:28:16.000000 asyncssh-2.9.0/tox.ini
+-rw-r--r--   0 ronf       (501) staff       (20)    11598 2022-01-23 16:15:42.000000 asyncssh-2.9.0/pylintrc
+-rw-r--r--   0 ronf       (501) staff       (20)       38 2022-01-23 16:54:38.000000 asyncssh-2.9.0/setup.cfg
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/.travis/
+-rwxr-xr-x   0 ronf       (501) staff       (20)      591 2019-08-10 22:48:24.000000 asyncssh-2.9.0/.travis/install.sh
+drwxr-xr-x   0 ronf       (501) staff       (20)        0 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh.egg-info/
+-rw-r--r--   0 ronf       (501) staff       (20)     8515 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh.egg-info/PKG-INFO
+-rw-r--r--   0 ronf       (501) staff       (20)     3833 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh.egg-info/SOURCES.txt
+-rw-r--r--   0 ronf       (501) staff       (20)      223 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh.egg-info/requires.txt
+-rw-r--r--   0 ronf       (501) staff       (20)        9 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh.egg-info/top_level.txt
+-rw-r--r--   0 ronf       (501) staff       (20)        1 2022-01-23 16:54:38.000000 asyncssh-2.9.0/asyncssh.egg-info/dependency_links.txt
+-rw-r--r--   0 ronf       (501) staff       (20)      611 2018-09-08 21:52:10.000000 asyncssh-2.9.0/COPYRIGHT
+-rw-r--r--   0 ronf       (501) staff       (20)     7439 2022-01-23 16:15:42.000000 asyncssh-2.9.0/README.rst
+-rw-r--r--   0 ronf       (501) staff       (20)     2001 2021-07-02 13:28:16.000000 asyncssh-2.9.0/.travis.yml
```

### Comparing `asyncssh-2.8.1/PKG-INFO` & `asyncssh-2.9.0/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: asyncssh
-Version: 2.8.1
+Version: 2.9.0
 Summary: AsyncSSH: Asynchronous SSHv2 client and server library
 Home-page: http://asyncssh.timeheart.net
 Author: Ron Frederick
 Author-email: ronf@timeheart.net
 License: Eclipse Public License v2.0
 Platform: Any
 Classifier: Development Status :: 5 - Production/Stable
@@ -65,14 +65,17 @@
   * Direct and forwarded TCP/IP channels
   * OpenSSH-compatible direct and forwarded UNIX domain socket channels
   * Local and remote TCP/IP port forwarding
   * Local and remote UNIX domain socket forwarding
   * Dynamic TCP/IP port forwarding via SOCKS
   * X11 forwarding support on both the client and the server
   * SFTP protocol version 3 with OpenSSH extensions
+
+    * Experimental support for SFTP versions 4-6, when requested
+
   * SCP protocol support, including third-party remote to remote copies
 
 * Multiple simultaneous sessions on a single SSH connection
 * Multiple SSH connections in a single event loop
 * Byte and string based I/O with settable encoding
 * A variety of `key exchange`__, `encryption`__, and `MAC`__ algorithms
 * Support for `gzip compression`__
@@ -113,15 +116,15 @@
 __ http://asyncssh.readthedocs.io/en/stable/api.html#config-file-support
 
 License
 -------
 
 This package is released under the following terms:
 
-  Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
+  Copyright (c) 2013-2022 by Ron Frederick <ronf@timeheart.net> and others.
 
   This program and the accompanying materials are made available under
   the terms of the Eclipse Public License v2.0 which accompanies this
   distribution and is available at:
 
     http://www.eclipse.org/legal/epl-2.0/
```

### Comparing `asyncssh-2.8.1/LICENSE` & `asyncssh-2.9.0/LICENSE`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/asyncssh/auth_keys.py` & `asyncssh-2.9.0/asyncssh/auth_keys.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,54 +16,62 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """Parser for SSH authorized_keys files"""
 
+from typing import Dict, List, Mapping, Optional, Sequence
+from typing import Set, Tuple, Union, cast
+
 try:
-    from .crypto import X509NamePattern
+    # pylint: disable=unused-import
+    from .crypto import X509Name, X509NamePattern
     _x509_available = True
 except ImportError: # pragma: no cover
     _x509_available = False
 
 from .misc import ip_address, read_file
 from .pattern import HostPatternList, WildcardPatternList
-from .public_key import KeyImportError, import_public_key
-from .public_key import import_certificate, import_certificate_subject
+from .public_key import KeyImportError, SSHKey
+from .public_key import SSHX509Certificate, SSHX509CertificateChain
+from .public_key import import_public_key, import_certificate
+from .public_key import import_certificate_subject
+
 
+_EntryOptions = Mapping[str, object]
 
 class _SSHAuthorizedKeyEntry:
     """An entry in an SSH authorized_keys list"""
 
-    def __init__(self, line):
-        self.key = None
-        self.cert = None
-        self.options = {}
+    def __init__(self, line: str):
+        self.key: Optional[SSHKey] = None
+        self.cert: Optional[SSHX509Certificate] = None
+        self.options: Dict[str, object] = {}
 
         try:
             self._import_key_or_cert(line)
             return
         except KeyImportError:
             pass
 
         line = self._parse_options(line)
         self._import_key_or_cert(line)
 
-    def _import_key_or_cert(self, line):
+    def _import_key_or_cert(self, line: str) -> None:
         """Import key or certificate in this entry"""
 
         try:
             self.key = import_public_key(line)
             return
         except KeyImportError:
             pass
 
         try:
-            self.cert = import_certificate(line)
+            self.cert = cast(SSHX509Certificate, import_certificate(line))
 
             if ('cert-authority' in self.options and
                     self.cert.subject != self.cert.issuer):
                 raise ValueError('X.509 cert-authority entries must '
                                  'contain a root CA certificate')
 
             return
@@ -77,86 +85,95 @@
                 self._add_subject('subject', import_certificate_subject(line))
                 return
             except KeyImportError:
                 pass
 
         raise KeyImportError('Unrecognized key, certificate, or subject')
 
-    def _set_string(self, option, value):
+    def _set_string(self, option: str, value: str) -> None:
         """Set an option with a string value"""
 
         self.options[option] = value
 
-    def _add_environment(self, option, value):
+    def _add_environment(self, option: str, value: str) -> None:
         """Add an environment key/value pair"""
 
         if value.startswith('=') or '=' not in value:
             raise ValueError('Invalid environment entry in authorized_keys')
 
         name, value = value.split('=', 1)
-        self.options.setdefault(option, {})[name] = value
+        cast(Dict[str, str], self.options.setdefault(option, {}))[name] = value
 
-    def _add_from(self, option, value):
+    def _add_from(self, option: str, value: str) -> None:
         """Add a from host pattern"""
 
-        self.options.setdefault(option, []).append(HostPatternList(value))
+        from_patterns = cast(List[HostPatternList],
+                             self.options.setdefault(option, []))
+        from_patterns.append(HostPatternList(value))
 
-    def _add_permitopen(self, option, value):
+    def _add_permitopen(self, option: str, value: str) -> None:
         """Add a permitopen host/port pair"""
 
         try:
-            host, port = value.rsplit(':', 1)
+            host, port_str = value.rsplit(':', 1)
 
             if host.startswith('[') and host.endswith(']'):
                 host = host[1:-1]
 
-            port = None if port == '*' else int(port)
+            port = None if port_str == '*' else int(port_str)
         except:
             raise ValueError('Illegal permitopen value: %s' % value) from None
 
-        self.options.setdefault(option, set()).add((host, port))
+        permitted_opens = cast(Set[Tuple[str, Optional[int]]],
+                               self.options.setdefault(option, set()))
+        permitted_opens.add((host, port))
 
-    def _add_principals(self, option, value):
+    def _add_principals(self, option: str, value: str) -> None:
         """Add a principals wildcard pattern list"""
 
-        self.options.setdefault(option, []).append(WildcardPatternList(value))
+        principal_patterns = cast(List[WildcardPatternList],
+                                  self.options.setdefault(option, []))
+        principal_patterns.append(WildcardPatternList(value))
 
-    def _add_subject(self, option, value):
+    def _add_subject(self, option: str, value: str) -> None:
         """Add an X.509 subject pattern"""
 
         if _x509_available: # pragma: no branch
-            self.options.setdefault(option, []).append(X509NamePattern(value))
+            subject_patterns = cast(List[X509NamePattern],
+                                    self.options.setdefault(option, []))
+            subject_patterns.append(X509NamePattern(value))
 
     _handlers = {
         'command':     _set_string,
         'environment': _add_environment,
         'from':        _add_from,
         'permitopen':  _add_permitopen,
         'principals':  _add_principals,
         'subject':     _add_subject
     }
 
-    def _add_option(self):
+    def _add_option(self) -> None:
         """Add an option value"""
 
         if self._option.startswith('='):
             raise ValueError('Missing option name in authorized_keys')
 
         if '=' in self._option:
             option, value = self._option.split('=', 1)
 
             handler = self._handlers.get(option)
             if handler:
                 handler(self, option, value)
             else:
-                self.options.setdefault(option, []).append(value)
+                values = cast(List[str], self.options.setdefault(option, []))
+                values.append(value)
         else:
             self.options[self._option] = True
 
-    def _parse_options(self, line):
+    def _parse_options(self, line: str) -> str:
         """Parse options in this entry"""
 
         self._option = ''
 
         idx = 0
         quoted = False
         escaped = False
@@ -184,57 +201,60 @@
         if quoted:
             raise ValueError('Unbalanced quote in authorized_keys')
         elif escaped:
             raise ValueError('Unbalanced backslash in authorized_keys')
 
         return line[idx:].strip()
 
-    def match_options(self, client_host, client_addr,
-                      cert_principals, cert_subject=None):
+    def match_options(self, client_host: str, client_addr: str,
+                      cert_principals: Optional[Sequence[str]],
+                      cert_subject: Optional['X509Name'] = None) -> bool:
         """Match "from", "principals" and "subject" options in entry"""
 
-        from_patterns = self.options.get('from')
+        from_patterns = cast(List[HostPatternList], self.options.get('from'))
 
         if from_patterns:
             client_ip = ip_address(client_addr)
 
             if not all(pattern.matches(client_host, client_addr, client_ip)
                        for pattern in from_patterns):
                 return False
 
-        principal_patterns = self.options.get('principals')
+        principal_patterns = cast(List[WildcardPatternList],
+                                  self.options.get('principals'))
 
         if cert_principals is not None and principal_patterns is not None:
             if not all(any(pattern.matches(principal)
                            for principal in cert_principals)
                        for pattern in principal_patterns):
                 return False
 
-        subject_patterns = self.options.get('subject')
+        subject_patterns = cast(List['X509NamePattern'],
+                                self.options.get('subject'))
 
         if cert_subject is not None and subject_patterns is not None:
             if not all(pattern.matches(cert_subject)
                        for pattern in subject_patterns):
                 return False
 
         return True
 
 
 class SSHAuthorizedKeys:
     """An SSH authorized keys list"""
 
-    def __init__(self, authorized_keys=None):
-        self._user_entries = []
-        self._ca_entries = []
-        self._x509_entries = []
+    def __init__(self, authorized_keys: Optional[str] = None):
+        self._user_entries: List[_SSHAuthorizedKeyEntry] = []
+        self._ca_entries: List[_SSHAuthorizedKeyEntry] = []
+        self._x509_entries: List[_SSHAuthorizedKeyEntry] = []
 
         if authorized_keys:
             self.load(authorized_keys)
 
-    def load(self, authorized_keys):
+    def load(self, authorized_keys: str) -> None:
         """Load authorized keys data into this object"""
 
         for line in authorized_keys.splitlines():
             line = line.strip()
             if not line or line.startswith('#'):
                 continue
 
@@ -251,42 +271,45 @@
             else:
                 self._x509_entries.append(entry)
 
         if (not self._user_entries and not self._ca_entries and
                 not self._x509_entries):
             raise ValueError('No valid entries found')
 
-    def validate(self, key, client_host, client_addr,
-                 cert_principals=None, ca=False):
+    def validate(self, key: SSHKey, client_host: str, client_addr: str,
+                 cert_principals: Optional[Sequence[str]] = None,
+                 ca: bool = False) -> Optional[Mapping[str, object]]:
         """Return whether a public key or CA is valid for authentication"""
 
         for entry in self._ca_entries if ca else self._user_entries:
             if (entry.key == key and
                     entry.match_options(client_host, client_addr,
                                         cert_principals)):
                 return entry.options
 
         return None
 
-    def validate_x509(self, cert, client_host, client_addr):
+    def validate_x509(self, cert: SSHX509CertificateChain, client_host: str,
+                      client_addr: str) -> Tuple[Optional[_EntryOptions],
+                                                 Optional[SSHX509Certificate]]:
         """Return whether an X.509 certificate is valid for authentication"""
 
         for entry in self._x509_entries:
             if (entry.cert and 'cert-authority' not in entry.options and
                     (cert.key != entry.cert.key or
                      cert.subject != entry.cert.subject)):
                 continue # pragma: no cover (work around bug in coverage tool)
 
             if entry.match_options(client_host, client_addr,
                                    cert.user_principals, cert.subject):
                 return entry.options, entry.cert
 
         return None, None
 
-def import_authorized_keys(data):
+def import_authorized_keys(data: str) -> SSHAuthorizedKeys:
     """Import SSH authorized keys
 
        This function imports public keys and associated options in
        OpenSSH authorized keys format.
 
        :param data:
            The key data to import.
@@ -295,15 +318,16 @@
        :returns: An :class:`SSHAuthorizedKeys` object
 
     """
 
     return SSHAuthorizedKeys(data)
 
 
-def read_authorized_keys(filelist):
+def read_authorized_keys(filelist: Union[str, Sequence[str]]) -> \
+        SSHAuthorizedKeys:
     """Read SSH authorized keys from a file or list of files
 
        This function reads public keys and associated options in
        OpenSSH authorized_keys format from a file or list of files.
 
        :param filelist:
            The file or list of files to read the keys from.
@@ -312,13 +336,15 @@
        :returns: An :class:`SSHAuthorizedKeys` object
 
     """
 
     authorized_keys = SSHAuthorizedKeys()
 
     if isinstance(filelist, str):
-        filelist = [filelist]
+        files: Sequence[str] = [filelist]
+    else:
+        files = filelist
 
-    for filename in filelist:
+    for filename in files:
         authorized_keys.load(read_file(filename, 'r'))
 
     return authorized_keys
```

### Comparing `asyncssh-2.8.1/asyncssh/auth.py` & `asyncssh-2.9.0/asyncssh/auth.py`

 * *Files 14% similar despite different names*

```diff
@@ -16,23 +16,40 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH authentication handlers"""
 
+from typing import TYPE_CHECKING, Awaitable, Dict, List, Optional
+from typing import Sequence, Tuple, Type, Union, cast
+
 from .constants import DEFAULT_LANG
+from .gss import GSSBase, GSSError
+from .logging import SSHLogger
+from .misc import ProtocolError, PasswordChangeRequired, get_symbol_names
+from .packet import Boolean, String, UInt32, SSHPacket, SSHPacketHandler
+from .public_key import SigningKey
+from .saslprep import saslprep, SASLPrepError
 
-from .gss import GSSError
 
-from .misc import ProtocolError, PasswordChangeRequired, get_symbol_names
+if TYPE_CHECKING:
+    import asyncio
 
-from .packet import Boolean, String, UInt32, SSHPacketHandler
+    # pylint: disable=cyclic-import
+    from .connection import SSHConnection, SSHClientConnection
+    from .connection import SSHServerConnection
 
-from .saslprep import saslprep, SASLPrepError
+
+KbdIntPrompts = Sequence[Tuple[str, bool]]
+KbdIntNewChallenge = Tuple[str, str, str, KbdIntPrompts]
+KbdIntChallenge = Union[bool, KbdIntNewChallenge]
+KbdIntResponse = Sequence[str]
+
+PasswordChangeResponse = Tuple[str, str]
 
 
 # SSH message values for GSS auth
 MSG_USERAUTH_GSSAPI_RESPONSE          = 60
 MSG_USERAUTH_GSSAPI_TOKEN             = 61
 MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE = 63
 MSG_USERAUTH_GSSAPI_ERROR             = 64
@@ -45,226 +62,236 @@
 # SSH message values for keyboard-interactive auth
 MSG_USERAUTH_INFO_REQUEST             = 60
 MSG_USERAUTH_INFO_RESPONSE            = 61
 
 # SSH message values for password auth
 MSG_USERAUTH_PASSWD_CHANGEREQ         = 60
 
-_auth_methods = []
-_client_auth_handlers = {}
-_server_auth_handlers = {}
+_auth_methods: List[bytes] = []
+_client_auth_handlers: Dict[bytes, Type['ClientAuth']] = {}
+_server_auth_handlers: Dict[bytes, Type['ServerAuth']] = {}
 
 
-class _Auth(SSHPacketHandler):
+class Auth(SSHPacketHandler):
     """Parent class for authentication"""
 
-    def __init__(self, conn, coro):
+    def __init__(self, conn: 'SSHConnection', coro: Awaitable[None]):
         self._conn = conn
         self._logger = conn.logger
-        self._coro = conn.create_task(coro)
+        self._coro: Optional['asyncio.Task[None]'] = conn.create_task(coro)
 
-    def send_packet(self, pkttype, *args, trivial=True):
+    def send_packet(self, pkttype: int, *args: bytes,
+                    trivial: bool = True) -> None:
         """Send an auth packet"""
 
         self._conn.send_userauth_packet(pkttype, *args, handler=self,
                                         trivial=trivial)
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this authentication handler"""
 
         return self._logger
 
-    def create_task(self, coro):
+    def create_task(self, coro: Awaitable[None]) -> None:
         """Create an asynchronous auth task"""
 
         self.cancel()
         self._coro = self._conn.create_task(coro)
 
-    def cancel(self):
+    def cancel(self) -> None:
         """Cancel any authentication in progress"""
 
         if self._coro: # pragma: no branch
             self._coro.cancel()
             self._coro = None
 
 
-class _ClientAuth(_Auth):
+class ClientAuth(Auth):
     """Parent class for client authentication"""
 
-    def __init__(self, conn, method):
+    _conn: 'SSHClientConnection'
+
+    def __init__(self, conn: 'SSHClientConnection', method: bytes):
         self._method = method
 
         super().__init__(conn, self._start())
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Abstract method for starting client authentication"""
 
         # Provided by subclass
         raise NotImplementedError
 
-    def auth_succeeded(self):
+    def auth_succeeded(self) -> None:
         """Callback when auth succeeds"""
 
-    def auth_failed(self):
+    def auth_failed(self) -> None:
         """Callback when auth fails"""
 
-    async def send_request(self, *args, key=None, trivial=True):
+    async def send_request(self, *args: bytes,
+                           key: Optional[SigningKey] = None,
+                           trivial: bool = True) -> None:
         """Send a user authentication request"""
 
         await self._conn.send_userauth_request(self._method, *args, key=key,
                                                trivial=trivial)
 
 
-class _ClientNullAuth(_ClientAuth):
+class _ClientNullAuth(ClientAuth):
     """Client side implementation of null auth"""
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client null authentication"""
 
         await self.send_request()
 
 
-class _ClientGSSKexAuth(_ClientAuth):
+class _ClientGSSKexAuth(ClientAuth):
     """Client side implementation of GSS key exchange auth"""
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client GSS key exchange authentication"""
 
         if self._conn.gss_kex_auth_requested():
             self.logger.debug1('Trying GSS key exchange auth')
 
             await self.send_request(key=self._conn.get_gss_context(),
                                     trivial=False)
         else:
             self._conn.try_next_auth()
 
 
-class _ClientGSSMICAuth(_ClientAuth):
+class _ClientGSSMICAuth(ClientAuth):
     """Client side implementation of GSS MIC auth"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_USERAUTH_GSSAPI_')
 
-    def __init__(self, conn, method):
+    def __init__(self, conn: 'SSHClientConnection', method: bytes):
         super().__init__(conn, method)
 
-        self._gss = None
+        self._gss: Optional[GSSBase] = None
         self._got_error = False
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client GSS MIC authentication"""
 
         if self._conn.gss_mic_auth_requested():
             self.logger.debug1('Trying GSS MIC auth')
 
             self._gss = self._conn.get_gss_context()
             self._gss.reset()
             mechs = b''.join((String(mech) for mech in self._gss.mechs))
             await self.send_request(UInt32(len(self._gss.mechs)), mechs)
         else:
             self._conn.try_next_auth()
 
-    def _finish(self):
+    def _finish(self) -> None:
         """Finish client GSS MIC authentication"""
 
+        assert self._gss is not None
+
         if self._gss.provides_integrity:
             data = self._conn.get_userauth_request_data(self._method)
 
             self.send_packet(MSG_USERAUTH_GSSAPI_MIC,
                              String(self._gss.sign(data)),
                              trivial=False)
         else:
             self.send_packet(MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)
 
-    def _process_response(self, _pkttype, _pktid, packet):
+    def _process_response(self, _pkttype: int, _pktid: int,
+                          packet: SSHPacket) -> None:
         """Process a GSS response from the server"""
 
         mech = packet.get_string()
         packet.check_end()
 
+        assert self._gss is not None
+
         if mech not in self._gss.mechs:
             raise ProtocolError('Mechanism mismatch')
 
         try:
             token = self._gss.step()
+            assert token is not None
 
             self.send_packet(MSG_USERAUTH_GSSAPI_TOKEN, String(token))
 
             if self._gss.complete:
                 self._finish()
         except GSSError as exc:
             if exc.token:
                 self.send_packet(MSG_USERAUTH_GSSAPI_ERRTOK, String(exc.token))
 
             self._conn.try_next_auth()
 
-        return True
-
-    def _process_token(self, _pkttype, _pktid, packet):
+    def _process_token(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a GSS token from the server"""
 
-        token = packet.get_string()
+        token: Optional[bytes] = packet.get_string()
         packet.check_end()
 
+        assert self._gss is not None
+
         try:
             token = self._gss.step(token)
 
             if token:
                 self.send_packet(MSG_USERAUTH_GSSAPI_TOKEN, String(token))
 
             if self._gss.complete:
                 self._finish()
         except GSSError as exc:
             if exc.token:
                 self.send_packet(MSG_USERAUTH_GSSAPI_ERRTOK, String(exc.token))
 
             self._conn.try_next_auth()
 
-        return True
-
-    def _process_error(self, _pkttype, _pktid, packet):
+    def _process_error(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a GSS error from the server"""
 
         _ = packet.get_uint32()         # major_status
         _ = packet.get_uint32()         # minor_status
         msg = packet.get_string()
         _ = packet.get_string()         # lang
         packet.check_end()
 
         self.logger.debug1('GSS error from server: %s', msg)
         self._got_error = True
 
-        return True
-
-    def _process_error_token(self, _pkttype, _pktid, packet):
+    def _process_error_token(self, _pkttype: int, _pktid: int,
+                             packet: SSHPacket) -> None:
         """Process a GSS error token from the server"""
 
         token = packet.get_string()
         packet.check_end()
 
+        assert self._gss is not None
+
         try:
             self._gss.step(token)
         except GSSError as exc:
             if not self._got_error: # pragma: no cover
                 self.logger.debug1('GSS error from server: %s', str(exc))
 
-        return True
-
     _packet_handlers = {
         MSG_USERAUTH_GSSAPI_RESPONSE: _process_response,
         MSG_USERAUTH_GSSAPI_TOKEN:    _process_token,
         MSG_USERAUTH_GSSAPI_ERROR:    _process_error,
         MSG_USERAUTH_GSSAPI_ERRTOK:   _process_error_token
     }
 
 
-class _ClientHostBasedAuth(_ClientAuth):
+class _ClientHostBasedAuth(ClientAuth):
     """Client side implementation of host based auth"""
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client host based authentication"""
 
         keypair, client_host, client_username = \
             await self._conn.host_based_auth_requested()
 
         if keypair is None:
             self._conn.try_next_auth()
@@ -276,24 +303,24 @@
 
         try:
             await self.send_request(String(keypair.algorithm),
                                     String(keypair.public_data),
                                     String(client_host),
                                     String(client_username), key=keypair)
         except ValueError as exc:
-            self.logger.debug1('Host based auth failed: %s', exc)
+            self.logger.debug1('Host based auth failed: %s', str(exc))
             self._conn.try_next_auth()
 
 
-class _ClientPublicKeyAuth(_ClientAuth):
+class _ClientPublicKeyAuth(ClientAuth):
     """Client side implementation of public key auth"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_USERAUTH_PK_')
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client public key authentication"""
 
         self._keypair = await self._conn.public_key_auth_requested()
 
         if self._keypair is None:
             self._conn.try_next_auth()
             return
@@ -301,247 +328,260 @@
         self.logger.debug1('Trying public key auth with %s key',
                            self._keypair.algorithm)
 
         await self.send_request(Boolean(False),
                                 String(self._keypair.algorithm),
                                 String(self._keypair.public_data))
 
-    async def _send_signed_request(self):
+    async def _send_signed_request(self) -> None:
         """Send signed public key request"""
 
+        assert self._keypair is not None
+
         self.logger.debug1('Signing request with %s key',
                            self._keypair.algorithm)
 
         await self.send_request(Boolean(True),
                                 String(self._keypair.algorithm),
                                 String(self._keypair.public_data),
                                 key=self._keypair, trivial=False)
 
-    def _process_public_key_ok(self, _pkttype, _pktid, packet):
+    def _process_public_key_ok(self, _pkttype: int, _pktid: int,
+                               packet: SSHPacket) -> None:
         """Process a public key ok response"""
 
         algorithm = packet.get_string()
         key_data = packet.get_string()
         packet.check_end()
 
+        assert self._keypair is not None
+
         if (algorithm != self._keypair.algorithm or
                 key_data != self._keypair.public_data):
             raise ProtocolError('Key mismatch')
 
         self.create_task(self._send_signed_request())
-        return True
 
     _packet_handlers = {
         MSG_USERAUTH_PK_OK: _process_public_key_ok
     }
 
 
-class _ClientKbdIntAuth(_ClientAuth):
+class _ClientKbdIntAuth(ClientAuth):
     """Client side implementation of keyboard-interactive auth"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_USERAUTH_INFO_')
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client keyboard interactive authentication"""
 
         submethods = await self._conn.kbdint_auth_requested()
 
         if submethods is None:
             self._conn.try_next_auth()
             return
 
         self.logger.debug1('Trying keyboard-interactive auth')
 
         await self.send_request(String(''), String(submethods))
 
-    async def _receive_challenge(self, name, instruction, lang, prompts):
+    async def _receive_challenge(self, name: str, instruction: str, lang: str,
+                                 prompts: KbdIntPrompts) -> None:
         """Receive and respond to a keyboard interactive challenge"""
 
         responses = \
             await self._conn.kbdint_challenge_received(name, instruction,
                                                        lang, prompts)
 
         if responses is None:
             self._conn.try_next_auth()
             return
 
         self.send_packet(MSG_USERAUTH_INFO_RESPONSE, UInt32(len(responses)),
                          b''.join(String(r) for r in responses),
                          trivial=not responses)
 
-    def _process_info_request(self, _pkttype, _pktid, packet):
+    def _process_info_request(self, _pkttype: int, _pktid: int,
+                              packet: SSHPacket) -> None:
         """Process a keyboard interactive authentication request"""
 
-        name = packet.get_string()
-        instruction = packet.get_string()
-        lang = packet.get_string()
+        name_bytes = packet.get_string()
+        instruction_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
 
         try:
-            name = name.decode('utf-8')
-            instruction = instruction.decode('utf-8')
-            lang = lang.decode('ascii')
+            name = name_bytes.decode('utf-8')
+            instruction = instruction_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid keyboard interactive '
                                 'info request') from None
 
         num_prompts = packet.get_uint32()
         prompts = []
         for _ in range(num_prompts):
-            prompt = packet.get_string()
+            prompt_bytes = packet.get_string()
             echo = packet.get_boolean()
 
             try:
-                prompt = prompt.decode('utf-8')
+                prompt = prompt_bytes.decode('utf-8')
             except UnicodeDecodeError:
                 raise ProtocolError('Invalid keyboard interactive '
                                     'info request') from None
 
             prompts.append((prompt, echo))
 
         self.create_task(self._receive_challenge(name, instruction,
                                                  lang, prompts))
 
-        return True
-
     _packet_handlers = {
         MSG_USERAUTH_INFO_REQUEST: _process_info_request
     }
 
 
-class _ClientPasswordAuth(_ClientAuth):
+class _ClientPasswordAuth(ClientAuth):
     """Client side implementation of password auth"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_USERAUTH_PASSWD_')
 
-    def __init__(self, conn, method):
+    def __init__(self, conn: 'SSHClientConnection', method: bytes):
         super().__init__(conn, method)
 
         self._password_change = False
 
-    async def _start(self):
+    async def _start(self) -> None:
         """Start client password authentication"""
 
         password = await self._conn.password_auth_requested()
 
         if password is None:
             self._conn.try_next_auth()
             return
 
         self.logger.debug1('Trying password auth')
 
         await self.send_request(Boolean(False), String(password),
                                 trivial=False)
 
-    async def _change_password(self, prompt, lang):
+    async def _change_password(self, prompt: str, lang: str) -> None:
         """Start password change"""
 
         result = await self._conn.password_change_requested(prompt, lang)
 
         if result == NotImplemented:
             # Password change not supported - move on to the next auth method
             self._conn.try_next_auth()
             return
 
         self.logger.debug1('Trying to chsnge password')
 
-        old_password, new_password = result
+        old_password, new_password = cast(PasswordChangeResponse, result)
 
         self._password_change = True
 
         await self.send_request(Boolean(True),
                                 String(old_password.encode('utf-8')),
                                 String(new_password.encode('utf-8')),
                                 trivial=False)
 
-    def auth_succeeded(self):
+    def auth_succeeded(self) -> None:
         if self._password_change:
             self._password_change = False
             self._conn.password_changed()
 
-    def auth_failed(self):
+    def auth_failed(self) -> None:
         if self._password_change:
             self._password_change = False
             self._conn.password_change_failed()
 
-    def _process_password_change(self, _pkttype, _pktid, packet):
+    def _process_password_change(self, _pkttype: int, _pktid: int,
+                                 packet: SSHPacket) -> None:
         """Process a password change request"""
 
-        prompt = packet.get_string()
-        lang = packet.get_string()
+        prompt_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
 
         try:
-            prompt = prompt.decode('utf-8')
-            lang = lang.decode('ascii')
+            prompt = prompt_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid password change request') from None
 
         self.auth_failed()
         self.create_task(self._change_password(prompt, lang))
 
-        return True
-
     _packet_handlers = {
         MSG_USERAUTH_PASSWD_CHANGEREQ: _process_password_change
     }
 
 
-class _ServerAuth(_Auth):
+class ServerAuth(Auth):
     """Parent class for server authentication"""
 
-    def __init__(self, conn, username, method, packet):
+    _conn: 'SSHServerConnection'
+
+    def __init__(self, conn: 'SSHServerConnection', username: str,
+                 method: bytes, packet: SSHPacket):
         self._username = username
         self._method = method
 
         super().__init__(conn, self._start(packet))
 
-    async def _start(self, packet):
+    @classmethod
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
+        """Return whether this authentication method is supported"""
+
+        raise NotImplementedError
+
+    async def _start(self, packet: SSHPacket) -> None:
         """Abstract method for starting server authentication"""
 
         # Provided by subclass
         raise NotImplementedError
 
-    def send_failure(self, partial_success=False):
+    def send_failure(self, partial_success: bool = False) -> None:
         """Send a user authentication failure response"""
 
         self._conn.send_userauth_failure(partial_success)
 
-    def send_success(self):
+    def send_success(self) -> None:
         """Send a user authentication success response"""
 
         self._conn.send_userauth_success()
 
 
-class _ServerNullAuth(_ServerAuth):
+class _ServerNullAuth(ServerAuth):
     """Server side implementation of null auth"""
 
     @classmethod
-    def supported(cls, _conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return that null authentication is never a supported auth mode"""
 
         return False
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Supported always returns false, so we never get here"""
 
 
-class _ServerGSSKexAuth(_ServerAuth):
+class _ServerGSSKexAuth(ServerAuth):
     """Server side implementation of GSS key exchange auth"""
 
-    def __init__(self, conn, username, method, packet):
+    def __init__(self, conn: 'SSHServerConnection', username: str,
+                 method: bytes, packet: SSHPacket):
         super().__init__(conn, username, method, packet)
 
         self._gss = conn.get_gss_context()
 
     @classmethod
-    def supported(cls, conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return whether GSS key exchange authentication is supported"""
 
         return conn.gss_kex_auth_supported()
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Start server GSS key exchange authentication"""
 
         mic = packet.get_string()
         packet.check_end()
 
         self.logger.debug1('Trying GSS key exchange auth')
 
@@ -552,31 +592,32 @@
                                                          self._gss.user,
                                                          self._gss.host))):
             self.send_success()
         else:
             self.send_failure()
 
 
-class _ServerGSSMICAuth(_ServerAuth):
+class _ServerGSSMICAuth(ServerAuth):
     """Server side implementation of GSS MIC auth"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_USERAUTH_GSSAPI_')
 
-    def __init__(self, conn, username, method, packet):
+    def __init__(self, conn: 'SSHServerConnection', username: str,
+                 method: bytes, packet: SSHPacket) -> None:
         super().__init__(conn, username, method, packet)
 
         self._gss = conn.get_gss_context()
 
     @classmethod
-    def supported(cls, conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return whether GSS MIC authentication is supported"""
 
         return conn.gss_mic_auth_supported()
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Start server GSS MIC authentication"""
 
         mechs = set()
 
         n = packet.get_uint32()
         for _ in range(n):
             mechs.add(packet.get_string())
@@ -593,28 +634,29 @@
             self.send_failure()
             return
 
         self.logger.debug1('Trying GSS MIC auth')
 
         self.send_packet(MSG_USERAUTH_GSSAPI_RESPONSE, String(match))
 
-    async def _finish(self):
+    async def _finish(self) -> None:
         """Finish server GSS MIC authentication"""
 
         if (await self._conn.validate_gss_principal(self._username,
                                                     self._gss.user,
                                                     self._gss.host)):
             self.send_success()
         else:
             self.send_failure()
 
-    def _process_token(self, _pkttype, _pktid, packet):
+    def _process_token(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a GSS token from the client"""
 
-        token = packet.get_string()
+        token: Optional[bytes] = packet.get_string()
         packet.check_end()
 
         try:
             token = self._gss.step(token)
 
             if token:
                 self.send_packet(MSG_USERAUTH_GSSAPI_TOKEN, String(token))
@@ -624,89 +666,84 @@
                              String(DEFAULT_LANG))
 
             if exc.token:
                 self.send_packet(MSG_USERAUTH_GSSAPI_ERRTOK, String(exc.token))
 
             self.send_failure()
 
-        return True
-
-    def _process_exchange_complete(self, _pkttype, _pktid, packet):
+    def _process_exchange_complete(self, _pkttype: int, _pktid: int,
+                                   packet: SSHPacket) -> None:
         """Process a GSS exchange complete message from the client"""
 
         packet.check_end()
 
         if self._gss.complete and not self._gss.provides_integrity:
             self.create_task(self._finish())
         else:
             self.send_failure()
 
-        return True
-
-    def _process_error_token(self, _pkttype, _pktid, packet):
+    def _process_error_token(self, _pkttype: int, _pktid: int,
+                             packet: SSHPacket) -> None:
         """Process a GSS error token from the client"""
 
         token = packet.get_string()
         packet.check_end()
 
         try:
             self._gss.step(token)
         except GSSError as exc:
             self.logger.debug1('GSS error from client: %s', str(exc))
 
-        return True
-
-    def _process_mic(self, _pkttype, _pktid, packet):
+    def _process_mic(self, _pkttype: int, _pktid: int,
+                     packet: SSHPacket) -> None:
         """Process a GSS MIC from the client"""
 
         mic = packet.get_string()
         packet.check_end()
 
         data = self._conn.get_userauth_request_data(self._method)
 
         if (self._gss.complete and self._gss.provides_integrity and
                 self._gss.verify(data, mic)):
             self.create_task(self._finish())
         else:
             self.send_failure()
 
-        return True
-
     _packet_handlers = {
         MSG_USERAUTH_GSSAPI_TOKEN:             _process_token,
         MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE: _process_exchange_complete,
         MSG_USERAUTH_GSSAPI_ERRTOK:            _process_error_token,
         MSG_USERAUTH_GSSAPI_MIC:               _process_mic
     }
 
 
-class _ServerHostBasedAuth(_ServerAuth):
+class _ServerHostBasedAuth(ServerAuth):
     """Server side implementation of host based auth"""
 
     @classmethod
-    def supported(cls, conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return whether host based authentication is supported"""
 
         return conn.host_based_auth_supported()
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Start server host based authentication"""
 
         algorithm = packet.get_string()
         key_data = packet.get_string()
-        client_host = packet.get_string()
-        client_username = packet.get_string()
+        client_host_bytes = packet.get_string()
+        client_username_bytes = packet.get_string()
         msg = packet.get_consumed_payload()
         signature = packet.get_string()
 
         packet.check_end()
 
         try:
-            client_host = client_host.decode('utf-8')
-            client_username = saslprep(client_username.decode('utf-8'))
+            client_host = client_host_bytes.decode('utf-8')
+            client_username = saslprep(client_username_bytes.decode('utf-8'))
         except (UnicodeDecodeError, SASLPrepError):
             raise ProtocolError('Invalid host-based auth request') from None
 
         self.logger.debug1('Verifying host based auth of user %s '
                            'on host %s with %s host key', client_username,
                            client_host, algorithm)
 
@@ -715,36 +752,36 @@
                                                       client_username,
                                                       msg, signature)):
             self.send_success()
         else:
             self.send_failure()
 
 
-class _ServerPublicKeyAuth(_ServerAuth):
+class _ServerPublicKeyAuth(ServerAuth):
     """Server side implementation of public key auth"""
 
     @classmethod
-    def supported(cls, conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return whether public key authentication is supported"""
 
         return conn.public_key_auth_supported()
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Start server public key authentication"""
 
         sig_present = packet.get_boolean()
         algorithm = packet.get_string()
         key_data = packet.get_string()
 
         if sig_present:
             msg = packet.get_consumed_payload()
             signature = packet.get_string()
         else:
-            msg = None
-            signature = None
+            msg = b''
+            signature = b''
 
         packet.check_end()
 
         if sig_present:
             self.logger.debug1('Verifying request with %s key', algorithm)
         else:
             self.logger.debug1('Trying public key auth with %s key', algorithm)
@@ -756,116 +793,116 @@
             else:
                 self.send_packet(MSG_USERAUTH_PK_OK, String(algorithm),
                                  String(key_data))
         else:
             self.send_failure()
 
 
-class _ServerKbdIntAuth(_ServerAuth):
+class _ServerKbdIntAuth(ServerAuth):
     """Server side implementation of keyboard-interactive auth"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_USERAUTH_INFO_')
 
     @classmethod
-    def supported(cls, conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return whether keyboard interactive authentication is supported"""
 
         return conn.kbdint_auth_supported()
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Start server keyboard interactive authentication"""
 
-        lang = packet.get_string()
-        submethods = packet.get_string()
+        lang_bytes = packet.get_string()
+        submethods_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            lang = lang.decode('ascii')
-            submethods = submethods.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
+            submethods = submethods_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid keyboard interactive '
                                 'auth request') from None
 
         self.logger.debug1('Trying keyboard-interactive auth')
 
         challenge = await self._conn.get_kbdint_challenge(self._username,
                                                           lang, submethods)
         self._send_challenge(challenge)
 
-    def _send_challenge(self, challenge):
+    def _send_challenge(self, challenge: KbdIntChallenge) -> None:
         """Send a keyboard interactive authentication request"""
 
         if isinstance(challenge, (tuple, list)):
             name, instruction, lang, prompts = challenge
 
             num_prompts = len(prompts)
-            prompts = (String(prompt) + Boolean(echo)
-                       for prompt, echo in prompts)
+            prompts_bytes = (String(prompt) + Boolean(echo)
+                             for prompt, echo in prompts)
 
             self.send_packet(MSG_USERAUTH_INFO_REQUEST, String(name),
                              String(instruction), String(lang),
-                             UInt32(num_prompts), *prompts)
+                             UInt32(num_prompts), *prompts_bytes)
         elif challenge:
             self.send_success()
         else:
             self.send_failure()
 
-    async def _validate_response(self, responses):
+    async def _validate_response(self, responses: KbdIntResponse) -> None:
         """Validate a keyboard interactive authentication response"""
 
         next_challenge = \
             await self._conn.validate_kbdint_response(self._username, responses)
         self._send_challenge(next_challenge)
 
-    def _process_info_response(self, _pkttype, _pktid, packet):
+    def _process_info_response(self, _pkttype: int, _pktid: int,
+                               packet: SSHPacket) -> None:
         """Process a keyboard interactive authentication response"""
 
         num_responses = packet.get_uint32()
         responses = []
         for _ in range(num_responses):
-            response = packet.get_string()
+            response_bytes = packet.get_string()
 
             try:
-                response = response.decode('utf-8')
+                response = response_bytes.decode('utf-8')
             except UnicodeDecodeError:
                 raise ProtocolError('Invalid keyboard interactive '
                                     'info response') from None
 
             responses.append(response)
 
         packet.check_end()
 
         self.create_task(self._validate_response(responses))
-        return True
 
     _packet_handlers = {
         MSG_USERAUTH_INFO_RESPONSE: _process_info_response
     }
 
 
-class _ServerPasswordAuth(_ServerAuth):
+class _ServerPasswordAuth(ServerAuth):
     """Server side implementation of password auth"""
 
     @classmethod
-    def supported(cls, conn):
+    def supported(cls, conn: 'SSHServerConnection') -> bool:
         """Return whether password authentication is supported"""
 
         return conn.password_auth_supported()
 
-    async def _start(self, packet):
+    async def _start(self, packet: SSHPacket) -> None:
         """Start server password authentication"""
 
         password_change = packet.get_boolean()
-        password = packet.get_string()
-        new_password = packet.get_string() if password_change else b''
+        password_bytes = packet.get_string()
+        new_password_bytes = packet.get_string() if password_change else b''
         packet.check_end()
 
         try:
-            password = saslprep(password.decode('utf-8'))
-            new_password = saslprep(new_password.decode('utf-8'))
+            password = saslprep(password_bytes.decode('utf-8'))
+            new_password = saslprep(new_password_bytes.decode('utf-8'))
         except (UnicodeDecodeError, SASLPrepError):
             raise ProtocolError('Invalid password auth request') from None
 
         try:
             if password_change:
                 self.logger.debug1('Trying to chsnge password')
 
@@ -883,51 +920,55 @@
             else:
                 self.send_failure()
         except PasswordChangeRequired as exc:
             self.send_packet(MSG_USERAUTH_PASSWD_CHANGEREQ,
                              String(exc.prompt), String(exc.lang))
 
 
-def register_auth_method(alg, client_handler, server_handler):
+def register_auth_method(alg: bytes, client_handler: Type[ClientAuth],
+        server_handler: Type[ServerAuth]) -> None:
     """Register an authentication method"""
 
     _auth_methods.append(alg)
     _client_auth_handlers[alg] = client_handler
     _server_auth_handlers[alg] = server_handler
 
 
-def get_client_auth_methods():
+def get_client_auth_methods() -> Sequence[bytes]:
     """Return a list of supported client auth methods"""
 
     return [method for method in _client_auth_handlers
             if method != b'none']
 
 
-def lookup_client_auth(conn, method):
+def lookup_client_auth(conn: 'SSHClientConnection',
+                       method: bytes) -> Optional[ClientAuth]:
     """Look up the client authentication method to use"""
 
     if method in _auth_methods:
         return _client_auth_handlers[method](conn, method)
     else:
         return None
 
 
-def get_server_auth_methods(conn):
+def get_server_auth_methods(conn: 'SSHServerConnection') -> Sequence[bytes]:
     """Return a list of supported server auth methods"""
 
     auth_methods = []
 
     for method in _auth_methods:
         if _server_auth_handlers[method].supported(conn):
             auth_methods.append(method)
 
     return auth_methods
 
 
-def lookup_server_auth(conn, username, method, packet):
+def lookup_server_auth(conn: 'SSHServerConnection', username: str,
+                       method: bytes, packet: SSHPacket) -> \
+        Optional[ServerAuth]:
     """Look up the server authentication method to use"""
 
     handler = _server_auth_handlers.get(method)
 
     if handler and handler.supported(conn):
         return handler(conn, username, method, packet)
     else:
```

### Comparing `asyncssh-2.8.1/asyncssh/logging.py` & `asyncssh-2.9.0/asyncssh/logging.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,82 +18,92 @@
 # Contributors:
 #     Sam Crooks - initial implementation
 #     Ron Frederick - minor cleanup
 
 """Logging functions"""
 
 import logging
+from typing import MutableMapping, Optional, Tuple, Union, cast
 
 
-class _SSHLogger(logging.LoggerAdapter):
+_LogArg = object
+_ObjDict = MutableMapping[str, object]
+
+
+class SSHLogger(logging.LoggerAdapter):
     """Adapter to add context to AsyncSSH log messages"""
 
     _debug_level = 1
     _pkg_logger = logging.getLogger(__package__ or 'asyncssh')
 
-    def __init__(self, parent=_pkg_logger, child=None, context=''):
+    def __init__(self, parent: logging.Logger = _pkg_logger,
+                 child: str = '', context: str = ''):
         self._context = context
         self._logger = parent.getChild(child) if child else parent
 
         super().__init__(self._logger, {})
 
-    def _extend_context(self, context):
+    def _extend_context(self, context: str) -> str:
         """Extend context provided by this logger"""
 
         if context:
             if self._context:
                 context = self._context + ', ' + context
         else:
             context = self._context
 
         return context
 
-    def get_child(self, child=None, context=None):
+    def get_child(self, child: str = '', context: str = '') -> 'SSHLogger':
         """Return child logger with optional added context"""
 
         return type(self)(self._logger, child, self._extend_context(context))
 
-    def log(self, level, msg, *args, **kwargs):
+    def log(self, level: int, msg: object, *args, **kwargs) -> None:
         """Log a message to the underlying logger"""
 
-        def _text(arg):
+        def _text(arg: _LogArg) -> str:
             """Convert a log argument to text"""
 
             if isinstance(arg, list):
-                sep = b',' if arg and isinstance(arg[0], bytes) else ','
-                arg = sep.join(arg)
-
-            if isinstance(arg, tuple):
+                if arg and isinstance(arg[0], bytes):
+                    result = b','.join(arg).decode('utf-8', errors='replace')
+                else:
+                    result = ','.join(arg)
+            elif isinstance(arg, tuple):
                 host, port = arg
 
                 if host:
-                    return '%s, port %d' % (host, port) if port else host
+                    result = '%s, port %d' % (host, port) if port else host
                 else:
-                    return 'port %d' % port if port else 'dynamic port'
-            elif isinstance(arg, bytes):
-                arg = arg.decode('ascii', errors='backslashreplace')
+                    result = 'port %d' % port if port else 'dynamic port'
+            else:
+                result = cast(str, arg)
+
+            if isinstance(result, bytes):
+                result = result.decode('ascii', errors='backslashreplace')
 
-                if not arg.isprintable():
-                    arg = repr(arg)[1:-1]
+                if not result.isprintable():
+                    result = repr(result)[1:-1]
 
-            return arg
+            return result
 
-        args = [_text(arg) for arg in args]
+        log_args = [_text(arg) for arg in args]
 
-        return super().log(level, msg, *args, **kwargs)
+        super().log(level, msg, *log_args, **kwargs)
 
-    def process(self, msg, kwargs):
+    def process(self, msg: str, kwargs: _ObjDict) -> Tuple[str, _ObjDict]:
         """Add context to log message"""
 
-        extra = kwargs.get('extra', {})
+        extra = cast(_ObjDict, kwargs.get('extra', {}))
 
-        context = self._extend_context(extra.get('context'))
+        context = self._extend_context(cast(str, extra.get('context')))
         context = '[' + context + '] ' if context else ''
 
-        packet = extra.get('packet')
+        packet = cast(bytes, extra.get('packet'))
         pktdata = ''
         offset = 0
 
         while packet:
             line = '\n  %08x:' % offset
 
             for b in packet[:16]:
@@ -115,48 +125,50 @@
 
             packet = packet[16:]
             offset += 16
 
         return context + msg + pktdata, kwargs
 
     @classmethod
-    def set_debug_level(cls, level):
+    def set_debug_level(cls, level: int) -> None:
         """Set AsyncSSH debug log level"""
 
         if level < 1 or level > 3:
             raise ValueError('Debug log level must be between 1 and 3')
 
         cls._debug_level = level
 
-    def debug1(self, msg, *args, **kwargs):
+    def debug1(self, msg: str, *args: _LogArg, **kwargs: object) -> None:
         """Write a level 1 debug log message"""
 
-        self.debug(msg, *args, **kwargs)
+        self.log(logging.DEBUG, msg, *args, **kwargs)
 
-    def debug2(self, msg, *args, **kwargs):
+    def debug2(self, msg: str, *args: _LogArg, **kwargs: object) -> None:
         """Write a level 2 debug log message"""
 
         if self._debug_level >= 2:
-            self.debug(msg, *args, **kwargs)
+            self.log(logging.DEBUG, msg, *args, **kwargs)
 
-    def packet(self, pktid, packet, msg, *args, **kwargs):
+    def packet(self, pktid: Optional[int], packet: bytes, msg: str,
+               *args: _LogArg, **kwargs: object) -> None:
         """Write a control packet debug log message"""
 
         if self._debug_level >= 3:
             kwargs.setdefault('extra', {})
+            extra = cast(_ObjDict, kwargs.get('extra'))
 
             if pktid is not None:
-                kwargs['extra'].update(context='pktid=%d' % pktid)
+                extra.update(context='pktid=%d' % pktid)
 
-            kwargs['extra'].update(packet=packet)
+            extra.update(packet=packet)
 
-            self.debug(msg, *args, **kwargs)
+            self.log(logging.DEBUG, msg, *args, **kwargs)
 
 
-def set_log_level(level):
+def set_log_level(level: Union[int, str]) -> None:
     """Set the AsyncSSH log level
 
        This function sets the log level of the AsyncSSH logger. It
        defaults to `'NOTSET`', meaning that it will track the debug
        level set on the root Python logger.
 
        For additional control over the level of debug logging, see the
@@ -167,15 +179,15 @@
        :type level: `int` or `str`
 
     """
 
     logger.setLevel(level)
 
 
-def set_sftp_log_level(level):
+def set_sftp_log_level(level: Union[int, str]) -> None:
     """Set the AsyncSSH SFTP/SCP log level
 
        This function sets the log level of the AsyncSSH SFTP/SCP logger.
        It defaults to `'NOTSET`', meaning that it will track the debug
        level set on the main AsyncSSH logger.
 
        For additional control over the level of debug logging, see the
@@ -186,15 +198,15 @@
        :type level: `int` or `str`
 
     """
 
     sftp_logger.setLevel(level)
 
 
-def set_debug_level(level):
+def set_debug_level(level: int) -> None:
     """Set the AsyncSSH debug log level
 
        This function sets the level of debugging logging done by the
        AsyncSSH logger, from the following options:
 
            ===== ====================================
            Level Description
@@ -220,9 +232,9 @@
        :type level: `int`
 
     """
 
     logger.set_debug_level(level)
 
 
-logger = _SSHLogger()
+logger = SSHLogger()
 sftp_logger = logger.get_child('sftp')
```

### Comparing `asyncssh-2.8.1/asyncssh/misc.py` & `asyncssh-2.9.0/asyncssh/misc.py`

 * *Files 13% similar despite different names*

```diff
@@ -16,92 +16,141 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """Miscellaneous utility classes and functions"""
 
-import codecs
 import functools
 import ipaddress
 import re
 import socket
 
-from pathlib import Path
+from pathlib import Path, PurePath
 from random import SystemRandom
-from typing import Union
+from types import TracebackType
+from typing import Any, AsyncContextManager, Awaitable, Callable, Dict
+from typing import Generator, Generic, IO, Mapping, Optional, Sequence
+from typing import Tuple, Type, TypeVar, Union, cast, overload
+from typing_extensions import Literal, Protocol
 
 from .constants import DEFAULT_LANG
 from .constants import DISC_COMPRESSION_ERROR, DISC_CONNECTION_LOST
 from .constants import DISC_HOST_KEY_NOT_VERIFIABLE, DISC_ILLEGAL_USER_NAME
 from .constants import DISC_KEY_EXCHANGE_FAILED, DISC_MAC_ERROR
 from .constants import DISC_NO_MORE_AUTH_METHODS_AVAILABLE
 from .constants import DISC_PROTOCOL_ERROR, DISC_PROTOCOL_VERSION_NOT_SUPPORTED
 from .constants import DISC_SERVICE_NOT_AVAILABLE
 
 
+class _Hash(Protocol):
+    """Protocol for hashing data"""
+
+    @property
+    def digest_size(self) -> int:
+        """Return the hash digest size"""
+
+    @property
+    def block_size(self) -> int:
+        """Return the hash block size"""
+
+    @property
+    def name(self) -> str:
+        """Return the hash name"""
+
+    def digest(self) -> bytes:
+        """Return the digest value as a bytes object"""
+
+    def hexdigest(self) -> str:
+        """Return the digest value as a string of hexadecimal digits"""
+
+    def update(self, __data: bytes) -> None:
+        """Update this hash object's state with the provided bytes"""
+
+
+class HashType(Protocol):
+    """Protocol for returning the type of a hash function"""
+
+    def __call__(self, __data: bytes = ...) -> _Hash:
+        """Create a new hash object"""
+
+
+class _SupportsWaitClosed(Protocol):
+    """A class that supports async wait_closed"""
+
+    async def wait_closed(self) -> None:
+        """Wait for transport to close"""
+
+
+_T = TypeVar('_T')
+DefTuple = Union[Tuple[()], _T]
+MaybeAwait = Union[_T, Awaitable[_T]]
+
+ExcInfo = Tuple[Type[BaseException], BaseException, TracebackType]
+OptExcInfo = Union[ExcInfo, Tuple[None, None, None]]
+
 BytesOrStr = Union[bytes, str]
+FilePath = Union[str, PurePath]
+HostPort = Tuple[str, int]
+IPAddress = Union[ipaddress.IPv4Address, ipaddress.IPv6Address]
+IPNetwork = Union[ipaddress.IPv4Network, ipaddress.IPv6Network]
+SockAddr = Union[Tuple[str, int], Tuple[str, int, int, int]]
 
 
 # Define a version of randrange which is based on SystemRandom(), so that
 # we get back numbers suitable for cryptographic use.
 _random = SystemRandom()
 randrange = _random.randrange
 
 _unit_pattern = re.compile(r'([A-Za-z])')
 _byte_units = {'': 1, 'k': 1024, 'm': 1024*1024, 'g': 1024*1024*1024}
 _time_units = {'': 1, 's': 1, 'm': 60, 'h': 60*60,
                'd': 24*60*60, 'w': 7*24*60*60}
 
 
-def hide_empty(value, prefix=', '):
+def hide_empty(value: object, prefix: str = ', ') -> str:
     """Return a string with optional prefix if value is non-empty"""
 
     value = str(value)
     return prefix + value if value else ''
 
 
-def plural(length, label, suffix='s'):
+def plural(length: int, label: str, suffix: str = 's') -> str:
     """Return a label with an optional plural suffix"""
 
     return '%d %s%s' % (length, label, suffix if length != 1 else '')
 
 
-def to_hex(data):
-    """Convert binary data to a hex string"""
-
-    return codecs.encode(data, 'hex')
-
-
-def all_ints(seq):
+def all_ints(seq: Sequence[object]) -> bool:
     """Return if a sequence contains all integers"""
 
     return all(isinstance(i, int) for i in seq)
 
 
-def get_symbol_names(symbols, prefix, strip_leading=0):
+def get_symbol_names(symbols: Mapping[str, int], prefix: str,
+                     strip_leading: int = 0) -> Mapping[int, str]:
     """Return a mapping from values to symbol names for logging"""
 
     return {value: name[strip_leading:] for name, value in symbols.items()
             if name.startswith(prefix)}
 
 
 # Punctuation to map when creating handler names
 _HANDLER_PUNCTUATION = (('@', '_at_'), ('.', '_dot_'), ('-', '_'))
 
-def map_handler_name(name):
+def map_handler_name(name: str) -> str:
     """Map punctuation so a string can be used as a handler name"""
 
     for old, new in _HANDLER_PUNCTUATION:
         name = name.replace(old, new)
 
     return name
 
 
-def _normalize_scoped_ip(addr):
+def _normalize_scoped_ip(addr: str) -> str:
     """Normalize scoped IP address
 
        The ipaddress module doesn't handle scoped addresses properly,
        so we normalize scoped IP addresses using socket.getaddrinfo
        before we pass them into ip_address/ip_network.
 
     """
@@ -120,58 +169,71 @@
         idx = addr.find('%')
         if idx >= 0: # pragma: no cover
             addr = addr[:idx]
 
         ip = ipaddress.ip_address(addr)
 
         if ip.is_link_local:
-            addr = str(ipaddress.ip_address(int(ip) | (sa[3] << 96)))
+            scope_id = cast(Tuple[str, int, int, int], sa)[3]
+            addr = str(ipaddress.ip_address(int(ip) | (scope_id << 96)))
 
     return addr
 
 
-def ip_address(addr):
+def ip_address(addr: str) -> IPAddress:
     """Wrapper for ipaddress.ip_address which supports scoped addresses"""
 
     return ipaddress.ip_address(_normalize_scoped_ip(addr))
 
 
-def ip_network(addr):
+def ip_network(addr: str) -> IPNetwork:
     """Wrapper for ipaddress.ip_network which supports scoped addresses"""
 
     idx = addr.find('/')
     if idx >= 0:
         addr, mask = addr[:idx], addr[idx:]
     else:
         mask = ''
 
     return ipaddress.ip_network(_normalize_scoped_ip(addr) + mask)
 
 
-def open_file(filename, *args, **kwargs):
+def open_file(filename: FilePath, mode: str, buffering: int = -1) -> IO[bytes]:
     """Open a file with home directory expansion"""
 
-    return open(Path(filename).expanduser(), *args, **kwargs)
+    return open(Path(filename).expanduser(), mode, buffering=buffering)
+
 
+@overload
+def read_file(filename: FilePath) -> bytes:
+    """Read from a binary file with home directory expansion"""
 
-def read_file(filename, mode='rb'):
+@overload
+def read_file(filename: FilePath, mode: Literal['rb']) -> bytes:
+    """Read from a binary file with home directory expansion"""
+
+@overload
+def read_file(filename: FilePath, mode: Literal['r']) -> str:
+    """Read from a text file with home directory expansion"""
+
+def read_file(filename, mode = 'rb'):
     """Read from a file with home directory expansion"""
 
     with open_file(filename, mode) as f:
         return f.read()
 
 
-def write_file(filename, data, mode='wb'):
+def write_file(filename: FilePath, data: bytes, mode: str = 'wb') -> int:
     """Write or append to a file with home directory expansion"""
 
     with open_file(filename, mode) as f:
         return f.write(data)
 
 
-def _parse_units(value, suffixes, label):
+def _parse_units(value: str, suffixes: Mapping[str, int], label: str) -> float:
     """Parse a series of integers followed by unit suffixes"""
 
     matches = _unit_pattern.split(value)
 
     if matches[-1]:
         matches.append('')
     else:
@@ -180,67 +242,82 @@
     try:
         return sum(float(matches[i]) * suffixes[matches[i+1].lower()]
                    for i in range(0, len(matches), 2))
     except KeyError:
         raise ValueError('Invalid ' + label) from None
 
 
-def parse_byte_count(value):
+def parse_byte_count(value: str) -> int:
     """Parse a byte count with optional k, m, or g suffixes"""
 
-    return _parse_units(value, _byte_units, 'byte count')
+    return int(_parse_units(value, _byte_units, 'byte count'))
 
 
-def parse_time_interval(value):
+def parse_time_interval(value: str) -> float:
     """Parse a time interval with optional s, m, h, d, or w suffixes"""
 
     return _parse_units(value, _time_units, 'time interval')
 
 
-def async_context_manager(coro):
+_ACM = TypeVar('_ACM', bound=AsyncContextManager)
+
+class _ACMWrapper(Generic[_ACM]):
+    """Async context manager wrapper"""
+
+    def __init__(self, coro: Awaitable[_ACM]):
+        self._coro = coro
+        self._coro_result: Optional[_ACM] = None
+
+    def __await__(self) -> Generator[Any, None, _ACM]:
+        return self._coro.__await__()
+
+    async def __aenter__(self) -> _ACM:
+        self._coro_result = await self._coro
+
+        return await self._coro_result.__aenter__()
+
+    async def __aexit__(self, exc_type: Optional[Type[BaseException]],
+                        exc_value: Optional[BaseException],
+                        traceback: Optional[TracebackType]) -> Optional[bool]:
+        assert self._coro_result is not None
+
+        exit_result = await self._coro_result.__aexit__(
+            exc_type, exc_value, traceback)
+
+        self._coro_result = None
+
+        return exit_result
+
+
+_ACMCoro = Callable[..., Awaitable[_ACM]]
+_ACMWrapperFunc = Callable[..., _ACMWrapper[_ACM]]
+
+def async_context_manager(coro: _ACMCoro[_ACM]) -> _ACMWrapperFunc[_ACM]:
     """Decorator for functions returning asynchronous context managers
 
        This decorator can be used on functions which return objects
        intended to be async context managers. The object returned by
        the function should implement __aenter__ and __aexit__ methods
        to run when the async context is entered and exited.
 
        This wrapper also allows the use of "await" on the function being
        decorated, to return the context manager without entering it.
 
     """
 
-    class AsyncContextManager:
-        """Async context manager wrapper"""
-
-        def __init__(self, coro):
-            self._coro = coro
-            self._result = None
-
-        def __await__(self):
-            return self._coro.__await__()
-
-        async def __aenter__(self):
-            self._result = await self._coro
-            return await self._result.__aenter__()
-
-        async def __aexit__(self, *exc_info):
-            await self._result.__aexit__(*exc_info)
-            self._result = None
-
     @functools.wraps(coro)
-    def context_wrapper(*args, **kwargs):
+    def context_wrapper(*args, **kwargs) -> _ACMWrapper[_ACM]:
         """Return an async context manager wrapper for this coroutine"""
 
-        return AsyncContextManager(coro(*args, **kwargs))
+        return _ACMWrapper(coro(*args, **kwargs))
 
     return context_wrapper
 
 
-async def maybe_wait_closed(writer):
+async def maybe_wait_closed(writer: '_SupportsWaitClosed') -> None:
     """Wait for a StreamWriter to close, if Python version supports it
 
        Python 3.8 triggers a false error report about garbage collecting
        an open stream if a close is in progress when a StreamWriter is
        garbage collected. This can be avoided by calling wait_closed(),
        but that method is not available in Python releases prior to 3.7.
        This function wraps this call, ignoring the error if the method
@@ -253,90 +330,92 @@
     except AttributeError: # pragma: no cover
         pass
 
 
 class Options:
     """Container for configuration options"""
 
-    def __init__(self, options=None, **kwargs):
+    kwargs: Dict[str, object]
+
+    def __init__(self, options: Optional['Options'] = None, **kwargs: object):
         if options:
             if not isinstance(options, type(self)):
                 raise TypeError('Invalid %s, got %s' %
                                 (type(self).__name__, type(options).__name__))
 
             self.kwargs = options.kwargs.copy()
         else:
             self.kwargs = {}
 
         self.kwargs.update(kwargs)
         self.prepare(**self.kwargs)
 
-    def prepare(self):
+    def prepare(self, **kwargs: object) -> None:
         """Pre-process configuration options"""
 
-    def update(self, kwargs):
+    def update(self, kwargs: Dict[str, object]) -> None:
         """Update options based on keyword parameters passed in"""
 
         self.kwargs.update(kwargs)
         self.prepare(**self.kwargs)
 
 
 class _RecordMeta(type):
     """Metaclass for general-purpose record type"""
 
-    def __new__(mcs, name, bases, ns):
+    def __new__(mcs: Type['_RecordMeta'], name: str, bases: Tuple[type, ...],
+                ns: Dict[str, object]) -> '_RecordMeta':
         if name != 'Record':
-            fields = ns.get('__annotations__', {}).keys()
+            fields = cast(Mapping[str, str],
+                          ns.get('__annotations__', {})).keys()
             defaults = {k: ns.get(k) for k in fields}
 
             ns = {k: v for k, v in ns.items() if k not in fields}
             ns['__slots__'] = defaults
 
-        return super().__new__(mcs, name, bases, ns)
+        return cast(_RecordMeta, super().__new__(mcs, name, bases, ns))
 
 
 class Record(metaclass=_RecordMeta):
-    """General-purpose record type with fixed set of fields"""
+    """Generic Record class"""
 
-    __slots__ = {}
+    __slots__: Mapping[str, object] = {}
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args: object, **kwargs: object):
         for k, v in self.__slots__.items():
             setattr(self, k, v)
 
         for k, v in zip(self.__slots__, args):
             setattr(self, k, v)
 
         for k, v in kwargs.items():
             setattr(self, k, v)
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return '%s(%s)' % (type(self).__name__,
                            ', '.join('%s=%r' % (k, getattr(self, k))
                                      for k in self.__slots__))
 
-    def __str__(self):
+    def __str__(self) -> str:
         values = ((k, self._format(k, getattr(self, k)))
                   for k in self.__slots__)
 
         return ', '.join('%s: %s' % (k, v) for k, v in values if v is not None)
 
-    def _format(self, k, v):
+    def _format(self, k: str, v: object) -> Optional[str]:
         """Format a field as a string"""
 
         # pylint: disable=no-self-use,unused-argument
 
         return str(v)
 
-
 class Error(Exception):
     """General SSH error"""
 
-    def __init__(self, code, reason, lang=DEFAULT_LANG):
-
+    def __init__(self, code: int, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(reason)
         self.code = code
         self.reason = reason
         self.lang = lang
 
 
 class DisconnectError(Error):
@@ -373,15 +452,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_COMPRESSION_ERROR, reason, lang)
 
 
 class ConnectionLost(DisconnectError):
     """SSH connection lost
 
        This exception is raised when the SSH connection to the remote
@@ -394,15 +473,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_CONNECTION_LOST, reason, lang)
 
 
 class HostKeyNotVerifiable(DisconnectError):
     """SSH host key not verifiable
 
        This exception is raised when the SSH server's host key or
@@ -413,15 +492,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_HOST_KEY_NOT_VERIFIABLE, reason, lang)
 
 
 class IllegalUserName(DisconnectError):
     """SSH illegal user name
 
        This exception is raised when an error occurs while processing
@@ -432,15 +511,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_ILLEGAL_USER_NAME, reason, lang)
 
 
 class KeyExchangeFailed(DisconnectError):
     """SSH key exchange failed
 
        This exception is raised when the SSH key exchange fails.
@@ -450,15 +529,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_KEY_EXCHANGE_FAILED, reason, lang)
 
 
 class MACError(DisconnectError):
     """SSH MAC error
 
        This exception is raised when an error occurs while processing
@@ -470,15 +549,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_MAC_ERROR, reason, lang)
 
 
 class PermissionDenied(DisconnectError):
     """SSH permission denied
 
        This exception is raised when there are no authentication methods
@@ -489,15 +568,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_NO_MORE_AUTH_METHODS_AVAILABLE, reason, lang)
 
 
 class ProtocolError(DisconnectError):
     """SSH protocol error
 
        This exception is raised when the SSH connection is disconnected
@@ -508,15 +587,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_PROTOCOL_ERROR, reason, lang)
 
 
 class ProtocolNotSupported(DisconnectError):
     """SSH protocol not supported
 
        This exception is raised when the remote system sends an SSH
@@ -527,15 +606,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_PROTOCOL_ERROR, reason, lang)
 
 
 class ServiceNotAvailable(DisconnectError):
     """SSH service not available
 
        This exception is raised when an unexpected service name is
@@ -546,15 +625,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(DISC_SERVICE_NOT_AVAILABLE, reason, lang)
 
 
 class ChannelOpenError(Error):
     """SSH channel open error
 
        This exception is raised by connection handlers to report
@@ -600,15 +679,15 @@
        :param lang:
            The language that the prompt is in
        :type prompt: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, prompt, lang=DEFAULT_LANG):
+    def __init__(self, prompt: str, lang: str = DEFAULT_LANG):
         super().__init__('Password change required: %s' % prompt)
         self.prompt = prompt
         self.lang = lang
 
 
 class BreakReceived(Exception):
     """SSH break request received
@@ -618,15 +697,15 @@
 
        :param msec:
            The duration of the break in milliseconds
        :type msec: `int`
 
     """
 
-    def __init__(self, msec):
+    def __init__(self, msec: int):
         super().__init__('Break for %s msec' % msec)
         self.msec = msec
 
 
 class SignalReceived(Exception):
     """SSH signal request received
 
@@ -635,28 +714,28 @@
 
        :param signal:
            The name of the signal sent by the client
        :type signal: `str`
 
     """
 
-    def __init__(self, signal):
+    def __init__(self, signal: str):
         super().__init__('Signal: %s' % signal)
         self.signal = signal
 
 
 class SoftEOFReceived(Exception):
     """SSH soft EOF request received
 
        This exception is raised on an SSH server stdin stream when the
        client sends an EOF from within the line editor on the channel.
 
     """
 
-    def __init__(self):
+    def __init__(self) -> None:
         super().__init__('Soft EOF')
 
 
 class TerminalSizeChanged(Exception):
     """SSH terminal size change notification received
 
        This exception is raised on an SSH server stdin stream when the
@@ -673,15 +752,15 @@
        :type width: `int`
        :type height: `int`
        :type pixwidth: `int`
        :type pixheight: `int`
 
     """
 
-    def __init__(self, width, height, pixwidth, pixheight):
+    def __init__(self, width: int, height: int, pixwidth: int, pixheight: int):
         super().__init__('Terminal size change: (%s, %s, %s, %s)' %
                          (width, height, pixwidth, pixheight))
         self.width = width
         self.height = height
         self.pixwidth = pixwidth
         self.pixheight = pixheight
 
@@ -696,14 +775,14 @@
     DISC_HOST_KEY_NOT_VERIFIABLE: HostKeyNotVerifiable,
     DISC_CONNECTION_LOST: ConnectionLost,
     DISC_NO_MORE_AUTH_METHODS_AVAILABLE: PermissionDenied,
     DISC_ILLEGAL_USER_NAME: IllegalUserName
 }
 
 
-def construct_disc_error(code, reason, lang):
+def construct_disc_error(code: int, reason: str, lang: str) -> DisconnectError:
     """Map disconnect error code to appropriate DisconnectError exception"""
 
     try:
         return _disc_error_map[code](reason, lang)
     except KeyError:
         return DisconnectError(code, '%s (error %d)' % (reason, code), lang)
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/misc.py` & `asyncssh-2.9.0/asyncssh/crypto/kdf.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2017-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2017-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -14,27 +14,20 @@
 #    that license
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
-"""Miscellaneous PyCA utility classes and functions"""
+"""A shim around PyCA for key derivation functions"""
 
-from cryptography.hazmat.primitives.hashes import MD5, SHA1, SHA224
-from cryptography.hazmat.primitives.hashes import SHA256, SHA384, SHA512
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
 
+from .misc import hashes
 
-hashes = {h.name: h for h in (MD5, SHA1, SHA224, SHA256, SHA384, SHA512)}
 
+def pbkdf2_hmac(hash_name: str, passphrase: bytes, salt: bytes,
+                count: int, key_size: int) -> bytes:
+    """A shim around PyCA for PBKDF2 HMAC key derivation"""
 
-class PyCAKey:
-    """Base class for PyCA private/public keys"""
-
-    def __init__(self, pyca_key):
-        self._pyca_key = pyca_key
-
-    @property
-    def pyca_key(self):
-        """Return the PyCA object associated with this key"""
-
-        return self._pyca_key
+    return PBKDF2HMAC(hashes[hash_name](), key_size, salt,
+                      count).derive(passphrase)
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/ec.py` & `asyncssh-2.9.0/asyncssh/crypto/ec.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,182 +16,189 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """A shim around PyCA for elliptic curve keys and key exchange"""
 
+from typing import Mapping, Optional, Type, cast
+
 from cryptography.exceptions import InvalidSignature
-from cryptography.hazmat.backends.openssl import backend
 from cryptography.hazmat.primitives.asymmetric import ec
 from cryptography.hazmat.primitives.serialization import Encoding
 from cryptography.hazmat.primitives.serialization import PublicFormat
 
-from .misc import PyCAKey, hashes
+from .misc import CryptoKey, PyCAKey, hashes
 
 
 # Short variable names are used here, matching names in the spec
 # pylint: disable=invalid-name
 
-_curves = {b'1.3.132.0.10': ec.SECP256K1,
-           b'nistp256':     ec.SECP256R1,
-           b'nistp384':     ec.SECP384R1,
-           b'nistp521':     ec.SECP521R1}
+_curves: Mapping[bytes, Type[ec.EllipticCurve]] = {
+    b'1.3.132.0.10': ec.SECP256K1,
+    b'nistp256':     ec.SECP256R1,
+    b'nistp384':     ec.SECP384R1,
+    b'nistp521':     ec.SECP521R1
+}
 
 
-class _ECKey(PyCAKey):
+class _ECKey(CryptoKey):
     """Base class for shim around PyCA for EC keys"""
 
-    def __init__(self, pyca_key, curve_id, pub, point, priv=None):
+    def __init__(self, pyca_key: PyCAKey, curve_id: bytes,
+                 pub: ec.EllipticCurvePublicNumbers, point: bytes,
+                 priv: Optional[ec.EllipticCurvePrivateNumbers] = None):
         super().__init__(pyca_key)
 
         self._curve_id = curve_id
         self._pub = pub
         self._point = point
         self._priv = priv
 
     @classmethod
-    def lookup_curve(cls, curve_id):
+    def lookup_curve(cls, curve_id: bytes) -> Type[ec.EllipticCurve]:
         """Look up curve and hash algorithm"""
 
         try:
             return _curves[curve_id]
         except KeyError: # pragma: no cover, other curves not registered
             raise ValueError('Unknown EC curve %s' %
                              curve_id.decode()) from None
 
     @property
-    def curve_id(self):
+    def curve_id(self) -> bytes:
         """Return the EC curve name"""
 
         return self._curve_id
 
     @property
-    def x(self):
+    def x(self) -> int:
         """Return the EC public x coordinate"""
 
         return self._pub.x
 
     @property
-    def y(self):
+    def y(self) -> int:
         """Return the EC public y coordinate"""
 
         return self._pub.y
 
     @property
-    def d(self):
+    def d(self) -> Optional[int]:
         """Return the EC private value as an integer"""
 
         return self._priv.private_value if self._priv else None
 
     @property
-    def public_value(self):
+    def public_value(self) -> bytes:
         """Return the EC public point value encoded as a byte string"""
 
         return self._point
 
     @property
-    def private_value(self):
+    def private_value(self) -> Optional[bytes]:
         """Return the EC private value encoded as a byte string"""
 
         if self._priv:
             keylen = (self._pub.curve.key_size + 7) // 8
             return self._priv.private_value.to_bytes(keylen, 'big')
         else:
             return None
 
 
 class ECDSAPrivateKey(_ECKey):
     """A shim around PyCA for ECDSA private keys"""
 
     @classmethod
-    def construct(cls, curve_id, public_value, private_value):
+    def construct(cls, curve_id: bytes, public_value: bytes,
+                  private_value: int) -> 'ECDSAPrivateKey':
         """Construct an ECDSA private key"""
 
         curve = cls.lookup_curve(curve_id)
 
-        priv_key = ec.derive_private_key(private_value, curve(), backend)
+        priv_key = ec.derive_private_key(private_value, curve())
         priv = priv_key.private_numbers()
         pub = priv.public_numbers
 
         return cls(priv_key, curve_id, pub, public_value, priv)
 
     @classmethod
-    def generate(cls, curve_id):
+    def generate(cls, curve_id: bytes) -> 'ECDSAPrivateKey':
         """Generate a new ECDSA private key"""
 
         curve = cls.lookup_curve(curve_id)
 
-        priv_key = ec.generate_private_key(curve(), backend)
+        priv_key = ec.generate_private_key(curve())
         priv = priv_key.private_numbers()
 
         pub_key = priv_key.public_key()
         pub = pub_key.public_numbers()
 
         public_value = pub_key.public_bytes(Encoding.X962,
                                             PublicFormat.UncompressedPoint)
 
         return cls(priv_key, curve_id, pub, public_value, priv)
 
-    def sign(self, data, hash_alg):
+    def sign(self, data: bytes, hash_name: str = '') -> bytes:
         """Sign a block of data"""
 
         # pylint: disable=unused-argument
 
-        priv_key = self.pyca_key
-        return priv_key.sign(data, ec.ECDSA(hashes[hash_alg]()))
+        priv_key = cast('ec.EllipticCurvePrivateKey', self.pyca_key)
+        return priv_key.sign(data, ec.ECDSA(hashes[hash_name]()))
 
 
 class ECDSAPublicKey(_ECKey):
     """A shim around PyCA for ECDSA public keys"""
 
     @classmethod
-    def construct(cls, curve_id, public_value):
+    def construct(cls, curve_id: bytes,
+                  public_value: bytes) -> 'ECDSAPublicKey':
         """Construct an ECDSA public key"""
 
         curve = cls.lookup_curve(curve_id)
 
         pub_key = ec.EllipticCurvePublicKey.from_encoded_point(curve(),
                                                                public_value)
         pub = pub_key.public_numbers()
 
         return cls(pub_key, curve_id, pub, public_value)
 
-    def verify(self, data, sig, hash_alg):
+    def verify(self, data: bytes, sig: bytes, hash_name: str = '') -> bool:
         """Verify the signature on a block of data"""
 
         try:
-            pub_key = self.pyca_key
-            pub_key.verify(sig, data, ec.ECDSA(hashes[hash_alg]()))
+            pub_key = cast('ec.EllipticCurvePublicKey', self.pyca_key)
+            pub_key.verify(sig, data, ec.ECDSA(hashes[hash_name]()))
             return True
         except InvalidSignature:
             return False
 
 
 class ECDH:
     """A shim around PyCA for ECDH key exchange"""
 
-    def __init__(self, curve_id):
+    def __init__(self, curve_id: bytes):
         try:
             curve = _curves[curve_id]
         except KeyError: # pragma: no cover, other curves not registered
             raise ValueError('Unknown EC curve %s' %
                              curve_id.decode()) from None
 
-        self._priv_key = ec.generate_private_key(curve(), backend)
+        self._priv_key = ec.generate_private_key(curve())
 
-    def get_public(self):
+    def get_public(self) -> bytes:
         """Return the public key to send in the handshake"""
 
         pub_key = self._priv_key.public_key()
 
         return pub_key.public_bytes(Encoding.X962,
                                     PublicFormat.UncompressedPoint)
 
-    def get_shared(self, peer_public):
+    def get_shared(self, peer_public: bytes) -> int:
         """Return the shared key from the peer's public key"""
 
         peer_key = ec.EllipticCurvePublicKey.from_encoded_point(
             self._priv_key.curve, peer_public)
 
         shared_key = self._priv_key.exchange(ec.ECDH(), peer_key)
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/chacha.py` & `asyncssh-2.9.0/asyncssh/crypto/chacha.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,15 +16,16 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """Chacha20-Poly1305 symmetric encryption handler"""
 
-import ctypes
+from ctypes import c_ulonglong, create_string_buffer
+from typing import Optional, Tuple
 
 from cryptography.exceptions import InvalidSignature
 from cryptography.hazmat.backends.openssl import backend
 from cryptography.hazmat.primitives.ciphers import Cipher
 from cryptography.hazmat.primitives.ciphers.algorithms import ChaCha20
 from cryptography.hazmat.primitives.poly1305 import Poly1305
 
@@ -33,31 +34,32 @@
 
 if backend.poly1305_supported():
     _CTR_0 = (0).to_bytes(8, 'little')
     _CTR_1 = (1).to_bytes(8, 'little')
 
     _POLY1305_KEYBYTES = 32
 
-    def chacha20(key, data, nonce, ctr):
+    def chacha20(key: bytes, data: bytes, nonce: bytes, ctr: int) -> bytes:
         """Encrypt/decrypt a block of data with the ChaCha20 cipher"""
 
         return Cipher(ChaCha20(key, (_CTR_1 if ctr else _CTR_0) + nonce),
-                      mode=None, backend=backend).encryptor().update(data)
+                      mode=None).encryptor().update(data)
 
-    def poly1305_key(key, nonce):
+    def poly1305_key(key: bytes, nonce: bytes) -> bytes:
         """Derive a Poly1305 key"""
 
         return chacha20(key, _POLY1305_KEYBYTES * b'\0', nonce, 0)
 
-    def poly1305(key, data, nonce):
+    def poly1305(key: bytes, data: bytes, nonce: bytes) -> bytes:
         """Compute a Poly1305 tag for a block of data"""
 
         return Poly1305.generate_tag(poly1305_key(key, nonce), data)
 
-    def poly1305_verify(key, data, nonce, tag):
+    def poly1305_verify(key: bytes, data: bytes,
+                        nonce: bytes, tag: bytes) -> bool:
         """Verify a Poly1305 tag for a block of data"""
 
         try:
             Poly1305.verify_tag(poly1305_key(key, nonce), data, tag)
             return True
         except InvalidSignature:
             return False
@@ -72,83 +74,86 @@
 
         _POLY1305_BYTES = nacl.crypto_onetimeauth_poly1305_bytes()
         _POLY1305_KEYBYTES = nacl.crypto_onetimeauth_poly1305_keybytes()
 
         _poly1305 = nacl.crypto_onetimeauth_poly1305
         _poly1305_verify = nacl.crypto_onetimeauth_poly1305_verify
 
-        def chacha20(key, data, nonce, ctr):
+        def chacha20(key: bytes, data: bytes, nonce: bytes, ctr: int) -> bytes:
             """Encrypt/decrypt a block of data with the ChaCha20 cipher"""
 
             datalen = len(data)
-            result = ctypes.create_string_buffer(datalen)
-            datalen = ctypes.c_ulonglong(datalen)
-            ctr = ctypes.c_ulonglong(ctr)
+            result = create_string_buffer(datalen)
+            ull_datalen = c_ulonglong(datalen)
+            ull_ctr = c_ulonglong(ctr)
 
-            _chacha20_xor_ic(result, data, datalen, nonce, ctr, key)
+            _chacha20_xor_ic(result, data, ull_datalen, nonce, ull_ctr, key)
 
             return result.raw
 
-        def poly1305_key(key, nonce):
+        def poly1305_key(key: bytes, nonce: bytes) -> bytes:
             """Derive a Poly1305 key"""
 
-            polykey = ctypes.create_string_buffer(_POLY1305_KEYBYTES)
-            polykeylen = ctypes.c_ulonglong(_POLY1305_KEYBYTES)
+            polykey = create_string_buffer(_POLY1305_KEYBYTES)
+            ull_polykeylen = c_ulonglong(_POLY1305_KEYBYTES)
 
-            _chacha20(polykey, polykeylen, nonce, key)
+            _chacha20(polykey, ull_polykeylen, nonce, key)
 
-            return polykey
+            return polykey.raw
 
-        def poly1305(key, data, nonce):
+        def poly1305(key: bytes, data: bytes, nonce: bytes) -> bytes:
             """Compute a Poly1305 tag for a block of data"""
 
-            tag = ctypes.create_string_buffer(_POLY1305_BYTES)
-            datalen = ctypes.c_ulonglong(len(data))
+            tag = create_string_buffer(_POLY1305_BYTES)
+            ull_datalen = c_ulonglong(len(data))
             polykey = poly1305_key(key, nonce)
 
-            _poly1305(tag, data, datalen, polykey)
+            _poly1305(tag, data, ull_datalen, polykey)
 
             return tag.raw
 
-        def poly1305_verify(key, data, nonce, tag):
+        def poly1305_verify(key: bytes, data: bytes,
+                            nonce: bytes, tag: bytes) -> bool:
             """Verify a Poly1305 tag for a block of data"""
 
-            datalen = ctypes.c_ulonglong(len(data))
+            ull_datalen = c_ulonglong(len(data))
             polykey = poly1305_key(key, nonce)
 
-            return _poly1305_verify(tag, data, datalen, polykey) == 0
+            return _poly1305_verify(tag, data, ull_datalen, polykey) == 0
 
         chacha_available = True
     except (ImportError, OSError, AttributeError):
         chacha_available = False
 
 
 class ChachaCipher:
     """Shim for Chacha20-Poly1305 symmetric encryption"""
 
-    def __init__(self, key):
+    def __init__(self, key: bytes):
         keylen = len(key) // 2
         self._key = key[:keylen]
         self._adkey = key[keylen:]
 
-    def encrypt_and_sign(self, header, data, nonce):
+    def encrypt_and_sign(self, header: bytes, data: bytes,
+                         nonce: bytes) -> Tuple[bytes, bytes]:
         """Encrypt and sign a block of data"""
 
         header = chacha20(self._adkey, header, nonce, 0)
         data = chacha20(self._key, data, nonce, 1)
         tag = poly1305(self._key, header + data, nonce)
 
         return header + data, tag
 
-    def decrypt_header(self, header, nonce):
+    def decrypt_header(self, header: bytes, nonce: bytes) -> bytes:
         """Decrypt header data"""
 
         return chacha20(self._adkey, header, nonce, 0)
 
-    def verify_and_decrypt(self, header, data, nonce, tag):
+    def verify_and_decrypt(self, header: bytes, data: bytes,
+                           nonce: bytes, tag: bytes) -> Optional[bytes]:
         """Verify the signature of and decrypt a block of data"""
 
         if poly1305_verify(self._key, header + data, nonce, tag):
             return chacha20(self._key, data, nonce, 1)
         else:
             return None
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/x509.py` & `asyncssh-2.9.0/asyncssh/crypto/x509.py`

 * *Files 13% similar despite different names*

```diff
@@ -17,27 +17,36 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """A shim around PyCA and PyOpenSSL for X.509 certificates"""
 
 from datetime import datetime, timezone
-from ipaddress import ip_address
 import re
 import sys
+from typing import Iterable, List, Optional, Sequence, Set, Union, cast
 
-from cryptography.hazmat.backends import default_backend
 from cryptography.hazmat.primitives.serialization import Encoding
 from cryptography.hazmat.primitives.serialization import PublicFormat
 from cryptography import x509
 
 from OpenSSL import crypto
 
 from ..asn1 import IA5String, der_decode, der_encode
-from .misc import hashes
+from ..misc import ip_address
+
+from .misc import PyCAKey, PyCAPrivateKey, PyCAPublicKey, hashes
+
+
+_Comment = Union[None, bytes, str]
+_Principals = Union[str, Sequence[str]]
+_Purposes = Union[None, str, Sequence[str]]
+_PurposeOIDs = Union[None, Set[x509.ObjectIdentifier]]
+_GeneralNameList = List[x509.GeneralName]
+_NameInit = Union[str, x509.Name, Iterable[x509.RelativeDistinguishedName]]
 
 
 _purpose_to_oid = {
     'serverAuth':        x509.ExtendedKeyUsageOID.SERVER_AUTH,
     'clientAuth':        x509.ExtendedKeyUsageOID.CLIENT_AUTH,
     'secureShellClient': x509.ObjectIdentifier('1.3.6.1.5.5.7.3.21'),
     'secureShellServer': x509.ObjectIdentifier('1.3.6.1.5.5.7.3.22')}
@@ -55,15 +64,15 @@
 if sys.platform == 'win32': # pragma: no cover
     # Windows' datetime.max is year 9999, but timestamps that large don't work
     _datetime_max = datetime.max.replace(year=2999, tzinfo=timezone.utc)
 else:
     _datetime_max = datetime.max.replace(tzinfo=timezone.utc)
 
 
-def _to_generalized_time(t):
+def _to_generalized_time(t: int) -> datetime:
     """Convert a timestamp value to a datetime"""
 
     if t <= 0:
         return _datetime_min
     else:
         try:
             return datetime.utcfromtimestamp(t).replace(tzinfo=timezone.utc)
@@ -73,39 +82,39 @@
                 # systems with a small time_t.
                 datetime.utcfromtimestamp(_datetime_max.timestamp() - 1)
                 return _datetime_max
             except (OSError, OverflowError): # pragma: no cover
                 return _datetime_32bit_max
 
 
-def _to_purpose_oids(purposes):
+def _to_purpose_oids(purposes: _Purposes) -> _PurposeOIDs:
     """Convert a list of purposes to purpose OIDs"""
 
     if isinstance(purposes, str):
         purposes = [p.strip() for p in purposes.split(',')]
 
     if not purposes or 'any' in purposes or _purpose_any in purposes:
         purpose_oids = None
     else:
         purpose_oids = set(_purpose_to_oid.get(p) or x509.ObjectIdentifier(p)
                            for p in purposes)
 
     return purpose_oids
 
 
-def _encode_user_principals(principals):
+def _encode_user_principals(principals: _Principals) -> _GeneralNameList:
     """Encode user principals as e-mail addresses"""
 
     if isinstance(principals, str):
         principals = [p.strip() for p in principals.split(',')]
 
     return [x509.RFC822Name(name) for name in principals]
 
 
-def _encode_host_principals(principals):
+def _encode_host_principals(principals: _Principals) -> _GeneralNameList:
     """Encode host principals as DNS names or IP addresses"""
 
     def _encode_host(name: str) -> x509.GeneralName:
         """Encode a host principal as a DNS name or IP address"""
 
         try:
             return x509.IPAddress(ip_address(name))
@@ -134,50 +143,51 @@
         ('OU', x509.NameOID.ORGANIZATIONAL_UNIT_NAME),
         ('CN', x509.NameOID.COMMON_NAME),
         ('DC', x509.NameOID.DOMAIN_COMPONENT))
 
     _to_oid = dict((k, v) for k, v in _attrs)
     _from_oid = dict((v, k) for k, v in _attrs)
 
-    def __init__(self, name):
+    def __init__(self, name: _NameInit):
         if isinstance(name, str):
             rdns = self._parse_name(name)
         elif isinstance(name, x509.Name):
             rdns = name.rdns
         else:
             rdns = name
 
         super().__init__(rdns)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return ','.join(self._format_rdn(rdn) for rdn in self.rdns)
 
-    def _format_rdn(self, rdn):
+    def _format_rdn(self, rdn: x509.RelativeDistinguishedName) -> str:
         """Format an X.509 RelativeDistinguishedName as a string"""
 
         return '+'.join(sorted(self._format_attr(nameattr) for nameattr in rdn))
 
-    def _format_attr(self, nameattr):
+    def _format_attr(self, nameattr: x509.NameAttribute) -> str:
         """Format an X.509 NameAttribute as a string"""
 
         attr = self._from_oid.get(nameattr.oid) or nameattr.oid.dotted_string
         return attr + '=' + self._escape.sub(r'\\\1', nameattr.value)
 
-    def _parse_name(self, name):
+    def _parse_name(self, name: str) -> \
+            Iterable[x509.RelativeDistinguishedName]:
         """Parse an X.509 distinguished name"""
 
-        return (self._parse_rdn(rdn) for rdn in self._split_name.findall(name))
+        return [self._parse_rdn(rdn) for rdn in self._split_name.findall(name)]
 
-    def _parse_rdn(self, rdn):
+    def _parse_rdn(self, rdn: str) -> x509.RelativeDistinguishedName:
         """Parse an X.509 relative distinguished name"""
 
         return x509.RelativeDistinguishedName(
             self._parse_nameattr(av) for av in self._split_rdn.findall(rdn))
 
-    def _parse_nameattr(self, av):
+    def _parse_nameattr(self, av: str) -> x509.NameAttribute:
         """Parse an X.509 name attribute/value pair"""
 
         try:
             attr, value = av.split('=', 1)
         except ValueError:
             raise ValueError('Invalid X.509 name attribute: ' + av) from None
 
@@ -189,57 +199,60 @@
 
         return x509.NameAttribute(oid, self._unescape.sub(r'\1', value))
 
 
 class X509NamePattern:
     """Match X.509 distinguished names"""
 
-    def __init__(self, pattern):
+    def __init__(self, pattern: str):
         if pattern.endswith(',*'):
             self._pattern = X509Name(pattern[:-2])
-            self._prefix_len = len(self._pattern.rdns)
+            self._prefix_len: Optional[int] = len(self._pattern.rdns)
         else:
             self._pattern = X509Name(pattern)
             self._prefix_len = None
 
-    def __eq__(self, other):
+    def __eq__(self, other: object) -> bool:
         # This isn't protected access - both objects are _RSAKey instances
         # pylint: disable=protected-access
 
-        return (isinstance(other, type(self)) and
-                self._pattern == other._pattern and
+        if not isinstance(other, X509NamePattern): # pragma: no cover
+            return NotImplemented
+
+        return (self._pattern == other._pattern and
                 self._prefix_len == other._prefix_len)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self._pattern, self._prefix_len))
 
-    def matches(self, name):
+    def matches(self, name: X509Name) -> bool:
         """Return whether an X.509 name matches this pattern"""
 
         return self._pattern.rdns == name.rdns[:self._prefix_len]
 
 
 class X509Certificate:
     """A shim around PyCA and PyOpenSSL for X.509 certificates"""
 
-    def __init__(self, cert, data):
+    def __init__(self, cert: x509.Certificate, data: bytes):
         self.data = data
 
         self.subject = X509Name(cert.subject)
         self.issuer = X509Name(cert.issuer)
         self.key_data = cert.public_key().public_bytes(
             Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
 
         self.openssl_cert = crypto.X509.from_cryptography(cert)
         self.subject_hash = hex(self.openssl_cert.get_subject().hash())[2:]
         self.issuer_hash = hex(self.openssl_cert.get_issuer().hash())[2:]
 
         try:
-            self.purposes = set(cert.extensions.get_extension_for_class(
-                x509.ExtendedKeyUsage).value)
+            self.purposes: Optional[Set[bytes]] = \
+                set(cert.extensions.get_extension_for_class(
+                    x509.ExtendedKeyUsage).value)
         except x509.ExtensionNotFound:
             self.purposes = None
 
         try:
             sans = cert.extensions.get_extension_for_class(
                 x509.SubjectAlternativeName).value
 
@@ -251,26 +264,32 @@
             principals = [attr.value for attr in cn]
 
             self.user_principals = principals
             self.host_principals = principals
 
         try:
             comment = cert.extensions.get_extension_for_oid(_nscomment_oid)
-            comment_der = comment.value.value
-            self.comment = der_decode(comment_der).value
+            comment_der = cast(x509.UnrecognizedExtension, comment.value).value
+            self.comment: Optional[bytes] = \
+                cast(IA5String, der_decode(comment_der)).value
         except x509.ExtensionNotFound:
             self.comment = None
 
-    def __eq__(self, other):
-        return isinstance(other, type(self)) and self.data == other.data
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, X509Certificate): # pragma: no cover
+            return NotImplemented
 
-    def __hash__(self):
+        return self.data == other.data
+
+    def __hash__(self) -> int:
         return hash(self.data)
 
-    def validate(self, trust_store, purposes, user_principal, host_principal):
+    def validate(self, trust_store: Sequence['X509Certificate'],
+                 purposes: _Purposes, user_principal: str,
+                 host_principal: str) -> None:
         """Validate an X.509 certificate"""
 
         purpose_oids = _to_purpose_oids(purposes)
 
         if purpose_oids and self.purposes and not purpose_oids & self.purposes:
             raise ValueError('Certificate purpose mismatch')
 
@@ -282,24 +301,30 @@
 
         x509_store = crypto.X509Store()
 
         for c in trust_store:
             x509_store.add_cert(c.openssl_cert)
 
         try:
-            x509_ctx = crypto.X509StoreContext(x509_store, self.openssl_cert)
+            x509_ctx = crypto.X509StoreContext(x509_store, self.openssl_cert,
+                                               None)
             x509_ctx.verify_certificate()
         except crypto.X509StoreContextError as exc:
             raise ValueError(str(exc)) from None
 
 
-def generate_x509_certificate(signing_key, key, subject, issuer, serial,
-                              valid_after, valid_before, ca, ca_path_len,
-                              purposes, user_principals, host_principals,
-                              hash_alg, comment):
+def generate_x509_certificate(signing_key: PyCAKey, key: PyCAKey,
+                              subject: _NameInit, issuer: Optional[_NameInit],
+                              serial: Optional[int], valid_after: int,
+                              valid_before: int, ca: bool,
+                              ca_path_len: Optional[int], purposes: _Purposes,
+                              user_principals: _Principals,
+                              host_principals: _Principals,
+                              hash_name: str,
+                              comment: _Comment) -> X509Certificate:
     """Generate a new X.509 certificate"""
 
     builder = x509.CertificateBuilder()
 
     subject = X509Name(subject)
     issuer = X509Name(issuer) if issuer else subject
     self_signed = subject == issuer
@@ -311,15 +336,15 @@
         serial = x509.random_serial_number()
 
     builder = builder.serial_number(serial)
 
     builder = builder.not_valid_before(_to_generalized_time(valid_after))
     builder = builder.not_valid_after(_to_generalized_time(valid_before))
 
-    builder = builder.public_key(key.pyca_key)
+    builder = builder.public_key(cast(PyCAPublicKey, key))
 
     if ca:
         basic_constraints = x509.BasicConstraints(ca=True,
                                                   path_length=ca_path_len)
         key_usage = x509.KeyUsage(digital_signature=False,
                                   content_commitment=False,
                                   key_encipherment=False,
@@ -344,46 +369,50 @@
 
     purpose_oids = _to_purpose_oids(purposes)
 
     if purpose_oids:
         builder = builder.add_extension(x509.ExtendedKeyUsage(purpose_oids),
                                         critical=False)
 
-    skid = x509.SubjectKeyIdentifier.from_public_key(key.pyca_key)
+    skid = x509.SubjectKeyIdentifier.from_public_key(cast(PyCAPublicKey, key))
+
     builder = builder.add_extension(skid, critical=False)
 
     if not self_signed:
-        issuer_pk = signing_key.convert_to_public().pyca_key
+        issuer_pk = cast(PyCAPrivateKey, signing_key).public_key()
         akid = x509.AuthorityKeyIdentifier.from_issuer_public_key(issuer_pk)
         builder = builder.add_extension(akid, critical=False)
 
     sans = _encode_user_principals(user_principals) + \
            _encode_host_principals(host_principals)
 
     if sans:
         builder = builder.add_extension(x509.SubjectAlternativeName(sans),
                                         critical=False)
 
     if comment:
         if isinstance(comment, str):
-            comment = comment.encode('utf-8')
+            comment_bytes = comment.encode('utf-8')
+        else:
+            comment_bytes = comment
 
-        comment = der_encode(IA5String(comment))
+        comment_bytes = der_encode(IA5String(comment_bytes))
         builder = builder.add_extension(
-            x509.UnrecognizedExtension(_nscomment_oid, comment), critical=False)
+            x509.UnrecognizedExtension(_nscomment_oid, comment_bytes),
+            critical=False)
 
     try:
-        hash_alg = hashes[hash_alg]() if hash_alg else None
+        hash_alg = hashes[hash_name]() if hash_name else None
     except KeyError:
         raise ValueError('Unknown hash algorithm') from None
 
-    cert = builder.sign(signing_key.pyca_key, hash_alg, default_backend())
+    cert = builder.sign(cast(PyCAPrivateKey, signing_key), hash_alg)
     data = cert.public_bytes(Encoding.DER)
 
     return X509Certificate(cert, data)
 
 
-def import_x509_certificate(data):
+def import_x509_certificate(data: bytes) -> X509Certificate:
     """Construct an X.509 certificate from DER data"""
 
-    cert = x509.load_der_x509_certificate(data, default_backend())
+    cert = x509.load_der_x509_certificate(data)
     return X509Certificate(cert, data)
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/rsa.py` & `asyncssh-2.9.0/asyncssh/crypto/rsa.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2014-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2014-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,150 +16,152 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """A shim around PyCA for RSA public and private keys"""
 
+from typing import Optional, cast
+
 from cryptography.exceptions import InvalidSignature
-from cryptography.hazmat.backends import default_backend
 from cryptography.hazmat.primitives.asymmetric.padding import MGF1, OAEP
 from cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15
 from cryptography.hazmat.primitives.asymmetric import rsa
 
-from .misc import PyCAKey, hashes
+from .misc import CryptoKey, PyCAKey, hashes
 
 
 # Short variable names are used here, matching names in the spec
 # pylint: disable=invalid-name
 
 
-class _RSAKey(PyCAKey):
+class _RSAKey(CryptoKey):
     """Base class for shim around PyCA for RSA keys"""
 
-    def __init__(self, pyca_key, pub, priv=None):
+    def __init__(self, pyca_key: PyCAKey, pub: rsa.RSAPublicNumbers,
+                 priv: rsa.RSAPrivateNumbers = None):
         super().__init__(pyca_key)
 
         self._pub = pub
         self._priv = priv
 
     @property
-    def n(self):
+    def n(self) -> int:
         """Return the RSA public modulus"""
 
         return self._pub.n
 
     @property
-    def e(self):
+    def e(self) -> int:
         """Return the RSA public exponent"""
 
         return self._pub.e
 
     @property
-    def d(self):
+    def d(self) -> Optional[int]:
         """Return the RSA private exponent"""
 
         return self._priv.d if self._priv else None
 
     @property
-    def p(self):
+    def p(self) -> Optional[int]:
         """Return the RSA first private prime"""
 
         return self._priv.p if self._priv else None
 
     @property
-    def q(self):
+    def q(self) -> Optional[int]:
         """Return the RSA second private prime"""
 
         return self._priv.q if self._priv else None
 
     @property
-    def dmp1(self):
+    def dmp1(self) -> Optional[int]:
         """Return d modulo p-1"""
 
         return self._priv.dmp1 if self._priv else None
 
     @property
-    def dmq1(self):
+    def dmq1(self) -> Optional[int]:
         """Return q modulo p-1"""
 
         return self._priv.dmq1 if self._priv else None
 
     @property
-    def iqmp(self):
+    def iqmp(self) -> Optional[int]:
         """Return the inverse of q modulo p"""
 
         return self._priv.iqmp if self._priv else None
 
 
 class RSAPrivateKey(_RSAKey):
     """A shim around PyCA for RSA private keys"""
 
     @classmethod
-    def construct(cls, n, e, d, p, q, dmp1, dmq1, iqmp):
+    def construct(cls, n: int, e: int, d: int, p: int, q: int,
+                  dmp1: int, dmq1: int, iqmp: int) -> 'RSAPrivateKey':
         """Construct an RSA private key"""
 
         pub = rsa.RSAPublicNumbers(e, n)
         priv = rsa.RSAPrivateNumbers(p, q, d, dmp1, dmq1, iqmp, pub)
-        priv_key = priv.private_key(default_backend())
+        priv_key = priv.private_key()
 
         return cls(priv_key, pub, priv)
 
     @classmethod
-    def generate(cls, key_size, exponent):
+    def generate(cls, key_size: int, exponent: int) -> 'RSAPrivateKey':
         """Generate a new RSA private key"""
 
-        priv_key = rsa.generate_private_key(exponent, key_size,
-                                            default_backend())
+        priv_key = rsa.generate_private_key(exponent, key_size)
         priv = priv_key.private_numbers()
         pub = priv.public_numbers
 
         return cls(priv_key, pub, priv)
 
-    def decrypt(self, data, hash_alg):
+    def decrypt(self, data: bytes, hash_name: str) -> Optional[bytes]:
         """Decrypt a block of data"""
 
         try:
-            hash_alg = hashes[hash_alg]()
-            priv_key = self.pyca_key
+            hash_alg = hashes[hash_name]()
+            priv_key = cast('rsa.RSAPrivateKey', self.pyca_key)
             return priv_key.decrypt(data, OAEP(MGF1(hash_alg), hash_alg, None))
         except ValueError:
             return None
 
-    def sign(self, data, hash_alg):
+    def sign(self, data: bytes, hash_name: str = '') -> bytes:
         """Sign a block of data"""
 
-        priv_key = self.pyca_key
-        return priv_key.sign(data, PKCS1v15(), hashes[hash_alg]())
+        priv_key = cast('rsa.RSAPrivateKey', self.pyca_key)
+        return priv_key.sign(data, PKCS1v15(), hashes[hash_name]())
 
 
 class RSAPublicKey(_RSAKey):
     """A shim around PyCA for RSA public keys"""
 
     @classmethod
-    def construct(cls, n, e):
+    def construct(cls, n: int, e: int) -> 'RSAPublicKey':
         """Construct an RSA public key"""
 
         pub = rsa.RSAPublicNumbers(e, n)
-        pub_key = pub.public_key(default_backend())
+        pub_key = pub.public_key()
 
         return cls(pub_key, pub)
 
-    def encrypt(self, data, hash_alg):
+    def encrypt(self, data: bytes, hash_name: str) -> Optional[bytes]:
         """Encrypt a block of data"""
 
         try:
-            hash_alg = hashes[hash_alg]()
-            pub_key = self.pyca_key
+            hash_alg = hashes[hash_name]()
+            pub_key = cast('rsa.RSAPublicKey', self.pyca_key)
             return pub_key.encrypt(data, OAEP(MGF1(hash_alg), hash_alg, None))
         except ValueError:
             return None
 
-    def verify(self, data, sig, hash_alg):
+    def verify(self, data: bytes, sig: bytes, hash_name: str = '') -> bool:
         """Verify the signature on a block of data"""
 
         try:
-            pub_key = self.pyca_key
-            pub_key.verify(sig, data, PKCS1v15(), hashes[hash_alg]())
+            pub_key = cast('rsa.RSAPublicKey', self.pyca_key)
+            pub_key.verify(sig, data, PKCS1v15(), hashes[hash_name]())
             return True
         except InvalidSignature:
             return False
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/__init__.py` & `asyncssh-2.9.0/asyncssh/crypto/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2014-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2014-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -30,24 +30,26 @@
 from .ed import curve25519_available, curve448_available
 from .ed import EdDSAPrivateKey, EdDSAPublicKey, Curve25519DH, Curve448DH
 
 from .ec_params import lookup_ec_curve_by_params
 
 from .kdf import pbkdf2_hmac
 
+from .misc import CryptoKey, PyCAKey
+
 from .rsa import RSAPrivateKey, RSAPublicKey
 
 # Import chacha20-poly1305 cipher if available
 from .chacha import ChachaCipher, chacha_available
 
 # Import umac cryptographic hash if available
 try:
     from .umac import umac32, umac64, umac96, umac128
 except (ImportError, AttributeError, OSError): # pragma: no cover
     pass
 
 # Import X.509 certificate support if available
 try:
-    from .x509 import X509Name, X509NamePattern
+    from .x509 import X509Certificate, X509Name, X509NamePattern
     from .x509 import generate_x509_certificate, import_x509_certificate
 except ImportError: # pragma: no cover
     pass
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/ec_params.py` & `asyncssh-2.9.0/asyncssh/crypto/ec_params.py`

 * *Files 4% similar despite different names*

```diff
@@ -22,29 +22,31 @@
 
 _curve_param_map = {}
 
 # Short variable names are used here, matching names in the spec
 # pylint: disable=invalid-name
 
 
-def register_prime_curve(curve_id, p, a, b, point, n):
+def register_prime_curve(curve_id: bytes, p: int, a: int, b: int,
+                         point: bytes, n: int) -> None:
     """Register an elliptic curve prime domain
 
        This function registers an elliptic curve prime domain by
        specifying the SSH identifier for the curve and the set of
        parameters describing the curve, generator point, and order.
        This allows EC keys encoded with explicit parameters to be
        mapped back into their SSH curve IDs.
 
     """
 
     _curve_param_map[p, a % p, b % p, point, n] = curve_id
 
 
-def lookup_ec_curve_by_params(p, a, b, point, n):
+def lookup_ec_curve_by_params(p: int, a: int, b: int,
+                              point: bytes, n: int) -> bytes:
     """Look up an elliptic curve by its parameters
 
        This function looks up an elliptic curve by its parameters
        and returns the curve's name.
 
     """
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/cipher.py` & `asyncssh-2.9.0/asyncssh/crypto/cipher.py`

 * *Files 9% similar despite different names*

```diff
@@ -16,131 +16,136 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """A shim around PyCA for accessing symmetric ciphers needed by AsyncSSH"""
 
+from typing import Any, MutableMapping, Optional, Tuple
+
 from cryptography.exceptions import InvalidTag
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives.ciphers import Cipher
+from cryptography.hazmat.primitives.ciphers import Cipher, CipherContext
+from cryptography.hazmat.primitives.ciphers.aead import AESGCM
 from cryptography.hazmat.primitives.ciphers.algorithms import AES, ARC4
 from cryptography.hazmat.primitives.ciphers.algorithms import Blowfish, CAST5
 from cryptography.hazmat.primitives.ciphers.algorithms import SEED, TripleDES
 
-from cryptography.hazmat.primitives.ciphers.modes import CBC, CTR, GCM
+from cryptography.hazmat.primitives.ciphers.modes import CBC, CTR
+
+
+_CipherAlgs = Tuple[Any, Any, int]
+_CipherParams = Tuple[int, int, int]
+
+
+_GCM_MAC_SIZE = 16
 
-_cipher_algs = {}
-_cipher_params = {}
+_cipher_algs: MutableMapping[str, _CipherAlgs] = {}
+_cipher_params: MutableMapping[str, _CipherParams] = {}
 
 
 class BasicCipher:
     """Shim for basic ciphers"""
 
-    def __init__(self, cipher_name, key, iv):
+    def __init__(self, cipher_name: str, key: bytes, iv: bytes):
         cipher, mode, initial_bytes = _cipher_algs[cipher_name]
 
-        self._cipher = Cipher(cipher(key), mode(iv) if mode else None,
-                              default_backend())
+        self._cipher = Cipher(cipher(key), mode(iv) if mode else None)
         self._initial_bytes = initial_bytes
-        self._encryptor = None
-        self._decryptor = None
+        self._encryptor: Optional[CipherContext] = None
+        self._decryptor: Optional[CipherContext] = None
 
-    def encrypt(self, data):
+    def encrypt(self, data: bytes) -> bytes:
         """Encrypt a block of data"""
 
         if not self._encryptor:
             self._encryptor = self._cipher.encryptor()
 
             if self._initial_bytes:
+                assert self._encryptor is not None
                 self._encryptor.update(self._initial_bytes * b'\0')
 
+        assert self._encryptor is not None
         return self._encryptor.update(data)
 
-    def decrypt(self, data):
+    def decrypt(self, data: bytes) -> bytes:
         """Decrypt a block of data"""
 
         if not self._decryptor:
             self._decryptor = self._cipher.decryptor()
 
             if self._initial_bytes:
+                assert self._decryptor is not None
                 self._decryptor.update(self._initial_bytes * b'\0')
 
+        assert self._decryptor is not None
         return self._decryptor.update(data)
 
 
 class GCMCipher:
     """Shim for GCM ciphers"""
 
-    def __init__(self, cipher_name, key, iv):
+    def __init__(self, cipher_name: str, key: bytes, iv: bytes):
         self._cipher = _cipher_algs[cipher_name][0]
         self._key = key
         self._iv = iv
 
-    def _update_iv(self):
+    def _update_iv(self) -> None:
         """Update the IV after each encrypt/decrypt operation"""
 
         invocation = int.from_bytes(self._iv[4:], 'big')
         invocation = (invocation + 1) & 0xffffffffffffffff
         self._iv = self._iv[:4] + invocation.to_bytes(8, 'big')
 
-    def encrypt_and_sign(self, header, data):
+    def encrypt_and_sign(self, header: bytes,
+                         data: bytes) -> Tuple[bytes, bytes]:
         """Encrypt and sign a block of data"""
 
-        encryptor = Cipher(self._cipher(self._key), GCM(self._iv),
-                           default_backend()).encryptor()
-
-        if header:
-            encryptor.authenticate_additional_data(header)
-
-        data = encryptor.update(data) + encryptor.finalize()
+        data = AESGCM(self._key).encrypt(self._iv, data, header)
 
         self._update_iv()
 
-        return header + data, encryptor.tag
+        return header + data[:-_GCM_MAC_SIZE], data[-_GCM_MAC_SIZE:]
 
-    def verify_and_decrypt(self, header, data, mac):
+    def verify_and_decrypt(self, header: bytes, data: bytes,
+                           mac: bytes) -> Optional[bytes]:
         """Verify the signature of and decrypt a block of data"""
 
-        decryptor = Cipher(self._cipher(self._key), GCM(self._iv, mac),
-                           default_backend()).decryptor()
-
-        decryptor.authenticate_additional_data(header)
-
         try:
-            data = decryptor.update(data) + decryptor.finalize()
+            decrypted_data: Optional[bytes] = \
+                AESGCM(self._key).decrypt(self._iv, data + mac, header)
         except InvalidTag:
-            data = None
+            decrypted_data = None
 
         self._update_iv()
 
-        return data
+        return decrypted_data
 
 
-def register_cipher(cipher_name, key_size, iv_size, block_size):
+def register_cipher(cipher_name: str, key_size: int,
+                    iv_size: int, block_size: int) -> None:
     """Register a symmetric cipher"""
 
     _cipher_params[cipher_name] = (key_size, iv_size, block_size)
 
 
-def get_cipher_params(cipher_name):
+def get_cipher_params(cipher_name: str) -> _CipherParams:
     """Get parameters of a symmetric cipher"""
 
     return _cipher_params[cipher_name]
 
 
 _cipher_alg_list = (
     ('aes128-cbc',   AES,       CBC,     0, 16, 16, 16),
     ('aes192-cbc',   AES,       CBC,     0, 24, 16, 16),
     ('aes256-cbc',   AES,       CBC,     0, 32, 16, 16),
     ('aes128-ctr',   AES,       CTR,     0, 16, 16, 16),
     ('aes192-ctr',   AES,       CTR,     0, 24, 16, 16),
     ('aes256-ctr',   AES,       CTR,     0, 32, 16, 16),
-    ('aes128-gcm',   AES,       GCM,     0, 16, 12, 16),
-    ('aes256-gcm',   AES,       GCM,     0, 32, 12, 16),
+    ('aes128-gcm',   None,      None,    0, 16, 12, 16),
+    ('aes256-gcm',   None,      None,    0, 32, 12, 16),
     ('arcfour',      ARC4,      None,    0, 16,  1,  1),
     ('arcfour40',    ARC4,      None,    0,  5,  1,  1),
     ('arcfour128',   ARC4,      None, 1536, 16,  1,  1),
     ('arcfour256',   ARC4,      None, 1536, 32,  1,  1),
     ('blowfish-cbc', Blowfish,  CBC,     0, 16,  8,  8),
     ('cast128-cbc',  CAST5,     CBC,     0, 16,  8,  8),
     ('des-cbc',      TripleDES, CBC,     0,  8,  8,  8),
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/dsa.py` & `asyncssh-2.9.0/asyncssh/crypto/dsa.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2014-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2014-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,113 +16,116 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """A shim around PyCA for DSA public and private keys"""
 
+from typing import Optional, cast
+
 from cryptography.exceptions import InvalidSignature
-from cryptography.hazmat.backends import default_backend
 from cryptography.hazmat.primitives.asymmetric import dsa
 
-from .misc import PyCAKey, hashes
+from .misc import CryptoKey, PyCAKey, hashes
 
 
 # Short variable names are used here, matching names in the spec
 # pylint: disable=invalid-name
 
 
-class _DSAKey(PyCAKey):
+class _DSAKey(CryptoKey):
     """Base class for shim around PyCA for DSA keys"""
 
-    def __init__(self, pyca_key, params, pub, priv=None):
+    def __init__(self, pyca_key: PyCAKey, params: dsa.DSAParameterNumbers,
+                 pub: dsa.DSAPublicNumbers, priv: dsa.DSAPrivateNumbers = None):
         super().__init__(pyca_key)
 
         self._params = params
         self._pub = pub
         self._priv = priv
 
     @property
-    def p(self):
+    def p(self) -> int:
         """Return the DSA public modulus"""
 
         return self._params.p
 
     @property
-    def q(self):
+    def q(self) -> int:
         """Return the DSA sub-group order"""
 
         return self._params.q
 
     @property
-    def g(self):
+    def g(self) -> int:
         """Return the DSA generator"""
 
         return self._params.g
 
     @property
-    def y(self):
+    def y(self) -> int:
         """Return the DSA public value"""
 
         return self._pub.y
 
     @property
-    def x(self):
+    def x(self) -> Optional[int]:
         """Return the DSA private value"""
 
         return self._priv.x if self._priv else None
 
 
 class DSAPrivateKey(_DSAKey):
     """A shim around PyCA for DSA private keys"""
 
     @classmethod
-    def construct(cls, p, q, g, y, x):
+    def construct(cls, p: int, q: int, g: int,
+                  y: int, x: int) -> 'DSAPrivateKey':
         """Construct a DSA private key"""
 
         params = dsa.DSAParameterNumbers(p, q, g)
         pub = dsa.DSAPublicNumbers(y, params)
         priv = dsa.DSAPrivateNumbers(x, pub)
-        priv_key = priv.private_key(default_backend())
+        priv_key = priv.private_key()
 
         return cls(priv_key, params, pub, priv)
 
     @classmethod
-    def generate(cls, key_size):
+    def generate(cls, key_size: int) -> 'DSAPrivateKey':
         """Generate a new DSA private key"""
 
-        priv_key = dsa.generate_private_key(key_size, default_backend())
+        priv_key = dsa.generate_private_key(key_size)
         priv = priv_key.private_numbers()
         pub = priv.public_numbers
         params = pub.parameter_numbers
 
         return cls(priv_key, params, pub, priv)
 
-    def sign(self, data, hash_alg):
+    def sign(self, data: bytes, hash_name: str = '') -> bytes:
         """Sign a block of data"""
 
-        priv_key = self.pyca_key
-        return priv_key.sign(data, hashes[hash_alg]())
+        priv_key = cast('dsa.DSAPrivateKey', self.pyca_key)
+        return priv_key.sign(data, hashes[hash_name]())
 
 
 class DSAPublicKey(_DSAKey):
     """A shim around PyCA for DSA public keys"""
 
     @classmethod
-    def construct(cls, p, q, g, y):
+    def construct(cls, p: int, q: int, g: int, y: int) -> 'DSAPublicKey':
         """Construct a DSA public key"""
 
         params = dsa.DSAParameterNumbers(p, q, g)
         pub = dsa.DSAPublicNumbers(y, params)
-        pub_key = pub.public_key(default_backend())
+        pub_key = pub.public_key()
 
         return cls(pub_key, params, pub)
 
-    def verify(self, data, sig, hash_alg):
+    def verify(self, data: bytes, sig: bytes, hash_name: str = '') -> bool:
         """Verify the signature on a block of data"""
 
         try:
-            pub_key = self.pyca_key
-            pub_key.verify(sig, data, hashes[hash_alg]())
+            pub_key = cast('dsa.DSAPublicKey', self.pyca_key)
+            pub_key.verify(sig, data, hashes[hash_name]())
             return True
         except InvalidSignature:
             return False
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/kdf.py` & `asyncssh-2.9.0/examples/simple_client.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,10 @@
-# Copyright (c) 2017-2020 by Ron Frederick <ronf@timeheart.net> and others.
+#!/usr/bin/env python3.6
+#
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -14,20 +16,18 @@
 #    that license
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
-"""A shim around PyCA for key derivation functions"""
-
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
-
-from .misc import hashes
-
-
-def pbkdf2_hmac(hash_name, passphrase, salt, count, key_size):
-    """A shim around PyCA for PBKDF2 HMAC key derivation"""
+import asyncio, asyncssh, sys
 
-    return PBKDF2HMAC(hashes[hash_name](), key_size, salt, count,
-                      default_backend()).derive(passphrase)
+async def run_client() -> None:
+    async with asyncssh.connect('localhost') as conn:
+        result = await conn.run('ls abc', check=True)
+        print(result.stdout, end='')
+
+try:
+    asyncio.get_event_loop().run_until_complete(run_client())
+except (OSError, asyncssh.Error) as exc:
+    sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/ed.py` & `asyncssh-2.9.0/asyncssh/crypto/ed.py`

 * *Files 10% similar despite different names*

```diff
@@ -18,188 +18,198 @@
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """A shim around PyCA and libnacl for Edwards-curve keys and key exchange"""
 
 import ctypes
 import os
+from typing import Dict, Optional, Union, cast
 
 from cryptography.exceptions import InvalidSignature
 from cryptography.hazmat.backends.openssl import backend
 from cryptography.hazmat.primitives.asymmetric import ed25519, ed448
 from cryptography.hazmat.primitives.asymmetric import x25519, x448
 from cryptography.hazmat.primitives.serialization import Encoding
 from cryptography.hazmat.primitives.serialization import PrivateFormat
 from cryptography.hazmat.primitives.serialization import PublicFormat
 from cryptography.hazmat.primitives.serialization import NoEncryption
 
-from .misc import PyCAKey
+from .misc import CryptoKey, PyCAKey
+
+
+_EdPrivateKey = Union[ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey]
+_EdPublicKey = Union[ed25519.Ed25519PublicKey, ed448.Ed448PublicKey]
 
 
 ed25519_available = backend.ed25519_supported()
 ed448_available = backend.ed448_supported()
 curve25519_available = backend.x25519_supported()
 curve448_available = backend.x448_supported()
 
 
 if ed25519_available or ed448_available: # pragma: no branch
-    class _EdKey(PyCAKey):
-        """Base class for shim around PyCA for Ed25519/Ed448 keys"""
+    class _EdDSAKey(CryptoKey):
+        """Base class for shim around PyCA for EdDSA keys"""
 
-        def __init__(self, pyca_key, pub, priv=None):
+        def __init__(self, pyca_key: PyCAKey, pub: bytes, priv: bytes = None):
             super().__init__(pyca_key)
 
             self._pub = pub
             self._priv = priv
 
         @property
-        def public_value(self):
+        def public_value(self) -> bytes:
             """Return the public value encoded as a byte string"""
 
             return self._pub
 
         @property
-        def private_value(self):
+        def private_value(self) -> Optional[bytes]:
             """Return the private value encoded as a byte string"""
 
             return self._priv
 
 
-    class EdDSAPrivateKey(_EdKey):
+    class EdDSAPrivateKey(_EdDSAKey):
         """A shim around PyCA for EdDSA private keys"""
 
-        _priv_classes = {}
+        _priv_classes: Dict[bytes, object] = {}
 
         if ed25519_available: # pragma: no branch
             _priv_classes[b'ed25519'] = ed25519.Ed25519PrivateKey
 
         if ed448_available: # pragma: no branch
             _priv_classes[b'ed448'] = ed448.Ed448PrivateKey
 
         @classmethod
-        def construct(cls, curve_id, priv):
+        def construct(cls, curve_id: bytes, priv: bytes) -> 'EdDSAPrivateKey':
             """Construct an EdDSA private key"""
 
-            priv_cls = cls._priv_classes[curve_id]
+            priv_cls = cast('_EdPrivateKey', cls._priv_classes[curve_id])
             priv_key = priv_cls.from_private_bytes(priv)
             pub_key = priv_key.public_key()
             pub = pub_key.public_bytes(Encoding.Raw, PublicFormat.Raw)
 
             return cls(priv_key, pub, priv)
 
         @classmethod
-        def generate(cls, curve_id):
+        def generate(cls, curve_id: bytes) -> 'EdDSAPrivateKey':
             """Generate a new EdDSA private key"""
 
-            priv_cls = cls._priv_classes[curve_id]
+            priv_cls = cast('_EdPrivateKey', cls._priv_classes[curve_id])
             priv_key = priv_cls.generate()
             priv = priv_key.private_bytes(Encoding.Raw, PrivateFormat.Raw,
                                           NoEncryption())
 
             pub_key = priv_key.public_key()
             pub = pub_key.public_bytes(Encoding.Raw, PublicFormat.Raw)
 
             return cls(priv_key, pub, priv)
 
-        def sign(self, data, hash_alg=None):
+        def sign(self, data: bytes, hash_name: str = '') -> bytes:
             """Sign a block of data"""
 
             # pylint: disable=unused-argument
 
-            return self.pyca_key.sign(data)
+            priv_key = cast('_EdPrivateKey', self.pyca_key)
+            return priv_key.sign(data)
 
 
-    class EdDSAPublicKey(_EdKey):
+    class EdDSAPublicKey(_EdDSAKey):
         """A shim around PyCA for EdDSA public keys"""
 
-        _pub_classes = {b'ed25519': ed25519.Ed25519PublicKey,
-                        b'ed448': ed448.Ed448PublicKey}
+        _pub_classes: Dict[bytes, object] = {
+            b'ed25519': ed25519.Ed25519PublicKey,
+            b'ed448': ed448.Ed448PublicKey
+        }
 
         @classmethod
-        def construct(cls, curve_id, pub):
+        def construct(cls, curve_id: bytes, pub: bytes) -> 'EdDSAPublicKey':
             """Construct an EdDSA public key"""
 
-            pub_cls = cls._pub_classes[curve_id]
+            pub_cls = cast('_EdPublicKey', cls._pub_classes[curve_id])
             pub_key = pub_cls.from_public_bytes(pub)
 
             return cls(pub_key, pub)
 
-        def verify(self, data, sig, hash_alg=None):
+        def verify(self, data: bytes, sig: bytes, hash_name: str = '') -> bool:
             """Verify the signature on a block of data"""
 
             # pylint: disable=unused-argument
 
             try:
-                self.pyca_key.verify(sig, data)
+                pub_key = cast('_EdPublicKey', self.pyca_key)
+                pub_key.verify(sig, data)
                 return True
             except InvalidSignature:
                 return False
 else: # pragma: no cover
-    class _EdKey:
-        """Base class for shim around libnacl for Ed25519 keys"""
+    class _EdDSANaclKey:
+        """Base class for shim around libnacl for EdDSA keys"""
 
-        def __init__(self, pub, priv=None):
+        def __init__(self, pub: bytes, priv: bytes = None):
             self._pub = pub
             self._priv = priv
 
         @property
-        def public_value(self):
+        def public_value(self) -> bytes:
             """Return the public value encoded as a byte string"""
 
             return self._pub
 
         @property
-        def private_value(self):
+        def private_value(self) -> Optional[bytes]:
             """Return the private value encoded as a byte string"""
 
             return self._priv[:-len(self._pub)] if self._priv else None
 
 
-    class EdDSAPrivateKey(_EdKey):
-        """A shim around libnacl for Ed25519 private keys"""
+    class EdDSAPrivateKey(_EdDSANaclKey): # type: ignore
+        """A shim around libnacl for EdDSA private keys"""
 
         @classmethod
-        def construct(cls, curve_id, priv):
+        def construct(cls, curve_id: bytes, priv: bytes) -> 'EdDSAPrivateKey':
             """Construct an EdDSA private key"""
 
             # pylint: disable=unused-argument
 
             return cls(*_ed25519_construct_keypair(priv))
 
         @classmethod
-        def generate(cls, curve_id):
+        def generate(cls, curve_id: str) -> 'EdDSAPrivateKey':
             """Generate a new EdDSA private key"""
 
             # pylint: disable=unused-argument
 
             return cls(*_ed25519_generate_keypair())
 
-        def sign(self, data, hash_alg=None):
+        def sign(self, data: bytes, hash_name: str = '') -> bytes:
             """Sign a block of data"""
 
             # pylint: disable=unused-argument
 
+            assert self._priv is not None
             return _ed25519_sign(data, self._priv)[:-len(data)]
 
 
-    class EdDSAPublicKey(_EdKey):
-        """A shim around libnacl for Ed25519 public keys"""
+    class EdDSAPublicKey(_EdDSANaclKey): # type: ignore
+        """A shim around libnacl for EdDSA public keys"""
 
         @classmethod
-        def construct(cls, curve_id, pub):
+        def construct(cls, curve_id: bytes, pub: bytes) -> 'EdDSAPublicKey':
             """Construct an EdDSA public key"""
 
             # pylint: disable=unused-argument
 
             if len(pub) != _ED25519_PUBLIC_BYTES:
-                raise ValueError('Invalid Ed25519 public key')
+                raise ValueError('Invalid EdDSA public key')
 
             return cls(pub)
 
-        def verify(self, data, sig, hash_alg=None):
+        def verify(self, data: bytes, sig: bytes, hash_name: str = '') -> bool:
             """Verify the signature on a block of data"""
 
             # pylint: disable=unused-argument
 
             try:
                 return _ed25519_verify(sig + data, self._pub) == data
             except ValueError:
@@ -220,48 +230,48 @@
         pass
 
 
 if curve25519_available: # pragma: no branch
     class Curve25519DH:
         """Curve25519 Diffie Hellman implementation based on PyCA"""
 
-        def __init__(self):
+        def __init__(self) -> None:
             self._priv_key = x25519.X25519PrivateKey.generate()
 
-        def get_public(self):
+        def get_public(self) -> bytes:
             """Return the public key to send in the handshake"""
 
             return self._priv_key.public_key().public_bytes(Encoding.Raw,
                                                             PublicFormat.Raw)
 
-        def get_shared(self, peer_public):
+        def get_shared(self, peer_public: bytes) -> int:
             """Return the shared key from the peer's public key"""
 
             peer_key = x25519.X25519PublicKey.from_public_bytes(peer_public)
             shared = self._priv_key.exchange(peer_key)
             return int.from_bytes(shared, 'big')
 else: # pragma: no cover
-    class Curve25519DH:
+    class Curve25519DH: # type: ignore
         """Curve25519 Diffie Hellman implementation based on libnacl"""
 
-        def __init__(self):
+        def __init__(self) -> None:
             self._private = os.urandom(_CURVE25519_SCALARBYTES)
 
-        def get_public(self):
+        def get_public(self) -> bytes:
             """Return the public key to send in the handshake"""
 
             public = ctypes.create_string_buffer(_CURVE25519_BYTES)
 
             if _curve25519_base(public, self._private) != 0:
                 # This error is never returned by libsodium
                 raise ValueError('Curve25519 failed') # pragma: no cover
 
             return public.raw
 
-        def get_shared(self, peer_public):
+        def get_shared(self, peer_public: bytes) -> int:
             """Return the shared key from the peer's public key"""
 
             if len(peer_public) != _CURVE25519_BYTES:
                 raise ValueError('Invalid curve25519 public key size')
 
             shared = ctypes.create_string_buffer(_CURVE25519_BYTES)
 
@@ -284,22 +294,22 @@
     except (ImportError, OSError, AttributeError):
         pass
 
 
 class Curve448DH:
     """Curve448 Diffie Hellman implementation based on PyCA"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         self._priv_key = x448.X448PrivateKey.generate()
 
-    def get_public(self):
+    def get_public(self) -> bytes:
         """Return the public key to send in the handshake"""
 
         return self._priv_key.public_key().public_bytes(Encoding.Raw,
                                                         PublicFormat.Raw)
 
-    def get_shared(self, peer_public):
+    def get_shared(self, peer_public: bytes) -> int:
         """Return the shared key from the peer's public key"""
 
         peer_key = x448.X448PublicKey.from_public_bytes(peer_public)
         shared = self._priv_key.exchange(peer_key)
         return int.from_bytes(shared, 'big')
```

### Comparing `asyncssh-2.8.1/asyncssh/crypto/umac.py` & `asyncssh-2.9.0/asyncssh/crypto/umac.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -20,104 +20,116 @@
 
 """UMAC cryptographic hash (RFC 4418) wrapper for Nettle library"""
 
 import binascii
 import ctypes
 import ctypes.util
 import sys
+from typing import TYPE_CHECKING, Callable, Optional
+
+
+if TYPE_CHECKING:
+    _ByteArray = ctypes.Array[ctypes.c_char]
+    _SetKey = Callable[[_ByteArray, bytes], None]
+    _SetNonce = Callable[[_ByteArray, ctypes.c_size_t, bytes], None]
+    _Update = Callable[[_ByteArray, ctypes.c_size_t, bytes], None]
+    _Digest = Callable[[_ByteArray, ctypes.c_size_t, _ByteArray], None]
+    _New = Callable[[bytes, Optional[bytes], Optional[bytes]], object]
 
 
 _UMAC_BLOCK_SIZE = 1024
 _UMAC_DEFAULT_CTX_SIZE = 4096
 
 
-def __build_umac(size):
+def _build_umac(size: int) -> '_New':
     """Function to build UMAC wrapper for a specific digest size"""
 
     _name = 'umac%d' % size
     _prefix = 'nettle_%s_' % _name
 
     try:
-        _context_size = getattr(_nettle, _prefix + '_ctx_size')()
+        _context_size: int = getattr(_nettle, _prefix + '_ctx_size')()
     except AttributeError:
         _context_size = _UMAC_DEFAULT_CTX_SIZE
 
-    _set_key = getattr(_nettle, _prefix + 'set_key')
-    _set_nonce = getattr(_nettle, _prefix + 'set_nonce')
-    _update = getattr(_nettle, _prefix + 'update')
-    _digest = getattr(_nettle, _prefix + 'digest')
+    _set_key: _SetKey = getattr(_nettle, _prefix + 'set_key')
+    _set_nonce: _SetNonce = getattr(_nettle, _prefix + 'set_nonce')
+    _update: _Update = getattr(_nettle, _prefix + 'update')
+    _digest: _Digest = getattr(_nettle, _prefix + 'digest')
 
 
     class _UMAC:
         """Wrapper for UMAC cryptographic hash
 
            This class supports the cryptographic hash API defined in PEP 452.
 
         """
 
         name = _name
         block_size = _UMAC_BLOCK_SIZE
         digest_size = size // 8
 
-        def __init__(self, ctx, nonce=None, msg=None):
+        def __init__(self, ctx: '_ByteArray', nonce: Optional[bytes] = None,
+                     msg: Optional[bytes] = None):
             self._ctx = ctx
 
             if nonce:
                 self.set_nonce(nonce)
 
             if msg:
                 self.update(msg)
 
         @classmethod
-        def new(cls, key, msg=None, nonce=None):
+        def new(cls, key: bytes, msg: Optional[bytes] = None,
+                nonce: Optional[bytes] = None) -> '_UMAC':
             """Construct a new UMAC hash object"""
 
             ctx = ctypes.create_string_buffer(_context_size)
             _set_key(ctx, key)
 
             return cls(ctx, nonce, msg)
 
-        def copy(self):
+        def copy(self) -> '_UMAC':
             """Return a new hash object with this object's state"""
 
             ctx = ctypes.create_string_buffer(self._ctx.raw)
             return self.__class__(ctx)
 
-        def set_nonce(self, nonce):
+        def set_nonce(self, nonce: bytes) -> None:
             """Reset the nonce associated with this object"""
 
             _set_nonce(self._ctx, ctypes.c_size_t(len(nonce)), nonce)
 
-        def update(self, msg):
+        def update(self, msg: bytes) -> None:
             """Add the data in msg to the hash"""
 
             _update(self._ctx, ctypes.c_size_t(len(msg)), msg)
 
-        def digest(self):
+        def digest(self) -> bytes:
             """Return the hash and increment nonce to begin a new message
 
                .. note:: The hash is reset and the nonce is incremented
                          when this function is called. This doesn't match
                          the behavior defined in PEP 452.
 
             """
 
             result = ctypes.create_string_buffer(self.digest_size)
             _digest(self._ctx, ctypes.c_size_t(self.digest_size), result)
             return result.raw
 
-        def hexdigest(self):
+        def hexdigest(self) -> str:
             """Return the digest as a string of hexadecimal digits"""
 
             return binascii.b2a_hex(self.digest()).decode('ascii')
 
 
-    globals()[_name] = _UMAC.new
+    return _UMAC.new
 
 
 _nettle_lib = 'libnettle-6' if sys.platform == 'win32' \
                             else ctypes.util.find_library('nettle')
 
-_nettle = ctypes.cdll.LoadLibrary(_nettle_lib)
+if _nettle_lib: # pragma: no branch
+    _nettle = ctypes.cdll.LoadLibrary(_nettle_lib)
 
-for _size in (32, 64, 96, 128):
-    __build_umac(_size)
+    umac32, umac64, umac96, umac128 = map(_build_umac, (32, 64, 96, 128))
```

### Comparing `asyncssh-2.8.1/asyncssh/gss.py` & `asyncssh-2.9.0/asyncssh/gss.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2017-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2017-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -22,38 +22,40 @@
 
 import sys
 
 try:
     # pylint: disable=unused-import
 
     if sys.platform == 'win32': # pragma: no cover
-        from .gss_win32 import GSSError, GSSClient, GSSServer
+        from .gss_win32 import GSSBase, GSSClient, GSSServer, GSSError
     else:
-        from .gss_unix import GSSError, GSSClient, GSSServer
+        from .gss_unix import GSSBase, GSSClient, GSSServer, GSSError
 
     gss_available = True
 except ImportError: # pragma: no cover
     gss_available = False
 
-    class GSSError(ValueError):
+    class GSSError(ValueError): # type: ignore
         """Stub class for reporting that GSS is not available"""
 
-        def __init__(self, maj_code=0, min_code=0, token=None):
+        def __init__(self, maj_code: int = 0, min_code: int = 0,
+                     token: bytes = None):
             super().__init__('GSS not available')
 
             self.maj_code = maj_code
             self.min_code = min_code
             self.token = token
 
+    class GSSBase: # type: ignore
+        """Base class for reporting that GSS is not available"""
 
-    class GSSClient:
+    class GSSClient(GSSBase): # type: ignore
         """Stub client class for reporting that GSS is not available"""
 
-        def __init__(self, _host, _delegate_creds):
+        def __init__(self, _host: str, _delegate_creds: bool):
             raise GSSError()
 
-
-    class GSSServer:
+    class GSSServer(GSSBase): # type: ignore
         """Stub client class for reporting that GSS is not available"""
 
-        def __init__(self, _host):
+        def __init__(self, _host: str):
             raise GSSError()
```

### Comparing `asyncssh-2.8.1/asyncssh/server.py` & `asyncssh-2.9.0/asyncssh/server.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,14 +16,41 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH server protocol handler"""
 
+from typing import TYPE_CHECKING, Optional, Tuple, Union
+
+from .auth import KbdIntChallenge, KbdIntResponse
+from .listener import SSHListener
+from .misc import MaybeAwait
+from .public_key import SSHKey
+from .stream import SSHSocketSessionFactory, SSHServerSessionFactory
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .connection import SSHServerConnection
+    from .channel import SSHServerChannel, SSHTCPChannel, SSHUNIXChannel
+    from .session import SSHServerSession, SSHTCPSession, SSHUNIXSession
+
+
+_NewSession = Union[bool, 'SSHServerSession', SSHServerSessionFactory,
+                    Tuple['SSHServerChannel', 'SSHServerSession'],
+                    Tuple['SSHServerChannel', SSHServerSessionFactory]]
+_NewTCPSession = Union[bool, 'SSHTCPSession', SSHSocketSessionFactory,
+                       Tuple['SSHTCPChannel', 'SSHTCPSession'],
+                       Tuple['SSHTCPChannel', SSHSocketSessionFactory]]
+_NewUNIXSession = Union[bool, 'SSHUNIXSession', SSHSocketSessionFactory,
+                        Tuple['SSHUNIXChannel', 'SSHUNIXSession'],
+                        Tuple['SSHUNIXChannel', SSHSocketSessionFactory]]
+_NewListener = Union[bool, SSHListener]
+
 
 class SSHServer:
     """SSH server protocol handler
 
        Applications may subclass this when implementing an SSH server to
        provide custom authentication and request handlers.
 
@@ -45,37 +72,38 @@
                  exception to perform cleanup, they should make sure to
                  re-raise it to allow AsyncSSH to finish its own cleanup.
 
     """
 
     # pylint: disable=no-self-use,unused-argument
 
-    def connection_made(self, conn):
+    def connection_made(self, conn: 'SSHServerConnection') -> None:
         """Called when a connection is made
 
            This method is called when a new TCP connection is accepted. The
            `conn` parameter should be stored if needed for later use.
 
            :param conn:
                The connection which was successfully opened
            :type conn: :class:`SSHServerConnection`
 
         """
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         """Called when a connection is lost or closed
 
            This method is called when a connection is closed. If the
            connection is shut down cleanly, *exc* will be `None`.
            Otherwise, it will be an exception explaining the reason for
            the disconnect.
 
         """
 
-    def debug_msg_received(self, msg, lang, always_display):
+    def debug_msg_received(self, msg: str, lang: str,
+                           always_display: bool) -> None:
         """A debug message was received on this connection
 
            This method is called when the other end of the connection sends
            a debug message. Applications should implement this method if
            they wish to process these debug messages.
 
            :param msg:
@@ -86,15 +114,15 @@
                Whether or not to display the message
            :type msg: `str`
            :type lang: `str`
            :type always_display: `bool`
 
         """
 
-    def begin_auth(self, username):
+    def begin_auth(self, username: str) -> MaybeAwait[bool]:
         """Authentication has been requested by the client
 
            This method will be called when authentication is attempted for
            the specified user. Applications should use this method to
            prepare whatever state they need to complete the authentication,
            such as loading in the set of authorized keys for that user. If
            no authentication is required for this user, this method should
@@ -112,28 +140,28 @@
 
            :returns: A `bool` indicating whether authentication is required
 
         """
 
         return True # pragma: no cover
 
-    def auth_completed(self):
+    def auth_completed(self) -> None:
         """Authentication was completed successfully
 
            This method is called when authentication has completed
            succesfully. Applications may use this method to perform
            processing based on the authenticated username or options in
            the authorized keys list or certificate associated with the
            user before any sessions are opened or forwarding requests
            are handled.
 
         """
 
-    def validate_gss_principal(self, username, user_principal,
-                               host_principal):
+    def validate_gss_principal(self, username: str, user_principal: str,
+                               host_principal: str) -> MaybeAwait[bool]:
         """Return whether a GSS principal is valid for this user
 
            This method should return `True` if the specified user
            principal is valid for the user being authenticated. It can
            be overridden by applications wishing to perform their own
            authentication.
 
@@ -160,15 +188,15 @@
                      is valid for the user being authenticated
 
         """
 
         host_domain = host_principal.rsplit('@')[-1]
         return user_principal == username + '@' + host_domain
 
-    def host_based_auth_supported(self):
+    def host_based_auth_supported(self) -> bool:
         """Return whether or not host-based authentication is supported
 
            This method should return `True` if client host-based
            authentication is supported. Applications wishing to support
            it must have this method return `True` and implement
            :meth:`validate_host_public_key` and/or :meth:`validate_host_ca_key`
            to return whether or not the key provided by the client is valid
@@ -180,16 +208,16 @@
            :returns: A `bool` indicating if host-based authentication is
                      supported or not
 
         """
 
         return False # pragma: no cover
 
-    def validate_host_public_key(self, client_host, client_addr,
-                                 client_port, key):
+    def validate_host_public_key(self, client_host: str, client_addr: str,
+                                 client_port: int, key: SSHKey) -> bool:
         """Return whether key is an authorized host key for this client host
 
            Host key based client authentication can be supported by
            passing authorized host keys in the `known_client_hosts`
            argument of :func:`create_server`. However, for more flexibility
            in matching on the allowed set of keys, this method can be
            implemented by the application to do the matching itself. It
@@ -226,16 +254,16 @@
            :returns: A `bool` indicating if the specified key is a valid
                      key for the client host being authenticated
 
         """
 
         return False # pragma: no cover
 
-    def validate_host_ca_key(self, client_host, client_addr,
-                             client_port, key):
+    def validate_host_ca_key(self, client_host: str, client_addr: str,
+                             client_port: int, key: SSHKey) -> bool:
         """Return whether key is an authorized CA key for this client host
 
            Certificate based client host authentication can be
            supported by passing authorized host CA keys in the
            `known_client_hosts` argument of :func:`create_server`.
            However, for more flexibility in matching on the allowed
            set of keys, this method can be implemented by the application
@@ -276,15 +304,16 @@
            :returns: A `bool` indicating if the specified key is a valid
                      CA key for the client host being authenticated
 
         """
 
         return False # pragma: no cover
 
-    def validate_host_based_user(self, username, client_host, client_username):
+    def validate_host_based_user(self, username: str, client_host: str,
+                                 client_username: str) -> MaybeAwait[bool]:
         """Return whether remote host and user is authorized for this user
 
            This method should return `True` if the specified client host
            and user is valid for the user being authenticated. It can be
            overridden by applications wishing to enforce restrictions on
            which remote users are allowed to authenticate as particular
            local users.
@@ -309,15 +338,15 @@
            :returns: A `bool` indicating if the specified client host
                      and user is valid for the user being authenticated
 
         """
 
         return username == client_username
 
-    def public_key_auth_supported(self):
+    def public_key_auth_supported(self) -> bool:
         """Return whether or not public key authentication is supported
 
            This method should return `True` if client public key
            authentication is supported. Applications wishing to support
            it must have this method return `True` and implement
            :meth:`validate_public_key` and/or :meth:`validate_ca_key`
            to return whether or not the key provided by the client is
@@ -329,15 +358,16 @@
            :returns: A `bool` indicating if public key authentication is
                      supported or not
 
         """
 
         return False # pragma: no cover
 
-    def validate_public_key(self, username, key):
+    def validate_public_key(self, username: str, key: SSHKey) -> \
+            MaybeAwait[bool]:
         """Return whether key is an authorized client key for this user
 
            Key based client authentication can be supported by
            passing authorized keys in the `authorized_client_keys`
            argument of :func:`create_server`, or by calling
            :meth:`set_authorized_keys
            <SSHServerConnection.set_authorized_keys>` on the server
@@ -374,15 +404,15 @@
            :returns: A `bool` indicating if the specified key is a valid
                      client key for the user being authenticated
 
         """
 
         return False # pragma: no cover
 
-    def validate_ca_key(self, username, key):
+    def validate_ca_key(self, username: str, key: SSHKey) -> MaybeAwait[bool]:
         """Return whether key is an authorized CA key for this user
 
            Certificate based client authentication can be supported by
            passing authorized CA keys in the `authorized_client_keys`
            argument of :func:`create_server`, or by calling
            :meth:`set_authorized_keys
            <SSHServerConnection.set_authorized_keys>` on the server
@@ -423,15 +453,15 @@
            :returns: A `bool` indicating if the specified key is a valid
                      CA key for the user being authenticated
 
         """
 
         return False # pragma: no cover
 
-    def password_auth_supported(self):
+    def password_auth_supported(self) -> bool:
         """Return whether or not password authentication is supported
 
            This method should return `True` if password authentication
            is supported. Applications wishing to support it must have
            this method return `True` and implement :meth:`validate_password`
            to return whether or not the password provided by the client
            is valid for the user being authenticated.
@@ -442,15 +472,16 @@
            :returns: A `bool` indicating if password authentication is
                      supported or not
 
         """
 
         return False # pragma: no cover
 
-    def validate_password(self, username, password):
+    def validate_password(self, username: str, password: str) -> \
+            MaybeAwait[bool]:
         """Return whether password is valid for this user
 
            This method should return `True` if the specified password
            is a valid password for the user being authenticated. It must
            be overridden by applications wishing to support password
            authentication.
 
@@ -487,15 +518,16 @@
            :raises: :exc:`PasswordChangeRequired` if the password
                     provided is expired and needs to be changed
 
         """
 
         return False # pragma: no cover
 
-    def change_password(self, username, old_password, new_password):
+    def change_password(self, username: str, old_password: str,
+                        new_password: str) -> MaybeAwait[bool]:
         """Handle a request to change a user's password
 
            This method is called when a user makes a request to
            change their password. It should first validate that
            the old password provided is correct and then attempt
            to change the user's password to the new value.
 
@@ -531,15 +563,15 @@
                     is not acceptable and the client should be asked
                     to provide another
 
         """
 
         return False # pragma: no cover
 
-    def kbdint_auth_supported(self):
+    def kbdint_auth_supported(self) -> bool:
         """Return whether or not keyboard-interactive authentication
            is supported
 
            This method should return `True` if keyboard-interactive
            authentication is supported. Applications wishing to support
            it must have this method return `True` and implement
            :meth:`get_kbdint_challenge` and :meth:`validate_kbdint_response`
@@ -556,15 +588,16 @@
            :returns: A `bool` indicating if keyboard-interactive
                      authentication is supported or not
 
         """
 
         return NotImplemented # pragma: no cover
 
-    def get_kbdint_challenge(self, username, lang, submethods):
+    def get_kbdint_challenge(self, username: str, lang: str,
+                             submethods: str) -> MaybeAwait[KbdIntChallenge]:
         """Return a keyboard-interactive auth challenge
 
            This method should return `True` if authentication should
            succeed without any challenge, `False` if authentication
            should fail without any challenge, or an auth challenge
            consisting of a challenge name, instructions, a language tag,
            and a list of tuples containing prompt strings and booleans
@@ -587,15 +620,17 @@
 
            :returns: An authentication challenge as described above
 
         """
 
         return False # pragma: no cover
 
-    def validate_kbdint_response(self, username, responses):
+    def validate_kbdint_response(
+            self, username: str, responses: KbdIntResponse) -> \
+                MaybeAwait[KbdIntChallenge]:
         """Return whether the keyboard-interactive response is valid
            for this user
 
            This method should validate the keyboard-interactive responses
            provided and return `True` if authentication should succeed
            with no further challenge, `False` if authentication should
            fail, or an additional auth challenge in the same format returned
@@ -619,15 +654,15 @@
 
            :returns: `True`, `False`, or the next challenge
 
         """
 
         return False # pragma: no cover
 
-    def session_requested(self):
+    def session_requested(self) -> MaybeAwait[_NewSession]:
         """Handle an incoming session request
 
            This method is called when a session open request is received
            from the client, indicating it wishes to open a channel to be
            used for running a shell, executing a command, or connecting
            to a subsystem. If the application wishes to accept the session,
            it must override this method to return either an
@@ -673,15 +708,16 @@
            :raises: :exc:`ChannelOpenError` if the session shouldn't
                     be accepted
 
         """
 
         return False # pragma: no cover
 
-    def connection_requested(self, dest_host, dest_port, orig_host, orig_port):
+    def connection_requested(self, dest_host: str, dest_port: int,
+                             orig_host: str, orig_port: int) -> _NewTCPSession:
         """Handle a direct TCP/IP connection request
 
            This method is called when a direct TCP/IP connection
            request is received by the server. Applications wishing
            to accept such connections must override this method.
 
            To allow standard port forwarding of data on the connection
@@ -741,15 +777,16 @@
            :raises: :exc:`ChannelOpenError` if the connection shouldn't
                     be accepted
 
         """
 
         return False # pragma: no cover
 
-    def server_requested(self, listen_host, listen_port):
+    def server_requested(self, listen_host: str,
+                         listen_port: int) -> MaybeAwait[_NewListener]:
         """Handle a request to listen on a TCP/IP address and port
 
            This method is called when a client makes a request to
            listen on an address and port for incoming TCP connections.
            The port to listen on may be `0` to request a dynamically
            allocated port. Applications wishing to allow TCP/IP connection
            forwarding must override this method.
@@ -788,15 +825,15 @@
                      * `False` to reject the request
                      * A coroutine object which returns one of the above
 
         """
 
         return False # pragma: no cover
 
-    def unix_connection_requested(self, dest_path):
+    def unix_connection_requested(self, dest_path: str) -> _NewUNIXSession:
         """Handle a direct UNIX domain socket connection request
 
            This method is called when a direct UNIX domain socket connection
            request is received by the server. Applications wishing to accept
            such connections must override this method.
 
            To allow standard path forwarding of data on the connection to the
@@ -846,15 +883,16 @@
            :raises: :exc:`ChannelOpenError` if the connection shouldn't
                     be accepted
 
         """
 
         return False # pragma: no cover
 
-    def unix_server_requested(self, listen_path):
+    def unix_server_requested(self, listen_path: str) -> \
+            MaybeAwait[_NewListener]:
         """Handle a request to listen on a UNIX domain socket
 
            This method is called when a client makes a request to
            listen on a path for incoming UNIX domain socket connections.
            Applications wishing to allow UNIX domain socket forwarding
            must override this method.
```

### Comparing `asyncssh-2.8.1/asyncssh/config.py` & `asyncssh-2.9.0/asyncssh/config.py`

 * *Files 5% similar despite different names*

```diff
@@ -23,72 +23,70 @@
 import os
 import re
 import shlex
 import socket
 
 from hashlib import sha1
 from pathlib import Path, PurePath
+from typing import Callable, Dict, List, NoReturn, Optional, Sequence
+from typing import Set, Tuple, Union, cast
 
 from .constants import DEFAULT_PORT
-from .misc import ip_address
+from .misc import DefTuple, FilePath, ip_address
 from .pattern import HostPatternList, WildcardPatternList
 
 
+ConfigPaths = Union[None, FilePath, Sequence[FilePath]]
+
+
 class ConfigParseError(ValueError):
     """Configuration parsing exception"""
 
 
 class SSHConfig:
     """Settings from an OpenSSH config file"""
 
     _conditionals = {'match'}
-    _no_split = set()
+    _no_split: Set[str] = set()
     _percent_expand = {'AuthorizedKeysFile'}
-    _handlers = {}
+    _handlers: Dict[str, Tuple[str, Callable]] = {}
 
-    def __init__(self, last_config, reload, *args, **kwargs):
+    def __init__(self, last_config: Optional['SSHConfig'], reload: bool):
         if last_config:
             self._last_options = last_config.get_options(reload)
         else:
             self._last_options = {}
 
-        self._path = ''
+        self._path = Path()
         self._line_no = 0
         self._matching = True
         self._options = self._last_options.copy()
-        self._tokens = {}
-
-        self._init_options(*args, **kwargs)
-
-    def _init_options(self):
-        """Set options used for matching and token substitutions"""
+        self._tokens: Dict[str, str] = {}
 
-        raise NotImplementedError
-
-    def _error(self, reason, *args):
+    def _error(self, reason: str, *args: object) -> NoReturn:
         """Raise a configuration parsing error"""
 
         raise ConfigParseError('%s line %s: %s' % (self._path, self._line_no,
                                                    reason % args))
 
-    def _match_val(self, match):
+    def _match_val(self, match: str) -> object:
         """Return the value to match against in a match condition"""
 
         raise NotImplementedError
 
-    def _set_tokens(self):
+    def _set_tokens(self) -> None:
         """Set the tokens available for percent expansion"""
 
         raise NotImplementedError
 
-    def _expand_val(self, value):
+    def _expand_val(self, value: str) -> str:
         """Perform percent token expansion on a string"""
 
         last_idx = 0
-        result = []
+        result: List[str] = []
 
         for match in re.finditer(r'%', value):
             idx = match.start()
 
             if idx < last_idx:
                 continue
 
@@ -101,15 +99,15 @@
             except KeyError:
                 raise ConfigParseError('Invalid token substitution: %s' %
                                        value[idx+1]) from None
 
         result.append(value[last_idx:])
         return ''.join(result)
 
-    def _include(self, option, args):
+    def _include(self, option: str, args: List[str]) -> None:
         """Read config from a list of other config files"""
 
         # pylint: disable=unused-argument
 
         for pattern in args:
             path = Path(pattern).expanduser()
 
@@ -120,15 +118,15 @@
                 path = Path(self._path).parent
 
             for path in path.glob(pattern):
                 self.parse(path)
 
         args.clear()
 
-    def _match(self, option, args):
+    def _match(self, option: str, args: List[str]) -> None:
         """Begin a conditional block"""
 
         # pylint: disable=unused-argument
 
         while args:
             match = args.pop(0).lower()
 
@@ -139,135 +137,138 @@
             match_val = self._match_val(match)
 
             if match_val is None:
                 self._error('Invalid match condition')
 
             try:
                 if match in ('address', 'localaddress'):
-                    pattern = HostPatternList(args.pop(0))
-                    ip = ip_address(match_val) if match_val else None
-                    self._matching = pattern.matches(None, match_val, ip)
+                    host_pat = HostPatternList(args.pop(0))
+                    ip = ip_address(cast(str, match_val)) \
+                        if match_val else None
+                    self._matching = host_pat.matches(None, match_val, ip)
                 else:
-                    pattern = WildcardPatternList(args.pop(0))
-                    self._matching = pattern.matches(match_val)
+                    wild_pat = WildcardPatternList(args.pop(0))
+                    self._matching = wild_pat.matches(match_val)
             except IndexError:
                 self._error('Missing %s match pattern', match)
 
             if not self._matching:
                 args.clear()
                 break
 
-    def _set_bool(self, option, args):
+    def _set_bool(self, option: str, args: List[str]) -> None:
         """Set a boolean config option"""
 
-        value = args.pop(0).lower()
+        value_str = args.pop(0).lower()
 
-        if value in ('yes', 'true'):
+        if value_str in ('yes', 'true'):
             value = True
-        elif value in ('no', 'false'):
+        elif value_str in ('no', 'false'):
             value = False
         else:
-            self._error('Invalid %s boolean value: %s', option, value)
+            self._error('Invalid %s boolean value: %s', option, value_str)
 
         if option not in self._options:
             self._options[option] = value
 
-    def _set_int(self, option, args):
+    def _set_int(self, option: str, args: List[str]) -> None:
         """Set an integer config option"""
 
-        value = args.pop(0)
+        value_str = args.pop(0)
 
         try:
-            value = int(value)
+            value = int(value_str)
         except ValueError:
-            self._error('Invalid %s integer value: %s', option, value)
+            self._error('Invalid %s integer value: %s', option, value_str)
 
         if option not in self._options:
             self._options[option] = value
 
-    def _set_string(self, option, args):
+    def _set_string(self, option: str, args: List[str]) -> None:
         """Set a string config option"""
 
-        value = args.pop(0)
+        value_str = args.pop(0)
 
-        if value.lower() == 'none':
+        if value_str.lower() == 'none':
             value = None
+        else:
+            value = value_str
 
         if option not in self._options:
             self._options[option] = value
 
-    def _append_string(self, option, args):
+    def _append_string(self, option: str, args: List[str]) -> None:
         """Append a string config option to a list"""
 
-        value = args.pop(0)
+        value_str = args.pop(0)
 
-        if value.lower() != 'none':
+        if value_str.lower() != 'none':
             if option in self._options:
-                self._options[option].append(value)
+                cast(List[str], self._options[option]).append(value_str)
             else:
-                self._options[option] = [value]
+                self._options[option] = [value_str]
         else:
             if option not in self._options:
                 self._options[option] = []
 
-    def _set_string_list(self, option, args):
+    def _set_string_list(self, option: str, args: List[str]) -> None:
         """Set whitespace-separated string config options as a list"""
 
         if option not in self._options:
             self._options[option] = args[:]
 
         args.clear()
 
-    def _append_string_list(self, option, args):
+    def _append_string_list(self, option: str, args: List[str]) -> None:
         """Append whitespace-separated string config options to a list"""
 
         if option in self._options:
-            self._options[option].extend(args)
+            cast(List[str], self._options[option]).extend(args)
         else:
             self._options[option] = args[:]
 
         args.clear()
 
-    def _set_address_family(self, option, args):
+    def _set_address_family(self, option: str, args: List[str]) -> None:
         """Set an address family config option"""
 
-        value = args.pop(0).lower()
+        value_str = args.pop(0).lower()
 
-        if value == 'any':
+        if value_str == 'any':
             value = socket.AF_UNSPEC
-        elif value == 'inet':
+        elif value_str == 'inet':
             value = socket.AF_INET
-        elif value == 'inet6':
+        elif value_str == 'inet6':
             value = socket.AF_INET6
         else:
-            self._error('Invalid %s value: %s', option, value)
+            self._error('Invalid %s value: %s', option, value_str)
 
         if option not in self._options:
             self._options[option] = value
 
-    def _set_rekey_limits(self, option, args):
+    def _set_rekey_limits(self, option: str, args: List[str]) -> None:
         """Set rekey limits config option"""
 
-        byte_limit = args.pop(0).lower()
+        byte_limit: Union[str, Tuple[()]] = args.pop(0).lower()
 
         if byte_limit == 'default':
             byte_limit = ()
 
         if args:
-            time_limit = args.pop(0).lower()
+            time_limit: Optional[Union[str, Tuple[()]]] = args.pop(0).lower()
 
             if time_limit == 'none':
                 time_limit = None
         else:
             time_limit = ()
 
         if option not in self._options:
             self._options[option] = byte_limit, time_limit
 
-    def parse(self, path):
+    def parse(self, path: Path) -> None:
         """Parse an OpenSSH config file and return matching declarations"""
 
         self._path = path
         self._line_no = 0
         self._matching = True
         self._tokens = {'%': '%'}
 
@@ -328,132 +329,138 @@
                 if isinstance(value, list):
                     value = [self._expand_val(item) for item in value]
                 elif isinstance(value, str):
                     value = self._expand_val(value)
 
                 self._options[option] = value
 
-    def get_options(self, reload):
+    def get_options(self, reload: bool) -> Dict[str, object]:
         """Return options to base a new config object on"""
 
         return self._last_options.copy() if reload else self._options.copy()
 
     @classmethod
-    def load(cls, last_config, config_paths, reload, *args, **kwargs):
+    def load(cls, last_config: Optional['SSHConfig'],
+             config_paths: ConfigPaths, reload: bool,
+             *args: object) -> 'SSHConfig':
         """Load a list of OpenSSH config files into a config object"""
 
-        config = cls(last_config, reload, *args, **kwargs)
+        config = cls(last_config, reload, *args)
 
         if config_paths:
-            if isinstance(config_paths, (str, bytes, PurePath)):
-                config_paths = [config_paths]
+            if isinstance(config_paths, (str, PurePath)):
+                paths: Sequence[FilePath] = [config_paths]
+            else:
+                paths = config_paths
 
-            for path in config_paths:
-                config.parse(path)
+            for path in paths:
+                config.parse(Path(path))
 
         return config
 
-    def get(self, option, default=None):
+    def get(self, option: str, default: object = None) -> object:
         """Get the value of a config option"""
 
         return self._options.get(option, default)
 
-    def get_compression_algs(self, default=None):
+    def get_compression_algs(self) -> DefTuple[str]:
         """Return the compression algorithms to use"""
 
         compression = self.get('Compression')
 
         if compression is None:
-            return default
+            return ()
         elif compression:
             return 'zlib@openssh.com,zlib,none'
         else:
             return 'none,zlib@openssh.com,zlib'
 
 
 class SSHClientConfig(SSHConfig):
     """Settings from an OpenSSH client config file"""
 
     _conditionals = {'host', 'match'}
     _no_split = {'remotecommand'}
     _percent_expand = {'CertificateFile', 'IdentityAgent',
                        'IdentityFile', 'ProxyCommand', 'RemoteCommand'}
 
-    def _init_options(self, local_user, user, host, port):
-        """Set options used for matching and token substitutions"""
-
-        # pylint: disable=arguments-differ
+    def __init__(self, last_config: 'SSHConfig', reload: bool,
+                 local_user: str, user: str, host: str, port: int) -> None:
+        super().__init__(last_config, reload)
 
         self._local_user = local_user
         self._orig_host = host
 
         if user != ():
             self._options['User'] = user
 
         if port != ():
             self._options['Port'] = port
 
-    def _match_val(self, match):
+    def _match_val(self, match: str) -> object:
         """Return the value to match against in a match condition"""
 
         if match == 'host':
             return self._options.get('Hostname', self._orig_host)
         elif match == 'originalhost':
             return self._orig_host
         elif match == 'localuser':
             return self._local_user
         elif match == 'user':
             return self._options.get('User', self._local_user)
         else:
             return None
 
-    def _match_host(self, option, args):
+    def _match_host(self, option: str, args: List[str]) -> None:
         """Begin a conditional block matching on host"""
 
         # pylint: disable=unused-argument
 
         pattern = ','.join(args)
         self._matching = WildcardPatternList(pattern).matches(self._orig_host)
         args.clear()
 
-    def _set_hostname(self, option, args):
+    def _set_hostname(self, option: str, args: List[str]) -> None:
         """Set hostname config option"""
 
         value = args.pop(0)
 
         if option not in self._options:
-            self._tokens['h'] = self._options.get(option, self._orig_host)
+            self._tokens['h'] = \
+                cast(str, self._options.get(option, self._orig_host))
             self._options[option] = self._expand_val(value)
 
-    def _set_request_tty(self, option, args):
+    def _set_request_tty(self, option: str, args: List[str]) -> None:
         """Set a pseudo-terminal request config option"""
 
-        value = args.pop(0).lower()
+        value_str = args.pop(0).lower()
 
-        if value in ('yes', 'true'):
-            value = True
-        elif value in ('no', 'false'):
+        if value_str in ('yes', 'true'):
+            value: Union[bool, str] = True
+        elif value_str in ('no', 'false'):
             value = False
-        elif value not in ('force', 'auto'):
-            self._error('Invalid %s value: %s', option, value)
+        elif value_str not in ('force', 'auto'):
+            self._error('Invalid %s value: %s', option, value_str)
+        else:
+            value = value_str
 
         if option not in self._options:
             self._options[option] = value
 
-    def _set_tokens(self):
+    def _set_tokens(self) -> None:
         """Set the tokens available for percent expansion"""
 
         local_host = socket.gethostname()
 
         idx = local_host.find('.')
         short_local_host = local_host if idx < 0 else local_host[:idx]
 
-        host = self._options.get('Hostname', self._orig_host)
+        host = cast(str, self._options.get('Hostname', self._orig_host))
         port = str(self._options.get('Port', DEFAULT_PORT))
-        user = self._options.get('User') or self._local_user
+        user = cast(str, self._options.get('User') or self._local_user)
 
         conn_info = ''.join((local_host, host, port, user))
         conn_hash = sha1(conn_info.encode('utf-8')).hexdigest()
 
         self._tokens.update({'C': conn_hash,
                              'd': str(Path.home()),
                              'h': host,
@@ -516,26 +523,26 @@
         ('UserKnownHostsFile',              SSHConfig._set_string_list)
     )}
 
 
 class SSHServerConfig(SSHConfig):
     """Settings from an OpenSSH server config file"""
 
-    def _init_options(self, local_addr, local_port, user, host, addr):
-        """Set options used for matching and token substitutions"""
-
-        # pylint: disable=arguments-differ
+    def __init__(self, last_config: 'SSHConfig', reload: bool,
+                 local_addr: str, local_port: int, user: str,
+                 host: str, addr: str) -> None:
+        super().__init__(last_config, reload)
 
         self._local_addr = local_addr
         self._local_port = local_port
         self._user = user
         self._host = host or addr
         self._addr = addr
 
-    def _match_val(self, match):
+    def _match_val(self, match: str) -> object:
         """Return the value to match against in a match condition"""
 
         if match == 'localaddress':
             return self._local_addr
         elif match == 'localport':
             return str(self._local_port)
         elif match == 'user':
@@ -543,15 +550,15 @@
         elif match == 'host':
             return self._host
         elif match == 'address':
             return self._addr
         else:
             return None
 
-    def _set_tokens(self):
+    def _set_tokens(self) -> None:
         """Set the tokens available for percent expansion"""
 
         self._tokens.update({'u': self._user})
 
     _handlers = {option.lower(): (option, handler) for option, handler in (
         ('Match',                           SSHConfig._match),
         ('Include',                         SSHConfig._include),
```

### Comparing `asyncssh-2.8.1/asyncssh/version.py` & `asyncssh-2.9.0/asyncssh/version.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -22,8 +22,8 @@
 
 __author__ = 'Ron Frederick'
 
 __author_email__ = 'ronf@timeheart.net'
 
 __url__ = 'http://asyncssh.timeheart.net'
 
-__version__ = '2.8.1'
+__version__ = '2.9.0'
```

### Comparing `asyncssh-2.8.1/asyncssh/rsa.py` & `asyncssh-2.9.0/asyncssh/dsa.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,227 +14,245 @@
 #    that license
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
-"""RSA public key encryption handler"""
+"""DSA public key encryption handler"""
+
+from typing import Optional, Tuple, Union, cast
 
 from .asn1 import ASN1DecodeError, ObjectIdentifier, der_encode, der_decode
-from .crypto import RSAPrivateKey, RSAPublicKey
+from .crypto import DSAPrivateKey, DSAPublicKey
 from .misc import all_ints
-from .packet import MPInt, String
+from .packet import MPInt, String, SSHPacket
 from .public_key import SSHKey, SSHOpenSSHCertificateV01, KeyExportError
 from .public_key import register_public_key_alg, register_certificate_alg
 from .public_key import register_x509_certificate_alg
 
 
-_hash_algs = {b'ssh-rsa':                'sha1',
-              b'rsa-sha2-256':           'sha256',
-              b'rsa-sha2-512':           'sha512',
-              b'ssh-rsa-sha224@ssh.com': 'sha224',
-              b'ssh-rsa-sha256@ssh.com': 'sha256',
-              b'ssh-rsa-sha384@ssh.com': 'sha384',
-              b'ssh-rsa-sha512@ssh.com': 'sha512',
-              b'rsa1024-sha1':           'sha1',
-              b'rsa2048-sha256':         'sha256'}
-
-
-class _RSAKey(SSHKey):
-    """Handler for RSA public key encryption"""
-
-    algorithm = b'ssh-rsa'
-    default_hash_alg = 'sha256'
-    pem_name = b'RSA'
-    pkcs8_oid = ObjectIdentifier('1.2.840.113549.1.1.1')
-    sig_algorithms = (b'rsa-sha2-256', b'rsa-sha2-512',
-                      b'ssh-rsa-sha224@ssh.com', b'ssh-rsa-sha256@ssh.com',
-                      b'ssh-rsa-sha384@ssh.com', b'ssh-rsa-sha512@ssh.com',
-                      b'ssh-rsa')
-    x509_sig_algorithms = (b'rsa2048-sha256', b'ssh-rsa')
-    x509_algorithms = tuple(b'x509v3-' + alg for alg in x509_sig_algorithms)
-    all_sig_algorithms = set(x509_sig_algorithms + sig_algorithms)
+_PrivateKeyArgs = Tuple[int, int, int, int, int]
+_PublicKeyArgs = Tuple[int, int, int, int]
+
+
+class _DSAKey(SSHKey):
+    """Handler for DSA public key encryption"""
+
+    _key: Union[DSAPrivateKey, DSAPublicKey]
 
-    def __eq__(self, other):
-        # This isn't protected access - both objects are _RSAKey instances
+    algorithm = b'ssh-dss'
+    default_hash_name = 'sha1'
+    pem_name = b'DSA'
+    pkcs8_oid = ObjectIdentifier('1.2.840.10040.4.1')
+    sig_algorithms = (algorithm,)
+    x509_algorithms = (b'x509v3-' + algorithm,)
+    all_sig_algorithms = set(sig_algorithms)
+
+    def __eq__(self, other: object) -> bool:
+        # This isn't protected access - both objects are _DSAKey instances
         # pylint: disable=protected-access
 
         return (isinstance(other, type(self)) and
-                self._key.n == other._key.n and
-                self._key.e == other._key.e and
-                self._key.d == other._key.d)
+                self._key.p == other._key.p and
+                self._key.q == other._key.q and
+                self._key.g == other._key.g and
+                self._key.y == other._key.y and
+                self._key.x == other._key.x)
 
-    def __hash__(self):
-        return hash((self._key.n, self._key.e, self._key.d,
-                     self._key.p, self._key.q))
+    def __hash__(self) -> int:
+        return hash((self._key.p, self._key.q, self._key.g,
+                     self._key.y, self._key.x))
 
     @classmethod
-    def generate(cls, _algorithm, *, key_size=2048, exponent=65537):
-        """Generate a new RSA private key"""
+    def generate(cls, algorithm: bytes) -> '_DSAKey': # type: ignore
+        """Generate a new DSA private key"""
+
+        # pylint: disable=arguments-differ,unused-argument
 
-        return cls(RSAPrivateKey.generate(key_size, exponent))
+        return cls(DSAPrivateKey.generate(key_size=1024))
 
     @classmethod
-    def make_private(cls, n, e, d, p, q, dmp1, dmq1, iqmp):
-        """Construct an RSA private key"""
+    def make_private(cls, key_params: object) -> SSHKey:
+        """Construct a DSA private key"""
+
+        p, q, g, y, x = cast(_PrivateKeyArgs, key_params)
 
-        return cls(RSAPrivateKey.construct(n, e, d, p, q, dmp1, dmq1, iqmp))
+        return cls(DSAPrivateKey.construct(p, q, g, y, x))
 
     @classmethod
-    def make_public(cls, n, e):
-        """Construct an RSA public key"""
+    def make_public(cls, key_params: object) -> SSHKey:
+        """Construct a DSA public key"""
 
-        return cls(RSAPublicKey.construct(n, e))
+        p, q, g, y = cast(_PublicKeyArgs, key_params)
+
+        return cls(DSAPublicKey.construct(p, q, g, y))
 
     @classmethod
-    def decode_pkcs1_private(cls, key_data):
-        """Decode a PKCS#1 format RSA private key"""
+    def decode_pkcs1_private(cls, key_data: object) -> \
+            Optional[_PrivateKeyArgs]:
+        """Decode a PKCS#1 format DSA private key"""
 
-        if (isinstance(key_data, tuple) and all_ints(key_data) and
-                len(key_data) >= 9):
-            return key_data[1:9]
+        if (isinstance(key_data, tuple) and len(key_data) == 6 and
+                all_ints(key_data) and key_data[0] == 0):
+            return cast(_PrivateKeyArgs, key_data[1:])
         else:
             return None
 
     @classmethod
-    def decode_pkcs1_public(cls, key_data):
-        """Decode a PKCS#1 format RSA public key"""
-
-        if (isinstance(key_data, tuple) and all_ints(key_data) and
-                len(key_data) == 2):
-            return key_data
+    def decode_pkcs1_public(cls, key_data: object) -> \
+            Optional[_PublicKeyArgs]:
+        """Decode a PKCS#1 format DSA public key"""
+
+        if (isinstance(key_data, tuple) and len(key_data) == 4 and
+                all_ints(key_data)):
+            y, p, q, g = key_data
+            return p, q, g, y
         else:
             return None
 
     @classmethod
-    def decode_pkcs8_private(cls, alg_params, data):
-        """Decode a PKCS#8 format RSA private key"""
-
-        if alg_params is not None:
-            return None
+    def decode_pkcs8_private(cls, alg_params: object,
+                             data: bytes) -> Optional[_PrivateKeyArgs]:
+        """Decode a PKCS#8 format DSA private key"""
 
         try:
-            key_data = der_decode(data)
+            x = der_decode(data)
         except ASN1DecodeError:
             return None
 
-        return cls.decode_pkcs1_private(key_data)
+        if (isinstance(alg_params, tuple) and len(alg_params) == 3 and
+                all_ints(alg_params) and isinstance(x, int)):
+            p, q, g = alg_params
+            y = pow(g, x, p)
+            return p, q, g, y, x
+        else:
+            return None
 
     @classmethod
-    def decode_pkcs8_public(cls, alg_params, data):
-        """Decode a PKCS#8 format RSA public key"""
-
-        if alg_params is not None:
-            return None
+    def decode_pkcs8_public(cls, alg_params: object,
+                            data: bytes) -> Optional[_PublicKeyArgs]:
+        """Decode a PKCS#8 format DSA public key"""
 
         try:
-            key_data = der_decode(data)
+            y = der_decode(data)
         except ASN1DecodeError:
             return None
 
-        return cls.decode_pkcs1_public(key_data)
+        if (isinstance(alg_params, tuple) and len(alg_params) == 3 and
+                all_ints(alg_params) and isinstance(y, int)):
+            p, q, g = alg_params
+            return p, q, g, y
+        else:
+            return None
 
     @classmethod
-    def decode_ssh_private(cls, packet):
-        """Decode an SSH format RSA private key"""
+    def decode_ssh_private(cls, packet: SSHPacket) -> _PrivateKeyArgs:
+        """Decode an SSH format DSA private key"""
 
-        n = packet.get_mpint()
-        e = packet.get_mpint()
-        d = packet.get_mpint()
-        iqmp = packet.get_mpint()
         p = packet.get_mpint()
         q = packet.get_mpint()
+        g = packet.get_mpint()
+        y = packet.get_mpint()
+        x = packet.get_mpint()
 
-        return n, e, d, p, q, d % (p-1), d % (q-1), iqmp
+        return p, q, g, y, x
 
     @classmethod
-    def decode_ssh_public(cls, packet):
-        """Decode an SSH format RSA public key"""
+    def decode_ssh_public(cls, packet: SSHPacket) -> _PublicKeyArgs:
+        """Decode an SSH format DSA public key"""
 
-        e = packet.get_mpint()
-        n = packet.get_mpint()
+        p = packet.get_mpint()
+        q = packet.get_mpint()
+        g = packet.get_mpint()
+        y = packet.get_mpint()
 
-        return n, e
+        return p, q, g, y
 
-    def encode_pkcs1_private(self):
-        """Encode a PKCS#1 format RSA private key"""
+    def encode_pkcs1_private(self) -> object:
+        """Encode a PKCS#1 format DSA private key"""
 
-        if not self._key.d:
+        if not self._key.x:
             raise KeyExportError('Key is not private')
 
-        return (0, self._key.n, self._key.e, self._key.d, self._key.p,
-                self._key.q, self._key.dmp1, self._key.dmq1, self._key.iqmp)
+        return (0, self._key.p, self._key.q, self._key.g,
+                self._key.y, self._key.x)
 
-    def encode_pkcs1_public(self):
-        """Encode a PKCS#1 format RSA public key"""
+    def encode_pkcs1_public(self) -> object:
+        """Encode a PKCS#1 format DSA public key"""
 
-        return self._key.n, self._key.e
+        return (self._key.y, self._key.p, self._key.q, self._key.g)
 
-    def encode_pkcs8_private(self):
-        """Encode a PKCS#8 format RSA private key"""
+    def encode_pkcs8_private(self) -> Tuple[object, object]:
+        """Encode a PKCS#8 format DSA private key"""
 
-        return None, der_encode(self.encode_pkcs1_private())
+        if not self._key.x:
+            raise KeyExportError('Key is not private')
+
+        return (self._key.p, self._key.q, self._key.g), der_encode(self._key.x)
 
-    def encode_pkcs8_public(self):
-        """Encode a PKCS#8 format RSA public key"""
+    def encode_pkcs8_public(self) -> Tuple[object, object]:
+        """Encode a PKCS#8 format DSA public key"""
 
-        return None, der_encode(self.encode_pkcs1_public())
+        return (self._key.p, self._key.q, self._key.g), der_encode(self._key.y)
 
-    def encode_ssh_private(self):
-        """Encode an SSH format RSA private key"""
+    def encode_ssh_private(self) -> bytes:
+        """Encode an SSH format DSA private key"""
 
-        if not self._key.d:
+        if not self._key.x:
             raise KeyExportError('Key is not private')
 
-        return b''.join((MPInt(self._key.n), MPInt(self._key.e),
-                         MPInt(self._key.d), MPInt(self._key.iqmp),
-                         MPInt(self._key.p), MPInt(self._key.q)))
+        return b''.join((MPInt(self._key.p), MPInt(self._key.q),
+                         MPInt(self._key.g), MPInt(self._key.y),
+                         MPInt(self._key.x)))
 
-    def encode_ssh_public(self):
-        """Encode an SSH format RSA public key"""
+    def encode_ssh_public(self) -> bytes:
+        """Encode an SSH format DSA public key"""
 
-        return b''.join((MPInt(self._key.e), MPInt(self._key.n)))
+        return b''.join((MPInt(self._key.p), MPInt(self._key.q),
+                         MPInt(self._key.g), MPInt(self._key.y)))
 
-    def encode_agent_cert_private(self):
-        """Encode RSA certificate private key data for agent"""
+    def encode_agent_cert_private(self) -> bytes:
+        """Encode DSA certificate private key data for agent"""
 
-        if not self._key.d:
+        if not self._key.x:
             raise KeyExportError('Key is not private')
 
-        return b''.join((MPInt(self._key.d), MPInt(self._key.iqmp),
-                         MPInt(self._key.p), MPInt(self._key.q)))
+        return MPInt(self._key.x)
 
-    def sign_ssh(self, data, sig_algorithm):
+    def sign_ssh(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Compute an SSH-encoded signature of the specified data"""
 
-        if not self._key.d:
+        # pylint: disable=unused-argument
+
+        if not self._key.x:
             raise ValueError('Private key needed for signing')
 
-        return String(self._key.sign(data, _hash_algs[sig_algorithm]))
+        sig = der_decode(self._key.sign(data, 'sha1'))
+        r, s = cast(Tuple[int, int], sig)
+        return String(r.to_bytes(20, 'big') + s.to_bytes(20, 'big'))
 
-    def verify_ssh(self, data, sig_algorithm, packet):
+    def verify_ssh(self, data: bytes, sig_algorithm: bytes,
+                   packet: SSHPacket) -> bool:
         """Verify an SSH-encoded signature of the specified data"""
 
+        # pylint: disable=unused-argument
+
         sig = packet.get_string()
         packet.check_end()
 
-        return self._key.verify(data, sig, _hash_algs[sig_algorithm])
-
-    def encrypt(self, data, algorithm):
-        """Encrypt a block of data with this key"""
-
-        return self._key.encrypt(data, _hash_algs[algorithm])
+        if len(sig) != 40:
+            return False
 
-    def decrypt(self, data, algorithm):
-        """Decrypt a block of data with this key"""
+        r = int.from_bytes(sig[:20], 'big')
+        s = int.from_bytes(sig[20:], 'big')
 
-        return self._key.decrypt(data, _hash_algs[algorithm])
+        return self._key.verify(data, der_encode((r, s)), 'sha1')
 
 
-register_public_key_alg(b'ssh-rsa', _RSAKey, True)
+register_public_key_alg(b'ssh-dss', _DSAKey, False)
 
-register_certificate_alg(1, b'ssh-rsa', b'ssh-rsa-cert-v01@openssh.com',
-                         _RSAKey, SSHOpenSSHCertificateV01, True)
+register_certificate_alg(1, b'ssh-dss', b'ssh-dss-cert-v01@openssh.com',
+                         _DSAKey, SSHOpenSSHCertificateV01, False)
 
-for alg in _RSAKey.x509_algorithms:
-    register_x509_certificate_alg(alg, True)
+for alg in _DSAKey.x509_algorithms:
+    register_x509_certificate_alg(alg, False)
```

### Comparing `asyncssh-2.8.1/asyncssh/client.py` & `asyncssh-2.9.0/asyncssh/client.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,14 +16,25 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH client protocol handler"""
 
+from typing import TYPE_CHECKING, Optional
+
+from .auth import KbdIntPrompts, KbdIntResponse, PasswordChangeResponse
+from .misc import MaybeAwait
+from .public_key import KeyPairListArg, SSHKey
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .connection import SSHClientConnection
+
 
 class SSHClient:
     """SSH client protocol handler
 
        Applications may subclass this when implementing an SSH client
        to receive callbacks when certain events occur on the SSH
        connection.
@@ -51,42 +62,43 @@
                  exception to perform cleanup, they should make sure to
                  re-raise it to allow AsyncSSH to finish its own cleanup.
 
     """
 
     # pylint: disable=no-self-use,unused-argument
 
-    def connection_made(self, conn):
+    def connection_made(self, conn: 'SSHClientConnection') -> None:
         """Called when a connection is made
 
            This method is called as soon as the TCP connection completes.
            The `conn` parameter should be stored if needed for later use.
 
            :param conn:
                The connection which was successfully opened
            :type conn: :class:`SSHClientConnection`
 
         """
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         """Called when a connection is lost or closed
 
            This method is called when a connection is closed. If the
            connection is shut down cleanly, *exc* will be `None`.
            Otherwise, it will be an exception explaining the reason for
            the disconnect.
 
            :param exc:
                The exception which caused the connection to close, or
                `None` if the connection closed cleanly
            :type exc: :class:`Exception`
 
         """
 
-    def debug_msg_received(self, msg, lang, always_display):
+    def debug_msg_received(self, msg: str, lang: str,
+                           always_display: bool) -> None:
         """A debug message was received on this connection
 
            This method is called when the other end of the connection sends
            a debug message. Applications should implement this method if
            they wish to process these debug messages.
 
            :param msg:
@@ -97,15 +109,16 @@
                Whether or not to display the message
            :type msg: `str`
            :type lang: `str`
            :type always_display: `bool`
 
         """
 
-    def validate_host_public_key(self, host, addr, port, key):
+    def validate_host_public_key(self, host: str, addr: str,
+                                 port: int, key: SSHKey) -> bool:
         """Return whether key is an authorized key for this host
 
            Server host key validation can be supported by passing known
            host keys in the `known_hosts` argument of
            :func:`create_connection`. However, for more flexibility
            in matching on the allowed set of keys, this method can be
            implemented by the application to do the matching itself. It
@@ -136,15 +149,16 @@
            :returns: A `bool` indicating if the specified key is a valid
                      key for the target host
 
         """
 
         return False # pragma: no cover
 
-    def validate_host_ca_key(self, host, addr, port, key):
+    def validate_host_ca_key(self, host: str, addr: str,
+                             port: int, key: SSHKey) -> bool:
         """Return whether key is an authorized CA key for this host
 
            Server host certificate validation can be supported by passing
            known host CA keys in the `known_hosts` argument of
            :func:`create_connection`. However, for more flexibility
            in matching on the allowed set of keys, this method can be
            implemented by the application to do the matching itself. It
@@ -178,15 +192,15 @@
            :returns: A `bool` indicating if the specified key is a valid
                      CA key for the target host
 
         """
 
         return False # pragma: no cover
 
-    def auth_banner_received(self, msg, lang):
+    def auth_banner_received(self, msg: str, lang: str) -> None:
         """An incoming authentication banner was received
 
            This method is called when the server sends a banner to display
            during authentication. Applications should implement this method
            if they wish to do something with the banner.
 
            :param msg:
@@ -194,30 +208,31 @@
            :param lang:
                The language the message is in
            :type msg: `str`
            :type lang: `str`
 
         """
 
-    def auth_completed(self):
+    def auth_completed(self) -> None:
         """Authentication was completed successfully
 
            This method is called when authentication has completed
            succesfully. Applications may use this method to create
            whatever client sessions and direct TCP/IP or UNIX domain
            connections are needed and/or set up listeners for incoming
            TCP/IP or UNIX domain connections coming from the server.
            However, :func:`create_connection` now blocks until
            authentication is complete, so any code which wishes to
            use the SSH connection can simply follow that call and
            doesn't need to be performed in a callback.
 
         """
 
-    def public_key_auth_requested(self):
+    def public_key_auth_requested(self) -> \
+            MaybeAwait[Optional[KeyPairListArg]]:
         """Public key authentication has been requested
 
            This method should return a private key corresponding to
            the user that authentication is being attempted for.
 
            This method may be called multiple times and can return a
            different key to try each time it is called. When there are
@@ -235,15 +250,15 @@
                      or `None` to move on to another authentication
                      method
 
         """
 
         return None # pragma: no cover
 
-    def password_auth_requested(self):
+    def password_auth_requested(self) -> MaybeAwait[Optional[str]]:
         """Password authentication has been requested
 
            This method should return a string containing the password
            corresponding to the user that authentication is being
            attempted for. It may be called multiple times and can
            return a different password to try each time, but most
            servers have a limit on the number of attempts allowed.
@@ -262,15 +277,16 @@
                      with or `None` to move on to another authentication
                      method
 
         """
 
         return None # pragma: no cover
 
-    def password_change_requested(self, prompt, lang):
+    def password_change_requested(self, prompt: str, lang: str) -> \
+            MaybeAwait[PasswordChangeResponse]:
         """A password change has been requested
 
            This method is called when password authentication was
            attempted and the user's password was expired on the
            server. To request a password change, this method should
            return a tuple or two strings containing the old and new
            passwords. Otherwise, it should return `NotImplemented`.
@@ -292,36 +308,36 @@
                      passwords or `NotImplemented` if password changes
                      aren't supported
 
         """
 
         return NotImplemented # pragma: no cover
 
-    def password_changed(self):
+    def password_changed(self) -> None:
         """The requested password change was successful
 
            This method is called to indicate that a requested password
            change was successful. It is generally followed by a call to
            :meth:`auth_completed` since this means authentication was
            also successful.
 
         """
 
-    def password_change_failed(self):
+    def password_change_failed(self) -> None:
         """The requested password change has failed
 
            This method is called to indicate that a requested password
            change failed, generally because the requested new password
            doesn't meet the password criteria on the remote system.
            After this method is called, other forms of authentication
            will automatically be attempted.
 
         """
 
-    def kbdint_auth_requested(self):
+    def kbdint_auth_requested(self) -> MaybeAwait[Optional[str]]:
         """Keyboard-interactive authentication has been requested
 
            This method should return a string containing a comma-separated
            list of submethods that the server should use for
            keyboard-interactive authentication. An empty string can be
            returned to let the server pick the type of keyboard-interactive
            authentication to perform. If keyboard-interactive authentication
@@ -342,15 +358,17 @@
                      use for authentication or `None` to move on to
                      another authentication method
 
         """
 
         return NotImplemented # pragma: no cover
 
-    def kbdint_challenge_received(self, name, instructions, lang, prompts):
+    def kbdint_challenge_received(self, name: str, instructions: str,
+                                  lang: str, prompts: KbdIntPrompts) -> \
+            MaybeAwait[Optional[KbdIntResponse]]:
         """A keyboard-interactive auth challenge has been received
 
            This method is called when the server sends a keyboard-interactive
            authentication challenge.
 
            The return value should be a list of strings of the same length
            as the number of prompts provided if the challenge can be
```

### Comparing `asyncssh-2.8.1/asyncssh/subprocess.py` & `asyncssh-2.9.0/asyncssh/subprocess.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2019-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,124 +16,139 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH subprocess handlers"""
 
+from typing import TYPE_CHECKING, Any, AnyStr, Callable
+from typing import Dict, Generic, Iterable, Optional
+
 from .constants import EXTENDED_DATA_STDERR
 from .process import SSHClientProcess
+from .session import DataType
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHChannel, SSHClientChannel
 
 
-class SSHSubprocessPipe:
+SubprocessFactory = Callable[[], 'SSHSubprocessProtocol']
+
+
+class SSHSubprocessPipe(Generic[AnyStr]):
     """SSH subprocess pipe"""
 
-    def __init__(self, chan, datatype=None):
-        self._chan = chan
+    def __init__(self, chan: 'SSHClientChannel[AnyStr]',
+                 datatype: DataType = None):
+        self._chan: 'SSHClientChannel[AnyStr]' = chan
         self._datatype = datatype
 
-    def close(self):
+    def close(self) -> None:
         """Shut down the remote process"""
 
         self._chan.close()
 
-    def get_extra_info(self, name, default=None):
+    def get_extra_info(self, name: str, default: Any = None) -> Any:
         """Return additional information about the remote process
 
            This method returns extra information about the channel
            associated with this subprocess. See :meth:`get_extra_info()
            <SSHClientChannel.get_extra_info>` on :class:`SSHClientChannel`
            for additional information.
 
         """
 
         return self._chan.get_extra_info(name, default)
 
 
-class SSHSubprocessReadPipe(SSHSubprocessPipe):
+class SSHSubprocessReadPipe(SSHSubprocessPipe[AnyStr]):
     """SSH subprocess pipe reader"""
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause delivery of incoming data from the remote process"""
 
         self._chan.pause_reading()
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume delivery of incoming data from the remote process"""
 
         self._chan.resume_reading()
 
 
-class SSHSubprocessWritePipe(SSHSubprocessPipe):
+class SSHSubprocessWritePipe(SSHSubprocessPipe[AnyStr]):
     """SSH subprocess pipe writer"""
 
-    def abort(self):
+    def abort(self) -> None:
         """Forcibly close the channel to the remote process"""
 
         self._chan.abort()
 
-    def can_write_eof(self):
+    def can_write_eof(self) -> bool:
         """Return whether the pipe supports :meth:`write_eof`"""
 
         return self._chan.can_write_eof()
 
-    def get_write_buffer_size(self):
+    def get_write_buffer_size(self) -> int:
         """Return the current size of the pipe's output buffer"""
 
         return self._chan.get_write_buffer_size()
 
-    def set_write_buffer_limits(self, high=None, low=None):
+    def set_write_buffer_limits(self, high: int = None,
+                                low: int = None) -> None:
         """Set the high- and low-water limits for write flow control"""
 
         self._chan.set_write_buffer_limits(high, low)
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Write data on this pipe"""
 
         self._chan.write(data, self._datatype)
 
-    def writelines(self, list_of_data):
+    def writelines(self, list_of_data: Iterable[AnyStr]) -> None:
         """Write a list of data bytes on this pipe"""
 
         self._chan.writelines(list_of_data, self._datatype)
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Write EOF on this pipe"""
 
         self._chan.write_eof()
 
 
-class SSHSubprocessProtocol:
+class SSHSubprocessProtocol(Generic[AnyStr]):
     """SSH subprocess protocol
 
        This class conforms to :class:`asyncio.SubprocessProtocol`, but with
        the following enhancement:
 
            * If encoding is set when the subprocess is created, all data
              passed to :meth:`pipe_data_received` will be string values
              containing Unicode data. However, for compatibility with
              :class:`asyncio.SubprocessProtocol`, encoding defaults to
              `None`, in which case all data is delivered as bytes.
 
     """
 
-    def connection_made(self, transport):
+    def connection_made(self,
+                        transport: 'SSHSubprocessTransport[AnyStr]') -> None:
         """Called when a remote process is successfully started
 
            This method is called when a a remote process is successfully
            started. The transport parameter should be stored if needed
            for later use.
 
            :param transport:
                The transport to use to communicate with the remote process.
            :type transport: :class:`SSHSubprocessTransport`
 
         """
 
-    def pipe_data_received(self, fd, data):
+    def pipe_data_received(self, fd: int, data: AnyStr) -> None:
         """Called when data is received from the remote process
 
            This method is called when data is received from the remote
            process. If an encoding was specified when the process was
            started, the data will be delivered as a string after decoding
            with the requested encoding. Otherwise, the data will be
            delivered as bytes.
@@ -144,15 +159,15 @@
            :param data:
                The data received from the remote process
            :type fd: `int`
            :type data: `str` or `bytes`
 
         """
 
-    def pipe_connection_lost(self, fd, exc):
+    def pipe_connection_lost(self, fd: int, exc: Optional[Exception]) -> None:
         """Called when the pipe to a remote process is closed
 
            This method is called when a pipe to a remote process is
            closed. If the channel is shut down cleanly, *exc* will be
            `None`. Otherwise, it will be an exception explaining the
            reason the pipe was closed.
 
@@ -163,26 +178,26 @@
                The exception which caused the channel to close, or
                `None` if the channel closed cleanly.
            :type fd: `int`
            :type exc: :class:`Exception` or `None`
 
         """
 
-    def process_exited(self):
+    def process_exited(self) -> None:
         """Called when a remote process has exited
 
            This method is called when the remote process has exited.
            Exit status information can be retrieved by calling
            :meth:`get_returncode() <SSHSubprocessTransport.get_returncode>`
            on the transport provided in :meth:`connection_made`.
 
         """
 
 
-class SSHSubprocessTransport(SSHClientProcess):
+class SSHSubprocessTransport(SSHClientProcess[AnyStr]):
     """SSH subprocess transport
 
        This class conforms to :class:`asyncio.SubprocessTransport`, but with
        the following enhancements:
 
            * All functionality available through :class:`SSHClientProcess`
              is also available here, such as the ability to dynamically
@@ -194,98 +209,104 @@
              should be strings containing Unicode data. The encoding defaults
              to `None`, though, to preserve compatibility with
              :class:`asyncio.SubprocessTransport`, which expects data
              to be written as bytes.
 
     """
 
-    def __init__(self, protocol_factory):
+    _chan: 'SSHClientChannel[AnyStr]'
+
+    def __init__(self, protocol_factory: SubprocessFactory):
         super().__init__()
 
-        self._pipes = {}
-        self._protocol = protocol_factory()
+        self._pipes: Dict[int, SSHSubprocessPipe[AnyStr]] = {}
+        self._protocol: SSHSubprocessProtocol[AnyStr] = protocol_factory()
 
-    def get_protocol(self):
+    def get_protocol(self) -> SSHSubprocessProtocol[AnyStr]:
         """Return the subprocess protocol associated with this transport"""
 
         return self._protocol
 
-    def connection_made(self, chan):
+    def connection_made(self, chan: 'SSHChannel[AnyStr]') -> None:
         """Handle a newly opened channel"""
 
         super().connection_made(chan)
 
         self._protocol.connection_made(self)
 
-        self._pipes = {0: SSHSubprocessWritePipe(chan),
-                       1: SSHSubprocessReadPipe(chan),
-                       2: SSHSubprocessReadPipe(chan, EXTENDED_DATA_STDERR)}
+        self._pipes = {
+            0: SSHSubprocessWritePipe(self._chan),
+            1: SSHSubprocessReadPipe(self._chan),
+            2: SSHSubprocessReadPipe(self._chan, EXTENDED_DATA_STDERR)
+        }
 
-    def session_started(self):
+    def session_started(self) -> None:
         """Override SSHClientProcess to avoid creating SSHReader/SSHWriter
            streams, since this class uses read/write pipe objects instead"""
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         """Handle an incoming channel close"""
 
         self._protocol.pipe_connection_lost(1, exc)
         self._protocol.pipe_connection_lost(2, exc)
         super().connection_lost(exc)
 
-    def data_received(self, data, datatype):
+    def data_received(self, data: AnyStr, datatype: DataType) -> None:
         """Handle incoming data from the remote process"""
 
         writer = self._writers.get(datatype)
 
         if writer:
             writer.write(data)
         else:
             fd = 2 if datatype == EXTENDED_DATA_STDERR else 1
             self._protocol.pipe_data_received(fd, data)
 
-    def exit_status_received(self, status):
+    def exit_status_received(self, status: int) -> None:
         """Handle exit status for the remote process"""
 
         super().exit_status_received(status)
         self._protocol.process_exited()
 
-    def exit_signal_received(self, signal, core_dumped, msg, lang):
+    def exit_signal_received(self, signal: str, core_dumped: bool,
+                             msg: str, lang: str) -> None:
         """Handle exit signal for the remote process"""
 
         super().exit_signal_received(signal, core_dumped, msg, lang)
         self._protocol.process_exited()
 
-    def get_pid(self):
+    def get_pid(self) -> Optional[int]:
         """Return the PID of the remote process
 
            This method always returns `None`, since SSH doesn't report
            remote PIDs.
 
         """
 
         # pylint: disable=no-self-use
 
         return None
 
-    def get_pipe_transport(self, fd):
+    def get_pipe_transport(self, fd: int) -> \
+            Optional[SSHSubprocessPipe[AnyStr]]:
         """Return a transport for the requested stream
 
            :param fd:
                The integer file descriptor (0-2) to return the transport for,
                where 0 means stdin, 1 means stdout, and 2 means stderr.
            :type fd: `int`
 
            :returns: an :class:`SSHSubprocessReadPipe` or
                      :class:`SSHSubprocessWritePipe`
 
         """
 
         return self._pipes.get(fd)
 
-    def get_returncode(self):
+    def get_returncode(self) -> Optional[int]:
         """Return the exit status or signal for the remote process
 
            This method returns the exit status of the session if one has
            been sent. If an exit signal was sent, this method returns
            the negative of the numeric value of that signal, matching
            the behavior of :meth:`asyncio.SubprocessTransport.get_returncode`.
            If neither has been sent, this method returns `None`.
```

### Comparing `asyncssh-2.8.1/asyncssh/compression.py` & `asyncssh-2.9.0/asyncssh/compression.py`

 * *Files 24% similar despite different names*

```diff
@@ -16,112 +16,135 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH compression handlers"""
 
+from typing import Callable, List, Optional
 import zlib
 
-
-_cmp_algs = []
-_default_cmp_algs = []
+_cmp_algs: List[bytes] = []
+_default_cmp_algs: List[bytes] = []
 
 _cmp_params = {}
 
 _cmp_compressors = {}
 _cmp_decompressors = {}
 
 
-def _none():
-    """Compressor/decompressor for no compression."""
+class Compressor:
+    """Base class for data compressor"""
+
+    def compress(self, data: bytes) -> Optional[bytes]:
+        """Compress data"""
+
+        raise NotImplementedError
+
+
+class Decompressor:
+    """Base class for data decompressor"""
+
+    def decompress(self, data: bytes) -> Optional[bytes]:
+        """Decompress data"""
+
+        raise NotImplementedError
+
+
+_CompressorType = Callable[[], Optional[Compressor]]
+_DecompressorType = Callable[[], Optional[Decompressor]]
+
+
+def _none() -> None:
+    """Compressor/decompressor for no compression"""
 
     return None
 
 
-class _ZLibCompress:
+class _ZLibCompress(Compressor):
     """Wrapper class to force a sync flush and handle exceptions"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         self._comp = zlib.compressobj()
 
-    def compress(self, data):
+    def compress(self, data: bytes) -> Optional[bytes]:
         """Compress data using zlib compression with sync flush"""
 
         try:
             return self._comp.compress(data) + \
                    self._comp.flush(zlib.Z_SYNC_FLUSH)
         except zlib.error: # pragma: no cover
             return None
 
 
-class _ZLibDecompress:
+class _ZLibDecompress(Decompressor):
     """Wrapper class to handle exceptions"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         self._decomp = zlib.decompressobj()
 
-    def decompress(self, data):
+    def decompress(self, data: bytes) -> Optional[bytes]:
         """Decompress data using zlib compression"""
 
         try:
             return self._decomp.decompress(data)
         except zlib.error: # pragma: no cover
             return None
 
 
-def register_compression_alg(alg, compressor, decompressor,
-                             after_auth, default):
+def register_compression_alg(alg: bytes, compressor: _CompressorType,
+                             decompressor: _DecompressorType,
+                             after_auth: bool, default: bool) -> None:
     """Register a compression algorithm"""
 
     _cmp_algs.append(alg)
 
     if default:
         _default_cmp_algs.append(alg)
 
     _cmp_params[alg] = after_auth
 
     _cmp_compressors[alg] = compressor
     _cmp_decompressors[alg] = decompressor
 
 
-def get_compression_algs():
+def get_compression_algs() -> List[bytes]:
     """Return supported compression algorithms"""
 
     return _cmp_algs
 
 
-def get_default_compression_algs():
+def get_default_compression_algs() -> List[bytes]:
     """Return default compression algorithms"""
 
     return _default_cmp_algs
 
 
-def get_compression_params(alg):
+def get_compression_params(alg: bytes) -> bool:
     """Get parameters of a compression algorithm
 
        This function returns whether or not a compression algorithm should
        be delayed until after authentication completes.
 
     """
 
     return _cmp_params[alg]
 
 
-def get_compressor(alg):
+def get_compressor(alg: bytes) -> Optional[Compressor]:
     """Return an instance of a compressor
 
        This function returns an object that can be used for data compression.
 
     """
 
     return _cmp_compressors[alg]()
 
 
-def get_decompressor(alg):
+def get_decompressor(alg: bytes) -> Optional[Decompressor]:
     """Return an instance of a decompressor
 
        This function returns an object that can be used for data decompression.
 
     """
 
     return _cmp_decompressors[alg]()
```

### Comparing `asyncssh-2.8.1/asyncssh/channel.py` & `asyncssh-2.9.0/asyncssh/channel.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2022 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -23,153 +23,186 @@
 import asyncio
 import binascii
 import codecs
 import inspect
 import re
 import signal as _signal
 from types import MappingProxyType
+from typing import TYPE_CHECKING, Any, AnyStr, Awaitable, Callable
+from typing import Dict, Generic, Iterable, List, Mapping, Optional
+from typing import Set, Tuple, Union, cast
 
+from . import constants
 from .constants import DEFAULT_LANG, EXTENDED_DATA_STDERR
 from .constants import MSG_CHANNEL_OPEN, MSG_CHANNEL_WINDOW_ADJUST
 from .constants import MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA
 from .constants import MSG_CHANNEL_EOF, MSG_CHANNEL_CLOSE, MSG_CHANNEL_REQUEST
 from .constants import MSG_CHANNEL_SUCCESS, MSG_CHANNEL_FAILURE
 from .constants import OPEN_CONNECT_FAILED, PTY_OP_RESERVED, PTY_OP_END
 from .constants import OPEN_REQUEST_X11_FORWARDING_FAILED
 from .constants import OPEN_REQUEST_PTY_FAILED, OPEN_REQUEST_SESSION_FAILED
-from .constants import __dict__ as constants
 
 from .editor import SSHLineEditorChannel, SSHLineEditorSession
 
-from .misc import ChannelOpenError, ProtocolError
+from .logging import SSHLogger
+
+from .misc import ChannelOpenError, MaybeAwait, ProtocolError
 from .misc import get_symbol_names, map_handler_name
 
-from .packet import Boolean, Byte, String, UInt32, SSHPacketHandler
+from .packet import Boolean, Byte, String, UInt32, SSHPacket, SSHPacketHandler
+
+from .session import TermModes, TermSize, TermSizeArg
+from .session import SSHSession, SSHClientSession, SSHServerSession
+from .session import SSHTCPSession, SSHUNIXSession
+from .session import SSHSessionFactory, SSHClientSessionFactory
+from .session import SSHTCPSessionFactory, SSHUNIXSessionFactory
+
+from .stream import DataType
+
 
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .connection import SSHConnection, SSHClientConnection
+    from .connection import SSHServerConnection
 
-_pty_mode_names = get_symbol_names(constants, 'PTY_', 4)
-_data_type_names = get_symbol_names(constants, 'EXTENDED_DATA_', 14)
+
+_const_dict: Mapping[str, int] = constants.__dict__
+_pty_mode_names = get_symbol_names(_const_dict, 'PTY_', 4)
+_data_type_names = get_symbol_names(_const_dict, 'EXTENDED_DATA_', 14)
 
 _signal_regex = re.compile(r'SIG[^_]')
 _signal_numbers = {k[3:]: int(v) for (k, v) in vars(_signal).items()
                    if _signal_regex.match(k)}
 _signal_names = {v: k for (k, v) in _signal_numbers.items()}
 
+_ExitSignal = Tuple[str, bool, str, str]
+_RequestHandler = Callable[[SSHPacket], Optional[bool]]
+
 
-class SSHChannel(SSHPacketHandler):
+class SSHChannel(Generic[AnyStr], SSHPacketHandler):
     """Parent class for SSH channels"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_CHANNEL_')
 
-    _read_datatypes = set()
-    _write_datatypes = set()
+    _read_datatypes: Set[int] = set()
+    _write_datatypes: Set[int] = set()
 
-    def __init__(self, conn, loop, encoding, errors, window, max_pktsize):
+    def __init__(self, conn: 'SSHConnection',
+                 loop: asyncio.AbstractEventLoop, encoding: Optional[str],
+                 errors: str, window: int, max_pktsize: int):
         """Initialize an SSH channel
 
            If encoding is set, data sent and received will be in the form
            of strings, converted on the wire to bytes using the specified
            encoding. If encoding is None, data sent and received must be
            provided as bytes.
 
            Window specifies the initial receive window size.
 
            Max_pktsize specifies the maximum length of a single data packet.
 
         """
 
-        self._conn = conn
+        self._conn: Optional['SSHConnection'] = conn
         self._loop = loop
-        self._session = None
-        self._extra = {'connection': conn}
-
-        self._env = {}
-        self._command = None
-        self._subsystem = None
+        self._session: Optional[SSHSession[AnyStr]] = None
+        self._extra: Dict[str, object] = {'connection': conn}
+        self._encoding: Optional[str]
+        self._errors: str
+        self._send_high_water: int
+        self._send_low_water: int
+
+        self._env: Dict[str, str] = {}
+        self._command: Optional[str] = None
+        self._subsystem: Optional[str] = None
 
         self._send_state = 'closed'
-        self._send_chan = None
-        self._send_window = None
-        self._send_pktsize = None
+        self._send_chan: Optional[int] = None
+        self._send_window: int = 0
+        self._send_pktsize: int = 0
         self._send_paused = False
-        self._send_buf = []
+        self._send_buf: List[Tuple[bytearray, DataType]] = []
         self._send_buf_len = 0
 
         self._recv_state = 'closed'
         self._init_recv_window = window
         self._recv_window = window
         self._recv_pktsize = max_pktsize
-        self._recv_paused = 'starting'
-        self._recv_buf = []
+        self._recv_paused: Union[bool, str] = 'starting'
+        self._recv_buf: List[Tuple[bytes, DataType]] = []
 
-        self._request_queue = []
+        self._request_queue: List[Tuple[str, SSHPacket, bool]] = []
 
-        self._open_waiter = None
-        self._request_waiters = []
+        self._open_waiter: Optional[asyncio.Future[SSHPacket]] = None
+        self._request_waiters: List[asyncio.Future[bool]] = []
 
         self._close_event = asyncio.Event()
 
-        self._recv_chan = conn.add_channel(self)
+        self._recv_chan: Optional[int] = conn.add_channel(self)
 
         self._logger = conn.logger.get_child(context='chan=%d' %
                                              self._recv_chan)
 
         self.set_encoding(encoding, errors)
         self.set_write_buffer_limits()
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this channel"""
 
         return self._logger
 
-    def get_connection(self):
+    def get_connection(self) -> 'SSHConnection':
         """Return the connection used by this channel"""
 
+        assert self._conn is not None
         return self._conn
 
-    def get_loop(self):
+    def get_loop(self) -> asyncio.AbstractEventLoop:
         """Return the event loop used by this channel"""
 
         return self._loop
 
-    def get_encoding(self):
+    def get_encoding(self) -> Tuple[Optional[str], str]:
         """Return the encoding used by this channel"""
 
         return self._encoding, self._errors
 
-    def set_encoding(self, encoding, errors='strict'):
+    def set_encoding(self, encoding: Optional[str],
+                     errors: str = 'strict') -> None:
         """Set the encoding on this channel"""
 
         self._encoding = encoding
         self._errors = errors
 
         if encoding:
-            self._encoder = codecs.getincrementalencoder(encoding)(errors)
-            self._decoder = codecs.getincrementaldecoder(encoding)(errors)
+            self._encoder: Optional[codecs.IncrementalEncoder] = \
+                codecs.getincrementalencoder(encoding)(errors)
+            self._decoder: Optional[codecs.IncrementalDecoder] = \
+                codecs.getincrementaldecoder(encoding)(errors)
         else:
             self._encoder = None
             self._decoder = None
 
-    def get_recv_window(self):
+    def get_recv_window(self) -> int:
         """Return the configured receive window for this channel"""
 
         return self._init_recv_window
 
-    def get_read_datatypes(self):
+    def get_read_datatypes(self) -> Set[int]:
         """Return the legal read data types for this channel"""
 
         return self._read_datatypes
 
-    def get_write_datatypes(self):
+    def get_write_datatypes(self) -> Set[int]:
         """Return the legal write data types for this channel"""
 
         return self._write_datatypes
 
-    def _cleanup(self, exc=None):
+    def _cleanup(self, exc: Exception = None) -> None:
         """Clean up this channel"""
 
         if self._open_waiter:
             if not self._open_waiter.cancelled(): # pragma: no branch
                 self._open_waiter.set_exception(
                     ChannelOpenError(OPEN_CONNECT_FAILED,
                                      'SSH connection closed'))
@@ -194,71 +227,74 @@
 
         if self._conn: # pragma: no branch
             self.logger.info('Channel closed%s',
                              ': ' + str(exc) if exc else '')
 
             self._conn.detach_x11_listener(self)
 
+            assert self._recv_chan is not None
             self._conn.remove_channel(self._recv_chan)
             self._send_chan = None
             self._recv_chan = None
             self._conn = None
 
-    def _close_send(self):
+    def _close_send(self) -> None:
         """Discard unsent data and close the channel for sending"""
 
         # Discard unsent data
         self._send_buf = []
         self._send_buf_len = 0
 
         if self._send_state != 'closed':
             self.send_packet(MSG_CHANNEL_CLOSE)
             self._send_chan = None
             self._send_state = 'closed'
 
-    def _discard_recv(self):
+    def _discard_recv(self) -> None:
         """Discard unreceived data and clean up if close received"""
 
         # Discard unreceived data
         self._recv_buf = []
         self._recv_paused = False
 
         # If recv is close_pending, we know send is already closed
         if self._recv_state == 'close_pending':
             self._recv_state = 'closed'
             self._loop.call_soon(self._cleanup)
 
-    async def _start_reading(self):
+    async def _start_reading(self) -> None:
         """Start processing data on a new connection"""
 
         # If owner of the channel  didn't explicitly pause it at
         # startup, begin processing incoming data.
 
         if self._recv_paused == 'starting':
             self.logger.debug2('Reading from channel started')
             self._recv_paused = False
             self._flush_recv_buf()
 
-    def _pause_resume_writing(self):
+    def _pause_resume_writing(self) -> None:
         """Pause or resume writing based on send buffer low/high water marks"""
 
         if self._send_paused:
             if self._send_buf_len <= self._send_low_water:
                 self.logger.debug2('Writing from session resumed')
 
                 self._send_paused = False
+                assert self._session is not None
                 self._session.resume_writing()
         else:
             if self._send_buf_len > self._send_high_water:
                 self.logger.debug2('Writing from session paused')
 
                 self._send_paused = True
+                assert self._session is not None
                 self._session.pause_writing()
 
-    def _flush_send_buf(self):
+    def _flush_send_buf(self) -> None:
         """Flush as much data in send buffer as the send window allows"""
 
         while self._send_buf and self._send_window:
             pktsize = min(self._send_window, self._send_pktsize)
             buf, datatype = self._send_buf[0]
 
             if len(buf) > pktsize:
@@ -282,40 +318,43 @@
         if not self._send_buf:
             if self._send_state == 'eof_pending':
                 self.send_packet(MSG_CHANNEL_EOF)
                 self._send_state = 'eof'
             elif self._send_state == 'close_pending':
                 self._close_send()
 
-    def _flush_recv_buf(self, exc=None):
+    def _flush_recv_buf(self, exc: Exception = None) -> None:
         """Flush as much data in the recv buffer as the application allows"""
 
         while self._recv_buf and not self._recv_paused:
             self._deliver_data(*self._recv_buf.pop(0))
 
         if not self._recv_buf and self._recv_paused != 'starting':
             if self._encoding and not exc and \
                     self._recv_state in ('eof_pending', 'close_pending'):
                 try:
+                    assert self._decoder is not None
                     self._decoder.decode(b'', True)
                 except UnicodeDecodeError as unicode_exc:
                     raise ProtocolError(str(unicode_exc)) from None
 
             if self._recv_state == 'eof_pending':
                 self._recv_state = 'eof'
 
+                assert self._session is not None
+
                 if (not self._session.eof_received() and
                         self._send_state == 'open'):
                     self.write_eof()
 
         if not self._recv_buf and self._recv_state == 'close_pending':
             self._recv_state = 'closed'
             self._loop.call_soon(self._cleanup, exc)
 
-    def _deliver_data(self, data, datatype):
+    def _deliver_data(self, data: bytes, datatype: DataType) -> None:
         """Deliver incoming data to the session"""
 
         self._recv_window -= len(data)
 
         if self._recv_window < self._init_recv_window / 2:
             adjust = self._init_recv_window - self._recv_window
 
@@ -323,22 +362,25 @@
                                'new window %d', adjust, self._init_recv_window)
 
             self.send_packet(MSG_CHANNEL_WINDOW_ADJUST, UInt32(adjust))
             self._recv_window = self._init_recv_window
 
         if self._encoding:
             try:
-                data = self._decoder.decode(data)
+                assert self._decoder is not None
+                decoded_data = cast(AnyStr, self._decoder.decode(data))
             except UnicodeDecodeError as unicode_exc:
                 raise ProtocolError(str(unicode_exc)) from None
+        else:
+            decoded_data = cast(AnyStr, data)
 
         if self._session is not None:
-            self._session.data_received(data, datatype)
+            self._session.data_received(decoded_data, datatype)
 
-    def _accept_data(self, data, datatype=None):
+    def _accept_data(self, data: bytes, datatype: DataType = None) -> None:
         """Accept new data on the channel
 
            This method accepts new data on the channel, immediately
            delivering it to the session if it hasn't paused reading.
            If it has paused, data is buffered until reading is resumed.
 
            Data sent after the channel has been closed by the session
@@ -366,108 +408,119 @@
                            's' if datalen > 1 else '', typename)
 
         if self._recv_paused:
             self._recv_buf.append((data, datatype))
         else:
             self._deliver_data(data, datatype)
 
-    def _service_next_request(self):
+    def _service_next_request(self) -> None:
         """Process next item on channel request queue"""
 
         request, packet, _ = self._request_queue[0]
 
         name = '_process_' + map_handler_name(request) + '_request'
-        handler = getattr(self, name, None)
+        handler = cast(_RequestHandler, getattr(self, name, None))
 
-        if callable(handler):
-            result = handler(packet)
+        if handler:
+            result = cast(Optional[bool], handler(packet))
         else:
             self.logger.debug1('Received unknown channel request: %s', request)
             result = False
 
         if result is not None:
             self._report_response(result)
 
-    def _report_response(self, result):
+    def _report_response(self, result: bool) -> None:
         """Report back the response to a previously issued channel request"""
 
         request, _, want_reply = self._request_queue.pop(0)
 
         if want_reply and self._send_state not in {'close_pending', 'closed'}:
             if result:
                 self.send_packet(MSG_CHANNEL_SUCCESS)
             else:
                 self.send_packet(MSG_CHANNEL_FAILURE)
 
         if result and request in {'shell', 'exec', 'subsystem'}:
+            assert self._session is not None
             self._session.session_started()
             self.resume_reading()
 
         if self._request_queue:
             self._service_next_request()
 
-    def process_connection_close(self, exc):
+    def process_connection_close(self, exc: Optional[Exception]) -> None:
         """Process the SSH connection closing"""
 
         self.logger.info('Closing channel due to connection close')
 
         self._cleanup(exc)
 
-    def process_open(self, send_chan, send_window, send_pktsize, session):
+    def process_open(self, send_chan: int, send_window: int, send_pktsize: int,
+                     session: MaybeAwait[SSHSession[AnyStr]]) -> None:
         """Process a channel open request"""
 
         self._send_chan = send_chan
         self._send_window = send_window
         self._send_pktsize = send_pktsize
 
         self.logger.debug2('  Initial send window %d, packet size %d',
                            send_window, send_pktsize)
 
+        assert self._conn is not None
         self._conn.create_task(self._finish_open_request(session), self.logger)
 
-    def _wrap_session(self, session):
+    def _wrap_session(self, session: SSHSession[AnyStr]) -> \
+            Tuple['SSHChannel[AnyStr]', SSHSession[AnyStr]]:
         """Hook to optionally wrap channel and session objects"""
 
         # By default, return the original channel and session objects
         return self, session
 
-    async def _finish_open_request(self, session):
+    async def _finish_open_request(
+            self, result: MaybeAwait[SSHSession[AnyStr]]) -> None:
         """Finish processing a channel open request"""
 
         try:
-            if inspect.isawaitable(session):
-                session = await session
+            if inspect.isawaitable(result):
+                session = await cast(Awaitable[SSHSession[AnyStr]], result)
+            else:
+                session = cast(SSHSession[AnyStr], result)
 
             if not self._conn:
                 raise ChannelOpenError(OPEN_CONNECT_FAILED,
                                        'SSH connection closed')
 
             chan, self._session = self._wrap_session(session)
 
             self.logger.debug2('  Initial recv window %d, packet size %d',
                                self._recv_window, self._recv_pktsize)
 
+            assert self._send_chan is not None
+            assert self._recv_chan is not None
+
             self._conn.send_channel_open_confirmation(self._send_chan,
                                                       self._recv_chan,
                                                       self._recv_window,
                                                       self._recv_pktsize)
 
             self._send_state = 'open'
             self._recv_state = 'open'
 
             self._session.connection_made(chan)
         except ChannelOpenError as exc:
             if self._conn:
+                assert self._send_chan is not None
                 self._conn.send_channel_open_failure(self._send_chan, exc.code,
                                                      exc.reason, exc.lang)
 
             self._loop.call_soon(self._cleanup)
 
-    def process_open_confirmation(self, send_chan, send_window,
-                                  send_pktsize, packet):
+    def process_open_confirmation(self, send_chan: int, send_window: int,
+                                  send_pktsize: int, packet: SSHPacket) -> None:
         """Process a channel open confirmation"""
 
         if not self._open_waiter:
             raise ProtocolError('Channel not being opened')
 
         self._send_chan = send_chan
         self._send_window = send_window
@@ -480,28 +533,29 @@
         self._recv_state = 'open'
 
         if not self._open_waiter.cancelled(): # pragma: no branch
             self._open_waiter.set_result(packet)
 
         self._open_waiter = None
 
-    def process_open_failure(self, code, reason, lang):
+    def process_open_failure(self, code: int, reason: str, lang: str) -> None:
         """Process a channel open failure"""
 
         if not self._open_waiter:
             raise ProtocolError('Channel not being opened')
 
         if not self._open_waiter.cancelled(): # pragma: no branch
             self._open_waiter.set_exception(
                 ChannelOpenError(code, reason, lang))
 
         self._open_waiter = None
         self._loop.call_soon(self._cleanup)
 
-    def _process_window_adjust(self, _pkttype, _pktid, packet):
+    def _process_window_adjust(self, _pkttype: int, _pktid: int,
+                               packet: SSHPacket) -> None:
         """Process a send window adjustment"""
 
         if self._recv_state not in {'open', 'eof_pending', 'eof'}:
             raise ProtocolError('Channel not open')
 
         adjust = packet.get_uint32()
         packet.check_end()
@@ -509,163 +563,176 @@
         self._send_window += adjust
 
         self.logger.debug2('Received window adjust of %d bytes, '
                            'new window %d', adjust, self._send_window)
 
         self._flush_send_buf()
 
-    def _process_data(self, _pkttype, _pktid, packet):
+    def _process_data(self, _pkttype: int, _pktid: int,
+                      packet: SSHPacket) -> None:
         """Process incoming data"""
 
         if self._recv_state != 'open':
             raise ProtocolError('Channel not open for sending')
 
         data = packet.get_string()
         packet.check_end()
 
         self._accept_data(data)
 
-    def _process_extended_data(self, _pkttype, _pktid, packet):
+    def _process_extended_data(self, _pkttype: int, _pktid: int,
+                               packet: SSHPacket) -> None:
         """Process incoming extended data"""
 
         if self._recv_state != 'open':
             raise ProtocolError('Channel not open for sending')
 
         datatype = packet.get_uint32()
         data = packet.get_string()
         packet.check_end()
 
         if datatype not in self._read_datatypes:
             raise ProtocolError('Invalid extended data type')
 
         self._accept_data(data, datatype)
 
-    def _process_eof(self, _pkttype, _pktid, packet):
+    def _process_eof(self, _pkttype: int, _pktid: int,
+                     packet: SSHPacket) -> None:
         """Process an incoming end of file"""
 
         if self._recv_state != 'open':
             raise ProtocolError('Channel not open for sending')
 
         packet.check_end()
 
         self.logger.debug2('Received EOF')
 
         self._recv_state = 'eof_pending'
         self._flush_recv_buf()
 
-    def _process_close(self, _pkttype, _pktid, packet):
+    def _process_close(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process an incoming channel close"""
 
         if self._recv_state not in {'open', 'eof_pending', 'eof'}:
             raise ProtocolError('Channel not open')
 
         packet.check_end()
 
         self.logger.info('Received channel close')
 
         self._close_send()
 
         self._recv_state = 'close_pending'
         self._flush_recv_buf()
 
-    def _process_request(self, _pkttype, _pktid, packet):
+    def _process_request(self, _pkttype: int, _pktid: int,
+                         packet: SSHPacket) -> None:
         """Process an incoming channel request"""
 
         if self._recv_state not in {'open', 'eof_pending', 'eof'}:
             raise ProtocolError('Channel not open')
 
-        request = packet.get_string()
+        request_bytes = packet.get_string()
         want_reply = packet.get_boolean()
 
         try:
-            request = request.decode('ascii')
+            request = request_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid channel request') from None
 
         self._request_queue.append((request, packet, want_reply))
         if len(self._request_queue) == 1:
             self._service_next_request()
 
-    def _process_response(self, pkttype, _pktid, packet):
+    def _process_response(self, pkttype: int, _pktid: int,
+                          packet: SSHPacket) -> None:
         """Process a success or failure response"""
 
         packet.check_end()
 
         if self._request_waiters:
             waiter = self._request_waiters.pop(0)
             if not waiter.cancelled(): # pragma: no branch
                 waiter.set_result(pkttype == MSG_CHANNEL_SUCCESS)
         else:
             raise ProtocolError('Unexpected channel response')
 
-    def _process_keepalive_at_openssh_dot_com_request(self, packet):
+    def _process_keepalive_at_openssh_dot_com_request(
+            self, packet: SSHPacket) -> bool:
         """Process an incoming OpenSSH keepalive request"""
 
         packet.check_end()
 
         self.logger.debug2('Received OpenSSH keepalive channel request')
-        return True
+        return False
 
     _packet_handlers = {
         MSG_CHANNEL_WINDOW_ADJUST:      _process_window_adjust,
         MSG_CHANNEL_DATA:               _process_data,
         MSG_CHANNEL_EXTENDED_DATA:      _process_extended_data,
         MSG_CHANNEL_EOF:                _process_eof,
         MSG_CHANNEL_CLOSE:              _process_close,
         MSG_CHANNEL_REQUEST:            _process_request,
         MSG_CHANNEL_SUCCESS:            _process_response,
         MSG_CHANNEL_FAILURE:            _process_response
     }
 
-    async def _open(self, chantype, *args):
+    async def _open(self, chantype: bytes, *args: bytes) -> SSHPacket:
         """Make a request to open the channel"""
 
         if self._send_state != 'closed':
             raise OSError('Channel already open')
 
         self._open_waiter = self._loop.create_future()
 
         self.logger.debug2('  Initial recv window %d, packet size %d',
                            self._recv_window, self._recv_pktsize)
 
+        assert self._conn is not None
+        assert self._recv_chan is not None
+
         self._conn.send_packet(MSG_CHANNEL_OPEN, String(chantype),
                                UInt32(self._recv_chan),
                                UInt32(self._recv_window),
                                UInt32(self._recv_pktsize), *args, handler=self)
 
         return await self._open_waiter
 
-    def send_packet(self, pkttype, *args):
+    def send_packet(self, pkttype: int, *args: bytes) -> None:
         """Send a packet on the channel"""
 
         if self._send_chan is None: # pragma: no cover
             return
 
         payload = UInt32(self._send_chan) + b''.join(args)
 
+        assert self._conn is not None
         self._conn.send_packet(pkttype, payload, handler=self)
 
-    def _send_request(self, request, *args, want_reply=False):
+    def _send_request(self, request: bytes, *args: bytes,
+                      want_reply: bool = False) -> None:
         """Send a channel request"""
 
         self.send_packet(MSG_CHANNEL_REQUEST, String(request),
                          Boolean(want_reply), *args)
 
-    async def _make_request(self, request, *args):
+    async def _make_request(self, request: bytes,
+                            *args: bytes) -> Optional[bool]:
         """Make a channel request and wait for the response"""
 
         if self._send_chan is None:
             return False
 
         waiter = self._loop.create_future()
         self._request_waiters.append(waiter)
         self._send_request(request, *args, want_reply=True)
         return await waiter
 
-    def abort(self):
+    def abort(self) -> None:
         """Forcibly close the channel
 
            This method can be called to forcibly close the channel, after
            which no more data can be sent or received. Any unsent buffered
            data and any incoming data in flight will be discarded.
 
         """
@@ -676,15 +743,15 @@
             # Send an immediate close, discarding unsent data
             self._close_send()
 
         if self._recv_state != 'closed':
             # Discard unreceived data
             self._discard_recv()
 
-    def close(self):
+    def close(self) -> None:
         """Cleanly close the channel
 
            This method can be called to cleanly close the channel, after
            which no more data can be sent or received. Any unsent buffered
            data will be flushed asynchronously before the channel is
            closed.
 
@@ -697,30 +764,30 @@
             self._send_state = 'close_pending'
             self._flush_send_buf()
 
         if self._recv_state != 'closed':
             # Discard unreceived data
             self._discard_recv()
 
-    def is_closing(self):
+    def is_closing(self) -> bool:
         """Return if the channel is closing or is closed"""
 
         return self._send_state != 'open'
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this channel to close
 
            This method is a coroutine which can be called to block until
            this channel has finished closing.
 
         """
 
         await self._close_event.wait()
 
-    def get_extra_info(self, name, default=None):
+    def get_extra_info(self, name: str, default: Any = None) -> Any:
         """Get additional information about the channel
 
            This method returns extra information about the channel once
            it is established. Supported values include `'connection'`
            to return the SSH connection this channel is running over plus
            all of the values supported on that connection.
 
@@ -741,48 +808,49 @@
            :meth:`set_extra_info` can also be returned here.
 
         """
 
         return self._extra.get(name, self._conn.get_extra_info(name, default)
                                if self._conn else default)
 
-    def set_extra_info(self, **kwargs):
+    def set_extra_info(self, **kwargs: Any) -> None:
         """Store additional information associated with the channel
 
            This method allows extra information to be associated with the
            channel. The information to store should be passed in as
            keyword parameters and can later be returned by calling
            :meth:`get_extra_info` with one of the keywords as the name
            to retrieve.
 
         """
 
         self._extra.update(**kwargs)
 
-    def can_write_eof(self):
+    def can_write_eof(self) -> bool:
         """Return whether the channel supports :meth:`write_eof`
 
            This method always returns `True`.
 
         """
 
         # pylint: disable=no-self-use
         return True
 
-    def get_write_buffer_size(self):
+    def get_write_buffer_size(self) -> int:
         """Return the current size of the channel's output buffer
 
            This method returns how many bytes are currently in the
            channel's output buffer waiting to be written.
 
         """
 
         return self._send_buf_len
 
-    def set_write_buffer_limits(self, high=None, low=None):
+    def set_write_buffer_limits(self, high: int = None,
+                                low: int = None) -> None:
         """Set the high- and low-water limits for write flow control
 
            This method sets the limits used when deciding when to call
            the :meth:`pause_writing() <SSHClientSession.pause_writing>`
            and :meth:`resume_writing() <SSHClientSession.resume_writing>`
            methods on SSH sessions. Writing will be paused when the write
            buffer size exceeds the high-water mark, and resumed when the
@@ -803,15 +871,15 @@
         self.logger.debug1('Set write buffer limits: low-water=%d, '
                            'high-water=%d', low, high)
 
         self._send_high_water = high
         self._send_low_water = low
         self._pause_resume_writing()
 
-    def write(self, data, datatype=None):
+    def write(self, data: AnyStr, datatype: DataType = None) -> None:
         """Write data on the channel
 
            This method can be called to send data on the channel. If
            an encoding was specified when the channel was created, the
            data should be provided as a string and will be converted
            using that encoding. Otherwise, the data should be provided
            as bytes.
@@ -836,35 +904,39 @@
 
         if self._send_state != 'open':
             raise BrokenPipeError('Channel not open for sending')
 
         if datatype is not None and datatype not in self._write_datatypes:
             raise OSError('Invalid extended data type')
 
-        datalen = len(data)
-
-        if datalen == 0:
+        if not data:
             return
 
         if self._encoding:
-            data = self._encoder.encode(data)
+            assert self._encoder is not None
+            encoded_data = self._encoder.encode(cast(str, data))
+        else:
+            encoded_data = cast(bytes, data)
+
+        datalen = len(encoded_data)
 
         if datatype:
             typename = ' to %s' % _data_type_names[datatype]
         else:
             typename = ''
 
         self.logger.debug2('Sending %d data byte%s%s', datalen,
                            's' if datalen > 1 else '', typename)
 
-        self._send_buf.append((bytearray(data), datatype))
+        self._send_buf.append((bytearray(encoded_data), datatype))
         self._send_buf_len += datalen
         self._flush_send_buf()
 
-    def writelines(self, list_of_data, datatype=None):
+    def writelines(self, list_of_data: Iterable[AnyStr],
+                   datatype: DataType = None) -> None:
         """Write a list of data bytes on the channel
 
            This method can be called to write a list (or any iterable) of
            data bytes to the channel. It is functionality equivalent to
            calling :meth:`write` on each element in the list.
 
            :param list_of_data:
@@ -877,18 +949,22 @@
 
            :raises: :exc:`OSError` if the channel isn't open for sending
                     or the extended data type is not valid for this type
                     of channel
 
         """
 
-        sep = '' if self._encoding else b''
-        return self.write(sep.join(list_of_data), datatype)
+        if self._encoding:
+            data = cast(AnyStr, ''.join(cast(Iterable[str], list_of_data)))
+        else:
+            data = cast(AnyStr, b''.join(cast(Iterable[bytes], list_of_data)))
+
+        return self.write(data, datatype)
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Write EOF on the channel
 
            This method sends an end-of-file indication on the
            channel, after which no more data can be sent. The
            channel remains open, though, and data may still be
            sent in the other direction.
 
@@ -898,15 +974,15 @@
 
         self.logger.debug2('Sending EOF')
 
         if self._send_state == 'open':
             self._send_state = 'eof_pending'
             self._flush_send_buf()
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause delivery of incoming data
 
            This method is used to temporarily suspend delivery of incoming
            channel data. After this call, incoming data will no longer
            be delivered until :meth:`resume_reading` is called. Data will be
            buffered locally up to the configured SSH channel window size,
            but window updates will no longer be sent, eventually causing
@@ -919,15 +995,15 @@
 
         """
 
         self.logger.debug2('Reading from channel paused')
 
         self._recv_paused = True
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume delivery of incoming data
 
            This method can be called to resume delivery of incoming data
            which was suspended by a call to :meth:`pause_reading`. As soon
            as this method is called, any buffered data will be delivered
            immediately. A pending end-of-file notication may also be
            delivered if one was queued while reading was paused.
@@ -936,15 +1012,15 @@
 
         if self._recv_paused:
             self.logger.debug2('Reading from channel resumed')
 
             self._recv_paused = False
             self._flush_recv_buf()
 
-    def get_environment(self):
+    def get_environment(self) -> Mapping[str, str]:
         """Return the environment for this session
 
            This method returns the environment set by the client when
            the session was opened. On the server, calls to this method
            should only be made after :meth:`session_started
            <SSHServerSession.session_started>` has been called on the
            :class:`SSHServerSession`. When using the stream-based API,
@@ -954,15 +1030,15 @@
            :returns: A dictionary containing the environment variables
                      set by the client
 
         """
 
         return MappingProxyType(self._env)
 
-    def get_command(self):
+    def get_command(self) -> Optional[str]:
         """Return the command the client requested to execute, if any
 
            This method returns the command the client requested to
            execute when the session was opened, if any. If the client
            did not request that a command be executed, this method
            will return `None`. On the server, alls to this method
            should only be made after :meth:`session_started
@@ -971,15 +1047,15 @@
            calls to this can be made at any time after the handler
            function has started up.
 
         """
 
         return self._command
 
-    def get_subsystem(self):
+    def get_subsystem(self) -> Optional[str]:
         """Return the subsystem the client requested to open, if any
 
            This method returns the subsystem the client requested to
            open when the session was opened, if any. If the client
            did not request that a subsystem be opened, this method will
            return `None`. On the server, calls to this method should
            only be made after :meth:`session_started
@@ -989,29 +1065,38 @@
            function has started up.
 
         """
 
         return self._subsystem
 
 
-class SSHClientChannel(SSHChannel):
+class SSHClientChannel(SSHChannel, Generic[AnyStr]):
     """SSH client channel"""
 
+    _conn: 'SSHClientConnection'
+    _session: SSHClientSession[AnyStr]
+
     _read_datatypes = {EXTENDED_DATA_STDERR}
 
-    def __init__(self, conn, loop, encoding, errors, window, max_pktsize):
+    def __init__(self, conn: 'SSHClientConnection',
+                 loop: asyncio.AbstractEventLoop, encoding: Optional[str],
+                 errors: str, window: int, max_pktsize: int):
         super().__init__(conn, loop, encoding, errors, window, max_pktsize)
 
-        self._exit_status = None
-        self._exit_signal = None
+        self._exit_status: Optional[int] = None
+        self._exit_signal: Optional[_ExitSignal] = None
 
-    async def create(self, session_factory, command, subsystem, env,
-                     request_pty, term_type, term_size, term_modes,
-                     x11_forwarding, x11_display, x11_auth_path,
-                     x11_single_connection, agent_forwarding):
+    async def create(self, session_factory: SSHClientSessionFactory[AnyStr],
+                     command: Optional[str], subsystem: Optional[str],
+                     env: Dict[str, str], request_pty: bool,
+                     term_type: Optional[str], term_size: TermSizeArg,
+                     term_modes: TermModes, x11_forwarding: Union[bool, str],
+                     x11_display: Optional[str], x11_auth_path: Optional[str],
+                     x11_single_connection: bool,
+                     agent_forwarding: bool) -> SSHClientSession[AnyStr]:
         """Create an SSH client session"""
 
         self.logger.info('Requesting new SSH session')
 
         packet = await self._open(b'session')
 
         # Client sessions should have no extra data in the open confirmation
@@ -1020,43 +1105,44 @@
         self._session = session_factory()
         self._session.connection_made(self)
 
         self._env = env
         self._command = command
         self._subsystem = subsystem
 
-        for name, value in env.items():
-            self.logger.debug1('  Env: %s=%s', name, value)
-            self._send_request(b'env', String(str(name)), String(str(value)))
+        for name, env_value in env.items():
+            self.logger.debug1('  Env: %s=%s', name, env_value)
+            self._send_request(b'env', String(str(name)),
+                               String(str(env_value)))
 
         if request_pty:
             self.logger.debug1('  Terminal type: %s', term_type or 'None')
 
             if not term_size:
                 width = height = pixwidth = pixheight = 0
             elif len(term_size) == 2:
-                width, height = term_size
+                width, height = cast(Tuple[int, int], term_size)
                 pixwidth = pixheight = 0
                 self.logger.debug1('  Terminal size: %sx%s', width, height)
             elif len(term_size) == 4:
-                width, height, pixwidth, pixheight = term_size
+                width, height, pixwidth, pixheight = cast(TermSize, term_size)
                 self.logger.debug1('  Terminal size: %sx%s (%sx%s pixels)',
                                    width, height, pixwidth, pixheight)
             else:
                 raise ValueError('If set, terminal size must be a tuple of '
                                  '2 or 4 integers')
 
             modes = b''
-            for mode, value in term_modes.items():
+            for mode, mode_value in term_modes.items():
                 if mode <= PTY_OP_END or mode >= PTY_OP_RESERVED:
                     raise ValueError('Invalid pty mode: %s' % mode)
 
                 name = _pty_mode_names.get(mode, str(mode))
-                self.logger.debug2('  Mode %s: %s', name, value)
-                modes += Byte(mode) + UInt32(value)
+                self.logger.debug2('  Mode %s: %d', name, mode_value)
+                modes += Byte(mode) + UInt32(mode_value)
 
             modes += Byte(PTY_OP_END)
 
             if not (await self._make_request(b'pty-req',
                                              String(term_type or ''),
                                              UInt32(width), UInt32(height),
                                              UInt32(pixwidth),
@@ -1066,26 +1152,28 @@
                 raise ChannelOpenError(OPEN_REQUEST_PTY_FAILED,
                                        'PTY request failed')
 
         if x11_forwarding:
             self.logger.debug1('  X11 forwarding enabled')
 
             try:
-                auth_proto, remote_auth, screen = \
+                attach_result: Optional[Tuple[bytes, bytes, int]] = \
                     await self._conn.attach_x11_listener(
                         self, x11_display, x11_auth_path, x11_single_connection)
             except ValueError as exc:
                 if x11_forwarding != 'ignore_failure':
                     raise ChannelOpenError(OPEN_REQUEST_X11_FORWARDING_FAILED,
                                            str(exc)) from None
                 else:
-                    auth_proto = None
+                    attach_result = None
                     self.logger.info('  X11 forwarding attach failure ignored')
 
-            if auth_proto:
+            if attach_result:
+                auth_proto, remote_auth, screen = attach_result
+
                 result = await self._make_request(
                     b'x11-req', Boolean(x11_single_connection),
                     String(auth_proto), String(binascii.b2a_hex(remote_auth)),
                     UInt32(screen))
 
                 if not result:
                     if self._conn: # pragma: no branch
@@ -1119,63 +1207,63 @@
                                    'Session request failed')
 
         self._session.session_started()
         self._conn.create_task(self._start_reading(), self.logger)
 
         return self._session
 
-    def _process_xon_xoff_request(self, packet):
+    def _process_xon_xoff_request(self, packet: SSHPacket) -> bool:
         """Process a request to set up XON/XOFF processing"""
 
         client_can_do = packet.get_boolean()
         packet.check_end()
 
         self.logger.info('Received XON/XOFF flow control %s request',
                          'enable' if client_can_do else 'disable')
 
         self._session.xon_xoff_requested(client_can_do)
         return True
 
-    def _process_exit_status_request(self, packet):
+    def _process_exit_status_request(self, packet: SSHPacket) -> bool:
         """Process a request to deliver exit status"""
 
         status = packet.get_uint32() & 0xff
         packet.check_end()
 
         self.logger.info('Received exit status %d', status)
 
         self._exit_status = status
         self._session.exit_status_received(status)
         return True
 
-    def _process_exit_signal_request(self, packet):
+    def _process_exit_signal_request(self, packet: SSHPacket) -> bool:
         """Process a request to deliver an exit signal"""
 
-        signal = packet.get_string()
+        signal_bytes = packet.get_string()
         core_dumped = packet.get_boolean()
-        msg = packet.get_string()
-        lang = packet.get_string()
+        msg_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            signal = signal.decode('ascii')
-            msg = msg.decode('utf-8')
-            lang = lang.decode('ascii')
+            signal = signal_bytes.decode('ascii')
+            msg = msg_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid exit signal request') from None
 
         self.logger.info('Received exit signal %s', signal)
         self.logger.debug1('  Core dumped: %s', core_dumped)
         self.logger.debug1('  Message: %s', msg)
 
         self._exit_signal = (signal, core_dumped, msg, lang)
         self._session.exit_signal_received(signal, core_dumped, msg, lang)
         return True
 
-    def get_exit_status(self):
+    def get_exit_status(self) -> Optional[int]:
         """Return the session's exit status
 
            This method returns the exit status of the session if one has
            been sent. If an exit signal was sent, this method returns -1
            and the exit signal information can be collected by calling
            :meth:`get_exit_signal`. If neither has been sent, this method
            returns `None`.
@@ -1185,28 +1273,28 @@
         if self._exit_status is not None:
             return self._exit_status
         elif self._exit_signal:
             return -1
         else:
             return None
 
-    def get_exit_signal(self):
+    def get_exit_signal(self) -> Optional[_ExitSignal]:
         """Return the session's exit signal, if one was sent
 
            This method returns information about the exit signal sent on
            this session. If an exit signal was sent, a tuple is returned
            containing the signal name, a boolean for whether a core dump
            occurred, a message associated with the signal, and the language
            the message was in. Otherwise, this method returns `None`.
 
         """
 
         return self._exit_signal
 
-    def get_returncode(self):
+    def get_returncode(self) -> Optional[int]:
         """Return the session's exit status or signal
 
            This method returns the exit status of the session if one has
            been sent. If an exit signal was sent, this method returns
            the negative of the numeric value of that signal, matching
            the behavior of :meth:`asyncio.SubprocessTransport.get_returncode`.
            If neither has been sent, this method returns `None`.
@@ -1218,15 +1306,16 @@
         if self._exit_status is not None:
             return self._exit_status
         elif self._exit_signal:
             return -_signal_numbers.get(self._exit_signal[0], 99)
         else:
             return None
 
-    def change_terminal_size(self, width, height, pixwidth=0, pixheight=0):
+    def change_terminal_size(self, width: int, height: int,
+                             pixwidth: int = 0, pixheight: int = 0) -> None:
         """Change the terminal window size for this session
 
            This method changes the width and height of the terminal
            associated with this session.
 
            :param width:
                The width of the terminal in characters
@@ -1248,15 +1337,15 @@
                              width, height, pixwidth, pixheight)
         else:
             self.logger.info('Sending window size change: %sx%s', width, height)
 
         self._send_request(b'window-change', UInt32(width), UInt32(height),
                            UInt32(pixwidth), UInt32(pixheight))
 
-    def send_break(self, msec):
+    def send_break(self, msec: int) -> None:
         """Send a break to the remote process
 
            This method requests that the server perform a break
            operation on the remote process or service as described in
            :rfc:`4335`.
 
            :param msec:
@@ -1267,15 +1356,15 @@
 
         """
 
         self.logger.info('Sending %d msec break', msec)
 
         self._send_request(b'break', UInt32(msec))
 
-    def send_signal(self, signal):
+    def send_signal(self, signal: Union[str, int]) -> None:
         """Send a signal to the remote process
 
            This method can be called to deliver a signal to the remote
            process or service. Signal names should be as described in
            section 6.10 of :rfc:`RFC 4254 <4254#section-6.10>`, or
            can be integer values as defined in the :mod:`signal`
            module, in which case they will be translated to their
@@ -1305,15 +1394,15 @@
             except KeyError:
                 raise ValueError('Unknown signal: %s' % int(signal)) from None
 
         self.logger.info('Sending %s signal', signal)
 
         self._send_request(b'signal', String(signal))
 
-    def terminate(self):
+    def terminate(self) -> None:
         """Terminate the remote process
 
            This method can be called to terminate the remote process or
            service by sending it a `TERM` signal.
 
            :raises: :exc:`OSError` if the channel is not open
 
@@ -1322,15 +1411,15 @@
                      for more details, see the note in
                      :meth:`send_signal`
 
         """
 
         self.send_signal('TERM')
 
-    def kill(self):
+    def kill(self) -> None:
         """Forcibly kill the remote process
 
            This method can be called to forcibly stop the remote process
            or service by sending it a `KILL` signal.
 
            :raises: :exc:`OSError` if the channel is not open
 
@@ -1340,69 +1429,84 @@
                      :meth:`send_signal`
 
         """
 
         self.send_signal('KILL')
 
 
-class SSHServerChannel(SSHChannel):
+class SSHServerChannel(SSHChannel, Generic[AnyStr]):
     """SSH server channel"""
 
+    _conn: 'SSHServerConnection'
+    _session: SSHServerSession[AnyStr]
+
     _write_datatypes = {EXTENDED_DATA_STDERR}
 
-    def __init__(self, conn, loop, allow_pty, line_editor, line_history,
-                 max_line_length, encoding, errors, window, max_pktsize):
+    def __init__(self, conn: 'SSHServerConnection',
+                 loop: asyncio.AbstractEventLoop, allow_pty: bool,
+                 line_editor: bool, line_history: int, max_line_length: int,
+                 encoding: Optional[str], errors: str, window: int,
+                 max_pktsize: int):
         """Initialize an SSH server channel"""
 
         super().__init__(conn, loop, encoding, errors, window, max_pktsize)
 
-        self._env = conn.get_key_option('environment', {})
+        self._env = cast(Dict[str, str],
+                         conn.get_key_option('environment', {}))
 
         self._allow_pty = allow_pty
         self._line_editor = line_editor
         self._line_history = line_history
         self._max_line_length = max_line_length
-        self._term_type = None
+        self._term_type: Optional[str] = None
         self._term_size = (0, 0, 0, 0)
-        self._term_modes = {}
-        self._x11_display = None
+        self._term_modes: TermModes = {}
+        self._x11_display: Optional[str] = None
 
         self.logger.info('New SSH session requested')
 
-    def _wrap_session(self, session):
+    def _wrap_session(self, session: SSHSession[AnyStr]) -> \
+            Tuple[SSHChannel[AnyStr], SSHSession[AnyStr]]:
         """Wrap a line editor around the session if enabled"""
 
         if self._line_editor:
-            chan = SSHLineEditorChannel(self, session, self._line_history,
-                                        self._max_line_length)
-            session = SSHLineEditorSession(chan, session)
+            server_chan = cast(SSHServerChannel[str], self)
+            server_session = cast(SSHServerSession[str], session)
+
+            editor_chan = SSHLineEditorChannel(server_chan, server_session,
+                                               self._line_history,
+                                               self._max_line_length)
+            editor_session = SSHLineEditorSession(editor_chan, server_session)
+
+            chan = cast(SSHChannel[AnyStr], editor_chan)
+            session = cast(SSHSession[AnyStr], editor_session)
         else:
             chan = self
 
         return chan, session
 
-    def _process_pty_req_request(self, packet):
+    def _process_pty_req_request(self, packet: SSHPacket) -> bool:
         """Process a request to open a pseudo-terminal"""
 
-        term_type = packet.get_string()
+        term_type_bytes = packet.get_string()
         width = packet.get_uint32()
         height = packet.get_uint32()
         pixwidth = packet.get_uint32()
         pixheight = packet.get_uint32()
         modes = packet.get_string()
         packet.check_end()
 
         if not self._allow_pty or \
            not self._conn.check_key_permission('pty') or \
            not self._conn.check_certificate_permission('pty'):
             self.logger.info('PTY request denied: PTY not permitted')
             return False
 
         try:
-            term_type = term_type.decode('ascii')
+            term_type = term_type_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid pty request') from None
 
         term_size = (width, height, pixwidth, pixheight)
         term_modes = {}
 
         self.logger.debug1('  Terminal type: %s', term_type)
@@ -1441,15 +1545,15 @@
             self._term_size = term_size
             self._term_modes = term_modes
         else:
             self.logger.info('  PTY creation failed')
 
         return result
 
-    def _process_x11_req_request(self, packet):
+    def _process_x11_req_request(self, packet: SSHPacket) -> Optional[bool]:
         """Process request to enable X11 forwarding"""
 
         _ = packet.get_boolean()                        # single_connection
         auth_proto = packet.get_string()
         auth_data = packet.get_string()
         screen = packet.get_uint32()
         packet.check_end()
@@ -1459,70 +1563,75 @@
         except binascii.Error:
             self.logger.debug1('  Invalid X11 auth data')
             return False
 
         self._conn.create_task(self._finish_x11_req_request(auth_proto,
                                                             auth_data, screen),
                                self.logger)
+        return None
 
-    async def _finish_x11_req_request(self, auth_proto, auth_data, screen):
+    async def _finish_x11_req_request(self, auth_proto: bytes,
+                                      auth_data: bytes, screen: int) -> None:
         """Finish processing request to enable X11 forwarding"""
 
         self._x11_display = await self._conn.attach_x11_listener(
             self, auth_proto, auth_data, screen)
 
         if self._x11_display:
             self.logger.debug1('  X11 forwarding enabled')
             self._report_response(True)
         else:
             self.logger.debug1('  X11 forwarding failed')
             self._report_response(False)
 
-    def _process_auth_agent_req_at_openssh_dot_com_request(self, packet):
+    def _process_auth_agent_req_at_openssh_dot_com_request(
+            self, packet: SSHPacket) -> None:
         """Process a request to enable ssh-agent forwarding"""
 
         packet.check_end()
 
         self._conn.create_task(self._finish_agent_req_request(), self.logger)
 
-    async def _finish_agent_req_request(self):
+    async def _finish_agent_req_request(self) -> None:
         """Finish processing request to enable agent forwarding"""
 
         if await self._conn.create_agent_listener():
             self.logger.debug1('  Agent forwarding enabled')
             self._report_response(True)
         else:
             self.logger.debug1('  Agent forwarding failed')
             self._report_response(False)
 
-    def _process_env_request(self, packet):
+    def _process_env_request(self, packet: SSHPacket) -> bool:
         """Process a request to set an environment variable"""
 
-        name = packet.get_string()
-        value = packet.get_string()
+        name_bytes = packet.get_string()
+        value_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            name = name.decode('utf-8')
-            value = value.decode('utf-8')
+            name = name_bytes.decode('utf-8')
+            value = value_bytes.decode('utf-8')
         except UnicodeDecodeError:
             self.logger.debug1('Invalid environment data')
             return False
 
         self.logger.debug1('  Env: %s=%s', name, value)
         self._env[name] = value
         return True
 
-    def _start_session(self, command=None, subsystem=None):
+    def _start_session(self, command: str = None,
+                       subsystem: str = None) -> bool:
         """Tell the session what type of channel is being requested"""
 
-        forced_command = self._conn.get_certificate_option('force-command')
+        forced_command = \
+            cast(str, self._conn.get_certificate_option('force-command'))
 
         if forced_command is None:
-            forced_command = self._conn.get_key_option('command')
+            forced_command = cast(str, self._conn.get_key_option('command'))
 
         if forced_command is not None:
             self.logger.info('  Forced command override: %s', forced_command)
 
             command = forced_command
 
         if command is not None:
@@ -1532,51 +1641,51 @@
             self._subsystem = subsystem
             result = self._session.subsystem_requested(subsystem)
         else:
             result = self._session.shell_requested()
 
         return result
 
-    def _process_shell_request(self, packet):
+    def _process_shell_request(self, packet: SSHPacket) -> bool:
         """Process a request to open a shell"""
 
         packet.check_end()
 
         self.logger.info('  Interactive shell requested')
         return self._start_session()
 
-    def _process_exec_request(self, packet):
+    def _process_exec_request(self, packet: SSHPacket) -> bool:
         """Process a request to execute a command"""
 
-        command = packet.get_string()
+        command_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            command = command.decode('utf-8')
+            command = command_bytes.decode('utf-8')
         except UnicodeDecodeError:
             return False
 
         self.logger.info('  Command: %s', command)
         return self._start_session(command=command)
 
-    def _process_subsystem_request(self, packet):
+    def _process_subsystem_request(self, packet: SSHPacket) -> bool:
         """Process a request to open a subsystem"""
 
-        subsystem = packet.get_string()
+        subsystem_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            subsystem = subsystem.decode('ascii')
+            subsystem = subsystem_bytes.decode('ascii')
         except UnicodeDecodeError:
             return False
 
         self.logger.info('  Subsystem: %s', subsystem)
         return self._start_session(subsystem=subsystem)
 
-    def _process_window_change_request(self, packet):
+    def _process_window_change_request(self, packet: SSHPacket) -> bool:
         """Process a request to change the window size"""
 
         width = packet.get_uint32()
         height = packet.get_uint32()
         pixwidth = packet.get_uint32()
         pixheight = packet.get_uint32()
         packet.check_end()
@@ -1587,41 +1696,41 @@
         else:
             self.logger.info('Recceived window change: %sx%s', width, height)
 
         self._term_size = (width, height, pixwidth, pixheight)
         self._session.terminal_size_changed(width, height, pixwidth, pixheight)
         return True
 
-    def _process_signal_request(self, packet):
+    def _process_signal_request(self, packet: SSHPacket) -> bool:
         """Process a request to send a signal"""
 
-        signal = packet.get_string()
+        signal_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            signal = signal.decode('ascii')
+            signal = signal_bytes.decode('ascii')
         except UnicodeDecodeError:
             return False
 
         self.logger.info('Received %s signal', signal)
 
         self._session.signal_received(signal)
         return True
 
-    def _process_break_request(self, packet):
+    def _process_break_request(self, packet: SSHPacket) -> bool:
         """Process a request to send a break"""
 
         msec = packet.get_uint32()
         packet.check_end()
 
         self.logger.info('Received %d msec break', msec)
 
         return self._session.break_received(msec)
 
-    def get_terminal_type(self):
+    def get_terminal_type(self) -> Optional[str]:
         """Return the terminal type for this session
 
            This method returns the terminal type set by the client
            when the session was opened. If the client didn't request
            a pseudo-terminal, this method will return `None`. Calls
            to this method should only be made after :meth:`session_started
            <SSHServerSession.session_started>` has been called on the
@@ -1632,15 +1741,15 @@
            :returns: A `str` containing the terminal type or `None` if
                      no pseudo-terminal was requested
 
         """
 
         return self._term_type
 
-    def get_terminal_size(self):
+    def get_terminal_size(self) -> TermSize:
         """Return terminal size information for this session
 
            This method returns the latest terminal size information set
            by the client. If the client didn't set any terminal size
            information, all values returned will be zero. Calls to
            this method should only be made after :meth:`session_started
            <SSHServerSession.session_started>` has been called on the
@@ -1657,15 +1766,15 @@
                      height of the terminal in characters and the width
                      and height of the terminal in pixels
 
         """
 
         return self._term_size
 
-    def get_terminal_mode(self, mode):
+    def get_terminal_mode(self, mode: int) -> Optional[int]:
         """Return the requested TTY mode for this session
 
            This method looks up the value of a POSIX terminal mode
            set by the client when the session was opened. If the client
            didn't request a pseudo-terminal or didn't set the requested
            TTY mode opcode, this method will return `None`. Calls to
            this method should only be made after :meth:`session_started
@@ -1683,15 +1792,15 @@
                      POSIX terminal mode or `None` if the requested
                      mode was not set
 
         """
 
         return self._term_modes.get(mode)
 
-    def get_terminal_modes(self):
+    def get_terminal_modes(self) -> TermModes:
         """Return the TTY modes for this session
 
            This method returns a mapping of all the POSIX terminal modes
            set by the client when the session was opened. If the client
            didn't request a pseudo-terminal, this method will return an
            empty mapping. Calls to this method should only be made after
            :meth:`session_started <SSHServerSession.session_started>`
@@ -1703,30 +1812,30 @@
                       set by the client or an empty mapping if no
                       pseudo-terminal was requested
 
         """
 
         return MappingProxyType(self._term_modes)
 
-    def get_x11_display(self):
+    def get_x11_display(self) -> Optional[str]:
         """Return the display to use for X11 forwarding
 
            When X11 forwarding has been requested by the client, this
            method returns the X11 display which should be used to open
            a forwarded connection. If the client did not request X11
            forwarding, this method returns `None`.
 
            :returns: A `str` containing the X11 display or `None` if
                      X11 fowarding was not requested
 
         """
 
         return self._x11_display
 
-    def get_agent_path(self):
+    def get_agent_path(self) -> Optional[str]:
         """Return the path of the ssh-agent listening socket
 
            When agent forwarding has been requested by the client,
            this method returns the path of the listening socket which
            should be used to open a forwarded agent connection. If the
            client did not request agent forwarding, this method returns
            `None`.
@@ -1734,15 +1843,15 @@
            :returns: A `str` containing the ssh-agent socket path or
                      `None` if agent fowarding was not requested
 
         """
 
         return self._conn.get_agent_path()
 
-    def set_xon_xoff(self, client_can_do):
+    def set_xon_xoff(self, client_can_do: bool) -> None:
         """Set whether the client should enable XON/XOFF flow control
 
            This method can be called to tell the client whether or not
            to enable XON/XOFF flow control, indicating that it should
            intercept Control-S and Control-Q coming from its local
            terminal to pause and resume output, respectively.
            Applications should set client_can_do to `True` to
@@ -1756,15 +1865,15 @@
         """
 
         self.logger.info('Sending XON/XOFF flow control %s',
                          'enable' if client_can_do else 'disable')
 
         self._send_request(b'xon-xoff', Boolean(client_can_do))
 
-    def write_stderr(self, data):
+    def write_stderr(self, data: AnyStr) -> None:
         """Write output to stderr
 
            This method can be called to send output to the client which
            is intended to be displayed on stderr. If an encoding was
            specified when the channel was created, the data should be
            provided as a string and will be converted using that
            encoding. Otherwise, the data should be provided as bytes.
@@ -1775,26 +1884,26 @@
 
            :raises: :exc:`OSError` if the channel isn't open for sending
 
         """
 
         self.write(data, EXTENDED_DATA_STDERR)
 
-    def writelines_stderr(self, list_of_data):
+    def writelines_stderr(self, list_of_data: Iterable[AnyStr]) -> None:
         """Write a list of data bytes to stderr
 
            This method can be called to write a list (or any iterable) of
            data bytes to the channel. It is functionality equivalent to
            calling :meth:`write_stderr` on each element in the list.
 
         """
 
         self.writelines(list_of_data, EXTENDED_DATA_STDERR)
 
-    def exit(self, status):
+    def exit(self, status: int) -> None:
         """Send exit status and close the channel
 
            This method can be called to report an exit status for the
            process back to the client and close the channel. A zero
            exit status is generally returned when the operation was
            successful. After reporting the status, the channel is
            closed.
@@ -1811,16 +1920,16 @@
 
         if self._send_state not in {'close_pending', 'closed'}:
             self.logger.info('Sending exit status %d', status)
 
             self._send_request(b'exit-status', UInt32(status))
             self.close()
 
-    def exit_with_signal(self, signal, core_dumped=False,
-                         msg='', lang=DEFAULT_LANG):
+    def exit_with_signal(self, signal: str, core_dumped: bool = False,
+                         msg: str = '', lang: str = DEFAULT_LANG) -> None:
         """Send exit signal and close the channel
 
            This method can be called to report that the process
            terminated abnormslly with a signal. A more detailed
            error message may also provided, along with an indication
            of whether or not the process dumped core. After
            reporting the signal, the channel is closed.
@@ -1848,133 +1957,154 @@
 
         if self._send_state not in {'close_pending', 'closed'}:
             self._send_request(b'exit-signal', String(signal),
                                Boolean(core_dumped), String(msg), String(lang))
             self.close()
 
 
-class SSHForwardChannel(SSHChannel):
+class SSHForwardChannel(SSHChannel, Generic[AnyStr]):
     """SSH channel for forwarding TCP and UNIX domain connections"""
 
-    async def _finish_open_request(self, session):
+    async def _finish_open_request(
+            self, result: MaybeAwait[SSHSession[AnyStr]]) -> None:
         """Finish processing a forward channel open request"""
 
-        await super()._finish_open_request(session)
+        await super()._finish_open_request(result)
 
         if self._session is not None:
             self._session.session_started()
             self.resume_reading()
 
-    async def _open_forward(self, session_factory, chantype, *args):
+    async def _open_forward(self, session_factory: SSHSessionFactory[AnyStr],
+                            chantype: bytes, *args: bytes) -> \
+            SSHSession[AnyStr]:
         """Open a forward channel"""
 
         packet = await super()._open(chantype, *args)
 
         # Forward channels should have no extra data in the open confirmation
         packet.check_end()
 
         self._session = session_factory()
         self._session.connection_made(self)
         self._session.session_started()
+
+        assert self._conn is not None
         self._conn.create_task(self._start_reading(), self.logger)
 
         return self._session
 
 
-class SSHTCPChannel(SSHForwardChannel):
+class SSHTCPChannel(SSHForwardChannel, Generic[AnyStr]):
     """SSH TCP channel"""
 
-    async def _open_tcp(self, session_factory, chantype, host, port,
-                        orig_host, orig_port):
+    async def _open_tcp(self, session_factory: SSHTCPSessionFactory[AnyStr],
+                        chantype: bytes, host: str, port: int, orig_host: str,
+                        orig_port: int) -> SSHTCPSession[AnyStr]:
         """Open a TCP channel"""
 
         self.set_extra_info(peername=(None, None),
                             local_peername=(orig_host, orig_port),
                             remote_peername=(host, port))
 
-        return (await super()._open_forward(session_factory, chantype,
-                                            String(host), UInt32(port),
-                                            String(orig_host),
-                                            UInt32(orig_port)))
-
-    async def connect(self, session_factory, host, port, orig_host, orig_port):
+        return cast(SSHTCPSession[AnyStr],
+                    await self._open_forward(session_factory, chantype,
+                                             String(host), UInt32(port),
+                                             String(orig_host),
+                                             UInt32(orig_port)))
+
+    async def connect(self, session_factory: SSHTCPSessionFactory[AnyStr],
+                     host: str, port: int, orig_host: str, orig_port: int) -> \
+            SSHTCPSession[AnyStr]:
         """Create a new outbound TCP session"""
 
         return (await self._open_tcp(session_factory, b'direct-tcpip',
                                      host, port, orig_host, orig_port))
 
-    async def accept(self, session_factory, host, port, orig_host, orig_port):
+    async def accept(self, session_factory: SSHTCPSessionFactory[AnyStr],
+                     host: str, port: int, orig_host: str,
+                     orig_port: int) -> SSHTCPSession[AnyStr]:
         """Create a new forwarded TCP session"""
 
         return (await self._open_tcp(session_factory, b'forwarded-tcpip',
                                      host, port, orig_host, orig_port))
 
-    def set_inbound_peer_names(self, dest_host, dest_port,
-                               orig_host, orig_port):
+    def set_inbound_peer_names(self, dest_host: str, dest_port: int,
+                               orig_host: str, orig_port: int) -> None:
         """Set local and remote peer names for inbound connections"""
 
         self.set_extra_info(peername=(None, None),
                             local_peername=(dest_host, dest_port),
                             remote_peername=(orig_host, orig_port))
 
 
-class SSHUNIXChannel(SSHForwardChannel):
+class SSHUNIXChannel(SSHForwardChannel, Generic[AnyStr]):
     """SSH UNIX channel"""
 
-    async def _open_unix(self, session_factory, chantype, path, *args):
+    async def _open_unix(self, session_factory: SSHUNIXSessionFactory[AnyStr],
+                         chantype: bytes, path: str,
+                          *args: bytes) -> SSHUNIXSession[AnyStr]:
         """Open a UNIX channel"""
 
         self.set_extra_info(local_peername='', remote_peername=path)
 
-        return await super()._open_forward(session_factory, chantype,
-                                           String(path), *args)
+        return cast(SSHUNIXSession[AnyStr],
+                    await self._open_forward(session_factory, chantype,
+                                             String(path), *args))
 
-    async def connect(self, session_factory, path):
+    async def connect(self, session_factory: SSHUNIXSessionFactory[AnyStr],
+                      path: str) -> SSHUNIXSession[AnyStr]:
         """Create a new outbound UNIX session"""
 
         # OpenSSH appears to have a bug which requires an originator
         # host and port to be sent after the path name to connect to
         # when opening a direct streamlocal channel.
         return await self._open_unix(session_factory,
                                      b'direct-streamlocal@openssh.com',
                                      path, String(''), UInt32(0))
 
-    async def accept(self, session_factory, path):
+    async def accept(self, session_factory: SSHUNIXSessionFactory[AnyStr],
+                     path: str) -> SSHUNIXSession[AnyStr]:
         """Create a new forwarded UNIX session"""
 
         return await self._open_unix(session_factory,
                                      b'forwarded-streamlocal@openssh.com',
                                      path, String(''))
 
-    def set_inbound_peer_names(self, dest_path):
+    def set_inbound_peer_names(self, dest_path: str) -> None:
         """Set local and remote peer names for inbound connections"""
 
         self.set_extra_info(local_peername=dest_path, remote_peername='')
 
 
-class SSHX11Channel(SSHForwardChannel):
+class SSHX11Channel(SSHForwardChannel[bytes]):
     """SSH X11 channel"""
 
-    async def open(self, session_factory, orig_host, orig_port):
+    async def open(self, session_factory: SSHTCPSessionFactory[bytes],
+                   orig_host: str, orig_port: int) -> SSHTCPSession[bytes]:
         """Open an SSH X11 channel"""
 
         self.set_extra_info(local_peername=(orig_host, orig_port),
                             remote_peername=(None, None))
 
-        return await self._open_forward(session_factory, b'x11',
-                                        String(orig_host), UInt32(orig_port))
+        return cast(SSHTCPSession[bytes],
+                    await self._open_forward(session_factory, b'x11',
+                                             String(orig_host),
+                                             UInt32(orig_port)))
 
-    def set_inbound_peer_names(self, orig_host, orig_port):
+    def set_inbound_peer_names(self, orig_host: str, orig_port: int) -> None:
         """Set local and remote peer name for inbound connections"""
 
         self.set_extra_info(local_peername=(None, None),
                             remote_peername=(orig_host, orig_port))
 
 
-class SSHAgentChannel(SSHForwardChannel):
+class SSHAgentChannel(SSHForwardChannel[bytes]):
     """SSH agent channel"""
 
-    async def open(self, session_factory):
+    async def open(self, session_factory: SSHUNIXSessionFactory[bytes]) -> \
+            SSHUNIXSession[bytes]:
         """Open an SSH agent channel"""
 
-        return await self._open_forward(session_factory,
-                                        b'auth-agent@openssh.com')
+        return cast(SSHUNIXSession[bytes],
+                    await self._open_forward(session_factory,
+                                             b'auth-agent@openssh.com'))
```

### Comparing `asyncssh-2.8.1/asyncssh/session.py` & `asyncssh-2.9.0/asyncssh/session.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,46 +16,65 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH session handlers"""
 
+from typing import TYPE_CHECKING, Any, AnyStr, Callable, Generic
+from typing import Mapping, Optional, Tuple, Union
 
-class SSHSession:
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHClientChannel, SSHServerChannel
+    from .channel import SSHTCPChannel, SSHUNIXChannel
+
+DataType = Optional[int]
+
+TermModes = Mapping[int, int]
+TermModesArg = Optional[TermModes]
+TermSize = Tuple[int, int, int, int]
+TermSizeArg = Union[None, Tuple[int, int], TermSize]
+
+
+class SSHSession(Generic[AnyStr]):
     """SSH session handler"""
 
     # pylint: disable=no-self-use,unused-argument
 
-    def connection_lost(self, exc):
+    def connection_made(self, chan: Any) -> None:
+        """Called when a channel is opened successfully"""
+
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         """Called when a channel is closed
 
            This method is called when a channel is closed. If the channel
            is shut down cleanly, *exc* will be `None`. Otherwise, it
            will be an exception explaining the reason for the channel close.
 
            :param exc:
                The exception which caused the channel to close, or
                `None` if the channel closed cleanly.
            :type exc: :class:`Exception`
 
         """
 
-    def session_started(self):
+    def session_started(self) -> None:
         """Called when the session is started
 
            This method is called when a session has started up. For
            client and server sessions, this will be called once a
            shell, exec, or subsystem request has been successfully
            completed. For TCP and UNIX domain socket sessions, it will
            be called immediately after the connection is opened.
 
         """
 
-    def data_received(self, data, datatype):
+    def data_received(self, data: AnyStr, datatype: DataType) -> None:
         """Called when data is received on the channel
 
            This method is called when data is received on the channel.
            If an encoding was specified when the channel was created,
            the data will be delivered as a string after decoding with
            the requested encoding. Otherwise, the data will be delivered
            as bytes.
@@ -65,15 +84,15 @@
            :param datatype:
                The extended data type of the data, from :ref:`extended
                data types <ExtendedDataTypes>`
            :type data: `str` or `bytes`
 
         """
 
-    def eof_received(self):
+    def eof_received(self) -> bool:
         """Called when EOF is received on the channel
 
            This method is called when an end-of-file indication is received
            on the channel, after which no more data will be received. If this
            method returns `True`, the channel remains half open and data
            may still be sent. Otherwise, the channel is automatically closed
            after this method returns. This is the default behavior for
@@ -83,36 +102,36 @@
            allow applications to respond to input read after an end-of-file
            indication is received.
 
         """
 
         return False # pragma: no cover
 
-    def pause_writing(self):
+    def pause_writing(self) -> None:
         """Called when the write buffer becomes full
 
            This method is called when the channel's write buffer becomes
            full and no more data can be sent until the remote system
            adjusts its window. While data can still be buffered locally,
            applications may wish to stop producing new data until the
            write buffer has drained.
 
         """
 
-    def resume_writing(self):
+    def resume_writing(self) -> None:
         """Called when the write buffer has sufficiently drained
 
            This method is called when the channel's send window reopens
            and enough data has drained from the write buffer to allow the
            application to produce more data.
 
         """
 
 
-class SSHClientSession(SSHSession):
+class SSHClientSession(SSHSession[AnyStr]):
     """SSH client session handler
 
        Applications should subclass this when implementing an SSH client
        session handler. The functions listed below should be implemented
        to define application-specific behavior. In particular, the standard
        `asyncio` protocol methods such as :meth:`connection_made`,
        :meth:`connection_lost`, :meth:`data_received`, :meth:`eof_received`,
@@ -124,27 +143,27 @@
        :meth:`exit_signal_received` can be used to receive session exit
        information.
 
     """
 
     # pylint: disable=no-self-use,unused-argument
 
-    def connection_made(self, chan):
+    def connection_made(self, chan: 'SSHClientChannel[AnyStr]') -> None:
         """Called when a channel is opened successfully
 
            This method is called when a channel is opened successfully. The
            channel parameter should be stored if needed for later use.
 
            :param chan:
                The channel which was successfully opened.
            :type chan: :class:`SSHClientChannel`
 
         """
 
-    def xon_xoff_requested(self, client_can_do):
+    def xon_xoff_requested(self, client_can_do: bool) -> None:
         """XON/XOFF flow control has been enabled or disabled
 
            This method is called to notify the client whether or not
            to enable XON/XOFF flow control. If client_can_do is
            `True` and output is being sent to an interactive
            terminal the application should allow input of Control-S
            and Control-Q to pause and resume output, respectively.
@@ -157,15 +176,15 @@
 
            :param client_can_do:
                Whether or not to enable XON/XOFF flow control
            :type client_can_do: `bool`
 
         """
 
-    def exit_status_received(self, status):
+    def exit_status_received(self, status: int) -> None:
         """A remote exit status has been received for this session
 
            This method is called when the shell, command, or subsystem
            running on the server terminates and returns an exit status.
            A zero exit status generally means that the operation was
            successful. This call will generally be followed by a call
            to :meth:`connection_lost`.
@@ -174,15 +193,16 @@
 
            :param status:
                The exit status returned by the remote process
            :type status: `int`
 
         """
 
-    def exit_signal_received(self, signal, core_dumped, msg, lang):
+    def exit_signal_received(self, signal: str, core_dumped: bool,
+                             msg: str, lang: str) -> None:
         """A remote exit signal has been received for this session
 
            This method is called when the shell, command, or subsystem
            running on the server terminates abnormally with a signal.
            A more detailed error may also be provided, along with an
            indication of whether the remote process dumped core. This call
            will generally be followed by a call to :meth:`connection_lost`.
@@ -201,15 +221,15 @@
            :type core_dumped: `bool`
            :type msg: `str`
            :type lang: `str`
 
         """
 
 
-class SSHServerSession(SSHSession):
+class SSHServerSession(SSHSession[AnyStr]):
     """SSH server session handler
 
        Applications should subclass this when implementing an SSH server
        session handler. The functions listed below should be implemented
        to define application-specific behavior. In particular, the
        standard `asyncio` protocol methods such as :meth:`connection_made`,
        :meth:`connection_lost`, :meth:`data_received`, :meth:`eof_received`,
@@ -223,27 +243,29 @@
        is called when the client sends a signal, and :meth:`break_received`
        is called when the client sends a break.
 
     """
 
     # pylint: disable=no-self-use,unused-argument
 
-    def connection_made(self, chan):
+    def connection_made(self, chan: 'SSHServerChannel[AnyStr]') -> None:
         """Called when a channel is opened successfully
 
            This method is called when a channel is opened successfully. The
            channel parameter should be stored if needed for later use.
 
            :param chan:
                The channel which was successfully opened.
            :type chan: :class:`SSHServerChannel`
 
         """
 
-    def pty_requested(self, term_type, term_size, term_modes):
+    def pty_requested(self, term_type: str,
+                      term_size: Tuple[int, int, int, int],
+                      term_modes: Mapping[int, int]) -> bool:
         """A psuedo-terminal has been requested
 
            This method is called when the client sends a request to allocate
            a pseudo-terminal with the requested terminal type, size, and
            POSIX terminal modes. This method should return `True` if the
            request for the pseudo-terminal is accepted. Otherwise, it should
            return `False` to reject the request.
@@ -276,15 +298,16 @@
            :returns: A `bool` indicating if the request for a
                      pseudo-terminal was allowed or not
 
         """
 
         return True # pragma: no cover
 
-    def terminal_size_changed(self, width, height, pixwidth, pixheight):
+    def terminal_size_changed(self, width: int, height: int,
+                              pixwidth: int, pixheight: int) -> None:
         """The terminal size has changed
 
            This method is called when a client requests a
            pseudo-terminal and again whenever the the size of
            he client's terminal window changes.
 
            By default, this information is ignored, but applications
@@ -302,15 +325,15 @@
            :type width: `int`
            :type height: `int`
            :type pixwidth: `int`
            :type pixheight: `int`
 
         """
 
-    def shell_requested(self):
+    def shell_requested(self) -> bool:
         """The client has requested a shell
 
            This method should be implemented by the application to
            perform whatever processing is required when a client makes
            a request to open an interactive shell. It should return
            `True` to accept the request, or `False` to reject it.
 
@@ -323,15 +346,15 @@
            :returns: A `bool` indicating if the shell request was
                      allowed or not
 
         """
 
         return False # pragma: no cover
 
-    def exec_requested(self, command):
+    def exec_requested(self, command: str) -> bool:
         """The client has requested to execute a command
 
            This method should be implemented by the application to
            perform whatever processing is required when a client makes
            a request to execute a command. It should return `True` to
            accept the request, or `False` to reject it.
 
@@ -348,15 +371,15 @@
            :returns: A `bool` indicating if the exec request was
                      allowed or not
 
         """
 
         return False # pragma: no cover
 
-    def subsystem_requested(self, subsystem):
+    def subsystem_requested(self, subsystem: str) -> bool:
         """The client has requested to start a subsystem
 
            This method should be implemented by the application to
            perform whatever processing is required when a client makes
            a request to start a subsystem. It should return `True` to
            accept the request, or `False` to reject it.
 
@@ -373,15 +396,15 @@
            :returns: A `bool` indicating if the request to open the
                      subsystem was allowed or not
 
         """
 
         return False # pragma: no cover
 
-    def break_received(self, msec):
+    def break_received(self, msec: int) -> bool:
         """The client has sent a break
 
            This method is called when the client requests that the
            server perform a break operation on the terminal. If the
            break is performed, this method should return `True`.
            Otherwise, it should return `False`.
 
@@ -395,26 +418,42 @@
            :returns: A `bool` to indicate if the break operation was
                      performed or not
 
         """
 
         return False # pragma: no cover
 
-    def signal_received(self, signal):
+    def signal_received(self, signal: str) -> None:
         """The client has sent a signal
 
            This method is called when the client delivers a signal
            on the channel.
 
            By default, signals from the client are ignored.
 
+           :param signal:
+               The name of the signal received
+           :type signal: `str`
+
+        """
+
+    def soft_eof_received(self) -> None:
+        """The client has sent a soft EOF
+
+           This method is called by the line editor when the client
+           send a soft EOF (Ctrl-D on an empty input line).
+
+           By default, soft EOF will trigger an EOF to an outstanding
+           read call but still allow additional input to be received
+           from the client after that.
+
         """
 
 
-class SSHTCPSession(SSHSession):
+class SSHTCPSession(SSHSession[AnyStr]):
     """SSH TCP session handler
 
        Applications should subclass this when implementing a handler for
        SSH direct or forwarded TCP connections.
 
        SSH client applications wishing to open a direct connection should call
        :meth:`create_connection() <SSHClientConnection.create_connection>`
@@ -436,28 +475,28 @@
 
        When a connection is successfully opened, :meth:`session_started`
        will be called, after which the application can begin sending data.
        Received data will be passed to the :meth:`data_received` method.
 
     """
 
-    def connection_made(self, chan):
+    def connection_made(self, chan: 'SSHTCPChannel[AnyStr]') -> None:
         """Called when a channel is opened successfully
 
            This method is called when a channel is opened successfully. The
            channel parameter should be stored if needed for later use.
 
            :param chan:
                The channel which was successfully opened.
            :type chan: :class:`SSHTCPChannel`
 
         """
 
 
-class SSHUNIXSession(SSHSession):
+class SSHUNIXSession(SSHSession[AnyStr]):
     """SSH UNIX domain socket session handler
 
        Applications should subclass this when implementing a handler for
        SSH direct or forwarded UNIX domain socket connections.
 
        SSH client applications wishing to open a direct connection should call
        :meth:`create_unix_connection()
@@ -481,18 +520,24 @@
 
        When a connection is successfully opened, :meth:`session_started`
        will be called, after which the application can begin sending data.
        Received data will be passed to the :meth:`data_received` method.
 
     """
 
-    def connection_made(self, chan):
+    def connection_made(self, chan: 'SSHUNIXChannel[AnyStr]') -> None:
         """Called when a channel is opened successfully
 
            This method is called when a channel is opened successfully. The
            channel parameter should be stored if needed for later use.
 
            :param chan:
                The channel which was successfully opened.
            :type chan: :class:`SSHUNIXChannel`
 
         """
+
+
+SSHSessionFactory = Callable[[], SSHSession[AnyStr]]
+SSHClientSessionFactory = Callable[[], SSHClientSession[AnyStr]]
+SSHTCPSessionFactory = Callable[[], SSHTCPSession[AnyStr]]
+SSHUNIXSessionFactory = Callable[[], SSHUNIXSession[AnyStr]]
```

### Comparing `asyncssh-2.8.1/asyncssh/__init__.py` & `asyncssh-2.9.0/asyncssh/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -36,14 +36,16 @@
 from .channel import SSHClientChannel, SSHServerChannel
 from .channel import SSHTCPChannel, SSHUNIXChannel
 
 from .client import SSHClient
 
 from .config import ConfigParseError
 
+from .forward import SSHForwarder
+
 from .connection import SSHAcceptor, SSHClientConnection, SSHServerConnection
 from .connection import SSHClientConnectionOptions, SSHServerConnectionOptions
 from .connection import create_connection, create_server, connect, listen
 from .connection import connect_reverse, listen_reverse, get_server_host_key
 
 from .editor import SSHLineEditorChannel
 
@@ -51,26 +53,27 @@
 from .known_hosts import import_known_hosts, read_known_hosts
 from .known_hosts import match_known_hosts
 
 from .listener import SSHListener
 
 from .logging import logger, set_log_level, set_sftp_log_level, set_debug_level
 
+from .misc import BytesOrStr
 from .misc import Error, DisconnectError, ChannelOpenError, ChannelListenError
 from .misc import ConnectionLost, CompressionError, HostKeyNotVerifiable
 from .misc import KeyExchangeFailed, IllegalUserName, MACError
 from .misc import PermissionDenied, ProtocolError, ProtocolNotSupported
-from .misc import ServiceNotAvailable
-from .misc import PasswordChangeRequired
+from .misc import ServiceNotAvailable, PasswordChangeRequired
 from .misc import BreakReceived, SignalReceived, TerminalSizeChanged
 
 from .pbe import KeyEncryptionError
 
 from .pkcs11 import load_pkcs11_keys
 
+from .process import SSHServerProcessFactory
 from .process import SSHClientProcess, SSHServerProcess
 from .process import SSHCompletedProcess, ProcessError
 from .process import TimeoutError # pylint: disable=redefined-builtin
 from .process import DEVNULL, PIPE, STDOUT
 
 from .public_key import SSHKey, SSHKeyPair, SSHCertificate
 from .public_key import KeyGenerationError, KeyImportError, KeyExportError
@@ -80,26 +83,36 @@
 from .public_key import read_private_key_list, read_public_key_list
 from .public_key import read_certificate_list
 from .public_key import load_keypairs, load_public_keys, load_certificates
 from .public_key import load_resident_keys
 
 from .scp import scp
 
-from .session import SSHClientSession, SSHServerSession
+from .session import DataType, SSHClientSession, SSHServerSession
 from .session import SSHTCPSession, SSHUNIXSession
 
 from .server import SSHServer
 
 from .sftp import SFTPClient, SFTPClientFile, SFTPServer, SFTPError
 from .sftp import SFTPEOFError, SFTPNoSuchFile, SFTPPermissionDenied
 from .sftp import SFTPFailure, SFTPBadMessage, SFTPNoConnection
+from .sftp import SFTPInvalidHandle, SFTPNoSuchPath, SFTPFileAlreadyExists
+from .sftp import SFTPWriteProtect, SFTPNoMedia, SFTPNoSpaceOnFilesystem
+from .sftp import SFTPQuotaExceeded, SFTPUnknownPrincipal, SFTPLockConflict
+from .sftp import SFTPDirNotEmpty, SFTPNotADirectory, SFTPInvalidFilename
+from .sftp import SFTPLinkLoop, SFTPCannotDelete, SFTPInvalidParameter
+from .sftp import SFTPFileIsADirectory, SFTPByteRangeLockConflict
+from .sftp import SFTPByteRangeLockRefused, SFTPDeletePending
+from .sftp import SFTPFileCorrupt, SFTPOwnerInvalid, SFTPGroupInvalid
+from .sftp import SFTPNoMatchingByteRangeLock
 from .sftp import SFTPConnectionLost, SFTPOpUnsupported
 from .sftp import SFTPAttrs, SFTPVFSAttrs, SFTPName
 from .sftp import SEEK_SET, SEEK_CUR, SEEK_END
 
-from .stream import SSHReader, SSHWriter
+from .stream import SSHSocketSessionFactory, SSHServerSessionFactory
+from .stream import SFTPServerFactory, SSHReader, SSHWriter
 
 from .subprocess import SSHSubprocessReadPipe, SSHSubprocessWritePipe
 from .subprocess import SSHSubprocessProtocol, SSHSubprocessTransport
 
 # Import these explicitly to trigger register calls in them
 from . import sk_eddsa, sk_ecdsa, eddsa, ecdsa, rsa, dsa, kex_dh, kex_rsa
```

### Comparing `asyncssh-2.8.1/asyncssh/pattern.py` & `asyncssh-2.9.0/asyncssh/pattern.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,57 +17,68 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """Pattern matching for principal and host names"""
 
 from fnmatch import fnmatch
+from typing import Union
 
-from .misc import ip_network
+from .misc import IPAddress, ip_network
 
 
-class WildcardPattern:
-    """A pattern matcher for '*' and '?' wildcards"""
+_HostPattern = Union['WildcardHostPattern', 'CIDRHostPattern']
+_AnyPattern = Union['WildcardPattern', _HostPattern]
+
+
+class _BaseWildcardPattern:
+    """A base class for matching '*' and '?' wildcards"""
 
-    def __init__(self, pattern):
+    def __init__(self, pattern: str):
         # We need to escape square brackets in host patterns if we
         # want to use Python's fnmatch.
         self._pattern = ''.join('[[]' if ch == '[' else
                                 '[]]' if ch == ']' else
                                 ch for ch in pattern)
 
-    def matches(self, value):
+    def _matches(self, value: str) -> bool:
         """Return whether a wild card pattern matches a value"""
 
         return fnmatch(value, self._pattern)
 
 
-class WildcardHostPattern(WildcardPattern):
+class WildcardPattern(_BaseWildcardPattern):
+    """A pattern matcher for '*' and '?' wildcards"""
+
+    def matches(self, value: str) -> bool:
+        """Return whether a wild card pattern matches a value"""
+
+        return super()._matches(value)
+
+
+class WildcardHostPattern(_BaseWildcardPattern):
     """Match a host name or address against a wildcard pattern"""
 
-    def matches(self, host, addr, _ip):
+    def matches(self, host: str, addr: str, _ip: IPAddress) -> bool:
         """Return whether a host or address matches a wild card host pattern"""
 
-        # Arguments vary by class, but inheritance is still needed here
-        # pylint: disable=arguments-differ
-
-        return (host and super().matches(host)) or \
-               (addr and super().matches(addr))
+        return (bool(host) and super()._matches(host)) or \
+               (bool(addr) and super()._matches(addr))
 
 
 class CIDRHostPattern:
     """Match IPv4/v6 address against CIDR-style subnet pattern"""
 
-    def __init__(self, pattern):
+    def __init__(self, pattern: str):
         self._network = ip_network(pattern)
 
-    def matches(self, _host, _addr, ip):
+    def matches(self, _host: str, _addr: str, ip: IPAddress) -> bool:
         """Return whether an IP address matches a CIDR address pattern"""
 
-        return ip and ip in self._network
+        return bool(ip) and ip in self._network
 
 
 class _PatternList:
     """Match against a list of comma-separated positive and negative patterns
 
        This class is a base class for building a pattern matcher that
        takes a set of comma-separated positive and negative patterns,
@@ -77,15 +88,15 @@
        The pattern matching is done by objects returned by the
        build_pattern method. The arguments passed in when a match
        is performed will vary depending on what class build_pattern
        returns.
 
     """
 
-    def __init__(self, patterns):
+    def __init__(self, patterns: str):
         self._pos_patterns = []
         self._neg_patterns = []
 
         for pattern in patterns.split(','):
             if pattern.startswith('!'):
                 negate = True
                 pattern = pattern[1:]
@@ -95,40 +106,40 @@
             matcher = self.build_pattern(pattern)
 
             if negate:
                 self._neg_patterns.append(matcher)
             else:
                 self._pos_patterns.append(matcher)
 
-    def build_pattern(self, pattern):
+    def build_pattern(self, pattern: str) -> _AnyPattern:
         """Abstract method to build a pattern object"""
 
         raise NotImplementedError
 
-    def matches(self, *args):
+    def matches(self, *args) -> bool:
         """Match a set of values against positive & negative pattern lists"""
 
         pos_match = any(p.matches(*args) for p in self._pos_patterns)
         neg_match = any(p.matches(*args) for p in self._neg_patterns)
 
         return pos_match and not neg_match
 
 
 class WildcardPatternList(_PatternList):
     """Match names against wildcard patterns"""
 
-    def build_pattern(self, pattern):
+    def build_pattern(self, pattern: str) -> WildcardPattern:
         """Build a wild card pattern"""
 
         return WildcardPattern(pattern)
 
 
 class HostPatternList(_PatternList):
     """Match host names & addresses against wildcard and CIDR patterns"""
 
-    def build_pattern(self, pattern):
+    def build_pattern(self, pattern: str) -> _HostPattern:
         """Build a CIDR address or wild card host pattern"""
 
         try:
             return CIDRHostPattern(pattern)
         except ValueError:
             return WildcardHostPattern(pattern)
```

### Comparing `asyncssh-2.8.1/asyncssh/known_hosts.py` & `asyncssh-2.9.0/asyncssh/known_hosts.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -21,188 +21,213 @@
 #                        entries, and support for the revoked marker
 #     Josh Yudaken - proposed change to split parsing and matching to avoid
 #                    parsing large known_hosts lists multiple times
 
 """Parser for SSH known_hosts files"""
 
 import binascii
-import hmac
-
 from hashlib import sha1
+import hmac
+from typing import Callable, Dict, List, Optional
+from typing import Sequence, Tuple, Union, cast
 
 try:
     from .crypto import X509NamePattern
     _x509_available = True
 except ImportError: # pragma: no cover
     _x509_available = False
 
-from .misc import ip_address, read_file
+from .misc import IPAddress, ip_address, read_file
 from .pattern import HostPatternList
-from .public_key import KeyImportError, import_public_key
-from .public_key import import_certificate, import_certificate_subject
+from .public_key import KeyImportError
+from .public_key import SSHKey, SSHCertificate, SSHX509Certificate
+from .public_key import import_public_key, import_certificate
+from .public_key import import_certificate_subject
 from .public_key import load_public_keys, load_certificates
 
 
-def _load_subject_names(names):
+_HostPattern = Union['_PlainHost', '_HashedHost']
+_HostEntry = Tuple[Optional[str], Optional[SSHKey],
+                   Optional[SSHX509Certificate], Optional['X509NamePattern']]
+
+_KnownHostsKeys = Sequence[SSHKey]
+_KnownHostsCerts = Sequence[SSHX509Certificate]
+_KnownHostsNames = Sequence['X509NamePattern']
+_KnownHostsResult = Tuple[_KnownHostsKeys, _KnownHostsKeys, _KnownHostsKeys,
+                          _KnownHostsCerts, _KnownHostsCerts,
+                          _KnownHostsNames, _KnownHostsNames]
+
+_KnownHostsCallable = Callable[[str, str, Optional[int]], Sequence[str]]
+_KnownHostsListArg = Union[str, Sequence[str], 'X509NamePattern']
+KnownHostsArg = Union[None, str, bytes, _KnownHostsCallable, 'SSHKnownHosts',
+                      _KnownHostsResult, Sequence[_KnownHostsListArg]]
+
+
+def _load_subject_names(names: Sequence[str]) -> Sequence['X509NamePattern']:
     """Load a list of X.509 subject name patterns"""
 
     if not _x509_available: # pragma: no cover
         return []
 
     return list(map(X509NamePattern, names))
 
 
 class _PlainHost:
     """A plain host entry in a known_hosts file"""
 
-    def __init__(self, pattern):
+    def __init__(self, pattern: str):
         self._pattern = HostPatternList(pattern)
 
-    def matches(self, host, addr, ip):
+    def matches(self, host: str, addr: str, ip: Optional[IPAddress]) -> bool:
         """Return whether a host or address matches this host pattern list"""
 
         return self._pattern.matches(host, addr, ip)
 
 
 class _HashedHost:
     """A hashed host entry in a known_hosts file"""
 
     _HMAC_SHA1_MAGIC = '1'
 
-    def __init__(self, pattern):
+    def __init__(self, pattern: str):
         try:
             magic, salt, hosthash = pattern[1:].split('|')
             self._salt = binascii.a2b_base64(salt)
             self._hosthash = binascii.a2b_base64(hosthash)
         except (ValueError, binascii.Error):
             raise ValueError('Invalid known hosts hash entry: %s' %
                              pattern) from None
 
         if magic != self._HMAC_SHA1_MAGIC:
             # Only support HMAC SHA-1 for now
             raise ValueError('Invalid known hosts hash type: %s' %
                              magic) from None
 
-    def _match(self, value):
+    def _match(self, value: str) -> bool:
         """Return whether this host hash matches a value"""
 
         hosthash = hmac.new(self._salt, value.encode(), sha1).digest()
         return hosthash == self._hosthash
 
-    def matches(self, host, addr, _ip):
+    def matches(self, host: str, addr: str, _ip: Optional[IPAddress]) -> bool:
         """Return whether a host or address matches this host hash"""
 
-        return (host and self._match(host)) or (addr and self._match(addr))
+        return self._match(host) or self._match(addr)
 
 
 class SSHKnownHosts:
     """An SSH known hosts list"""
 
-    def __init__(self, known_hosts=None):
-        self._exact_entries = {}
-        self._pattern_entries = []
+    def __init__(self, known_hosts: Optional[str] = None):
+        self._exact_entries: Dict[Optional[str], List[_HostEntry]] = {}
+        self._pattern_entries: List[Tuple[_HostPattern, _HostEntry]] = []
 
         if known_hosts:
             self.load(known_hosts)
 
-    def load(self, known_hosts):
+    def load(self, known_hosts: str) -> None:
         """Load known hosts data into this object"""
 
         for line in known_hosts.splitlines():
             line = line.strip()
             if not line or line.startswith('#'):
                 continue
 
+            marker: Optional[str]
+
             try:
                 if line.startswith('@'):
                     marker, pattern, data = line[1:].split(None, 2)
                 else:
                     marker = None
                     pattern, data = line.split(None, 1)
             except ValueError:
                 raise ValueError('Invalid known hosts entry: %s' %
                                  line) from None
 
             if marker not in (None, 'cert-authority', 'revoked'):
                 raise ValueError('Invalid known hosts marker: %s' %
                                  marker) from None
 
-            key = None
-            cert = None
-            subject = None
+            key: Optional[SSHKey] = None
+            cert: Optional[SSHCertificate] = None
+            subject: Optional['X509NamePattern'] = None
 
             try:
                 key = import_public_key(data)
             except KeyImportError:
                 try:
                     cert = import_certificate(data)
                 except KeyImportError:
                     if not _x509_available: # pragma: no cover
                         continue
 
                     try:
-                        subject = import_certificate_subject(data)
+                        subject_text = import_certificate_subject(data)
                     except KeyImportError:
                         # Ignore keys in the file that we're unable to parse
                         continue
 
-                    subject = X509NamePattern(subject)
+                    subject = X509NamePattern(subject_text)
+
+            entry = (marker, key, cast(SSHX509Certificate, cert), subject)
 
             if any(c in pattern for c in '*?|/!'):
-                self._add_pattern(marker, pattern, key, cert, subject)
+                self._add_pattern(pattern, entry)
             else:
-                self._add_exact(marker, pattern, key, cert, subject)
+                self._add_exact(pattern, entry)
 
-    def _add_exact(self, marker, pattern, key, cert, subject):
+    def _add_exact(self, pattern: str, entry: _HostEntry) -> None:
         """Add an exact match entry"""
 
-        for entry in pattern.split(','):
-            if entry not in self._exact_entries:
-                self._exact_entries[entry] = []
+        for host_pat in pattern.split(','):
+            if host_pat not in self._exact_entries:
+                self._exact_entries[host_pat] = []
 
-            self._exact_entries[entry].append((marker, key, cert, subject))
+            self._exact_entries[host_pat].append(entry)
 
-    def _add_pattern(self, marker, pattern, key, cert, subject):
+    def _add_pattern(self, pattern: str, entry: _HostEntry) -> None:
         """Add a pattern match entry"""
 
         if pattern.startswith('|'):
-            entry = _HashedHost(pattern)
+            host_pat: _HostPattern = _HashedHost(pattern)
         else:
-            entry = _PlainHost(pattern)
+            host_pat = _PlainHost(pattern)
 
-        self._pattern_entries.append((entry, (marker, key, cert, subject)))
+        self._pattern_entries.append((host_pat, entry))
 
-    def _match(self, host, addr, port=None):
+    def _match(self, host: str, addr: str,
+               port: Optional[int] = None) -> _KnownHostsResult:
         """Find host keys matching specified host, address, and port"""
 
         if addr:
-            ip = ip_address(addr)
+            ip: Optional[IPAddress] = ip_address(addr)
         else:
             try:
                 ip = ip_address(host)
             except ValueError:
                 ip = None
 
         if port:
-            host = '[{}]:{}'.format(host, port) if host else None
-            addr = '[{}]:{}'.format(addr, port) if addr else None
+            host = '[{}]:{}'.format(host, port) if host else ''
+            addr = '[{}]:{}'.format(addr, port) if addr else ''
 
         matches = []
         matches += self._exact_entries.get(host, [])
         matches += self._exact_entries.get(addr, [])
         matches += (match for (entry, match) in self._pattern_entries
                     if entry.matches(host, addr, ip))
 
-        host_keys = []
-        ca_keys = []
-        revoked_keys = []
-        x509_certs = []
-        revoked_certs = []
-        x509_subjects = []
-        revoked_subjects = []
+        host_keys: List[SSHKey] = []
+        ca_keys: List[SSHKey] = []
+        revoked_keys: List[SSHKey] = []
+        x509_certs: List[SSHX509Certificate] = []
+        revoked_certs: List[SSHX509Certificate] = []
+        x509_subjects: List['X509NamePattern'] = []
+        revoked_subjects: List['X509NamePattern'] = []
 
         for marker, key, cert, subject in matches:
             if key:
                 if marker == 'revoked':
                     revoked_keys.append(key)
                 elif marker == 'cert-authority':
                     ca_keys.append(key)
@@ -210,23 +235,26 @@
                     host_keys.append(key)
             elif cert:
                 if marker == 'revoked':
                     revoked_certs.append(cert)
                 else:
                     x509_certs.append(cert)
             else:
+                assert subject is not None
+
                 if marker == 'revoked':
                     revoked_subjects.append(subject)
                 else:
                     x509_subjects.append(subject)
 
         return (host_keys, ca_keys, revoked_keys, x509_certs, revoked_certs,
                 x509_subjects, revoked_subjects)
 
-    def match(self, host, addr, port):
+    def match(self, host: str, addr: str,
+              port: Optional[int]) -> _KnownHostsResult:
         """Match a host, IP address, and port against known_hosts patterns
 
            If the port is not the default port and no match is found
            for it, the lookup is attempted again without a port number.
 
            :param host:
                The hostname of the target host
@@ -250,15 +278,15 @@
             host_keys, ca_keys, revoked_keys, x509_certs, revoked_certs, \
                 x509_subjects, revoked_subjects = self._match(host, addr)
 
         return (host_keys, ca_keys, revoked_keys, x509_certs, revoked_certs,
                 x509_subjects, revoked_subjects)
 
 
-def import_known_hosts(data):
+def import_known_hosts(data: str) -> SSHKnownHosts:
     """Import SSH known hosts
 
        This function imports known host patterns and keys in
        OpenSSH known hosts format.
 
        :param data:
            The known hosts data to import
@@ -267,15 +295,15 @@
        :returns: An :class:`SSHKnownHosts` object
 
     """
 
     return SSHKnownHosts(data)
 
 
-def read_known_hosts(filelist):
+def read_known_hosts(filelist: Union[str, Sequence[str]]) -> SSHKnownHosts:
     """Read SSH known hosts from a file or list of files
 
        This function reads known host patterns and keys in
        OpenSSH known hosts format from a file or list of files.
 
        :param filelist:
            The file or list of files to read the known hosts from
@@ -292,15 +320,16 @@
 
     for filename in filelist:
         known_hosts.load(read_file(filename, 'r'))
 
     return known_hosts
 
 
-def match_known_hosts(known_hosts, host, addr, port):
+def match_known_hosts(known_hosts: KnownHostsArg, host: str,
+                      addr: str, port: Optional[int]) -> _KnownHostsResult:
     """Match a host, IP address, and port against a known_hosts list
 
        This function looks up a host, IP address, and port in a list of
        host patterns in OpenSSH `known_hosts` format and returns the
        host keys, CA keys, and revoked keys which match.
 
        The `known_hosts` argument can be any of the following:
@@ -343,16 +372,25 @@
 
     if isinstance(known_hosts, SSHKnownHosts):
         known_hosts = known_hosts.match(host, addr, port)
     else:
         if callable(known_hosts):
             known_hosts = known_hosts(host, addr, port)
 
-        known_hosts = (tuple(map(load_public_keys, known_hosts[:3])) +
-                       tuple(map(load_certificates, known_hosts[3:5])) +
-                       tuple(map(_load_subject_names, known_hosts[5:])))
+        result = cast(Sequence[str], known_hosts)
+
+        result = (tuple(map(load_public_keys, result[:3])) +
+                  tuple(map(load_certificates, result[3:5])) +
+                  tuple(map(_load_subject_names, result[5:7])))
 
-        if len(known_hosts) == 3:
+        if len(result) == 3:
             # Provide backward compatibility for pre-X.509 releases
-            known_hosts = tuple(known_hosts) + ((), (), (), ())
+            result += ((), (), (), ())
+
+        known_hosts = cast(_KnownHostsResult, result)
+
+    for cert in list(known_hosts[3]) + list(known_hosts[4]):
+        if not cert.is_x509:
+            raise ValueError('OpenSSH certificates not '
+                             'allowed in known hosts') from None
 
     return known_hosts
```

### Comparing `asyncssh-2.8.1/asyncssh/stream.py` & `asyncssh-2.9.0/tests/test_auth.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -14,705 +14,653 @@
 #    that license
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
-"""SSH stream handlers"""
+"""Unit tests for authentication"""
 
 import asyncio
-import inspect
-import re
+import unittest
 
-from .constants import EXTENDED_DATA_STDERR
-from .misc import BreakReceived, SignalReceived
-from .misc import SoftEOFReceived, TerminalSizeChanged
-from .session import SSHClientSession, SSHServerSession
-from .session import SSHTCPSession, SSHUNIXSession
-from .sftp import run_sftp_server
-from .scp import run_scp_server
+import asyncssh
 
-_NEWLINE = object()
+from asyncssh.auth import MSG_USERAUTH_PK_OK, lookup_client_auth
+from asyncssh.auth import get_server_auth_methods, lookup_server_auth
+from asyncssh.auth import MSG_USERAUTH_GSSAPI_RESPONSE
+from asyncssh.constants import MSG_USERAUTH_REQUEST, MSG_USERAUTH_FAILURE
+from asyncssh.constants import MSG_USERAUTH_SUCCESS
+from asyncssh.gss import GSSClient, GSSServer
+from asyncssh.packet import SSHPacket, Boolean, Byte, NameList, String
 
+from .util import asynctest, gss_available, patch_gss
+from .util import AsyncTestCase, ConnectionStub
 
-class SSHReader:
-    """SSH read stream handler"""
 
-    def __init__(self, session, chan, datatype=None):
-        self._session = session
-        self._chan = chan
-        self._datatype = datatype
+class _AuthConnectionStub(ConnectionStub):
+    """Connection stub class to test authentication"""
 
-    async def __aiter__(self):
-        """Allow SSHReader to be an async iterator"""
-
-        while not self.at_eof():
-            yield await self.readline()
-
-    @property
-    def channel(self):
-        """The SSH channel associated with this stream"""
-
-        return self._chan
-
-    @property
-    def logger(self):
-        """The SSH logger associated with this stream"""
-
-        return self._chan.logger
-
-    def get_extra_info(self, name, default=None):
-        """Return additional information about this stream
-
-           This method returns extra information about the channel
-           associated with this stream. See :meth:`get_extra_info()
-           <SSHClientChannel.get_extra_info>` on :class:`SSHClientChannel`
-           for additional information.
-
-        """
-
-        return self._chan.get_extra_info(name, default)
-
-    def feed_data(self, data):
-        """Feed data to the associated session
-
-           This method feeds data to the SSH session associated with
-           this stream, providing compatibility with the
-           :meth:`feed_data() <asyncio.StreamReader.feed_data>` method
-           on :class:`asyncio.StreamReader`. This is mostly useful
-           for testing.
-
-        """
-
-        self._session.data_received(data, self._datatype)
-
-    def feed_eof(self):
-        """Feed EOF to the associated session
-
-           This method feeds an end-of-file indication to the SSH session
-           associated with this stream, providing compatibility with the
-           :meth:`feed_eof() <asyncio.StreamReader.feed_data>` method
-           on :class:`asyncio.StreamReader`. This is mostly useful
-           for testing.
-
-        """
-
-        self._session.eof_received()
-
-    async def read(self, n=-1):
-        """Read data from the stream
-
-           This method is a coroutine which reads up to `n` bytes
-           or characters from the stream. If `n` is not provided or
-           set to `-1`, it reads until EOF or a signal is received.
-
-           If EOF is received and the receive buffer is empty, an
-           empty `bytes` or `str` object is returned.
-
-           If the next data in the stream is a signal, the signal is
-           delivered as a raised exception.
-
-           .. note:: Unlike traditional `asyncio` stream readers,
-                     the data will be delivered as either `bytes` or
-                     a `str` depending on whether an encoding was
-                     specified when the underlying channel was opened.
-
-        """
-
-        return await self._session.read(n, self._datatype, exact=False)
-
-    async def readline(self):
-        """Read one line from the stream
-
-           This method is a coroutine which reads one line, ending in
-           `'\\n'`.
-
-           If EOF is received before `'\\n'` is found, the partial
-           line is returned. If EOF is received and the receive buffer
-           is empty, an empty `bytes` or `str` object is returned.
-
-           If the next data in the stream is a signal, the signal is
-           delivered as a raised exception.
-
-           .. note:: In Python 3.5 and later, :class:`SSHReader` objects
-                     can also be used as async iterators, returning input
-                     data one line at a time.
-
-        """
-
-        try:
-            return await self.readuntil(_NEWLINE)
-        except asyncio.IncompleteReadError as exc:
-            return exc.partial
-
-    async def readuntil(self, separator):
-        """Read data from the stream until `separator` is seen
-
-           This method is a coroutine which reads from the stream until
-           the requested separator is seen. If a match is found, the
-           returned data will include the separator at the end.
-
-           The separator argument can be either a single `bytes` or
-           `str` value or a sequence of multiple values to match
-           against, returning data as soon as any of the separators
-           are found in the stream.
-
-           If EOF or a signal is received before a match occurs, an
-           :exc:`IncompleteReadError <asyncio.IncompleteReadError>`
-           is raised and its `partial` attribute will contain the
-           data in the stream prior to the EOF or signal.
-
-           If the next data in the stream is a signal, the signal is
-           delivered as a raised exception.
-
-        """
-
-        return await self._session.readuntil(separator, self._datatype)
-
-    async def readexactly(self, n):
-        """Read an exact amount of data from the stream
-
-           This method is a coroutine which reads exactly n bytes or
-           characters from the stream.
-
-           If EOF or a signal is received in the stream before `n`
-           bytes are read, an :exc:`IncompleteReadError
-           <asyncio.IncompleteReadError>` is raised and its `partial`
-           attribute will contain the data before the EOF or signal.
-
-           If the next data in the stream is a signal, the signal is
-           delivered as a raised exception.
-
-        """
-
-        return await self._session.read(n, self._datatype, exact=True)
-
-    def at_eof(self):
-        """Return whether the stream is at EOF
-
-           This method returns `True` when EOF has been received and
-           all data in the stream has been read.
-
-        """
-
-        return self._session.at_eof(self._datatype)
-
-    def get_redirect_info(self):
-        """Get information needed to redirect from this SSHReader"""
-
-        return self._session, self._datatype
-
-
-class SSHWriter:
-    """SSH write stream handler"""
-
-    def __init__(self, session, chan, datatype=None):
-        self._session = session
-        self._chan = chan
-        self._datatype = datatype
-
-    @property
-    def channel(self):
-        """The SSH channel associated with this stream"""
-
-        return self._chan
-
-    @property
-    def logger(self):
-        """The SSH logger associated with this stream"""
-
-        return self._chan.logger
-
-    def get_extra_info(self, name, default=None):
-        """Return additional information about this stream
-
-           This method returns extra information about the channel
-           associated with this stream. See :meth:`get_extra_info()
-           <SSHClientChannel.get_extra_info>` on :class:`SSHClientChannel`
-           for additional information.
-
-        """
-
-        return self._chan.get_extra_info(name, default)
-
-    def can_write_eof(self):
-        """Return whether the stream supports :meth:`write_eof`"""
+    def connection_lost(self, exc):
+        """Handle the closing of a connection"""
 
-        return self._chan.can_write_eof()
+        raise NotImplementedError
 
-    def close(self):
-        """Close the channel
+    def process_packet(self, data):
+        """Process an incoming packet"""
 
-           .. note:: After this is called, no data can be read or written
-                     from any of the streams associated with this channel.
+        raise NotImplementedError
 
-        """
+    def _get_userauth_request_packet(self, method, args):
+        """Get packet data for a user authentication request"""
 
-        return self._chan.close()
+        # pylint: disable=no-self-use
 
-    def is_closing(self):
-        """Return if the stream is closing or is closed"""
+        return b''.join((Byte(MSG_USERAUTH_REQUEST), String('user'),
+                         String('service'), String(method)) + args)
 
-        return self._chan.is_closing()
+    def get_userauth_request_data(self, method, *args):
+        """Get signature data for a user authentication request"""
 
-    async def wait_closed(self):
-        """Wait until the stream is closed
+        return String('') + self._get_userauth_request_packet(method, args)
 
-           This should be called after :meth:`close` to wait until
-           the underlying connection is closed.
+    def send_userauth_packet(self, pkttype, *args, handler=None,
+                             trivial=True):
+        """Send a user authentication packet"""
 
-        """
+        # pylint: disable=unused-argument
 
-        await self._chan.wait_closed()
+        self.send_packet(pkttype, *args, handler=handler)
 
-    async def drain(self):
-        """Wait until the write buffer on the channel is flushed
 
-           This method is a coroutine which blocks the caller if the
-           stream is currently paused for writing, returning when
-           enough data has been sent on the channel to allow writing
-           to resume. This can be used to avoid buffering an excessive
-           amount of data in the channel's send buffer.
+class _AuthClientStub(_AuthConnectionStub):
+    """Stub class for client connection"""
 
-        """
+    @classmethod
+    def make_pair(cls, method, **kwargs):
+        """Make a client and server connection pair to test authentication"""
 
-        return await self._session.drain(self._datatype)
+        client_conn = cls(method, **kwargs)
+        return client_conn, client_conn.get_peer()
 
-    def write(self, data):
-        """Write data to the stream
+    def __init__(self, method, gss_host=None, override_gss_mech=False,
+                 host_based_auth=False, client_host_key=None,
+                 client_host_cert=None, public_key_auth=False, client_key=None,
+                 client_cert=None, override_pk_ok=False, password_auth=False,
+                 password=None, password_change=NotImplemented,
+                 password_change_prompt=None, kbdint_auth=False,
+                 kbdint_submethods=None, kbdint_challenge=None,
+                 kbdint_response=None, success=False):
+        super().__init__(_AuthServerStub(self, gss_host, override_gss_mech,
+                                         host_based_auth, public_key_auth,
+                                         override_pk_ok, password_auth,
+                                         password_change_prompt, kbdint_auth,
+                                         kbdint_challenge, success), False)
 
-           This method writes bytes or characters to the stream.
+        self._gss = GSSClient(gss_host, False) if gss_host else None
 
-           .. note:: Unlike traditional `asyncio` stream writers,
-                     the data must be supplied as either `bytes` or
-                     a `str` depending on whether an encoding was
-                     specified when the underlying channel was opened.
+        self._client_host_key = client_host_key
+        self._client_host_cert = client_host_cert
 
-        """
+        self._client_key = client_key
+        self._client_cert = client_cert
 
-        return self._chan.write(data, self._datatype)
+        self._password = password
+        self._password_change = password_change
+        self._password_changed = None
 
-    def writelines(self, list_of_data):
-        """Write a collection of data to the stream"""
+        self._kbdint_submethods = kbdint_submethods
+        self._kbdint_response = kbdint_response
 
-        return self._chan.writelines(list_of_data, self._datatype)
+        self._auth_waiter = asyncio.Future()
+        self._auth = lookup_client_auth(self, method)
 
-    def write_eof(self):
-        """Write EOF on the channel
+        if self._auth is None:
+            self.close()
+            raise ValueError('Invalid auth method')
 
-           This method sends an end-of-file indication on the channel,
-           after which no more data can be written.
+    def connection_lost(self, exc=None):
+        """Handle the closing of a connection"""
 
-           .. note:: On an :class:`SSHServerChannel` where multiple
-                     output streams are created, writing EOF on one
-                     stream signals EOF for all of them, since it
-                     applies to the channel as a whole.
+        if exc:
+            self._auth_waiter.set_exception(exc)
 
-        """
+        self.close()
 
-        return self._chan.write_eof()
+    def process_packet(self, data):
+        """Process an incoming packet"""
 
-    def get_redirect_info(self):
-        """Get information needed to redirect to this SSHWriter"""
+        packet = SSHPacket(data)
+        pkttype = packet.get_byte()
 
-        return self._session, self._datatype
+        if pkttype == MSG_USERAUTH_FAILURE:
+            _ = packet.get_namelist()
+            partial_success = packet.get_boolean()
+            packet.check_end()
 
+            if partial_success: # pragma: no cover
+                # Partial success not implemented yet
+                self._auth.auth_succeeded()
+            else:
+                self._auth.auth_failed()
 
-class SSHStreamSession:
-    """SSH stream session handler"""
+            self._auth_waiter.set_result((False, self._password_changed))
+            self._auth = None
+            self._auth_waiter = None
+        elif pkttype == MSG_USERAUTH_SUCCESS:
+            packet.check_end()
 
-    def __init__(self):
-        self._chan = None
-        self._conn = None
-        self._encoding = None
-        self._errors = 'strict'
-        self._loop = None
-        self._limit = None
-        self._exception = None
-        self._eof_received = False
-        self._connection_lost = False
-        self._recv_buf = {None: []}
-        self._recv_buf_len = 0
-        self._read_locks = {None: asyncio.Lock()}
-        self._read_waiters = {None: None}
-        self._read_paused = False
-        self._write_paused = False
-        self._drain_waiters = {None: set()}
+            self._auth.auth_succeeded()
+            self._auth_waiter.set_result((True, self._password_changed))
+            self._auth = None
+            self._auth_waiter = None
+        else:
+            self._auth.process_packet(pkttype, None, packet)
 
-    async def _block_read(self, datatype):
-        """Wait for more data to arrive on the stream"""
+    async def get_auth_result(self):
+        """Return the result of the authentication"""
 
-        try:
-            waiter = self._loop.create_future()
-            self._read_waiters[datatype] = waiter
-            await waiter
-        finally:
-            self._read_waiters[datatype] = None
+        return await self._auth_waiter
 
-    def _unblock_read(self, datatype):
-        """Signal that more data has arrived on the stream"""
+    def try_next_auth(self):
+        """Handle a request to move to another form of auth"""
 
-        waiter = self._read_waiters[datatype]
-        if waiter and not waiter.done():
-            waiter.set_result(None)
+        # Report that the current auth attempt failed
+        self._auth_waiter.set_result((False, self._password_changed))
+        self._auth = None
+        self._auth_waiter = None
 
-    def _should_block_drain(self, _datatype):
-        """Return whether output is still being written to the channel"""
+    async def send_userauth_request(self, method, *args, key=None,
+                                    trivial=True):
+        """Send a user authentication request"""
 
-        return self._write_paused and not self._connection_lost
+        packet = self._get_userauth_request_packet(method, args)
 
-    def _unblock_drain(self, datatype):
-        """Signal that more data can be written on the stream"""
+        if key:
+            packet += String(key.sign(String('') + packet))
 
-        if not self._should_block_drain(datatype):
-            for waiter in self._drain_waiters[datatype]:
-                if not waiter.done(): # pragma: no branch
-                    waiter.set_result(None)
+        self.send_userauth_packet(MSG_USERAUTH_REQUEST, packet[1:],
+                                  trivial=trivial)
 
-    def _should_pause_reading(self):
-        """Return whether to pause reading from the channel"""
+    def get_gss_context(self):
+        """Return the GSS context associated with this connection"""
 
-        return self._limit and self._recv_buf_len >= self._limit
+        return self._gss
 
-    def _maybe_pause_reading(self):
-        """Pause reading if necessary"""
+    def gss_mic_auth_requested(self):
+        """Return whether to allow GSS MIC authentication or not"""
 
-        if not self._read_paused and self._should_pause_reading():
-            self._read_paused = True
-            self._chan.pause_reading()
-            return True
-        else:
-            return False
+        return bool(self._gss)
 
-    def _maybe_resume_reading(self):
-        """Resume reading if necessary"""
+    async def host_based_auth_requested(self):
+        """Return a host key pair, host, and user to authenticate with"""
 
-        if self._read_paused and not self._should_pause_reading():
-            self._read_paused = False
-            self._chan.resume_reading()
-            return True
+        if self._client_host_key:
+            keypair = asyncssh.load_keypairs((self._client_host_key,
+                                              self._client_host_cert))[0]
         else:
-            return False
-
-    def connection_made(self, chan):
-        """Handle a newly opened channel"""
+            keypair = None
 
-        self._chan = chan
-        self._conn = chan.get_connection()
-        self._encoding, self._errors = chan.get_encoding()
-        self._loop = chan.get_loop()
-        self._limit = self._chan.get_recv_window()
-
-        for datatype in chan.get_read_datatypes():
-            self._recv_buf[datatype] = []
-            self._read_locks[datatype] = asyncio.Lock()
-            self._read_waiters[datatype] = None
+        return keypair, 'host', 'user'
 
-        for datatype in chan.get_write_datatypes():
-            self._drain_waiters[datatype] = set()
+    async def public_key_auth_requested(self):
+        """Return key to use for public key authentication"""
 
-    def connection_lost(self, exc):
-        """Handle an incoming channel close"""
-
-        self._connection_lost = True
-        self._exception = exc
+        if self._client_key:
+            return asyncssh.load_keypairs((self._client_key,
+                                           self._client_cert))[0]
+        else:
+            return None
 
-        if not self._eof_received:
-            if exc:
-                for datatype in self._read_waiters:
-                    self._recv_buf[datatype].append(exc)
+    async def password_auth_requested(self):
+        """Return password to send for password authentication"""
 
-            self.eof_received()
+        return self._password
 
-        for datatype in self._drain_waiters:
-            self._unblock_drain(datatype)
+    async def password_change_requested(self, _prompt, _lang):
+        """Return old & new passwords for password change"""
 
-    def data_received(self, data, datatype):
-        """Handle incoming data on the channel"""
+        if self._password_change is True:
+            return 'password', 'new_password'
+        else:
+            return self._password_change
 
-        self._recv_buf[datatype].append(data)
-        self._recv_buf_len += len(data)
-        self._unblock_read(datatype)
-        self._maybe_pause_reading()
+    def password_changed(self):
+        """Handle a successful password change"""
 
-    def eof_received(self):
-        """Handle an incoming end of file on the channel"""
+        self._password_changed = True
 
-        self._eof_received = True
+    def password_change_failed(self):
+        """Handle an unsuccessful password change"""
 
-        for datatype in self._read_waiters:
-            self._unblock_read(datatype)
+        self._password_changed = False
 
-        return True
+    async def kbdint_auth_requested(self):
+        """Return submethods to send for keyboard-interactive authentication"""
 
-    def at_eof(self, datatype):
-        """Return whether end of file has been received on the channel"""
+        return self._kbdint_submethods
 
-        return self._eof_received and not self._recv_buf[datatype]
+    async def kbdint_challenge_received(self, _name, _instruction,
+                                        _lang, _prompts):
+        """Return responses to keyboard-interactive challenge"""
 
-    def pause_writing(self):
-        """Handle a request to pause writing on the channel"""
+        if self._kbdint_response is True:
+            return ('password',)
+        else:
+            return self._kbdint_response
 
-        self._write_paused = True
 
-    def resume_writing(self):
-        """Handle a request to resume writing on the channel"""
+class _AuthServerStub(_AuthConnectionStub):
+    """Stub class for server connection"""
 
-        self._write_paused = False
+    def __init__(self, peer=None, gss_host=None, override_gss_mech=False,
+                 host_based_auth=False, public_key_auth=False,
+                 override_pk_ok=False, password_auth=False,
+                 password_change_prompt=None, kbdint_auth=False,
+                 kbdint_challenge=False, success=False):
+        super().__init__(peer, True)
 
-        for datatype in self._drain_waiters:
-            self._unblock_drain(datatype)
+        self._gss = GSSServer(gss_host) if gss_host else None
+        self._override_gss_mech = override_gss_mech
 
-    async def read(self, n, datatype, exact):
-        """Read data from the channel"""
+        self._host_based_auth = host_based_auth
 
-        recv_buf = self._recv_buf[datatype]
-        buf = '' if self._encoding else b''
-        data = []
+        self._public_key_auth = public_key_auth
+        self._override_pk_ok = override_pk_ok
 
-        async with self._read_locks[datatype]:
-            while True:
-                while recv_buf and n != 0:
-                    if isinstance(recv_buf[0], Exception):
-                        if data:
-                            break
-                        else:
-                            exc = recv_buf.pop(0)
+        self._password_auth = password_auth
+        self._password_change_prompt = password_change_prompt
 
-                            if isinstance(exc, SoftEOFReceived):
-                                n = 0
-                                break
-                            else:
-                                raise exc
+        self._kbdint_auth = kbdint_auth
+        self._kbdint_challenge = kbdint_challenge
 
-                    l = len(recv_buf[0])
-                    if l > n > 0:
-                        data.append(recv_buf[0][:n])
-                        recv_buf[0] = recv_buf[0][n:]
-                        self._recv_buf_len -= n
-                        n = 0
-                        break
+        self._success = success
 
-                    data.append(recv_buf.pop(0))
-                    self._recv_buf_len -= l
-                    n -= l
+        self._auth = None
 
-                if self._maybe_resume_reading():
-                    continue
+    def connection_lost(self, exc=None):
+        """Handle the closing of a connection"""
 
-                if n == 0 or (n > 0 and data and not exact) or \
-                        (n < 0 and recv_buf) or self._eof_received:
-                    break
+        if self._peer:
+            self._peer.connection_lost(exc)
 
-                await self._block_read(datatype)
+        self.close()
 
-        buf = buf.join(data)
-        if n > 0 and exact:
-            raise asyncio.IncompleteReadError(buf, len(buf) + n)
+    def process_packet(self, data):
+        """Process an incoming packet"""
 
-        return buf
+        packet = SSHPacket(data)
+        pkttype = packet.get_byte()
 
-    async def readuntil(self, separator, datatype):
-        """Read data from the channel until a separator is seen"""
+        if pkttype == MSG_USERAUTH_REQUEST:
+            _ = packet.get_string()         # username
+            _ = packet.get_string()         # service
+            method = packet.get_string()
 
-        if separator is _NEWLINE:
-            separator = '\n' if self._encoding else b'\n'
-        elif not separator:
-            raise ValueError('Separator cannot be empty')
+            if self._auth:
+                self._auth.cancel()
 
-        if isinstance(separator, (str, bytes)):
-            separators = [separator]
+            if self._override_gss_mech:
+                self.send_userauth_packet(MSG_USERAUTH_GSSAPI_RESPONSE,
+                                          String('mismatch'))
+            elif self._override_pk_ok:
+                self.send_userauth_packet(MSG_USERAUTH_PK_OK, String(''),
+                                          String(''))
+            else:
+                self._auth = lookup_server_auth(self, 'user', method, packet)
         else:
-            separators = list(separator)
-
-        seplen = max(len(sep) for sep in separators)
-        bar = '|' if self._encoding else b'|'
-        pat = re.compile(bar.join(map(re.escape, separators)))
-        recv_buf = self._recv_buf[datatype]
-        buf = '' if self._encoding else b''
-        curbuf = 0
-        buflen = 0
-
-        async with self._read_locks[datatype]:
-            while True:
-                while curbuf < len(recv_buf):
-                    if isinstance(recv_buf[curbuf], Exception):
-                        if buf:
-                            recv_buf[:curbuf] = []
-                            self._recv_buf_len -= buflen
-                            raise asyncio.IncompleteReadError(buf, None)
-                        else:
-                            exc = recv_buf.pop(0)
-
-                            if isinstance(exc, SoftEOFReceived):
-                                return buf
-                            else:
-                                raise exc
-
-                    buf += recv_buf[curbuf]
-                    start = max(buflen + 1 - seplen, 0)
+            self._auth.process_packet(pkttype, None, packet)
 
-                    match = pat.search(buf, start)
-                    if match:
-                        idx = match.end()
-                        recv_buf[:curbuf] = []
-                        recv_buf[0] = buf[idx:]
-                        buf = buf[:idx]
-                        self._recv_buf_len -= idx
+    def send_userauth_failure(self, partial_success):
+        """Send a user authentication failure response"""
 
-                        if not recv_buf[0]:
-                            recv_buf.pop(0)
+        self._auth = None
+        self.send_userauth_packet(MSG_USERAUTH_FAILURE, NameList([]),
+                                  Boolean(partial_success))
 
-                        self._maybe_resume_reading()
-                        return buf
+    def send_userauth_success(self):
+        """Send a user authentication success response"""
 
-                    buflen += len(recv_buf[curbuf])
-                    curbuf += 1
+        self._auth = None
+        self.send_userauth_packet(MSG_USERAUTH_SUCCESS)
 
-                if self._read_paused or self._eof_received:
-                    recv_buf[:curbuf] = []
-                    self._recv_buf_len -= buflen
-                    self._maybe_resume_reading()
-                    raise asyncio.IncompleteReadError(buf, None)
+    def get_gss_context(self):
+        """Return the GSS context associated with this connection"""
 
-                await self._block_read(datatype)
+        return self._gss
 
-    async def drain(self, datatype):
-        """Wait for data written to the channel to drain"""
+    def gss_kex_auth_supported(self):
+        """Return whether or not GSS key exchange authentication is supported"""
 
-        while self._should_block_drain(datatype):
-            try:
-                waiter = self._loop.create_future()
-                self._drain_waiters[datatype].add(waiter)
-                await waiter
-            finally:
-                self._drain_waiters[datatype].remove(waiter)
+        return bool(self._gss)
 
-        if self._connection_lost:
-            exc = self._exception
+    def gss_mic_auth_supported(self):
+        """Return whether or not GSS MIC authentication is supported"""
 
-            if not exc and self._write_paused:
-                exc = BrokenPipeError()
+        return bool(self._gss)
 
-            if exc:
-                raise exc
+    async def validate_gss_principal(self, _username, _user_principal,
+                                     _host_principal):
+        """Validate the GSS principal name for the specified user"""
 
+        return self._success
 
-class SSHClientStreamSession(SSHStreamSession, SSHClientSession):
-    """SSH client stream session handler"""
+    def host_based_auth_supported(self):
+        """Return whether or not host-based authentication is supported"""
 
+        return self._host_based_auth
 
-class SSHServerStreamSession(SSHStreamSession, SSHServerSession):
-    """SSH server stream session handler"""
+    async def validate_host_based_auth(self, _username, _key_data, _client_host,
+                                       _client_username, _msg, _signature):
+        """Validate host based authentication for the specified host and user"""
 
-    def __init__(self, session_factory, sftp_factory, allow_scp):
-        super().__init__()
+        return self._success
 
-        self._session_factory = session_factory
-        self._sftp_factory = sftp_factory
-        self._allow_scp = allow_scp and bool(sftp_factory)
+    def public_key_auth_supported(self):
+        """Return whether or not public key authentication is supported"""
 
-    def _init_sftp_server(self):
-        """Initialize an SFTP server for this stream to use"""
+        return self._public_key_auth
 
-        self._chan.set_encoding(None)
-        self._encoding = None
+    async def validate_public_key(self, _username, _key_data, _msg, _signature):
+        """Validate public key"""
 
-        return self._sftp_factory(self._chan)
+        return self._success
 
-    def shell_requested(self):
-        """Return whether a shell can be requested"""
+    def password_auth_supported(self):
+        """Return whether or not password authentication is supported"""
 
-        return bool(self._session_factory)
+        return self._password_auth
 
-    def exec_requested(self, command):
-        """Return whether execution of a command can be requested"""
+    async def validate_password(self, _username, _password):
+        """Validate password"""
 
-        # Avoid incorrect pylint suggestion to use ternary
-        # pylint: disable=consider-using-ternary
-
-        return ((self._allow_scp and command.startswith('scp ')) or
-                bool(self._session_factory))
-
-    def subsystem_requested(self, subsystem):
-        """Return whether starting a subsystem can be requested"""
-
-        if subsystem == 'sftp':
-            return bool(self._sftp_factory)
+        if self._password_change_prompt:
+            raise asyncssh.PasswordChangeRequired(self._password_change_prompt)
         else:
-            return bool(self._session_factory)
+            return self._success
 
-    def session_started(self):
-        """Start a session for this newly opened server channel"""
-
-        command = self._chan.get_command()
-
-        stdin = SSHReader(self, self._chan)
-        stdout = SSHWriter(self, self._chan)
-        stderr = SSHWriter(self, self._chan, EXTENDED_DATA_STDERR)
-
-        if self._chan.get_subsystem() == 'sftp':
-            handler = run_sftp_server(self._init_sftp_server(), stdin, stdout)
-        elif self._allow_scp and command and command.startswith('scp '):
-            handler = run_scp_server(self._init_sftp_server(), command,
-                                     stdin, stdout, stderr)
-        else:
-            handler = self._session_factory(stdin, stdout, stderr)
+    async def change_password(self, _username, _old_password, _new_password):
+        """Validate password"""
 
-        if inspect.isawaitable(handler):
-            self._conn.create_task(handler, stdin.logger)
+        return self._success
 
-    def break_received(self, msec):
-        """Handle an incoming break on the channel"""
+    def kbdint_auth_supported(self):
+        """Return whether or not keyboard-interactive authentication
+           is supported"""
 
-        self._recv_buf[None].append(BreakReceived(msec))
-        self._unblock_read(None)
-        return True
+        return self._kbdint_auth
 
-    def signal_received(self, signal):
-        """Handle an incoming signal on the channel"""
+    async def get_kbdint_challenge(self, _username, _lang, _submethods):
+        """Return a keyboard-interactive challenge"""
 
-        self._recv_buf[None].append(SignalReceived(signal))
-        self._unblock_read(None)
-
-    def soft_eof_received(self):
-        """Handle an incoming soft EOF on the channel"""
-
-        self._recv_buf[None].append(SoftEOFReceived())
-        self._unblock_read(None)
-
-    def terminal_size_changed(self, width, height, pixwidth, pixheight):
-        """Handle an incoming terminal size change on the channel"""
-
-        self._recv_buf[None].append(TerminalSizeChanged(width, height,
-                                                        pixwidth, pixheight))
-        self._unblock_read(None)
-
-
-class SSHSocketStreamSession(SSHStreamSession):
-    """Socket stream session handler"""
-
-    def __init__(self, handler_factory=None):
-        super().__init__()
-
-        self._handler_factory = handler_factory
+        if self._kbdint_challenge is True:
+            return '', '', '', (('Password:', False),)
+        else:
+            return self._kbdint_challenge
 
-    def session_started(self):
-        """Start a session for this newly opened socket channel"""
+    async def validate_kbdint_response(self, _username, _responses):
+        """Validate keyboard-interactive responses"""
 
-        if self._handler_factory:
-            reader = SSHReader(self, self._chan)
-            writer = SSHWriter(self, self._chan)
+        return self._success
 
-            handler = self._handler_factory(reader, writer)
 
-            if inspect.isawaitable(handler):
-                self._conn.create_task(handler, reader.logger)
+@patch_gss
+class _TestAuth(AsyncTestCase):
+    """Unit tests for auth module"""
 
+    async def check_auth(self, method, expected_result, **kwargs):
+        """Unit test authentication"""
 
-class SSHTCPStreamSession(SSHSocketStreamSession, SSHTCPSession):
-    """TCP stream session handler"""
+        client_conn, server_conn = _AuthClientStub.make_pair(method, **kwargs)
 
+        try:
+            self.assertEqual((await client_conn.get_auth_result()),
+                             expected_result)
+        finally:
+            client_conn.close()
+            server_conn.close()
 
-class SSHUNIXStreamSession(SSHSocketStreamSession, SSHUNIXSession):
-    """UNIX stream session handler"""
+    @asynctest
+    async def test_client_auth_methods(self):
+        """Test client auth methods"""
+
+        with self.subTest('Unknown client auth method'):
+            with self.assertRaises(ValueError):
+                _AuthClientStub.make_pair(b'xxx')
+
+    @asynctest
+    async def test_server_auth_methods(self):
+        """Test server auth methods"""
+
+        with self.subTest('No auth methods'):
+            server_conn = _AuthServerStub()
+            self.assertEqual(get_server_auth_methods(server_conn), [])
+            server_conn.close()
+
+        with self.subTest('All auth methods'):
+            gss_host = '1' if gss_available else None
+            server_conn = _AuthServerStub(gss_host=gss_host,
+                                          host_based_auth=True,
+                                          public_key_auth=True,
+                                          password_auth=True, kbdint_auth=True)
+            if gss_available: # pragma: no branch
+                self.assertEqual(get_server_auth_methods(server_conn),
+                                 [b'gssapi-keyex', b'gssapi-with-mic',
+                                  b'hostbased', b'publickey',
+                                  b'keyboard-interactive', b'password'])
+            else: # pragma: no cover
+                self.assertEqual(get_server_auth_methods(server_conn),
+                                 [b'hostbased', b'publickey',
+                                  b'keyboard-interactive', b'password'])
+            server_conn.close()
+
+        with self.subTest('Unknown auth method'):
+            server_conn = _AuthServerStub()
+            self.assertEqual(lookup_server_auth(server_conn, 'user', b'xxx',
+                                                SSHPacket(b'')), None)
+            server_conn.close()
+
+    @asynctest
+    async def test_null_auth(self):
+        """Unit test null authentication"""
+
+        await self.check_auth(b'none', (False, None))
+
+    @unittest.skipUnless(gss_available, 'GSS not available')
+    @asynctest
+    async def test_gss_auth(self):
+        """Unit test GSS authentication"""
+
+        with self.subTest('GSS with MIC auth not available'):
+            await self.check_auth(b'gssapi-with-mic', (False, None))
+
+        for steps in range(4):
+            with self.subTest('GSS with MIC auth available'):
+                await self.check_auth(b'gssapi-with-mic', (True, None),
+                                      gss_host=str(steps), success=True)
+
+            gss_host = str(steps) + ',step_error'
+
+            with self.subTest('GSS with MIC error', steps=steps):
+                await self.check_auth(b'gssapi-with-mic', (False, None),
+                                      gss_host=gss_host)
+
+            with self.subTest('GSS with MIC error with token', steps=steps):
+                await self.check_auth(b'gssapi-with-mic', (False, None),
+                                      gss_host=gss_host + ',errtok')
+
+        with self.subTest('GSS with MIC without integrity'):
+            await self.check_auth(b'gssapi-with-mic', (True, None),
+                                  gss_host='1,no_client_integrity,' +
+                                  'no_server_integrity', success=True)
+
+        with self.subTest('GSS client integrity mismatch'):
+            await self.check_auth(b'gssapi-with-mic', (False, None),
+                                  gss_host='1,no_client_integrity')
+
+        with self.subTest('GSS server integrity mismatch'):
+            await self.check_auth(b'gssapi-with-mic', (False, None),
+                                  gss_host='1,no_server_integrity')
+
+        with self.subTest('GSS mechanism unknown'):
+            await self.check_auth(b'gssapi-with-mic', (False, None),
+                                  gss_host='1,unknown_mech')
+
+        with self.subTest('GSS mechanism mismatch'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'gssapi-with-mic', (False, None),
+                                      gss_host='1', override_gss_mech=True)
+
+    @asynctest
+    async def test_hostbased_auth(self):
+        """Unit test host-based authentication"""
+
+        hkey = asyncssh.generate_private_key('ssh-rsa')
+        cert = hkey.generate_host_certificate(hkey, 'host')
+
+        with self.subTest('Host-based auth not available'):
+            await self.check_auth(b'hostbased', (False, None))
+
+        with self.subTest('Untrusted key'):
+            await self.check_auth(b'hostbased', (False, None),
+                                  client_host_key=hkey, host_based_auth=True)
+
+        with self.subTest('Trusted key'):
+            await self.check_auth(b'hostbased', (True, None),
+                                  client_host_key=hkey,
+                                  host_based_auth=True, success=True)
+
+        with self.subTest('Trusted certificate'):
+            await self.check_auth(b'hostbased', (True, None),
+                                  client_host_key=hkey, client_host_cert=cert,
+                                  host_based_auth=True, success=True)
+
+    @asynctest
+    async def test_publickey_auth(self):
+        """Unit test public key authentication"""
+
+        ckey = asyncssh.generate_private_key('ssh-rsa')
+        cert = ckey.generate_user_certificate(ckey, 'name')
+
+        with self.subTest('Public key auth not available'):
+            await self.check_auth(b'publickey', (False, None))
+
+        with self.subTest('Untrusted key'):
+            await self.check_auth(b'publickey', (False, None), client_key=ckey,
+                                  public_key_auth=True)
+
+        with self.subTest('Trusted key'):
+            await self.check_auth(b'publickey', (True, None), client_key=ckey,
+                                  public_key_auth=True, success=True)
+
+        with self.subTest('Trusted certificate'):
+            await self.check_auth(b'publickey', (True, None), client_key=ckey,
+                                  client_cert=cert, public_key_auth=True,
+                                  success=True)
+
+        with self.subTest('Invalid PK_OK message'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'publickey', (False, None),
+                                      client_key=ckey, public_key_auth=True,
+                                      override_pk_ok=True)
+
+    @asynctest
+    async def test_password_auth(self):
+        """Unit test password authentication"""
+
+        with self.subTest('Password auth not available'):
+            await self.check_auth(b'password', (False, None))
+
+        with self.subTest('Invalid password'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'password', (False, None),
+                                      password_auth=True, password=b'\xff')
+
+        with self.subTest('Incorrect password'):
+            await self.check_auth(b'password', (False, None),
+                                  password_auth=True, password='password')
+
+        with self.subTest('Correct password'):
+            await self.check_auth(b'password', (True, None),
+                                  password_auth=True, password='password',
+                                  success=True)
+
+        with self.subTest('Password change not available'):
+            await self.check_auth(b'password', (False, None),
+                                  password_auth=True, password='password',
+                                  password_change_prompt='change')
+
+        with self.subTest('Invalid password change prompt'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'password', (False, False),
+                                      password_auth=True, password='password',
+                                      password_change=True,
+                                      password_change_prompt=b'\xff')
+
+        with self.subTest('Password change failed'):
+            await self.check_auth(b'password', (False, False),
+                                  password_auth=True, password='password',
+                                  password_change=True,
+                                  password_change_prompt='change')
+
+        with self.subTest('Password change succeeded'):
+            await self.check_auth(b'password', (True, True),
+                                  password_auth=True, password='password',
+                                  password_change=True,
+                                  password_change_prompt='change', success=True)
+
+    @asynctest
+    async def test_kbdint_auth(self):
+        """Unit test keyboard-interactive authentication"""
+
+        with self.subTest('Kbdint auth not available'):
+            await self.check_auth(b'keyboard-interactive', (False, None))
+
+        with self.subTest('No submethods'):
+            await self.check_auth(b'keyboard-interactive', (False, None),
+                                  kbdint_auth=True)
+
+        with self.subTest('Invalid submethods'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'keyboard-interactive', (False, None),
+                                      kbdint_auth=True,
+                                      kbdint_submethods=b'\xff')
+
+        with self.subTest('No challenge'):
+            await self.check_auth(b'keyboard-interactive', (False, None),
+                                  kbdint_auth=True, kbdint_submethods='')
+
+        with self.subTest('Invalid challenge name'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'keyboard-interactive', (False, None),
+                                      kbdint_auth=True, kbdint_submethods='',
+                                      kbdint_challenge=(b'\xff', '', '', ()))
+
+        with self.subTest('Invalid challenge prompt'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'keyboard-interactive', (False, None),
+                                      kbdint_auth=True, kbdint_submethods='',
+                                      kbdint_challenge=('', '', '',
+                                                        ((b'\xff', False),)))
+
+        with self.subTest('No response'):
+            await self.check_auth(b'keyboard-interactive', (False, None),
+                                  kbdint_auth=True, kbdint_submethods='',
+                                  kbdint_challenge=True)
+
+        with self.subTest('Invalid response'):
+            with self.assertRaises(asyncssh.ProtocolError):
+                await self.check_auth(b'keyboard-interactive', (False, None),
+                                      kbdint_auth=True, kbdint_submethods='',
+                                      kbdint_challenge=True,
+                                      kbdint_response=(b'\xff',))
+
+        with self.subTest('Incorrect response'):
+            await self.check_auth(b'keyboard-interactive', (False, None),
+                                  kbdint_auth=True, kbdint_submethods='',
+                                  kbdint_challenge=True, kbdint_response=True)
+
+        with self.subTest('Correct response'):
+            await self.check_auth(b'keyboard-interactive', (True, None),
+                                  kbdint_auth=True, kbdint_submethods='',
+                                  kbdint_challenge=True, kbdint_response=True,
+                                  success=True)
```

### Comparing `asyncssh-2.8.1/asyncssh/connection.py` & `asyncssh-2.9.0/asyncssh/connection.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2022 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -30,33 +30,40 @@
 import sys
 import tempfile
 import time
 
 from collections import OrderedDict
 from functools import partial
 from pathlib import Path
+from types import TracebackType
+from typing import TYPE_CHECKING, Any, AnyStr, Awaitable, Callable, Dict
+from typing import List, Mapping, Optional, Sequence, Set, Tuple, Type
+from typing import TypeVar, Union, cast
+from typing_extensions import Protocol
 
 from .agent import SSHAgentClient, SSHAgentListener
 
+from .auth import Auth, ClientAuth, KbdIntChallenge, KbdIntPrompts
+from .auth import KbdIntResponse, PasswordChangeResponse
 from .auth import get_client_auth_methods, lookup_client_auth
 from .auth import get_server_auth_methods, lookup_server_auth
 
-from .auth_keys import read_authorized_keys
+from .auth_keys import SSHAuthorizedKeys, read_authorized_keys
 
-from .channel import SSHClientChannel, SSHServerChannel
+from .channel import SSHChannel, SSHClientChannel, SSHServerChannel
 from .channel import SSHTCPChannel, SSHUNIXChannel
 from .channel import SSHX11Channel, SSHAgentChannel
 
 from .client import SSHClient
 
-from .compression import get_compression_algs, get_default_compression_algs
-from .compression import get_compression_params
+from .compression import Compressor, Decompressor, get_compression_algs
+from .compression import get_default_compression_algs, get_compression_params
 from .compression import get_compressor, get_decompressor
 
-from .config import SSHClientConfig, SSHServerConfig
+from .config import ConfigPaths, SSHConfig, SSHClientConfig, SSHServerConfig
 
 from .constants import DEFAULT_LANG, DEFAULT_PORT
 from .constants import DISC_BY_APPLICATION
 from .constants import EXTENDED_DATA_STDERR
 from .constants import MSG_DISCONNECT, MSG_IGNORE, MSG_UNIMPLEMENTED, MSG_DEBUG
 from .constants import MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT, MSG_EXT_INFO
 from .constants import MSG_CHANNEL_OPEN, MSG_CHANNEL_OPEN_CONFIRMATION
@@ -67,80 +74,169 @@
 from .constants import MSG_USERAUTH_SUCCESS, MSG_USERAUTH_BANNER
 from .constants import MSG_USERAUTH_FIRST, MSG_USERAUTH_LAST
 from .constants import MSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS
 from .constants import MSG_REQUEST_FAILURE
 from .constants import OPEN_ADMINISTRATIVELY_PROHIBITED, OPEN_CONNECT_FAILED
 from .constants import OPEN_UNKNOWN_CHANNEL_TYPE
 
-from .encryption import get_encryption_algs, get_default_encryption_algs
+from .encryption import Encryption, get_encryption_algs
+from .encryption import get_default_encryption_algs
 from .encryption import get_encryption_params, get_encryption
 
 from .forward import SSHForwarder
 
-from .gss import GSSClient, GSSServer, GSSError
+from .gss import GSSBase, GSSClient, GSSServer, GSSError
 
-from .kex import get_kex_algs, get_default_kex_algs, expand_kex_algs, get_kex
+from .kex import Kex, get_kex_algs, get_default_kex_algs
+from .kex import expand_kex_algs, get_kex
 
+from .keysign import KeySignPath, SSHKeySignKeyPair
 from .keysign import find_keysign, get_keysign_keys
 
-from .known_hosts import match_known_hosts
+from .known_hosts import KnownHostsArg, match_known_hosts
 
+from .listener import ListenKey, SSHListener
 from .listener import SSHTCPClientListener, SSHUNIXClientListener
+from .listener import TCPListenerFactory, UNIXListenerFactory
 from .listener import create_tcp_forward_listener, create_unix_forward_listener
 from .listener import create_socks_listener
 
-from .logging import logger
+from .logging import SSHLogger, logger
 
 from .mac import get_mac_algs, get_default_mac_algs
 
-from .misc import ChannelListenError, ChannelOpenError, DisconnectError
-from .misc import CompressionError, ConnectionLost, HostKeyNotVerifiable
+from .misc import BytesOrStr, DefTuple, FilePath, HostPort, IPNetwork
+from .misc import MaybeAwait, OptExcInfo, Options, SockAddr
+from .misc import ChannelListenError, ChannelOpenError, CompressionError
+from .misc import DisconnectError, ConnectionLost, HostKeyNotVerifiable
 from .misc import KeyExchangeFailed, IllegalUserName, MACError
 from .misc import PasswordChangeRequired, PermissionDenied, ProtocolError
-from .misc import ProtocolNotSupported, ServiceNotAvailable, Options
+from .misc import ProtocolNotSupported, ServiceNotAvailable
 from .misc import async_context_manager, construct_disc_error
 from .misc import get_symbol_names, ip_address, map_handler_name
 from .misc import parse_byte_count, parse_time_interval
 
-from .packet import Boolean, Byte, NameList, String, UInt32
-from .packet import PacketDecodeError, SSHPacket, SSHPacketHandler
+from .packet import Boolean, Byte, NameList, String, UInt32, PacketDecodeError
+from .packet import SSHPacket, SSHPacketHandler, SSHPacketLogger
 
 from .pattern import WildcardPattern
 
 from .pkcs11 import load_pkcs11_keys
 
-from .process import PIPE, SSHClientProcess, SSHServerProcess
+from .process import PIPE, ProcessSource, ProcessTarget
+from .process import SSHServerProcessFactory, SSHCompletedProcess
+from .process import SSHClientProcess, SSHServerProcess
 
 from .public_key import CERT_TYPE_HOST, CERT_TYPE_USER, KeyImportError
+from .public_key import CertListArg, IdentityListArg, KeyListArg, SigningKey
+from .public_key import KeyPairListArg, X509CertPurposes, SSHKey, SSHKeyPair
+from .public_key import SSHCertificate, SSHOpenSSHCertificate
+from .public_key import SSHX509Certificate, SSHX509CertificateChain
 from .public_key import decode_ssh_public_key, decode_ssh_certificate
 from .public_key import get_public_key_algs, get_default_public_key_algs
 from .public_key import get_certificate_algs, get_default_certificate_algs
 from .public_key import get_x509_certificate_algs
 from .public_key import get_default_x509_certificate_algs
 from .public_key import load_keypairs, load_default_keypairs
 from .public_key import load_public_keys, load_default_host_public_keys
 from .public_key import load_certificates
 from .public_key import load_identities, load_default_identities
 
 from .saslprep import saslprep, SASLPrepError
 
 from .server import SSHServer
 
-from .sftp import SFTPServer, start_sftp_client
+from .session import DataType, TermModesArg, TermSizeArg
+from .session import SSHClientSession, SSHServerSession
+from .session import SSHTCPSession, SSHUNIXSession
+from .session import SSHClientSessionFactory, SSHTCPSessionFactory
+from .session import SSHUNIXSessionFactory
 
+from .sftp import MIN_SFTP_VERSION, SFTPClient, SFTPServer
+from .sftp import start_sftp_client
+
+from .stream import SSHReader, SSHWriter, SFTPServerFactory
+from .stream import SSHSocketSessionFactory, SSHServerSessionFactory
 from .stream import SSHClientStreamSession, SSHServerStreamSession
 from .stream import SSHTCPStreamSession, SSHUNIXStreamSession
-from .stream import SSHReader, SSHWriter
 
-from .subprocess import SSHSubprocessTransport
+from .subprocess import SSHSubprocessTransport, SSHSubprocessProtocol
+from .subprocess import SubprocessFactory, SSHSubprocessWritePipe
 
 from .version import __version__
 
+from .x11 import SSHX11ClientForwarder
+from .x11 import SSHX11ClientListener, SSHX11ServerListener
 from .x11 import create_x11_client_listener, create_x11_server_listener
 
+if TYPE_CHECKING:
+    # pylint: disable=unused-import
+    from .crypto import X509NamePattern
+
+
+_ClientFactory = Callable[[], SSHClient]
+_ServerFactory = Callable[[], SSHServer]
+_ProtocolFactory = Union[_ClientFactory, _ServerFactory]
+
+_Conn = TypeVar('_Conn', 'SSHClientConnection', 'SSHServerConnection')
+_ConnectionFactory = Callable[[], _Conn]
+
+class _TunnelProtocol(Protocol):
+    """Base protocol for connections to tunnel SSH over"""
+
+    def close(self) -> None:
+        """Close this tunnel"""
+
+class _TunnelConnectorProtocol(_TunnelProtocol, Protocol):
+    """Protocol to open a connection to tunnel an SSH connection over"""
+
+    async def create_connection(
+            self, session_factory: SSHTCPSessionFactory[bytes],
+            remote_host: str, remote_port: int) -> \
+                Tuple[SSHTCPChannel[bytes], SSHTCPSession[bytes]]:
+        """Create an outbound tunnel connection"""
+
+class _TunnelListenerProtocol(_TunnelProtocol, Protocol):
+    """Protocol to open a listener to tunnel SSH connections over"""
+
+    async def create_server(self, session_factory: TCPListenerFactory,
+                            listen_host: str, listen_port: int) -> SSHListener:
+        """Create an inbound tunnel listener"""
+
+_AcceptHandler = Optional[Callable[['SSHConnection'], MaybeAwait[None]]]
+_ErrorHandler = Optional[Callable[['SSHConnection',
+                                   Optional[Exception]], None]]
+
+_OpenHandler = Callable[[SSHPacket], Tuple[SSHClientChannel, SSHClientSession]]
+_PacketHandler = Callable[[SSHPacket], None]
+
+_AlgsArg = DefTuple[Union[str, Sequence[str]]]
+_AuthArg = DefTuple[bool]
+_AuthKeysArg = DefTuple[Union[None, str, List[str], SSHAuthorizedKeys]]
+_ClientHostKey = Union[SSHKeyPair, SSHKeySignKeyPair]
+_ClientKeysArg = Union[KeyListArg, KeyPairListArg]
+
+_Env = Optional[Union[Mapping[str, str], Sequence[str]]]
+_SendEnv = Optional[Sequence[str]]
+
+_GlobalRequest = Tuple[Optional[_PacketHandler], SSHPacket, bool]
+_GlobalRequestResult = Tuple[int, SSHPacket]
+_KeyOrCertOptions = Mapping[str, object]
+_ListenerArg = Union[bool, SSHListener]
+_ProxyCommand = Optional[Sequence[str]]
+_RequestPTY = Union[bool, str]
+
+_TCPServerHandlerFactory = Callable[[str, int], SSHSocketSessionFactory]
+_UNIXServerHandlerFactory = Callable[[], SSHSocketSessionFactory]
+
+_TunnelConnector = Union[None, str, _TunnelConnectorProtocol]
+_TunnelListener = Union[None, str, _TunnelListenerProtocol]
+
+_VersionArg = DefTuple[BytesOrStr]
+
 
 # SSH service names
 _USERAUTH_SERVICE = b'ssh-userauth'
 _CONNECTION_SERVICE = b'ssh-connection'
 
 # Max banner and version line length and count
 _MAX_BANNER_LINES = 1024
@@ -166,230 +262,283 @@
 _DEFAULT_MAX_PKTSIZE = 32768        # 32 kiB
 
 # Default line editor parameters
 _DEFAULT_LINE_HISTORY = 1000        # 1000 lines
 _DEFAULT_MAX_LINE_LENGTH = 1024     # 1024 characters
 
 
-async def _open_proxy(loop, command, conn_factory):
+async def _open_proxy(
+        loop: asyncio.AbstractEventLoop, command: Sequence[str],
+        conn_factory: _ConnectionFactory[_Conn]) -> _Conn:
     """Open a tunnel running a proxy command"""
 
     class _ProxyCommandTunnel(asyncio.SubprocessProtocol):
         """SSH proxy command tunnel"""
 
-        def __init__(self):
-            self._transport = None
-            self._stdin = None
+        def __init__(self) -> None:
+            super().__init__()
+
+            self._transport: Optional[asyncio.SubprocessTransport] = None
+            self._stdin: Optional[asyncio.WriteTransport] = None
             self._conn = conn_factory()
             self._close_event = asyncio.Event()
 
-        def get_owner(self):
-            """Return the connection running over this tunnel"""
+        def set_protocol(self, protocol: asyncio.BaseProtocol) -> None:
+            """Changing the protocol is ignored here"""
 
-            return self._conn
+        def get_protocol(self) -> asyncio.BaseProtocol:
+            """Changing the protocol is ignored here"""
 
-        def get_extra_info(self, name, default=None):
+        def get_extra_info(self, name: str, default: Any = None) -> Any:
             """Return extra information associated with this tunnel"""
 
+            assert self._transport is not None
             return self._transport.get_extra_info(name, default)
 
-        def connection_made(self, transport):
+        def get_conn(self) -> _Conn:
+            """Return the connection associated with this tunnel"""
+
+            return self._conn
+
+        def connection_made(self, transport: asyncio.BaseTransport) -> None:
             """Handle startup of the subprocess"""
 
-            self._transport = transport
-            self._stdin = transport.get_pipe_transport(0)
-            self._conn.connection_made(self)
+            self._transport = cast(asyncio.SubprocessTransport, transport)
+            self._stdin = cast(asyncio.WriteTransport,
+                               self._transport.get_pipe_transport(0))
+            self._conn.connection_made(cast(asyncio.BaseTransport, self))
 
-        def pipe_data_received(self, fd, data):
+        def pipe_data_received(self, fd: int, data: bytes) -> None:
             """Handle data received from this tunnel"""
 
             # pylint: disable=unused-argument
 
             self._conn.data_received(data)
 
-        def pipe_connection_lost(self, fd, exc):
+        def pipe_connection_lost(self, fd: int,
+                                 exc: Optional[Exception]) -> None:
             """Handle when this tunnel is closed"""
 
             # pylint: disable=unused-argument
 
             self._conn.connection_lost(exc)
 
-        def is_closing(self):
+        def is_closing(self) -> bool:
             """Return whether the transport is closing or not"""
 
+            assert self._transport is not None
             return self._transport.is_closing()
 
-        def write(self, data):
+        def write(self, data: bytes) -> None:
             """Write data to this tunnel"""
 
+            assert self._stdin is not None
             self._stdin.write(data)
 
-        def abort(self):
+        def abort(self) -> None:
             """Forcibly close this tunnel"""
 
             self.close()
 
-        def close(self):
+        def close(self) -> None:
             """Close this tunnel"""
 
-            self._transport.close()
+            if self._transport: # pragma: no cover
+                self._transport.close()
+
             self._close_event.set()
 
 
     _, tunnel = await loop.subprocess_exec(_ProxyCommandTunnel, *command)
 
-    return tunnel.get_owner()
+    return cast(_Conn, cast(_ProxyCommandTunnel, tunnel).get_conn())
 
 
-async def _open_tunnel(tunnel, passphrase):
+async def _open_tunnel(tunnel: object, passphrase: Optional[BytesOrStr]) -> \
+        Optional['SSHClientConnection']:
     """Parse and open connection to tunnel over"""
 
+    username: DefTuple[str]
+    port: DefTuple[int]
+
     if isinstance(tunnel, str):
         if '@' in tunnel:
             username, host = tunnel.rsplit('@', 1)
         else:
             username, host = (), tunnel
 
         if ':' in host:
-            host, port = host.rsplit(':', 1)
-            port = int(port)
+            host, port_str = host.rsplit(':', 1)
+            port = int(port_str)
         else:
             port = ()
 
         return await connect(host, port, username=username,
                              passphrase=passphrase)
     else:
         return None
 
 
-async def _connect(options, loop, flags, conn_factory, msg):
+async def _connect(options: 'SSHConnectionOptions',
+                   loop: asyncio.AbstractEventLoop, flags: int,
+                   conn_factory: _ConnectionFactory[_Conn], msg: str) -> _Conn:
     """Make outbound TCP or SSH tunneled connection"""
 
     host = options.host
     port = options.port
     tunnel = options.tunnel
     family = options.family
     local_addr = options.local_addr
     proxy_command = options.proxy_command
     free_conn = True
 
+    options.waiter = loop.create_future()
+
     new_tunnel = await _open_tunnel(tunnel, options.passphrase)
+    tunnel: _TunnelConnectorProtocol
 
-    if new_tunnel:
-        new_tunnel.logger.info('%s %s via %s', msg, (host, port), tunnel)
+    try:
+        if new_tunnel:
+            new_tunnel.logger.info('%s %s via %s', msg, (host, port), tunnel)
 
-        # pylint: disable=broad-except
-        try:
-            _, conn = await new_tunnel.create_connection(conn_factory,
-                                                         host, port)
-        except Exception:
-            new_tunnel.close()
-            await new_tunnel.wait_closed()
-            raise
-        else:
-            conn.set_tunnel(new_tunnel)
-    elif tunnel:
-        tunnel_logger = getattr(tunnel, 'logger', logger)
-        tunnel_logger.info('%s %s via SSH tunnel', msg, (host, port))
-        _, conn = await tunnel.create_connection(conn_factory, host, port)
-    elif proxy_command:
-        conn = await _open_proxy(loop, proxy_command, conn_factory)
-    else:
-        logger.info('%s %s', msg, (host, port))
-        _, conn = await loop.create_connection(conn_factory, host, port,
-                                               family=family, flags=flags,
-                                               local_addr=local_addr)
+            # pylint: disable=broad-except
+            try:
+                _, tunnel_session = await new_tunnel.create_connection(
+                    cast(SSHTCPSessionFactory[bytes], conn_factory),
+                    host, port)
+            except Exception:
+                new_tunnel.close()
+                await new_tunnel.wait_closed()
+                raise
+            else:
+                conn = cast(_Conn, tunnel_session)
+                conn.set_tunnel(new_tunnel)
+        elif tunnel:
+            tunnel_logger = getattr(tunnel, 'logger', logger)
+            tunnel_logger.info('%s %s via SSH tunnel', msg, (host, port))
+
+            _, tunnel_session = await tunnel.create_connection(
+                cast(SSHTCPSessionFactory[bytes], conn_factory),
+                host, port)
+
+            conn = cast(_Conn, tunnel_session)
+        elif proxy_command:
+            conn = await _open_proxy(loop, proxy_command, conn_factory)
+        else:
+            logger.info('%s %s', msg, (host, port))
+
+            _, session = await loop.create_connection(
+                conn_factory, host, port, family=family,
+                flags=flags, local_addr=local_addr)
+
+            conn = cast(_Conn, session)
+    except asyncio.CancelledError:
+        options.waiter.cancel()
+        raise
 
     try:
-        await conn.wait_established()
+        await options.waiter
         free_conn = False
 
         if new_tunnel:
             conn.set_tunnel(new_tunnel)
 
         return conn
     finally:
         if free_conn:
             conn.abort()
             await conn.wait_closed()
 
 
-async def _listen(options, loop, flags, backlog, reuse_address,
-                  reuse_port, conn_factory, msg):
+async def _listen(options: 'SSHConnectionOptions',
+                  loop: asyncio.AbstractEventLoop, flags: int, backlog: int,
+                  reuse_address: bool, reuse_port: bool,
+                  conn_factory: _ConnectionFactory[_Conn],
+                  msg: str) -> 'SSHAcceptor':
     """Make inbound TCP or SSH tunneled listener"""
 
-    def tunnel_factory(_orig_host, _orig_port):
+    def tunnel_factory(_orig_host: str, _orig_port: int) -> SSHTCPSession:
         """Ignore original host and port"""
 
-        return conn_factory()
+        return cast(SSHTCPSession, conn_factory())
 
     host = options.host
     port = options.port
     tunnel = options.tunnel
     family = options.family
 
     new_tunnel = await _open_tunnel(tunnel, options.passphrase)
+    tunnel: _TunnelListenerProtocol
 
     if new_tunnel:
         new_tunnel.logger.info('%s %s via %s', msg, (host, port), tunnel)
 
         # pylint: disable=broad-except
         try:
-            server = await new_tunnel.create_server(tunnel_factory, host, port)
+            tunnel_server = await new_tunnel.create_server(
+                tunnel_factory, host, port)
         except Exception:
             new_tunnel.close()
             await new_tunnel.wait_closed()
             raise
         else:
-            server.set_tunnel(new_tunnel)
+            tunnel_server.set_tunnel(new_tunnel)
+            server = cast(asyncio.AbstractServer, tunnel_server)
     elif tunnel:
         tunnel_logger = getattr(tunnel, 'logger', logger)
         tunnel_logger.info('%s %s via SSH tunnel', msg, (host, port))
-        server = await tunnel.create_server(tunnel_factory, host, port)
+
+        tunnel_server = await tunnel.create_server(tunnel_factory, host, port)
+        server = cast(asyncio.AbstractServer, tunnel_server)
     else:
         logger.info('%s %s', msg, (host, port))
-        server = await loop.create_server(conn_factory, host, port,
-                                          family=family, flags=flags,
-                                          backlog=backlog,
-                                          reuse_address=reuse_address,
-                                          reuse_port=reuse_port)
+
+        server = await loop.create_server(
+            conn_factory, host, port, family=family, flags=flags,
+            backlog=backlog, reuse_address=reuse_address,
+            reuse_port=reuse_port)
 
     return SSHAcceptor(server, options)
 
 
-def _validate_version(version):
+def _validate_version(version: DefTuple[BytesOrStr]) -> bytes:
     """Validate requested SSH version"""
 
     if version == ():
         version = b'AsyncSSH_' + __version__.encode('ascii')
     else:
         if isinstance(version, str):
             version = version.encode('ascii')
+        else:
+            assert isinstance(version, bytes)
 
         # Version including 'SSH-2.0-' and CRLF must be 255 chars or less
         if len(version) > 245:
             raise ValueError('Version string is too long')
 
         for b in version:
             if b < 0x20 or b > 0x7e:
                 raise ValueError('Version string must be printable ASCII')
 
     return version
 
 
-def _expand_algs(alg_type, algs, possible_algs, default_algs, strict_match):
+def _expand_algs(alg_type: str, algs: str,
+                 possible_algs: List[bytes],
+                 default_algs: List[bytes],
+                 strict_match: bool) -> Sequence[bytes]:
     """Expand the set of allowed algorithms"""
 
     if algs[:1] in '^+-':
         prefix = algs[:1]
         algs = algs[1:]
     else:
         prefix = ''
 
-    matched = []
+    matched: List[bytes] = []
 
     for pat in algs.split(','):
         pattern = WildcardPattern(pat)
 
         matches = [alg for alg in possible_algs
                    if pattern.matches(alg.decode('ascii'))]
 
@@ -405,85 +554,95 @@
         return default_algs + matched
     elif prefix == '-':
         return [alg for alg in default_algs if alg not in matched]
     else:
         return matched
 
 
-def _select_algs(alg_type, algs, possible_algs, default_algs,
-                 config_algs, none_value=None):
+def _select_algs(alg_type: str, algs: _AlgsArg, config_algs: _AlgsArg,
+                 possible_algs: List[bytes], default_algs: List[bytes],
+                 none_value: Optional[bytes] = None) -> Sequence[bytes]:
     """Select a set of allowed algorithms"""
 
     if algs == ():
         algs = config_algs
         strict_match = False
     else:
         strict_match = True
 
     if algs in ((), 'default'):
         return default_algs
     elif algs:
         if isinstance(algs, str):
-            algs = _expand_algs(alg_type, algs, possible_algs,
-                                default_algs, strict_match)
+            expanded_algs = _expand_algs(alg_type, algs, possible_algs,
+                                         default_algs, strict_match)
         else:
-            algs = [alg.encode('ascii') for alg in algs]
+            expanded_algs = [alg.encode('ascii') for alg in algs]
 
-        result = []
+        result: List[bytes] = []
 
-        for alg in algs:
+        for alg in expanded_algs:
             if alg not in possible_algs:
                 raise ValueError('%s is not a valid %s algorithm' %
                                  (alg.decode('ascii'), alg_type))
 
             if alg not in result:
                 result.append(alg)
 
         return result
     elif none_value:
         return [none_value]
     else:
         raise ValueError('No %s algorithms selected' % alg_type)
 
 
-def _select_host_key_algs(algs, config_algs, default_algs):
+def _select_host_key_algs(algs: _AlgsArg, config_algs: _AlgsArg,
+                          default_algs: List[bytes]) -> Sequence[bytes]:
     """Select a set of allowed host key algorithms"""
 
     possible_algs = (get_x509_certificate_algs() + get_certificate_algs() +
                      get_public_key_algs())
 
-    return _select_algs('host key', algs, possible_algs,
-                        default_algs, config_algs)
+    return _select_algs('host key', algs, config_algs,
+                        possible_algs, default_algs)
 
 
-def _validate_algs(config, kex_algs, enc_algs, mac_algs, cmp_algs,
-                   sig_algs, allow_x509):
+def _validate_algs(config: SSHConfig, kex_algs_arg: _AlgsArg,
+                   enc_algs_arg: _AlgsArg, mac_algs_arg: _AlgsArg,
+                   cmp_algs_arg: _AlgsArg, sig_algs_arg: _AlgsArg,
+                   allow_x509: bool) -> \
+        Tuple[Sequence[bytes], Sequence[bytes], Sequence[bytes],
+              Sequence[bytes], Sequence[bytes]]:
     """Validate requested algorithms"""
 
-    kex_algs = _select_algs('key exchange', kex_algs, get_kex_algs(),
-                            get_default_kex_algs(),
-                            config.get('KexAlgorithms', ()))
-    enc_algs = _select_algs('encryption', enc_algs, get_encryption_algs(),
-                            get_default_encryption_algs(),
-                            config.get('Ciphers', ()))
-    mac_algs = _select_algs('MAC', mac_algs, get_mac_algs(),
-                            get_default_mac_algs(), config.get('MACs', ()))
-    cmp_algs = _select_algs('compression', cmp_algs, get_compression_algs(),
-                            get_default_compression_algs(),
-                            config.get_compression_algs(()), b'none')
+    kex_algs = _select_algs('key exchange', kex_algs_arg,
+                            cast(_AlgsArg, config.get('KexAlgorithms', ())),
+                            get_kex_algs(), get_default_kex_algs())
+    enc_algs = _select_algs('encryption', enc_algs_arg,
+                            cast(_AlgsArg, config.get('Ciphers', ())),
+                            get_encryption_algs(),
+                            get_default_encryption_algs())
+    mac_algs = _select_algs('MAC', mac_algs_arg,
+                            cast(_AlgsArg, config.get('MACs', ())),
+                            get_mac_algs(), get_default_mac_algs())
+    cmp_algs = _select_algs('compression', cmp_algs_arg,
+                            cast(_AlgsArg, config.get_compression_algs()),
+                            get_compression_algs(),
+                            get_default_compression_algs(), b'none')
 
     allowed_sig_algs = get_x509_certificate_algs() if allow_x509 else []
     allowed_sig_algs = allowed_sig_algs + get_public_key_algs()
 
     default_sig_algs = get_default_x509_certificate_algs() if allow_x509 else []
     default_sig_algs = allowed_sig_algs + get_default_public_key_algs()
 
-    sig_algs = _select_algs('signature', sig_algs,
-                            allowed_sig_algs, default_sig_algs,
-                            config.get('CASignatureAlgorithms', ()))
+    sig_algs = _select_algs('signature', sig_algs_arg,
+                            cast(_AlgsArg,
+                                 config.get('CASignatureAlgorithms', ())),
+                            allowed_sig_algs, default_sig_algs)
 
     return kex_algs, enc_algs, mac_algs, cmp_algs, sig_algs
 
 
 class SSHAcceptor:
     """SSH acceptor
 
@@ -495,29 +654,43 @@
        and :class:`SSHServerConnectionOptions` classes.
 
        In addition, this class supports all of the methods supported by
        :class:`asyncio.Server` to control accepting of new connections.
 
     """
 
-    def __init__(self, server, options):
+    def __init__(self, server: asyncio.AbstractServer,
+                 options: 'SSHConnectionOptions'):
         self._server = server
         self._options = options
 
-    async def __aenter__(self):
+    async def __aenter__(self) -> 'SSHAcceptor':
         return self
 
-    async def __aexit__(self, *exc_info):
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
         self.close()
         await self.wait_closed()
+        return False
 
-    def __getattr__(self, name):
+    def __getattr__(self, name: str) -> Any:
         return getattr(self._server, name)
 
-    def update(self, **kwargs):
+    def close(self) -> None:
+        """Close this SSH listener"""
+
+        self._server.close()
+
+    async def wait_closed(self) -> None:
+        """Wait for this SSH listener to close"""
+
+        await self._server.wait_closed()
+
+    def update(self, **kwargs: object) -> None:
         """Update options on an SSH listener
 
            Acceptors started by :func:`listen` support options defined
            in :class:`SSHServerConnectionOptions`. Acceptors started
            by :func:`listen_reverse` support options defined in
            :class:`SSHClientConnectionOptions`.
 
@@ -534,366 +707,385 @@
     """Parent class for SSH connections"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_')
 
     next_conn = 0    # Next connection number, for logging
 
     @staticmethod
-    def _get_next_conn():
+    def _get_next_conn() -> int:
         """Return the next available connection number (for logging)"""
 
         next_conn = SSHConnection.next_conn
         SSHConnection.next_conn += 1
         return next_conn
 
-    def __init__(self, loop, options, acceptor, error_handler, wait, server):
+    def __init__(self, loop: asyncio.AbstractEventLoop,
+                 options: 'SSHConnectionOptions',
+                 acceptor: _AcceptHandler, error_handler: _ErrorHandler,
+                 wait: Optional[str], server: bool):
         self._loop = loop
         self._options = options
         self._protocol_factory = options.protocol_factory
         self._acceptor = acceptor
         self._error_handler = error_handler
         self._server = server
         self._wait = wait
-        self._waiter = loop.create_future()
+        self._waiter = options.waiter if wait else None
 
-        self._transport = None
-        self._local_addr = None
-        self._local_port = None
-        self._peer_host = None
-        self._peer_addr = None
-        self._peer_port = None
+        self._transport: Optional[asyncio.Transport] = None
+        self._local_addr = ''
+        self._local_port = 0
+        self._peer_host = ''
+        self._peer_addr = ''
+        self._peer_port = 0
         self._tcp_keepalive = options.tcp_keepalive
-        self._owner = None
-        self._extra = {}
+        self._owner: Optional[Union[SSHClient, SSHServer]] = None
+        self._extra: Dict[str, object] = {}
 
         self._inpbuf = b''
         self._packet = b''
         self._pktlen = 0
         self._banner_lines = 0
 
         self._version = options.version
         self._client_version = b''
         self._server_version = b''
         self._client_kexinit = b''
         self._server_kexinit = b''
-        self._session_id = None
+        self._session_id = b''
 
         self._send_seq = 0
-        self._send_encryption = None
+        self._send_encryption: Optional[Encryption] = None
         self._send_enchdrlen = 5
         self._send_blocksize = 8
-        self._compressor = None
+        self._compressor: Optional[Compressor] = None
         self._compress_after_auth = False
-        self._deferred_packets = []
+        self._deferred_packets: List[Tuple[int, Sequence[bytes]]] = []
 
         self._recv_handler = self._recv_version
         self._recv_seq = 0
-        self._recv_encryption = None
+        self._recv_encryption: Optional[Encryption] = None
         self._recv_blocksize = 8
         self._recv_macsize = 0
-        self._decompressor = None
-        self._decompress_after_auth = None
-        self._next_recv_encryption = None
+        self._decompressor: Optional[Decompressor] = None
+        self._decompress_after_auth = False
+        self._next_recv_encryption: Optional[Encryption] = None
         self._next_recv_blocksize = 0
         self._next_recv_macsize = 0
-        self._next_decompressor = None
-        self._next_decompress_after_auth = None
+        self._next_decompressor: Optional[Decompressor] = None
+        self._next_decompress_after_auth = False
 
-        self._trusted_host_keys = set()
-        self._trusted_host_key_algs = []
-        self._trusted_ca_keys = set()
-        self._revoked_host_keys = set()
+        self._trusted_host_keys: Optional[Set[SSHKey]] = set()
+        self._trusted_host_key_algs: List[bytes] = []
+        self._trusted_ca_keys: Optional[Set[SSHKey]] = set()
+        self._revoked_host_keys: Set[SSHKey] = set()
 
         self._x509_trusted_certs = options.x509_trusted_certs
         self._x509_trusted_cert_paths = options.x509_trusted_cert_paths
-        self._x509_revoked_certs = []
-        self._x509_trusted_subjects = []
-        self._x509_revoked_subjects = []
+        self._x509_revoked_certs: Set[SSHX509Certificate] = set()
+        self._x509_trusted_subjects: Sequence['X509NamePattern'] = []
+        self._x509_revoked_subjects: Sequence['X509NamePattern'] = []
         self._x509_purposes = options.x509_purposes
 
         self._kex_algs = options.kex_algs
         self._enc_algs = options.encryption_algs
         self._mac_algs = options.mac_algs
         self._cmp_algs = options.compression_algs
         self._sig_algs = options.signature_algs
 
         self._host_based_auth = options.host_based_auth
         self._public_key_auth = options.public_key_auth
         self._kbdint_auth = options.kbdint_auth
         self._password_auth = options.password_auth
 
-        self._kex = None
+        self._kex: Optional[Kex] = None
         self._kexinit_sent = False
         self._kex_complete = False
         self._ignore_first_kex = False
 
-        self._gss = None
+        self._gss: Optional[GSSBase] = None
         self._gss_kex = False
         self._gss_auth = False
         self._gss_kex_auth = False
         self._gss_mic_auth = False
 
-        self._preferred_auth = None
+        self._preferred_auth: Optional[Sequence[bytes]] = None
 
         self._rekey_bytes = options.rekey_bytes
         self._rekey_seconds = options.rekey_seconds
         self._rekey_bytes_sent = 0
-        self._rekey_time = 0
+        self._rekey_time = 0.
 
         self._keepalive_count = 0
         self._keepalive_count_max = options.keepalive_count_max
         self._keepalive_interval = options.keepalive_interval
-        self._keepalive_timer = None
+        self._keepalive_timer: Optional[asyncio.TimerHandle] = None
 
-        self._tunnel = None
+        self._tunnel: Optional[_TunnelProtocol] = None
 
-        self._enc_alg_cs = None
-        self._enc_alg_sc = None
+        self._enc_alg_cs = b''
+        self._enc_alg_sc = b''
 
-        self._mac_alg_cs = None
-        self._mac_alg_sc = None
+        self._mac_alg_cs = b''
+        self._mac_alg_sc = b''
 
-        self._cmp_alg_cs = None
-        self._cmp_alg_sc = None
+        self._cmp_alg_cs = b''
+        self._cmp_alg_sc = b''
 
         self._can_send_ext_info = False
-        self._extensions_to_send = OrderedDict()
+        self._extensions_to_send: 'OrderedDict[bytes, bytes]' = OrderedDict()
 
-        self._server_sig_algs = ()
+        self._server_sig_algs: Set[bytes] = set()
 
-        self._next_service = None
+        self._next_service: Optional[bytes] = None
 
-        self._agent = None
-        self._auth = None
+        self._agent: Optional[SSHAgentClient] = None
+
+        self._auth: Optional[Auth] = None
         self._auth_in_progress = False
         self._auth_complete = False
         self._auth_methods = [b'none']
         self._auth_was_trivial = True
-        self._username = None
+        self._username = ''
 
-        self._channels = {}
+        self._channels: Dict[int, SSHChannel] = {}
         self._next_recv_chan = 0
 
-        self._global_request_queue = []
-        self._global_request_waiters = []
+        self._global_request_queue: List[_GlobalRequest] = []
+        self._global_request_waiters: \
+            'List[asyncio.Future[_GlobalRequestResult]]' = []
 
-        self._local_listeners = {}
+        self._local_listeners: Dict[ListenKey, SSHListener] = {}
 
-        self._x11_listener = None
+        self._x11_listener: Union[None, SSHX11ClientListener,
+                                  SSHX11ServerListener] = None
 
         self._close_event = asyncio.Event()
 
-        self._server_host_key_algs = []
+        self._server_host_key_algs: Optional[Sequence[bytes]] = None
 
         self._logger = logger.get_child(context='conn=%d' %
                                         self._get_next_conn())
 
+        self._login_timer: Optional[asyncio.TimerHandle]
+
         if options.login_timeout:
             self._login_timer = self._loop.call_later(
                 options.login_timeout, self._login_timer_callback)
         else:
             self._login_timer = None
 
         self._disable_trivial_auth = False
 
-    async def __aenter__(self):
+    async def __aenter__(self) -> 'SSHConnection':
         """Allow SSHConnection to be used as an async context manager"""
 
         return self
 
-    async def __aexit__(self, *exc_info):
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
         """Wait for connection close when used as an async context manager"""
 
         if not self._loop.is_closed(): # pragma: no branch
             self.close()
 
         await self.wait_closed()
+        return False
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this connection"""
 
         return self._logger
 
-    def _cleanup(self, exc):
+    def _cleanup(self, exc: Optional[Exception]) -> None:
         """Clean up this connection"""
 
         self._cancel_keepalive_timer()
 
         for chan in list(self._channels.values()):
             chan.process_connection_close(exc)
 
         for listener in list(self._local_listeners.values()):
             listener.close()
 
         while self._global_request_waiters:
-            self._process_global_response(MSG_REQUEST_FAILURE, None,
+            self._process_global_response(MSG_REQUEST_FAILURE, 0,
                                           SSHPacket(b''))
 
         if self._auth:
             self._auth.cancel()
             self._auth = None
 
         if self._error_handler:
             self._error_handler(self, exc)
             self._acceptor = None
             self._error_handler = None
 
-        if self._wait and not self._waiter.cancelled():
-            self._waiter.set_exception(exc)
+        if self._wait and self._waiter and not self._waiter.cancelled():
+            if exc:
+                self._waiter.set_exception(exc)
+            else: # pragma: no cover
+                self._waiter.set_result(None)
+
             self._wait = None
 
         if self._owner: # pragma: no branch
             self._owner.connection_lost(exc)
             self._owner = None
 
         self._cancel_login_timer()
         self._close_event.set()
 
         self._inpbuf = b''
-        self._recv_handler = None
 
         if self._tunnel:
             self._tunnel.close()
             self._tunnel = None
 
-    def _cancel_login_timer(self):
+    def _cancel_login_timer(self) -> None:
         """Cancel the login timer"""
 
         if self._login_timer:
             self._login_timer.cancel()
             self._login_timer = None
 
-    def _login_timer_callback(self):
+    def _login_timer_callback(self) -> None:
         """Close the connection if authentication hasn't completed yet"""
 
         self._login_timer = None
 
         self.connection_lost(ConnectionLost('Login timeout expired'))
 
-    def _cancel_keepalive_timer(self):
+    def _cancel_keepalive_timer(self) -> None:
         """Cancel the keepalive timer"""
 
         if self._keepalive_timer:
             self._keepalive_timer.cancel()
             self._keepalive_timer = None
 
-    def _set_keepalive_timer(self):
+    def _set_keepalive_timer(self) -> None:
         """Set the keepalive timer"""
 
         if self._keepalive_interval:
             self._keepalive_timer = self._loop.call_later(
                 self._keepalive_interval, self._keepalive_timer_callback)
 
-    def _reset_keepalive_timer(self):
+    def _reset_keepalive_timer(self) -> None:
         """Reset the keepalive timer"""
 
         if self._auth_complete:
             self._cancel_keepalive_timer()
             self._set_keepalive_timer()
 
-    async def _make_keepalive_request(self):
+    async def _make_keepalive_request(self) -> None:
         """Send keepalive request"""
 
         self.logger.debug1('Sending keepalive request')
 
-        await self._make_global_request('keepalive@openssh.com')
+        await self._make_global_request(b'keepalive@openssh.com')
 
         if self._keepalive_timer:
             self.logger.debug1('Got keepalive response')
 
         self._keepalive_count = 0
 
-    def _keepalive_timer_callback(self):
+    def _keepalive_timer_callback(self) -> None:
         """Handle keepalive check"""
 
         self._keepalive_count += 1
 
         if self._keepalive_count > self._keepalive_count_max:
             self.connection_lost(
                 ConnectionLost(('Server' if self.is_client() else 'Client') +
                                ' not responding to keepalive'))
         else:
             self._set_keepalive_timer()
             self.create_task(self._make_keepalive_request())
 
-    def _force_close(self, exc):
+    def _force_close(self, exc: Optional[BaseException]) -> None:
         """Force this connection to close immediately"""
 
         if not self._transport:
             return
 
         self._transport.abort()
         self._transport = None
 
         self._loop.call_soon(self._cleanup, exc)
 
-    def _reap_task(self, task_logger, task):
+    def _reap_task(self, task_logger: SSHLogger,
+                   task: 'asyncio.Task[None]') -> None:
         """Collect result of an async task, reporting errors"""
 
         # pylint: disable=broad-except
         try:
             task.result()
         except asyncio.CancelledError:
             pass
         except DisconnectError as exc:
             self._send_disconnect(exc.code, exc.reason, exc.lang)
             self._force_close(exc)
         except Exception:
             self.internal_error(error_logger=task_logger)
 
-    def create_task(self, coro, task_logger=None):
+    def create_task(self, coro: Awaitable[None],
+                    task_logger: SSHLogger = None) -> 'asyncio.Task[None]':
         """Create an asynchronous task which catches and reports errors"""
 
         task = asyncio.ensure_future(coro)
         task.add_done_callback(partial(self._reap_task, task_logger))
         return task
 
-    def is_client(self):
+    def is_client(self) -> bool:
         """Return if this is a client connection"""
 
         return not self._server
 
-    def is_server(self):
+    def is_server(self) -> bool:
         """Return if this is a server connection"""
 
         return self._server
 
-    def get_owner(self):
+    def get_owner(self) -> Optional[Union[SSHClient, SSHServer]]:
         """Return the SSHClient or SSHServer which owns this connection"""
 
         return self._owner
 
-    def get_hash_prefix(self):
+    def get_hash_prefix(self) -> bytes:
         """Return the bytes used in calculating unique connection hashes
 
            This methods returns a packetized version of the client and
            server version and kexinit strings which is needed to perform
            key exchange hashes.
 
         """
 
         return b''.join((String(self._client_version),
                          String(self._server_version),
                          String(self._client_kexinit),
                          String(self._server_kexinit)))
 
-    def set_tunnel(self, tunnel):
+    def set_tunnel(self, tunnel: _TunnelProtocol) -> None:
         """Set tunnel used to open this connection"""
 
         self._tunnel = tunnel
 
-    def _match_known_hosts(self, known_hosts, host, addr, port):
+    def _match_known_hosts(self, known_hosts: KnownHostsArg, host: str,
+                           addr: str, port: Optional[int]) -> None:
         """Determine the set of trusted host keys and certificates"""
 
         trusted_host_keys, trusted_ca_keys, revoked_host_keys, \
             trusted_x509_certs, revoked_x509_certs, \
             trusted_x509_subjects, revoked_x509_subjects = \
                 match_known_hosts(known_hosts, host, addr, port)
 
+        assert self._trusted_host_keys is not None
+
         for key in trusted_host_keys:
             self._trusted_host_keys.add(key)
 
             if key.algorithm not in self._trusted_host_key_algs:
                 self._trusted_host_key_algs.extend(key.sig_algorithms)
 
         self._trusted_ca_keys = set(trusted_ca_keys)
@@ -903,31 +1095,37 @@
             self._x509_trusted_certs = list(self._x509_trusted_certs)
             self._x509_trusted_certs.extend(trusted_x509_certs)
             self._x509_revoked_certs = set(revoked_x509_certs)
 
             self._x509_trusted_subjects = trusted_x509_subjects
             self._x509_revoked_subjects = revoked_x509_subjects
 
-    def _validate_openssh_host_certificate(self, host, addr, port, cert):
+    def _validate_openssh_host_certificate(
+            self, host: str, addr: str, port: int,
+            cert: SSHOpenSSHCertificate) -> SSHKey:
         """Validate an OpenSSH host certificate"""
 
         if self._trusted_ca_keys is not None:
             if cert.signing_key in self._revoked_host_keys:
                 raise ValueError('Host CA key is revoked')
 
+            if not self._owner: # pragma: no cover
+                raise ValueError('Connection closed')
+
             if cert.signing_key not in self._trusted_ca_keys and \
                not self._owner.validate_host_ca_key(host, addr, port,
                                                     cert.signing_key):
                 raise ValueError('Host CA key is not trusted')
 
             cert.validate(CERT_TYPE_HOST, host)
 
         return cert.key
 
-    def _validate_x509_host_certificate_chain(self, host, cert):
+    def _validate_x509_host_certificate_chain(
+            self, host: str, cert: SSHX509CertificateChain) -> SSHKey:
         """Validate an X.509 host certificate"""
 
         if (self._x509_revoked_subjects and
                 any(pattern.matches(cert.subject)
                     for pattern in self._x509_revoked_subjects)):
             raise ValueError('X.509 subject name is revoked')
 
@@ -936,114 +1134,121 @@
                         for pattern in self._x509_trusted_subjects)):
             raise ValueError('X.509 subject name is not trusted')
 
         # Only validate hostname against X.509 certificate host
         # principals when there are no X.509 trusted subject
         # entries matched in known_hosts.
         if self._x509_trusted_subjects:
-            host = None
+            host = ''
+
+        assert self._x509_trusted_certs is not None
 
         cert.validate_chain(self._x509_trusted_certs,
                             self._x509_trusted_cert_paths,
                             self._x509_revoked_certs,
                             self._x509_purposes,
                             host_principal=host)
 
         return cert.key
 
-    def _validate_host_key(self, host, addr, port, key_data):
+    def _validate_host_key(self, host: str, addr: str, port: int,
+                           key_data: bytes) -> SSHKey:
         """Validate and return a trusted host key"""
 
         try:
             cert = decode_ssh_certificate(key_data)
         except KeyImportError:
             pass
         else:
             if cert.is_x509_chain:
-                return self._validate_x509_host_certificate_chain(host, cert)
+                return self._validate_x509_host_certificate_chain(
+                    host, cast(SSHX509CertificateChain, cert))
             else:
-                return self._validate_openssh_host_certificate(host, addr,
-                                                               port, cert)
+                return self._validate_openssh_host_certificate(
+                    host, addr, port, cast(SSHOpenSSHCertificate, cert))
 
         try:
             key = decode_ssh_public_key(key_data)
         except KeyImportError:
             pass
         else:
             if self._trusted_host_keys is not None:
                 if key in self._revoked_host_keys:
                     raise ValueError('Host key is revoked')
 
+                if not self._owner: # pragma: no cover
+                    raise ValueError('Connection closed')
+
                 if key not in self._trusted_host_keys and \
                    not self._owner.validate_host_public_key(host, addr,
                                                             port, key):
                     raise ValueError('Host key is not trusted')
 
             return key
 
         raise ValueError('Unable to decode host key')
 
-    def connection_made(self, transport):
+    def connection_made(self, transport: asyncio.BaseTransport) -> None:
         """Handle a newly opened connection"""
 
-        self._transport = transport
+        self._transport = cast(asyncio.Transport, transport)
 
-        sock = transport.get_extra_info('socket')
+        sock = cast(socket.socket, transport.get_extra_info('socket'))
 
         if sock:
             sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE,
                             self._tcp_keepalive)
             sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
 
-        sockname = transport.get_extra_info('sockname')
+        sockname = cast(SockAddr, transport.get_extra_info('sockname'))
 
         if sockname: # pragma: no branch
             self._local_addr, self._local_port = sockname[:2]
 
-        peername = transport.get_extra_info('peername')
+        peername = cast(SockAddr, transport.get_extra_info('peername'))
 
         if peername: # pragma: no branch
             self._peer_addr, self._peer_port = peername[:2]
 
         self._owner = self._protocol_factory()
-        self._protocol_factory = None
 
         # pylint: disable=broad-except
         try:
             self._connection_made()
-            self._owner.connection_made(self)
+            self._owner.connection_made(self) # type: ignore
             self._send_version()
         except Exception:
             self._loop.call_soon(self.internal_error, sys.exc_info())
 
-    def connection_lost(self, exc=None):
+    def connection_lost(self, exc: Optional[Exception] = None) -> None:
         """Handle the closing of a connection"""
 
         if exc is None and self._transport:
             exc = ConnectionLost('Connection lost')
 
         self._force_close(exc)
 
-    def internal_error(self, exc_info=None, error_logger=None):
+    def internal_error(self, exc_info: Optional[OptExcInfo] = None,
+                       error_logger: Optional[SSHLogger] = None) -> None:
         """Handle a fatal error in connection processing"""
 
         if not exc_info:
             exc_info = sys.exc_info()
 
         if not error_logger:
             error_logger = self.logger
 
         error_logger.debug1('Uncaught exception', exc_info=exc_info)
         self._force_close(exc_info[1])
 
-    def session_started(self):
+    def session_started(self) -> None:
         """Handle session start when opening tunneled SSH connection"""
 
     # pylint: disable=arguments-differ
-    def data_received(self, data, datatype=None):
+    def data_received(self, data: bytes, datatype: DataType = None) -> None:
         """Handle incoming data on the connection"""
 
         # pylint: disable=unused-argument
 
         self._inpbuf += data
 
         self._reset_keepalive_timer()
@@ -1055,30 +1260,30 @@
         except DisconnectError as exc:
             self._send_disconnect(exc.code, exc.reason, exc.lang)
             self._force_close(exc)
         except Exception:
             self.internal_error()
     # pylint: enable=arguments-differ
 
-    def eof_received(self):
+    def eof_received(self) -> None:
         """Handle an incoming end of file on the connection"""
 
         self.connection_lost(None)
 
-    def pause_writing(self):
+    def pause_writing(self) -> None:
         """Handle a request from the transport to pause writing data"""
 
         # Do nothing with this for now
 
-    def resume_writing(self):
+    def resume_writing(self) -> None:
         """Handle a request from the transport to resume writing data"""
 
         # Do nothing with this for now
 
-    def add_channel(self, chan):
+    def add_channel(self, chan: SSHChannel[AnyStr]) -> int:
         """Add a new channel, returning its channel number"""
 
         if not self._transport:
             raise ChannelOpenError(OPEN_CONNECT_FAILED,
                                    'SSH connection closed')
 
         while self._next_recv_chan in self._channels: # pragma: no cover
@@ -1086,30 +1291,32 @@
 
         recv_chan = self._next_recv_chan
         self._next_recv_chan = (self._next_recv_chan + 1) & 0xffffffff
 
         self._channels[recv_chan] = chan
         return recv_chan
 
-    def remove_channel(self, recv_chan):
+    def remove_channel(self, recv_chan: int) -> None:
         """Remove the channel with the specified channel number"""
 
         del self._channels[recv_chan]
 
-    def get_gss_context(self):
+    def get_gss_context(self) -> GSSBase:
         """Return the GSS context associated with this connection"""
 
+        assert self._gss is not None
         return self._gss
 
-    def enable_gss_kex_auth(self):
+    def enable_gss_kex_auth(self) -> None:
         """Enable GSS key exchange authentication"""
 
         self._gss_kex_auth = self._gss_auth
 
-    def _choose_alg(self, alg_type, local_algs, remote_algs):
+    def _choose_alg(self, alg_type: str, local_algs: Sequence[bytes],
+                    remote_algs: Sequence[bytes]) -> bytes:
         """Choose a common algorithm from the client & server lists
 
            This method returns the earliest algorithm on the client's
            list which is supported by the server.
 
         """
 
@@ -1123,29 +1330,29 @@
                 return alg
 
         raise KeyExchangeFailed(
             'No matching %s algorithm found, sent %s and received %s' %
             (alg_type, b','.join(local_algs).decode('ascii'),
              b','.join(remote_algs).decode('ascii')))
 
-    def _get_ext_info_kex_alg(self):
+    def _get_ext_info_kex_alg(self) -> List[bytes]:
         """Return the kex alg to add if any to request extension info"""
 
-        return [b'ext-info-c'] if self.is_client() else [b'ext-info-s']
+        return [b'ext-info-c' if self.is_client() else b'ext-info-s']
 
-    def _send(self, data):
+    def _send(self, data: bytes) -> None:
         """Send data to the SSH connection"""
 
         if self._transport:
             if self._transport.is_closing():
-                self._force_close(BrokenPipeError)
+                self._force_close(BrokenPipeError())
             else:
                 self._transport.write(data)
 
-    def _send_version(self):
+    def _send_version(self) -> None:
         """Start the SSH handshake"""
 
         version = b'SSH-2.0-' + self._version
 
         self.logger.debug1('Sending version %s', version)
 
         if self.is_client():
@@ -1153,15 +1360,15 @@
             self.set_extra_info(client_version=version.decode('ascii'))
         else:
             self._server_version = version
             self.set_extra_info(server_version=version.decode('ascii'))
 
         self._send(version + b'\r\n')
 
-    def _recv_version(self):
+    def _recv_version(self) -> bool:
         """Receive and parse the remote SSH version"""
 
         idx = self._inpbuf.find(b'\n', 0, _MAX_BANNER_LINE_LEN)
         if idx < 0:
             if len(self._inpbuf) >= _MAX_BANNER_LINE_LEN:
                 self._force_close(ProtocolError('Banner line too long'))
 
@@ -1201,15 +1408,15 @@
         else:
             # Otherwise, reject the unknown version
             self._force_close(ProtocolNotSupported('Unsupported SSH version'))
             return False
 
         return True
 
-    def _recv_pkthdr(self):
+    def _recv_pkthdr(self) -> bool:
         """Receive and parse an SSH packet header"""
 
         if len(self._inpbuf) < self._recv_blocksize:
             return False
 
         self._packet = self._inpbuf[:self._recv_blocksize]
         self._inpbuf = self._inpbuf[self._recv_blocksize:]
@@ -1221,49 +1428,51 @@
         else:
             pktlen = self._packet[:4]
 
         self._pktlen = int.from_bytes(pktlen, 'big')
         self._recv_handler = self._recv_packet
         return True
 
-    def _recv_packet(self):
+    def _recv_packet(self) -> bool:
         """Receive the remainder of an SSH packet and process it"""
 
         rem = 4 + self._pktlen + self._recv_macsize - self._recv_blocksize
         if len(self._inpbuf) < rem:
             return False
 
         seq = self._recv_seq
         rest = self._inpbuf[:rem-self._recv_macsize]
         mac = self._inpbuf[rem-self._recv_macsize:rem]
 
         if self._recv_encryption:
-            packet = self._recv_encryption.decrypt_packet(seq, self._packet,
-                                                          rest, 4, mac)
+            packet_data = self._recv_encryption.decrypt_packet(
+                seq, self._packet, rest, 4, mac)
 
-            if not packet:
+            if not packet_data:
                 raise MACError('MAC verification failed')
         else:
-            packet = self._packet[4:] + rest
+            packet_data = self._packet[4:] + rest
 
         self._inpbuf = self._inpbuf[rem:]
         self._packet = b''
 
-        payload = packet[1:-packet[0]]
+        orig_payload = packet_data[1:-packet_data[0]]
 
         if self._decompressor and (self._auth_complete or
                                    not self._decompress_after_auth):
-            payload = self._decompressor.decompress(payload)
+            payload = self._decompressor.decompress(orig_payload)
 
             if payload is None:
                 raise CompressionError('Decompression failed')
+        else:
+            payload = orig_payload
 
         packet = SSHPacket(payload)
         pkttype = packet.get_byte()
-        handler = self
+        handler: SSHPacketHandler = self
         skip_reason = ''
         exc_reason = ''
 
         if self._kex and MSG_KEX_FIRST <= pkttype <= MSG_KEX_LAST:
             if self._ignore_first_kex: # pragma: no cover
                 skip_reason = 'ignored first kex'
                 self._ignore_first_kex = False
@@ -1274,21 +1483,24 @@
             handler = self._auth
         elif pkttype > MSG_USERAUTH_LAST and not self._auth_complete:
             skip_reason = 'invalid request before auth complete'
             exc_reason = 'Invalid request before authentication was complete'
         elif MSG_CHANNEL_FIRST <= pkttype <= MSG_CHANNEL_LAST:
             try:
                 recv_chan = packet.get_uint32()
-                handler = self._channels[recv_chan]
-            except KeyError:
-                skip_reason = 'invalid channel number'
-                exc_reason = 'Invalid channel number %d received' % recv_chan
             except PacketDecodeError:
                 skip_reason = 'incomplete channel request'
                 exc_reason = 'Incomplete channel request received'
+            else:
+                try:
+                    handler = self._channels[recv_chan]
+                except KeyError:
+                    skip_reason = 'invalid channel number'
+                    exc_reason = 'Invalid channel number %d ' \
+                                 'received' % recv_chan
 
         handler.log_received_packet(pkttype, seq, packet, skip_reason)
 
         if not skip_reason:
             try:
                 processed = handler.process_packet(pkttype, seq, packet)
             except PacketDecodeError as exc:
@@ -1303,15 +1515,16 @@
 
         if self._transport:
             self._recv_seq = (seq + 1) & 0xffffffff
             self._recv_handler = self._recv_pkthdr
 
         return True
 
-    def send_packet(self, pkttype, *args, handler=None):
+    def send_packet(self, pkttype: int, *args: bytes,
+                    handler: SSHPacketLogger = None) -> None:
         """Send an SSH packet"""
 
         if (self._auth_complete and self._kex_complete and
                 (self._rekey_bytes_sent >= self._rekey_bytes or
                  (self._rekey_seconds and
                   time.monotonic() >= self._rekey_time))):
             self._send_kexinit()
@@ -1326,23 +1539,24 @@
             return
 
         # If we're encrypting and we have no data outstanding, insert an
         # ignore packet into the stream
         if self._send_encryption and pkttype not in (MSG_IGNORE, MSG_EXT_INFO):
             self.send_packet(MSG_IGNORE, String(b''))
 
-        payload = Byte(pkttype) + b''.join(args)
-        log_data = payload
+        orig_payload = Byte(pkttype) + b''.join(args)
 
         if self._compressor and (self._auth_complete or
                                  not self._compress_after_auth):
-            payload = self._compressor.compress(payload)
+            payload = self._compressor.compress(orig_payload)
 
             if payload is None: # pragma: no cover
                 raise CompressionError('Compression failed')
+        else:
+            payload = orig_payload
 
         padlen = -(self._send_enchdrlen + len(payload)) % self._send_blocksize
         if padlen < 4:
             padlen += self._send_blocksize
 
         packet = Byte(padlen) + payload + os.urandom(padlen)
         pktlen = len(packet)
@@ -1360,47 +1574,52 @@
 
         if self._kex_complete:
             self._rekey_bytes_sent += pktlen
 
         if not handler:
             handler = self
 
-        handler.log_sent_packet(pkttype, seq, log_data)
+        handler.log_sent_packet(pkttype, seq, orig_payload)
 
-    def _send_deferred_packets(self):
+    def _send_deferred_packets(self) -> None:
         """Send packets deferred due to key exchange or auth"""
 
         deferred_packets = self._deferred_packets
         self._deferred_packets = []
 
         for pkttype, args in deferred_packets:
             self.send_packet(pkttype, *args)
 
-    def _send_disconnect(self, code, reason, lang):
+    def _send_disconnect(self, code: int, reason: str, lang: str) -> None:
         """Send a disconnect packet"""
 
         self.logger.info('Sending disconnect: %s (%d)', reason, code)
 
         self.send_packet(MSG_DISCONNECT, UInt32(code),
                          String(reason), String(lang))
 
-    def _send_kexinit(self):
+    def _send_kexinit(self) -> None:
         """Start a key exchange"""
 
         self._kex_complete = False
         self._rekey_bytes_sent = 0
 
         if self._rekey_seconds:
             self._rekey_time = time.monotonic() + self._rekey_seconds
 
-        gss_mechs = self._gss.mechs if self._gss_kex else []
+        if self._gss_kex:
+            assert self._gss is not None
+            gss_mechs = self._gss.mechs
+        else:
+            gss_mechs = []
+
         kex_algs = expand_kex_algs(self._kex_algs, gss_mechs,
-                                   bool(self._server_host_key_algs))
+                                   bool(self._server_host_key_algs)) + \
+                   self._get_ext_info_kex_alg()
 
-        kex_algs += self._get_ext_info_kex_alg()
         host_key_algs = self._server_host_key_algs or [b'null']
 
         self.logger.debug1('Requesting key exchange')
         self.logger.debug2('  Key exchange algs: %s', kex_algs)
         self.logger.debug2('  Host key algs: %s', host_key_algs)
         self.logger.debug2('  Encryption algs: %s', self._enc_algs)
         self.logger.debug2('  MAC algs: %s', self._mac_algs)
@@ -1421,29 +1640,29 @@
         if self.is_server():
             self._server_kexinit = packet
         else:
             self._client_kexinit = packet
 
         self.send_packet(MSG_KEXINIT, packet[1:])
 
-    def _send_ext_info(self):
+    def _send_ext_info(self) -> None:
         """Send extension information"""
 
         packet = UInt32(len(self._extensions_to_send))
 
         self.logger.debug2('Sending extension info')
 
         for name, value in self._extensions_to_send.items():
             packet += String(name) + String(value)
 
             self.logger.debug2('  %s: %s', name, value)
 
         self.send_packet(MSG_EXT_INFO, packet)
 
-    def send_newkeys(self, k, h):
+    def send_newkeys(self, k: int, h: bytes) -> None:
         """Finish a key exchange and send a new keys message"""
 
         if not self._session_id:
             first_kex = True
             self._session_id = h
         else:
             first_kex = False
@@ -1470,14 +1689,16 @@
         self.logger.debug2('    MAC alg: %s', self._mac_alg_cs)
         self.logger.debug2('    Compression alg: %s', self._cmp_alg_cs)
         self.logger.debug2('  Server to client:')
         self.logger.debug2('    Encryption alg: %s', self._enc_alg_sc)
         self.logger.debug2('    MAC alg: %s', self._mac_alg_sc)
         self.logger.debug2('    Compression alg: %s', self._cmp_alg_sc)
 
+        assert self._kex is not None
+
         iv_cs = self._kex.compute_key(k, h, b'A', self._session_id,
                                       enc_ivsize_cs)
         iv_sc = self._kex.compute_key(k, h, b'B', self._session_id,
                                       enc_ivsize_sc)
         enc_key_cs = self._kex.compute_key(k, h, b'C', self._session_id,
                                            enc_keysize_cs)
         enc_key_sc = self._kex.compute_key(k, h, b'D', self._session_id,
@@ -1491,15 +1712,15 @@
         next_enc_cs = get_encryption(self._enc_alg_cs, enc_key_cs, iv_cs,
                                      self._mac_alg_cs, mac_key_cs, etm_cs)
         next_enc_sc = get_encryption(self._enc_alg_sc, enc_key_sc, iv_sc,
                                      self._mac_alg_sc, mac_key_sc, etm_sc)
 
         self.send_packet(MSG_NEWKEYS)
 
-        self._extensions_to_send[b'global-requests-ok'] = ''
+        self._extensions_to_send[b'global-requests-ok'] = b''
 
         if self.is_client():
             self._send_encryption = next_enc_cs
             self._send_enchdrlen = 1 if etm_cs else 5
             self._send_blocksize = max(8, enc_blocksize_cs)
             self._compressor = get_compressor(self._cmp_alg_cs)
             self._compress_after_auth = cmp_after_auth_cs
@@ -1515,15 +1736,16 @@
                 send_mac=self._mac_alg_cs.decode('ascii'),
                 send_compression=self._cmp_alg_cs.decode('ascii'),
                 recv_cipher=self._enc_alg_sc.decode('ascii'),
                 recv_mac=self._mac_alg_sc.decode('ascii'),
                 recv_compression=self._cmp_alg_sc.decode('ascii'))
 
             if first_kex:
-                if self._wait == 'kex' and not self._waiter.cancelled():
+                if self._wait == 'kex' and self._waiter and \
+                        not self._waiter.cancelled():
                     self._waiter.set_result(None)
                     self._wait = None
                 else:
                     self.send_service_request(_USERAUTH_SERVICE)
         else:
             self._send_encryption = next_enc_sc
             self._send_enchdrlen = 1 if etm_sc else 5
@@ -1554,221 +1776,241 @@
         if self._can_send_ext_info:
             self._send_ext_info()
             self._can_send_ext_info = False
 
         self._kex_complete = True
         self._send_deferred_packets()
 
-    def send_service_request(self, service):
+    def send_service_request(self, service: bytes) -> None:
         """Send a service request"""
 
         self.logger.debug2('Requesting service %s', service)
 
         self._next_service = service
         self.send_packet(MSG_SERVICE_REQUEST, String(service))
 
-    def _get_userauth_request_packet(self, method, args):
+    def _get_userauth_request_packet(self, method: bytes,
+                                     args: Tuple[bytes, ...]) -> bytes:
         """Get packet data for a user authentication request"""
 
         return b''.join((Byte(MSG_USERAUTH_REQUEST), String(self._username),
                          String(_CONNECTION_SERVICE), String(method)) + args)
 
-    def get_userauth_request_data(self, method, *args):
+    def get_userauth_request_data(self, method: bytes, *args: bytes) -> bytes:
         """Get signature data for a user authentication request"""
 
         return (String(self._session_id) +
                 self._get_userauth_request_packet(method, args))
 
-    def send_userauth_packet(self, pkttype, *args, handler=None,
-                             trivial=True):
+    def send_userauth_packet(self, pkttype: int, *args: bytes,
+                             handler: SSHPacketLogger = None,
+                             trivial: bool = True) -> None:
         """Send a user authentication packet"""
 
         self._auth_was_trivial &= trivial
         self.send_packet(pkttype, *args, handler=handler)
 
-    async def send_userauth_request(self, method, *args, key=None,
-                                    trivial=True):
+    async def send_userauth_request(self, method: bytes, *args: bytes,
+                                    key: Optional[SigningKey] = None,
+                                    trivial: bool = True) -> None:
         """Send a user authentication request"""
 
         packet = self._get_userauth_request_packet(method, args)
 
         if key:
             data = String(self._session_id) + packet
 
-            if getattr(key, 'use_executor', False):
+            sign_async: Optional[Callable[[bytes], Awaitable[bytes]]] = \
+                getattr(key, 'sign_async', None)
+
+            if sign_async:
+                # pylint: disable=not-callable
+                sig = await sign_async(data)
+            elif getattr(key, 'use_executor', False):
                 sig = await self._loop.run_in_executor(None, key.sign, data)
             else:
                 sig = key.sign(data)
 
-                if inspect.isawaitable(sig):
-                    sig = await sig
-
             packet += String(sig)
 
         self.send_userauth_packet(MSG_USERAUTH_REQUEST, packet[1:],
                                   trivial=trivial)
 
-    def send_userauth_failure(self, partial_success):
+    def send_userauth_failure(self, partial_success: bool) -> None:
         """Send a user authentication failure response"""
 
-        methods = get_server_auth_methods(self)
+        methods = get_server_auth_methods(cast(SSHServerConnection, self))
 
         self.logger.debug2('Remaining auth methods: %s', methods or 'None')
 
         self._auth = None
         self.send_packet(MSG_USERAUTH_FAILURE, NameList(methods),
                          Boolean(partial_success))
 
-    def send_userauth_success(self):
+    def send_userauth_success(self) -> None:
         """Send a user authentication success response"""
 
         self.logger.info('Auth for user %s succeeded', self._username)
 
         self.send_packet(MSG_USERAUTH_SUCCESS)
         self._auth = None
         self._auth_in_progress = False
         self._auth_complete = True
         self._next_service = None
         self.set_extra_info(username=self._username)
         self._send_deferred_packets()
 
         self._cancel_login_timer()
         self._set_keepalive_timer()
-        self._owner.auth_completed()
+
+        if self._owner: # pragma: no branch
+            self._owner.auth_completed()
 
         if self._acceptor:
             result = self._acceptor(self)
 
             if inspect.isawaitable(result):
+                assert result is not None
                 self.create_task(result)
 
             self._acceptor = None
             self._error_handler = None
 
-        if self._wait == 'auth' and not self._waiter.cancelled():
+        if self._wait == 'auth' and self._waiter and \
+                not self._waiter.cancelled():
             self._waiter.set_result(None)
             self._wait = None
 
-    def send_channel_open_confirmation(self, send_chan, recv_chan,
-                                       recv_window, recv_pktsize,
-                                       *result_args):
+    def send_channel_open_confirmation(self, send_chan: int, recv_chan: int,
+                                       recv_window: int, recv_pktsize: int,
+                                       *result_args: bytes) -> None:
         """Send a channel open confirmation"""
 
         self.send_packet(MSG_CHANNEL_OPEN_CONFIRMATION, UInt32(send_chan),
                          UInt32(recv_chan), UInt32(recv_window),
                          UInt32(recv_pktsize), *result_args)
 
-    def send_channel_open_failure(self, send_chan, code, reason, lang):
+    def send_channel_open_failure(self, send_chan: int, code: int,
+                                  reason: str, lang: str) -> None:
         """Send a channel open failure"""
 
         self.send_packet(MSG_CHANNEL_OPEN_FAILURE, UInt32(send_chan),
                          UInt32(code), String(reason), String(lang))
 
-    async def _make_global_request(self, request, *args):
+    async def _make_global_request(self, request: bytes,
+                                   *args: bytes) -> Tuple[int, SSHPacket]:
         """Send a global request and wait for the response"""
 
         if not self._transport:
             return MSG_REQUEST_FAILURE, SSHPacket(b'')
 
-        waiter = self._loop.create_future()
+        waiter: 'asyncio.Future[_GlobalRequestResult]' = \
+            self._loop.create_future()
+
         self._global_request_waiters.append(waiter)
 
         self.send_packet(MSG_GLOBAL_REQUEST, String(request),
                          Boolean(True), *args)
 
         return await waiter
 
-    def _report_global_response(self, result):
+    def _report_global_response(self, result: Union[bool, bytes]) -> None:
         """Report back the response to a previously issued global request"""
 
         _, _, want_reply = self._global_request_queue.pop(0)
 
         if want_reply: # pragma: no branch
             if result:
-                response = b'' if result is True else result
+                response = b'' if result is True else cast(bytes, result)
                 self.send_packet(MSG_REQUEST_SUCCESS, response)
             else:
                 self.send_packet(MSG_REQUEST_FAILURE)
 
         if self._global_request_queue:
             self._service_next_global_request()
 
-    def _service_next_global_request(self):
+    def _service_next_global_request(self) -> None:
         """Process next item on global request queue"""
 
         handler, packet, _ = self._global_request_queue[0]
         if callable(handler):
             handler(packet)
         else:
             self._report_global_response(False)
 
-    def _connection_made(self):
+    def _connection_made(self) -> None:
         """Handle the opening of a new connection"""
 
         raise NotImplementedError
 
-    def _process_disconnect(self, _pkttype, _pktid, packet):
+    def _process_disconnect(self, _pkttype: int, _pktid: int,
+                            packet: SSHPacket) -> None:
         """Process a disconnect message"""
 
         code = packet.get_uint32()
-        reason = packet.get_string()
-        lang = packet.get_string()
+        reason_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            reason = reason.decode('utf-8')
-            lang = lang.decode('ascii')
+            reason = reason_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid disconnect message') from None
 
         self.logger.debug1('Received disconnect: %s (%d)', reason, code)
 
         if code != DISC_BY_APPLICATION or self._wait:
-            exc = construct_disc_error(code, reason, lang)
+            exc: Optional[Exception] = construct_disc_error(code, reason, lang)
         else:
             exc = None
 
         self._force_close(exc)
 
-    def _process_ignore(self, _pkttype, _pktid, packet):
+    def _process_ignore(self, _pkttype: int, _pktid: int,
+                        packet: SSHPacket) -> None:
         """Process an ignore message"""
 
         # pylint: disable=no-self-use
 
         _ = packet.get_string()     # data
         packet.check_end()
 
-    def _process_unimplemented(self, _pkttype, _pktid, packet):
+    def _process_unimplemented(self, _pkttype: int, _pktid: int,
+                               packet: SSHPacket) -> None:
         """Process an unimplemented message response"""
 
         # pylint: disable=no-self-use
 
         _ = packet.get_uint32()     # seq
         packet.check_end()
 
-    def _process_debug(self, _pkttype, _pktid, packet):
+    def _process_debug(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a debug message"""
 
         always_display = packet.get_boolean()
-        msg = packet.get_string()
-        lang = packet.get_string()
+        msg_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            msg = msg.decode('utf-8')
-            lang = lang.decode('ascii')
+            msg = msg_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid debug message') from None
 
         self.logger.debug1('Received debug message: %s%s', msg,
                            ' (always display)' if always_display else '')
 
-        self._owner.debug_msg_received(msg, lang, always_display)
+        if self._owner: # pragma: no branch
+            self._owner.debug_msg_received(msg, lang, always_display)
 
-    def _process_service_request(self, _pkttype, _pktid, packet):
+    def _process_service_request(self, _pkttype: int, _pktid: int,
+                                 packet: SSHPacket) -> None:
         """Process a service request"""
 
         service = packet.get_string()
         packet.check_end()
 
         if service == self._next_service:
             self.logger.debug2('Accepting request for service %s', service)
@@ -1779,15 +2021,16 @@
                     not self._auth_in_progress and
                     service == _USERAUTH_SERVICE):
                 self._auth_in_progress = True
                 self._send_deferred_packets()
         else:
             raise ServiceNotAvailable('Unexpected service request received')
 
-    def _process_service_accept(self, _pkttype, _pktid, packet):
+    def _process_service_accept(self, _pkttype: int, _pktid: int,
+                                packet: SSHPacket) -> None:
         """Process a service accept response"""
 
         service = packet.get_string()
         packet.check_end()
 
         if service == self._next_service:
             self.logger.debug2('Request for service %s accepted', service)
@@ -1798,22 +2041,23 @@
                     service == _USERAUTH_SERVICE):
                 self.logger.info('Beginning auth for user %s', self._username)
 
                 self._auth_in_progress = True
 
                 # This method is only in SSHClientConnection
                 # pylint: disable=no-member
-                self.try_next_auth()
+                cast('SSHClientConnection', self).try_next_auth()
         else:
             raise ServiceNotAvailable('Unexpected service accept received')
 
-    def _process_ext_info(self, _pkttype, _pktid, packet):
+    def _process_ext_info(self, _pkttype: int, _pktid: int,
+                          packet: SSHPacket) -> None:
         """Process extension information"""
 
-        extensions = {}
+        extensions: Dict[bytes, bytes] = {}
 
         self.logger.debug2('Received extension info')
 
         num_extensions = packet.get_uint32()
         for _ in range(num_extensions):
             name = packet.get_string()
             value = packet.get_string()
@@ -1821,17 +2065,18 @@
 
             self.logger.debug2('  %s: %s', name, value)
 
         packet.check_end()
 
         if self.is_client():
             self._server_sig_algs = \
-                extensions.get(b'server-sig-algs').split(b',')
+                set(extensions.get(b'server-sig-algs', b'').split(b','))
 
-    def _process_kexinit(self, _pkttype, _pktid, packet):
+    def _process_kexinit(self, _pkttype: int, _pktid: int,
+                         packet: SSHPacket) -> None:
         """Process a key exchange request"""
 
         if self._kex:
             raise ProtocolError('Key exchange already in progress')
 
         _ = packet.get_bytes(16)                        # cookie
         peer_kex_algs = packet.get_namelist()
@@ -1863,15 +2108,20 @@
             self._kexinit_sent = False
         else:
             self._send_kexinit()
 
         if self._gss:
             self._gss.reset()
 
-        gss_mechs = self._gss.mechs if self._gss_kex else []
+        if self._gss_kex:
+            assert self._gss is not None
+            gss_mechs = self._gss.mechs
+        else:
+            gss_mechs = []
+
         kex_algs = expand_kex_algs(self._kex_algs, gss_mechs,
                                    bool(self._server_host_key_algs))
 
         self.logger.debug1('Received key exchange request')
         self.logger.debug2('  Key exchange algs: %s', peer_kex_algs)
         self.logger.debug2('  Host key algs: %s', peer_host_key_algs)
         self.logger.debug2('  Client to server:')
@@ -1887,16 +2137,16 @@
         self._kex = get_kex(self, kex_alg)
         self._ignore_first_kex = (first_kex_follows and
                                   self._kex.algorithm != peer_kex_algs[0])
 
         if self.is_server():
             # This method is only in SSHServerConnection
             # pylint: disable=no-member
-            if (not self._choose_server_host_key(peer_host_key_algs) and
-                    not kex_alg.startswith(b'gss-')):
+            if (not cast(SSHServerConnection, self).choose_server_host_key(
+                    peer_host_key_algs) and not kex_alg.startswith(b'gss-')):
                 raise KeyExchangeFailed('Unable to find compatible '
                                         'server host key')
 
         self._enc_alg_cs = self._choose_alg('encryption', self._enc_algs,
                                             enc_algs_cs)
         self._enc_alg_sc = self._choose_alg('encryption', self._enc_algs,
                                             enc_algs_sc)
@@ -1910,15 +2160,16 @@
                                             cmp_algs_sc)
 
         self.logger.debug1('Beginning key exchange')
         self.logger.debug2('  Key exchange alg: %s', self._kex.algorithm)
 
         self._kex.start()
 
-    def _process_newkeys(self, _pkttype, _pktid, packet):
+    def _process_newkeys(self, _pkttype: int, _pktid: int,
+                         packet: SSHPacket) -> None:
         """Process a new keys message, finishing a key exchange"""
 
         packet.check_end()
 
         if self._next_recv_encryption:
             self._recv_encryption = self._next_recv_encryption
             self._recv_blocksize = self._next_recv_blocksize
@@ -1928,29 +2179,30 @@
 
             self._next_recv_encryption = None
         else:
             raise ProtocolError('New keys not negotiated')
 
         self.logger.debug1('Completed key exchange')
 
-    def _process_userauth_request(self, _pkttype, _pktid, packet):
+    def _process_userauth_request(self, _pkttype: int, _pktid: int,
+                                  packet: SSHPacket) -> None:
         """Process a user authentication request"""
 
-        username = packet.get_string()
+        username_bytes = packet.get_string()
         service = packet.get_string()
         method = packet.get_string()
 
-        if len(username) >= _MAX_USERNAME_LEN:
+        if len(username_bytes) >= _MAX_USERNAME_LEN:
             raise IllegalUserName('Username too long')
 
         if service != _CONNECTION_SERVICE:
             raise ServiceNotAvailable('Unexpected service in auth request')
 
         try:
-            username = saslprep(username.decode('utf-8'))
+            username = saslprep(username_bytes.decode('utf-8'))
         except (UnicodeDecodeError, SASLPrepError) as exc:
             raise IllegalUserName(str(exc)) from None
 
         if self.is_client():
             raise ProtocolError('Unexpected userauth request')
         elif self._auth_complete:
             # Silently ignore requests if we're already authenticated
@@ -1962,43 +2214,46 @@
                 self._username = username
                 begin_auth = True
             else:
                 begin_auth = False
 
             self.create_task(self._finish_userauth(begin_auth, method, packet))
 
-    async def _finish_userauth(self, begin_auth, method, packet):
+    async def _finish_userauth(self, begin_auth: bool, method: bytes,
+                               packet: SSHPacket) -> None:
         """Finish processing a user authentication request"""
 
         if not self._owner: # pragma: no cover
             return
 
         if begin_auth:
             # This method is only in SSHServerConnection
             # pylint: disable=no-member
-            await self._reload_config()
+            await cast(SSHServerConnection, self).reload_config()
 
-            result = self._owner.begin_auth(self._username)
+            result = cast(SSHServer, self._owner).begin_auth(self._username)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[bool], result)
 
             if not result:
                 self.send_userauth_success()
                 return
 
         if not self._owner: # pragma: no cover
             return
 
         if self._auth:
             self._auth.cancel()
 
-        self._auth = lookup_server_auth(self, self._username, method, packet)
+        self._auth = lookup_server_auth(cast(SSHServerConnection, self),
+                                             self._username, method, packet)
 
-    def _process_userauth_failure(self, _pkttype, pktid, packet):
+    def _process_userauth_failure(self, _pkttype: int, pktid: int,
+                                  packet: SSHPacket) -> None:
         """Process a user authentication failure response"""
 
         auth_methods = packet.get_namelist()
         partial_success = packet.get_boolean()
         packet.check_end()
 
         self.logger.debug2('Remaining auth methods: %s',
@@ -2007,154 +2262,169 @@
         if self._preferred_auth:
             self.logger.debug2('Preferred auth methods: %s',
                                self._preferred_auth or 'None')
 
             auth_methods = [method for method in self._preferred_auth
                             if method in auth_methods]
 
-        self._auth_methods = auth_methods
+        self._auth_methods = list(auth_methods)
 
         if self.is_client() and self._auth:
+            auth = cast(ClientAuth, self._auth)
+
             if partial_success: # pragma: no cover
                 # Partial success not implemented yet
-                self._auth.auth_succeeded()
+                auth.auth_succeeded()
             else:
-                self._auth.auth_failed()
+                auth.auth_failed()
 
             # This method is only in SSHClientConnection
             # pylint: disable=no-member
-            self.try_next_auth()
+            cast(SSHClientConnection, self).try_next_auth()
         else:
             self.logger.debug2('Unexpected userauth failure response')
             self.send_packet(MSG_UNIMPLEMENTED, UInt32(pktid))
 
-    def _process_userauth_success(self, _pkttype, pktid, packet):
+    def _process_userauth_success(self, _pkttype: int, pktid: int,
+                                  packet: SSHPacket) -> None:
         """Process a user authentication success response"""
 
         packet.check_end()
 
         if self.is_client() and self._auth:
+            auth = cast(ClientAuth, self._auth)
+
             if self._auth_was_trivial and self._disable_trivial_auth:
                 raise PermissionDenied('Trivial auth disabled')
 
             self.logger.info('Auth for user %s succeeded', self._username)
 
-            self._auth.auth_succeeded()
-            self._auth.cancel()
+            auth.auth_succeeded()
+            auth.cancel()
             self._auth = None
             self._auth_in_progress = False
             self._auth_complete = True
 
             if self._agent:
                 self._agent.close()
 
             self.set_extra_info(username=self._username)
             self._cancel_login_timer()
             self._send_deferred_packets()
             self._set_keepalive_timer()
-            self._owner.auth_completed()
+
+            if self._owner: # pragma: no branch
+                self._owner.auth_completed()
 
             if self._acceptor:
                 result = self._acceptor(self)
 
                 if inspect.isawaitable(result):
+                    assert result is not None
                     self.create_task(result)
 
                 self._acceptor = None
                 self._error_handler = None
 
-            if self._wait == 'auth' and not self._waiter.cancelled():
+            if self._wait == 'auth' and self._waiter and \
+                    not self._waiter.cancelled():
                 self._waiter.set_result(None)
                 self._wait = None
         else:
             self.logger.debug2('Unexpected userauth success response')
             self.send_packet(MSG_UNIMPLEMENTED, UInt32(pktid))
 
-    def _process_userauth_banner(self, _pkttype, _pktid, packet):
+    def _process_userauth_banner(self, _pkttype: int, _pktid: int,
+                                 packet: SSHPacket) -> None:
         """Process a user authentication banner message"""
 
-        msg = packet.get_string()
-        lang = packet.get_string()
+        msg_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            msg = msg.decode('utf-8')
-            lang = lang.decode('ascii')
+            msg = msg_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid userauth banner') from None
 
         self.logger.debug1('Received authentication banner')
 
         if self.is_client():
-            self._owner.auth_banner_received(msg, lang)
+            cast(SSHClient, self._owner).auth_banner_received(msg, lang)
         else:
             raise ProtocolError('Unexpected userauth banner')
 
-    def _process_global_request(self, _pkttype, _pktid, packet):
+    def _process_global_request(self, _pkttype: int, _pktid: int,
+                                packet: SSHPacket) -> None:
         """Process a global request"""
 
-        request = packet.get_string()
+        request_bytes = packet.get_string()
         want_reply = packet.get_boolean()
 
         try:
-            request = request.decode('ascii')
+            request = request_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid global request') from None
 
         name = '_process_' + map_handler_name(request) + '_global_request'
-        handler = getattr(self, name, None)
+        handler = cast(Optional[_PacketHandler], getattr(self, name, None))
 
         if not handler:
             self.logger.debug1('Received unknown global request: %s', request)
 
         self._global_request_queue.append((handler, packet, want_reply))
         if len(self._global_request_queue) == 1:
             self._service_next_global_request()
 
-    def _process_global_response(self, pkttype, _pktid, packet):
+    def _process_global_response(self, pkttype: int, _pktid: int,
+                                 packet: SSHPacket) -> None:
         """Process a global response"""
 
         if self._global_request_waiters:
             waiter = self._global_request_waiters.pop(0)
             if not waiter.cancelled(): # pragma: no branch
                 waiter.set_result((pkttype, packet))
         else:
             raise ProtocolError('Unexpected global response')
 
-    def _process_channel_open(self, _pkttype, _pktid, packet):
+    def _process_channel_open(self, _pkttype: int, _pktid: int,
+                              packet: SSHPacket) -> None:
         """Process a channel open request"""
 
-        chantype = packet.get_string()
+        chantype_bytes = packet.get_string()
         send_chan = packet.get_uint32()
         send_window = packet.get_uint32()
         send_pktsize = packet.get_uint32()
 
         try:
-            chantype = chantype.decode('ascii')
+            chantype = chantype_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid channel open request') from None
 
         try:
             name = '_process_' + map_handler_name(chantype) + '_open'
-            handler = getattr(self, name, None)
+            handler = cast(Optional[_OpenHandler], getattr(self, name, None))
+
             if callable(handler):
                 chan, session = handler(packet)
                 chan.process_open(send_chan, send_window,
                                   send_pktsize, session)
             else:
                 raise ChannelOpenError(OPEN_UNKNOWN_CHANNEL_TYPE,
                                        'Unknown channel type')
         except ChannelOpenError as exc:
             self.logger.debug1('Open failed for channel type %s: %s',
                                chantype, exc.reason)
 
             self.send_channel_open_failure(send_chan, exc.code,
                                            exc.reason, exc.lang)
 
-    def _process_channel_open_confirmation(self, _pkttype, _pktid, packet):
+    def _process_channel_open_confirmation(self, _pkttype: int, _pktid: int,
+                                           packet: SSHPacket) -> None:
         """Process a channel open confirmation response"""
 
         recv_chan = packet.get_uint32()
         send_chan = packet.get_uint32()
         send_window = packet.get_uint32()
         send_pktsize = packet.get_uint32()
 
@@ -2164,39 +2434,41 @@
                                            send_pktsize, packet)
         else:
             self.logger.debug1('Received open confirmation for unknown '
                                'channel %d', recv_chan)
 
             raise ProtocolError('Invalid channel number')
 
-    def _process_channel_open_failure(self, _pkttype, _pktid, packet):
+    def _process_channel_open_failure(self, _pkttype: int, _pktid: int,
+                                      packet: SSHPacket) -> None:
         """Process a channel open failure response"""
 
         recv_chan = packet.get_uint32()
         code = packet.get_uint32()
-        reason = packet.get_string()
-        lang = packet.get_string()
+        reason_bytes = packet.get_string()
+        lang_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            reason = reason.decode('utf-8')
-            lang = lang.decode('ascii')
+            reason = reason_bytes.decode('utf-8')
+            lang = lang_bytes.decode('ascii')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid channel open failure') from None
 
         chan = self._channels.get(recv_chan)
         if chan:
             chan.process_open_failure(code, reason, lang)
         else:
             self.logger.debug1('Received open failure for unknown '
                                'channel %d', recv_chan)
 
             raise ProtocolError('Invalid channel number')
 
-    def _process_keepalive_at_openssh_dot_com_global_request(self, packet):
+    def _process_keepalive_at_openssh_dot_com_global_request(
+            self, packet: SSHPacket) -> None:
         """Process an incoming OpenSSH keepalive request"""
 
         packet.check_end()
 
         self.logger.debug2('Received OpenSSH keepalive request')
         self._report_global_response(True)
 
@@ -2222,15 +2494,15 @@
         MSG_REQUEST_FAILURE:            _process_global_response,
 
         MSG_CHANNEL_OPEN:               _process_channel_open,
         MSG_CHANNEL_OPEN_CONFIRMATION:  _process_channel_open_confirmation,
         MSG_CHANNEL_OPEN_FAILURE:       _process_channel_open_failure
     }
 
-    def abort(self):
+    def abort(self) -> None:
         """Forcibly close the SSH connection
 
            This method closes the SSH connection immediately, without
            waiting for pending operations to complete and wihtout sending
            an explicit SSH disconnect message. Buffered data waiting to be
            sent will be lost and no more data will be received. When the
            the connection is closed, :meth:`connection_lost()
@@ -2239,46 +2511,42 @@
 
         """
 
         self.logger.info('Aborting connection')
 
         self._force_close(None)
 
-    def close(self):
+    def close(self) -> None:
         """Cleanly close the SSH connection
 
            This method calls :meth:`disconnect` with the reason set to
            indicate that the connection was closed explicitly by the
            application.
 
         """
 
         self.logger.info('Closing connection')
 
         self.disconnect(DISC_BY_APPLICATION, 'Disconnected by application')
 
-    async def wait_established(self):
-        """Wait for connection to be established"""
-
-        await self._waiter
-
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this connection to close
 
            This method is a coroutine which can be called to block until
            this connection has finished closing.
 
         """
 
         if self._agent:
             await self._agent.wait_closed()
 
         await self._close_event.wait()
 
-    def disconnect(self, code, reason, lang=DEFAULT_LANG):
+    def disconnect(self, code: int, reason: str,
+                   lang: str = DEFAULT_LANG) -> None:
         """Disconnect the SSH connection
 
            This method sends a disconnect message and closes the SSH
            connection after buffered data waiting to be written has been
            sent. No more data will be received. When the connection is
            fully closed, :meth:`connection_lost() <SSHClient.connection_lost>`
            on the associated :class:`SSHClient` or :class:`SSHServer` object
@@ -2299,15 +2567,15 @@
 
         for chan in list(self._channels.values()):
             chan.close()
 
         self._send_disconnect(code, reason, lang)
         self._force_close(None)
 
-    def get_extra_info(self, name, default=None):
+    def get_extra_info(self, name: str, default: Any = None) -> Any:
         """Get additional information about the connection
 
            This method returns extra information about the connection once
            it is established. Supported values include everything supported
            by a socket transport plus:
 
              | username
@@ -2328,28 +2596,29 @@
 
         """
 
         return self._extra.get(name,
                                self._transport.get_extra_info(name, default)
                                if self._transport else default)
 
-    def set_extra_info(self, **kwargs):
+    def set_extra_info(self, **kwargs: Any) -> None:
         """Store additional information associated with the connection
 
            This method allows extra information to be associated with the
            connection. The information to store should be passed in as
            keyword parameters and can later be returned by calling
            :meth:`get_extra_info` with one of the keywords as the name
            to retrieve.
 
         """
 
         self._extra.update(**kwargs)
 
-    def set_keepalive(self, interval=None, count_max=None):
+    def set_keepalive(self, interval: Union[None, float, str] = None,
+                      count_max: Optional[int] = None) -> None:
         """Set keep-alive timer on this connection
 
            This method sets the parameters of the keepalive timer on the
            connection. If *interval* is set to a non-zero value,
            keep-alive requests will be sent whenever the connection is
            idle, and if a response is not received after *count_max*
            attempts, the connection is closed.
@@ -2381,15 +2650,16 @@
             if count_max < 0:
                 raise ValueError('Keepalive count max cannot be negative')
 
             self._keepalive_count_max = count_max
 
         self._reset_keepalive_timer()
 
-    def send_debug(self, msg, lang=DEFAULT_LANG, always_display=False):
+    def send_debug(self, msg: str, lang: str = DEFAULT_LANG,
+                   always_display: bool = False) -> None:
         """Send a debug message on this connection
 
            This method can be called to send a debug message to the
            other end of the connection.
 
            :param msg:
                The debug message to send
@@ -2405,17 +2675,19 @@
 
         self.logger.debug1('Sending debug message: %s%s', msg,
                            ' (always display)' if always_display else '')
 
         self.send_packet(MSG_DEBUG, Boolean(always_display),
                          String(msg), String(lang))
 
-    def create_tcp_channel(self, encoding=None, errors='strict',
-                           window=_DEFAULT_WINDOW,
-                           max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def create_tcp_channel(self, encoding: Optional[str] = None,
+                           errors: str = 'strict',
+                           window: int = _DEFAULT_WINDOW,
+                           max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+            SSHTCPChannel:
         """Create an SSH TCP channel for a new direct TCP connection
 
            This method can be called by :meth:`connection_requested()
            <SSHServer.connection_requested>` to create an
            :class:`SSHTCPChannel` with the desired encoding, Unicode
            error handling strategy, window, and max packet size for
            a newly created SSH direct connection.
@@ -2438,17 +2710,19 @@
            :returns: :class:`SSHTCPChannel`
 
         """
 
         return SSHTCPChannel(self, self._loop, encoding,
                              errors, window, max_pktsize)
 
-    def create_unix_channel(self, encoding=None, errors='strict',
-                            window=_DEFAULT_WINDOW,
-                            max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def create_unix_channel(self, encoding: Optional[str] = None,
+                            errors: str = 'strict',
+                            window: int = _DEFAULT_WINDOW,
+                            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+            SSHUNIXChannel:
         """Create an SSH UNIX channel for a new direct UNIX domain connection
 
            This method can be called by :meth:`unix_connection_requested()
            <SSHServer.unix_connection_requested>` to create an
            :class:`SSHUNIXChannel` with the desired encoding, Unicode
            error handling strategy, window, and max packet size for
            a newly created SSH direct UNIX domain socket connection.
@@ -2471,104 +2745,112 @@
            :returns: :class:`SSHUNIXChannel`
 
         """
 
         return SSHUNIXChannel(self, self._loop, encoding,
                               errors, window, max_pktsize)
 
-    def create_x11_channel(self, window=_DEFAULT_WINDOW,
-                           max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def create_x11_channel(
+            self, window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> SSHX11Channel:
         """Create an SSH X11 channel to use in X11 forwarding"""
 
         return SSHX11Channel(self, self._loop, None, 'strict',
                              window, max_pktsize)
 
-    def create_agent_channel(self, window=_DEFAULT_WINDOW,
-                             max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def create_agent_channel(
+            self, window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> SSHAgentChannel:
         """Create an SSH agent channel to use in agent forwarding"""
 
         return SSHAgentChannel(self, self._loop, None, 'strict',
                                window, max_pktsize)
 
-    async def create_connection(self, session_factory, remote_host, remote_port,
-                                orig_host='', orig_port=0, *, encoding=None,
-                                errors='strict', window=_DEFAULT_WINDOW,
-                                max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_connection(
+            self, session_factory: SSHTCPSessionFactory[AnyStr],
+            remote_host: str, remote_port: int, orig_host: str = '',
+            orig_port: int = 0, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHTCPChannel[AnyStr], SSHTCPSession[AnyStr]]:
         """Create an SSH direct or forwarded TCP connection"""
 
         raise NotImplementedError
 
-    async def create_unix_connection(self, session_factory, remote_path, *,
-                                     encoding=None, errors='strict',
-                                     window=_DEFAULT_WINDOW,
-                                     max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_unix_connection(
+            self, session_factory: SSHUNIXSessionFactory[AnyStr],
+            remote_path: str, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHUNIXChannel[AnyStr], SSHUNIXSession[AnyStr]]:
+
         """Create an SSH direct or forwarded UNIX domain socket connection"""
 
         raise NotImplementedError
 
-    async def forward_connection(self, dest_host, dest_port):
+    async def forward_connection(
+            self, dest_host: str, dest_port: int) -> SSHForwarder:
         """Forward a tunneled TCP connection
 
            This method is a coroutine which can be returned by a
            `session_factory` to forward connections tunneled over
            SSH to the specified destination host and port.
 
            :param dest_host:
                The hostname or address to forward the connections to
            :param dest_port:
                The port number to forward the connections to
-           :type dest_host: `str`
+           :type dest_host: `str` or `None`
            :type dest_port: `int`
 
-           :returns: :class:`SSHTCPSession`
+           :returns: :class:`asyncio.BaseProtocol`
 
         """
 
         try:
-            if dest_host == '':
-                dest_host = None
-
             _, peer = await self._loop.create_connection(SSHForwarder,
                                                          dest_host, dest_port)
 
             self.logger.info('  Forwarding TCP connection to %s',
                              (dest_host, dest_port))
         except OSError as exc:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, str(exc)) from None
 
-        return SSHForwarder(peer)
+        return SSHForwarder(cast(SSHForwarder, peer))
 
-    async def forward_unix_connection(self, dest_path):
+    async def forward_unix_connection(self, dest_path: str) -> SSHForwarder:
         """Forward a tunneled UNIX domain socket connection
 
            This method is a coroutine which can be returned by a
            `session_factory` to forward connections tunneled over
            SSH to the specified destination path.
 
            :param dest_path:
                The path to forward the connection to
            :type dest_path: `str`
 
-           :returns: :class:`SSHUNIXSession`
+           :returns: :class:`asyncio.BaseProtocol`
 
         """
 
         try:
             _, peer = \
                 await self._loop.create_unix_connection(SSHForwarder, dest_path)
 
             self.logger.info('  Forwarding UNIX connection to %s', dest_path)
         except OSError as exc:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, str(exc)) from None
 
-        return SSHForwarder(peer)
+        return SSHForwarder(cast(SSHForwarder, peer))
 
     @async_context_manager
-    async def forward_local_port(self, listen_host, listen_port,
-                                 dest_host, dest_port):
+    async def forward_local_port(self, listen_host: str,
+                                 listen_port: int,
+                                 dest_host: str,
+                                 dest_port: int) -> SSHListener:
         """Set up local port forwarding
 
            This method is a coroutine which attempts to set up port
            forwarding from a local listening port to a remote host and port
            via the SSH connection. If the request is successful, the
            return value is an :class:`SSHListener` object which can be used
            later to shut down the port forwarding.
@@ -2588,27 +2870,31 @@
 
            :returns: :class:`SSHListener`
 
            :raises: :exc:`OSError` if the listener can't be opened
 
         """
 
-        async def tunnel_connection(session_factory, orig_host, orig_port):
+        async def tunnel_connection(
+                session_factory: SSHTCPSessionFactory[bytes],
+                orig_host: str, orig_port: int) -> \
+                    Tuple[SSHTCPChannel[bytes], SSHTCPSession[bytes]]:
             """Forward a local connection over SSH"""
 
             return (await self.create_connection(session_factory,
                                                  dest_host, dest_port,
                                                  orig_host, orig_port))
 
         if (listen_host, listen_port) == (dest_host, dest_port):
             self.logger.info('Creating local TCP forwarder on %s',
                              (listen_host, listen_port))
         else:
             self.logger.info('Creating local TCP forwarder from %s to %s',
-                             (listen_host, listen_port), (dest_host, dest_port))
+                             (listen_host, listen_port),
+                             (dest_host, dest_port))
 
         try:
             listener = await create_tcp_forward_listener(self, self._loop,
                                                          tunnel_connection,
                                                          listen_host,
                                                          listen_port)
         except OSError as exc:
@@ -2619,15 +2905,16 @@
             listen_port = listener.get_port()
 
         self._local_listeners[listen_host, listen_port] = listener
 
         return listener
 
     @async_context_manager
-    async def forward_local_path(self, listen_path, dest_path):
+    async def forward_local_path(self, listen_path: str,
+                                 dest_path: str) -> SSHListener:
         """Set up local UNIX domain socket forwarding
 
            This method is a coroutine which attempts to set up UNIX domain
            socket forwarding from a local listening path to a remote path
            via the SSH connection. If the request is successful, the
            return value is an :class:`SSHListener` object which can be used
            later to shut down the UNIX domain socket forwarding.
@@ -2641,18 +2928,21 @@
 
            :returns: :class:`SSHListener`
 
            :raises: :exc:`OSError` if the listener can't be opened
 
         """
 
-        async def tunnel_connection(session_factory):
+        async def tunnel_connection(
+                session_factory: SSHUNIXSessionFactory[bytes]) -> \
+                    Tuple[SSHUNIXChannel[bytes], SSHUNIXSession[bytes]]:
             """Forward a local connection over SSH"""
 
-            return await self.create_unix_connection(session_factory, dest_path)
+            return await self.create_unix_connection(session_factory,
+                                                     dest_path)
 
         self.logger.info('Creating local UNIX forwarder from %s to %s',
                          listen_path, dest_path)
 
         try:
             listener = await create_unix_forward_listener(self, self._loop,
                                                           tunnel_connection,
@@ -2661,19 +2951,24 @@
             self.logger.debug1('Failed to create local UNIX listener: %s', exc)
             raise
 
         self._local_listeners[listen_path] = listener
 
         return listener
 
-    def close_forward_listener(self, listen_key):
+    def close_forward_listener(self, listen_key: ListenKey) -> None:
         """Mark a local forwarding listener as closed"""
 
         self._local_listeners.pop(listen_key, None)
 
+    def detach_x11_listener(self, chan: SSHChannel[AnyStr]) -> None:
+        """Detach a session from a local X11 listener"""
+
+        raise NotImplementedError
+
 
 class SSHClientConnection(SSHConnection):
     """SSH client connection
 
        This class represents an SSH client connection.
 
        Once authentication is successful on a connection, new client
@@ -2695,38 +2990,42 @@
        or :meth:`forward_remote_port`.
 
        UNIX domain socket forwarding can be set up by calling
        :meth:`forward_local_path` or :meth:`forward_remote_path`.
 
     """
 
-    def __init__(self, loop, options, acceptor=None,
-                 error_handler=None, wait=None):
+    _options: 'SSHClientConnectionOptions'
+    _owner: SSHClient
+    _x11_listener: Optional[SSHX11ClientListener]
+
+    def __init__(self, loop: asyncio.AbstractEventLoop,
+                 options: 'SSHClientConnectionOptions',
+                 acceptor: _AcceptHandler = None,
+                 error_handler: _ErrorHandler = None,
+                 wait: Optional[str] = None):
         super().__init__(loop, options, acceptor, error_handler,
                          wait, server=False)
 
         self._host = options.host
         self._port = options.port
 
         self._known_hosts = options.known_hosts
         self._host_key_alias = options.host_key_alias
 
-        self._server_host_key_algs = options.server_host_key_algs
-        self._server_host_key = None
+        self._server_host_key_algs: Optional[Sequence[bytes]] = None
+        self._server_host_key: Optional[SSHKey] = None
 
         self._username = options.username
         self._password = options.password
 
-        self._client_host_keysign = options.client_host_keysign
-        self._client_host_keys = None if options.client_host_keys is None else \
-                                 list(options.client_host_keys)
-        self._client_host = options.client_host
-        self._client_username = options.client_username
-        self._client_keys = None if options.client_keys is None else \
-                            list(options.client_keys)
+        self._client_host_keys: List[_ClientHostKey] = []
+
+        self._client_keys: List[SSHKeyPair] = \
+            list(options.client_keys) if options.client_keys else []
 
         if options.preferred_auth != ():
             self._preferred_auth = [method.encode('ascii') for method in
                                     options.preferred_auth]
         else:
             self._preferred_auth = get_client_auth_methods()
 
@@ -2752,33 +3051,44 @@
                 self._gss_auth = options.gss_auth
                 self._gss_mic_auth = self._gss_auth
             except GSSError:
                 pass
 
         self._kbdint_password_auth = False
 
-        self._remote_listeners = {}
-        self._dynamic_remote_listeners = {}
+        self._remote_listeners: \
+            Dict[ListenKey, Union[SSHTCPClientListener,
+                                  SSHUNIXClientListener]] = {}
 
-    def _connection_made(self):
+        self._dynamic_remote_listeners: Dict[str, SSHTCPClientListener] = {}
+
+    def _connection_made(self) -> None:
         """Handle the opening of a new connection"""
 
+        assert self._transport is not None
+
         if not self._host:
             if self._peer_addr:
                 self._host = self._peer_addr
                 self._port = self._peer_port
             else:
                 remote_peer = self.get_extra_info('remote_peername')
-                self._host, self._port = remote_peer
+                self._host, self._port = cast(HostPort, remote_peer)
 
-        if self._client_host_keysign:
-            sock = self._transport.get_extra_info('socket')
-            self._client_host_keys = get_keysign_keys(self._client_host_keysign,
-                                                      sock.fileno(),
-                                                      self._client_host_keys)
+        if self._options.client_host_keysign:
+            sock = cast(socket.socket,
+                        self._transport.get_extra_info('socket'))
+
+            self._client_host_keys = list(get_keysign_keys(
+                self._options.client_host_keysign, sock.fileno(),
+                self._options.client_host_pubkeys))
+        elif self._options.client_host_keypairs:
+            self._client_host_keys = list(self._options.client_host_keypairs)
+        else:
+            self._client_host_keys = []
 
         if self._known_hosts is None:
             self._trusted_host_keys = None
             self._trusted_ca_keys = None
         else:
             if not self._known_hosts:
                 default_known_hosts = Path('~', '.ssh',
@@ -2788,21 +3098,21 @@
                         os.access(default_known_hosts, os.R_OK)):
                     self._known_hosts = str(default_known_hosts)
                 else:
                     self._known_hosts = b''
 
             port = self._port if self._port != DEFAULT_PORT else None
 
-            self._match_known_hosts(self._known_hosts,
+            self._match_known_hosts(cast(KnownHostsArg, self._known_hosts),
                                     self._host_key_alias or self._host,
                                     self._peer_addr, port)
 
         default_host_key_algs = []
 
-        if self._server_host_key_algs != 'default':
+        if self._options.server_host_key_algs != 'default':
             if self._trusted_host_key_algs:
                 default_host_key_algs = self._trusted_host_key_algs
 
             if self._trusted_ca_keys:
                 default_host_key_algs = \
                     get_default_certificate_algs() + default_host_key_algs
 
@@ -2811,19 +3121,19 @@
                 get_default_certificate_algs() + get_default_public_key_algs()
 
         if self._x509_trusted_certs is not None:
             if self._x509_trusted_certs or self._x509_trusted_cert_paths:
                 default_host_key_algs = \
                     get_default_x509_certificate_algs() + default_host_key_algs
 
-        self._server_host_key_algs = \
-            _select_host_key_algs(
-                self._server_host_key_algs,
-                self._options.config.get('HostKeyAlgorithms', ()),
-                default_host_key_algs)
+        self._server_host_key_algs = _select_host_key_algs(
+            self._options.server_host_key_algs,
+            cast(DefTuple[str], self._options.config.get(
+                'HostKeyAlgorithms', ())),
+            default_host_key_algs)
 
         self.logger.info('Connected to SSH server at %s',
                          (self._host, self._port))
 
         if self._options.proxy_command:
             proxy_command = ' '.join(shlex.quote(arg) for arg in
                                      self._options.proxy_command)
@@ -2831,76 +3141,76 @@
         else:
             self.logger.info('  Local address: %s',
                              (self._local_addr, self._local_port))
             self.logger.info('  Peer address: %s',
                              (self._peer_addr, self._peer_port))
 
 
-    def _cleanup(self, exc):
+    def _cleanup(self, exc: Optional[Exception]) -> None:
         """Clean up this client connection"""
 
         if self._agent:
             self._agent.close()
 
         if self._remote_listeners:
-            for listener in list(self._remote_listeners.values()):
-                listener.close()
+            for tcp_listener in list(self._remote_listeners.values()):
+                tcp_listener.close()
 
             self._remote_listeners = {}
             self._dynamic_remote_listeners = {}
 
         if exc is None:
             self.logger.info('Connection closed')
         elif isinstance(exc, ConnectionLost):
             self.logger.info(str(exc))
         else:
             self.logger.info('Connection failure: ' + str(exc))
 
         super()._cleanup(exc)
 
 
-    def _choose_signature_alg(self, keypair):
+    def _choose_signature_alg(self, keypair: _ClientHostKey) -> bool:
         """Choose signature algorithm to use for key-based authentication"""
 
         if self._server_sig_algs:
             for alg in keypair.sig_algorithms:
                 if alg in self._sig_algs and alg in self._server_sig_algs:
                     keypair.set_sig_algorithm(alg)
                     return True
 
         return keypair.sig_algorithms[-1] in self._sig_algs
 
-    def validate_server_host_key(self, key_data):
+    def validate_server_host_key(self, key_data: bytes) -> SSHKey:
         """Validate and return the server's host key"""
 
         try:
             host_key = self._validate_host_key(
                 self._host_key_alias or self._host,
                 self._peer_addr, self._port, key_data)
         except ValueError as exc:
             raise HostKeyNotVerifiable(str(exc)) from None
 
         self._server_host_key = host_key
         return host_key
 
-    def get_server_host_key(self):
+    def get_server_host_key(self) -> Optional[SSHKey]:
         """Return the server host key used in the key exchange
 
            This method returns the server host key used to complete the
            key exchange with the server.
 
            If GSS key exchange is used, `None` is returned.
 
            :returns: An :class:`SSHKey` public key or `None`
 
         """
 
         return self._server_host_key
 
-    def try_next_auth(self):
+    def try_next_auth(self) -> None:
         """Attempt client authentication using the next compatible method"""
 
         if self._auth:
             self._auth.cancel()
             self._auth = None
 
         while self._auth_methods:
@@ -2911,247 +3221,268 @@
             if self._auth:
                 return
 
         self.logger.info('Auth failed for user %s', self._username)
 
         self._force_close(PermissionDenied('Permission denied'))
 
-    def gss_kex_auth_requested(self):
+    def gss_kex_auth_requested(self) -> bool:
         """Return whether to allow GSS key exchange authentication or not"""
 
         if self._gss_kex_auth:
             self._gss_kex_auth = False
             return True
         else:
             return False
 
-    def gss_mic_auth_requested(self):
+    def gss_mic_auth_requested(self) -> bool:
         """Return whether to allow GSS MIC authentication or not"""
 
         if self._gss_mic_auth:
             self._gss_mic_auth = False
             return True
         else:
             return False
 
-    async def host_based_auth_requested(self):
-        """Return a host key pair, host, and user to authenticate with"""
+    async def host_based_auth_requested(self) -> \
+            Tuple[Optional[_ClientHostKey], str, str]:
+        """Return a host key, host, and user to authenticate with"""
 
         if not self._host_based_auth:
-            return None, None, None
+            return None, '', ''
 
         while True:
             try:
-                keypair = self._client_host_keys.pop(0)
+                key: Optional[_ClientHostKey] = self._client_host_keys.pop(0)
             except IndexError:
-                keypair = None
+                key = None
                 break
 
-            if self._choose_signature_alg(keypair):
+            assert key is not None
+
+            if self._choose_signature_alg(key):
                 break
 
-        if self._client_host is None:
-            self._client_host, _ = await self._loop.getnameinfo(
-                self.get_extra_info('sockname'), socket.NI_NUMERICSERV)
+        client_host = self._options.client_host
+
+        if client_host is None:
+            client_host, _ = await self._loop.getnameinfo(
+                cast(SockAddr, self.get_extra_info('sockname')),
+                socket.NI_NUMERICSERV)
 
         # Add a trailing '.' to the client host to be compatible with
         # ssh-keysign from OpenSSH
-        if self._client_host_keysign and self._client_host[-1:] != '.':
-            self._client_host += '.'
+        if self._options.client_host_keysign and client_host[-1:] != '.':
+            client_host += '.'
 
-        return keypair, self._client_host, self._client_username
+        return key, client_host, self._options.client_username
 
-    async def public_key_auth_requested(self):
+    async def public_key_auth_requested(self) -> Optional[SSHKeyPair]:
         """Return a client key pair to authenticate with"""
 
         if not self._public_key_auth:
             return None
 
         if self._get_agent_keys:
+            assert self._agent is not None
+
             try:
                 agent_keys = await self._agent.get_keys(self._agent_identities)
-                self._client_keys = agent_keys + (self._client_keys or [])
+                self._client_keys[:0] = list(agent_keys)
             except ValueError:
                 pass
 
             self._get_agent_keys = False
 
         if self._get_pkcs11_keys:
             pkcs11_keys = await self._loop.run_in_executor(
                 None, load_pkcs11_keys, self._pkcs11_provider, self._pkcs11_pin)
 
-            self._client_keys = pkcs11_keys + (self._client_keys or [])
+            self._client_keys[:0] = list(pkcs11_keys)
             self._get_pkcs11_keys = False
 
         while True:
             if not self._client_keys:
                 result = self._owner.public_key_auth_requested()
 
                 if inspect.isawaitable(result):
-                    result = await result
+                    result = await cast(Awaitable[KeyPairListArg], result)
 
                 if not result:
                     return None
 
-                self._client_keys = load_keypairs(result)
+                result: KeyPairListArg
+
+                self._client_keys = list(load_keypairs(result))
 
             keypair = self._client_keys.pop(0)
 
             if self._choose_signature_alg(keypair):
                 return keypair
 
-    async def password_auth_requested(self):
+    async def password_auth_requested(self) -> Optional[str]:
         """Return a password to authenticate with"""
 
         if not self._password_auth and not self._kbdint_password_auth:
             return None
 
         if self._password is not None:
-            result = self._password
+            password: Optional[str] = self._password
             self._password = None
         else:
             result = self._owner.password_auth_requested()
 
             if inspect.isawaitable(result):
-                result = await result
+                password = await cast(Awaitable[Optional[str]], result)
+            else:
+                password = cast(Optional[str], result)
 
-        return result
+        return password
 
-    async def password_change_requested(self, prompt, lang):
+    async def password_change_requested(self, prompt: str,
+                                        lang: str) -> Tuple[str, str]:
         """Return a password to authenticate with and what to change it to"""
 
         result = self._owner.password_change_requested(prompt, lang)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[PasswordChangeResponse], result)
 
-        return result
+        return cast(PasswordChangeResponse, result)
 
-    def password_changed(self):
+    def password_changed(self) -> None:
         """Report a successful password change"""
 
         self._owner.password_changed()
 
-    def password_change_failed(self):
+    def password_change_failed(self) -> None:
         """Report a failed password change"""
 
         self._owner.password_change_failed()
 
-    async def kbdint_auth_requested(self):
+    async def kbdint_auth_requested(self) -> Optional[str]:
         """Return the list of supported keyboard-interactive auth methods
 
            If keyboard-interactive auth is not supported in the client but
            a password was provided when the connection was opened, this
            will allow sending the password via keyboard-interactive auth.
 
         """
 
         if not self._kbdint_auth:
             return None
 
         result = self._owner.kbdint_auth_requested()
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[Optional[str]], result)
 
         if result is NotImplemented:
             if self._password is not None and not self._kbdint_password_auth:
                 self._kbdint_password_auth = True
                 result = ''
             else:
                 result = None
 
-        return result
+        return cast(Optional[str], result)
 
-    async def kbdint_challenge_received(self, name, instructions,
-                                        lang, prompts):
+    async def kbdint_challenge_received(
+            self, name: str, instructions: str, lang: str,
+            prompts: KbdIntPrompts) -> Optional[KbdIntResponse]:
         """Return responses to a keyboard-interactive auth challenge"""
 
         if self._kbdint_password_auth:
             if not prompts:
                 # Silently drop any empty challenges used to print messages
-                result = []
+                response: Optional[KbdIntResponse] = []
             elif len(prompts) == 1:
                 prompt = prompts[0][0].lower()
 
                 if 'password' in prompt or 'passcode' in prompt:
                     password = await self.password_auth_requested()
 
-                    result = [password] if password is not None else None
+                    response = [password] if password is not None else None
                 else:
-                    result = None
+                    response = None
             else:
-                result = None
+                response = None
         else:
             result = self._owner.kbdint_challenge_received(name, instructions,
                                                            lang, prompts)
 
             if inspect.isawaitable(result):
-                result = await result
+                response = await cast(Awaitable[KbdIntResponse], result)
+            else:
+                response = cast(KbdIntResponse, result)
 
-        return result
+        return response
 
-    def _process_session_open(self, _packet):
+    def _process_session_open(self, _packet: SSHPacket) -> \
+            Tuple[SSHServerChannel, SSHServerSession]:
         """Process an inbound session open request
 
            These requests are disallowed on an SSH client.
 
         """
 
         # pylint: disable=no-self-use
 
         raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
                                'Session open forbidden on client')
 
-    def _process_direct_tcpip_open(self, _packet):
+    def _process_direct_tcpip_open(self, _packet: SSHPacket) -> \
+            Tuple[SSHTCPChannel[bytes], SSHTCPSession[bytes]]:
         """Process an inbound direct TCP/IP channel open request
 
            These requests are disallowed on an SSH client.
 
         """
 
         # pylint: disable=no-self-use
 
         raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
                                'Direct TCP/IP open forbidden on client')
 
-    def _process_forwarded_tcpip_open(self, packet):
+    def _process_forwarded_tcpip_open(self, packet: SSHPacket) -> \
+            Tuple[SSHTCPChannel, MaybeAwait[SSHTCPSession]]:
         """Process an inbound forwarded TCP/IP channel open request"""
 
-        dest_host = packet.get_string()
+        dest_host_bytes = packet.get_string()
         dest_port = packet.get_uint32()
-        orig_host = packet.get_string()
+        orig_host_bytes = packet.get_string()
         orig_port = packet.get_uint32()
         packet.check_end()
 
         try:
-            dest_host = dest_host.decode('utf-8')
-            orig_host = orig_host.decode('utf-8')
+            dest_host = dest_host_bytes.decode('utf-8')
+            orig_host = orig_host_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid forwarded TCP/IP channel '
                                 'open request') from None
 
         # Some buggy servers send back a port of `0` instead of the actual
         # listening port when reporting connections which arrive on a listener
         # set up on a dynamic port. This lookup attempts to work around that.
-        listener = (self._remote_listeners.get((dest_host, dest_port)) or
-                    self._dynamic_remote_listeners.get(dest_host))
+        listener = cast(SSHTCPClientListener[bytes],
+            self._remote_listeners.get((dest_host, dest_port)) or
+            self._dynamic_remote_listeners.get(dest_host))
 
         if listener:
             chan, session = listener.process_connection(orig_host, orig_port)
 
             self.logger.info('Accepted forwarded TCP connection on %s',
                              (dest_host, dest_port))
             self.logger.info('  Client address: %s', (orig_host, orig_port))
 
             return chan, session
         else:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, 'No such listener')
 
-    async def close_client_tcp_listener(self, listen_host, listen_port):
+    async def close_client_tcp_listener(self, listen_host: str,
+                                        listen_port: int) -> None:
         """Close a remote TCP/IP listener"""
 
         await self._make_global_request(
             b'cancel-tcpip-forward', String(listen_host), UInt32(listen_port))
 
         self.logger.info('Closed remote TCP listener on %s',
                          (listen_host, listen_port))
@@ -3160,127 +3491,155 @@
 
         if listener:
             if self._dynamic_remote_listeners.get(listen_host) == listener:
                 del self._dynamic_remote_listeners[listen_host]
 
             del self._remote_listeners[listen_host, listen_port]
 
-    def _process_direct_streamlocal_at_openssh_dot_com_open(self, _packet):
+    def _process_direct_streamlocal_at_openssh_dot_com_open(
+            self, _packet: SSHPacket) -> \
+                Tuple[SSHUNIXChannel, SSHUNIXSession]:
         """Process an inbound direct UNIX domain channel open request
 
            These requests are disallowed on an SSH client.
 
         """
 
         # pylint: disable=no-self-use
 
         raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
                                'Direct UNIX domain socket open '
                                'forbidden on client')
 
-    def _process_forwarded_streamlocal_at_openssh_dot_com_open(self, packet):
+    def _process_forwarded_streamlocal_at_openssh_dot_com_open(
+            self, packet: SSHPacket) -> \
+                Tuple[SSHUNIXChannel, MaybeAwait[SSHUNIXSession]]:
         """Process an inbound forwarded UNIX domain channel open request"""
 
-        dest_path = packet.get_string()
+        dest_path_bytes = packet.get_string()
         _ = packet.get_string()                         # reserved
         packet.check_end()
 
         try:
-            dest_path = dest_path.decode('utf-8')
+            dest_path = dest_path_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid forwarded UNIX domain channel '
                                 'open request') from None
 
-        listener = self._remote_listeners.get(dest_path)
+        listener = cast(SSHUNIXClientListener[bytes],
+                        self._remote_listeners.get(dest_path))
 
         if listener:
             chan, session = listener.process_connection()
 
             self.logger.info('Accepted remote UNIX connection on %s', dest_path)
 
             return chan, session
         else:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, 'No such listener')
 
-    async def close_client_unix_listener(self, listen_path):
+    async def close_client_unix_listener(self, listen_path: str) -> None:
         """Close a remote UNIX domain socket listener"""
 
         await self._make_global_request(
             b'cancel-streamlocal-forward@openssh.com', String(listen_path))
 
         self.logger.info('Closed UNIX listener on %s', listen_path)
 
         if listen_path in self._remote_listeners:
             del self._remote_listeners[listen_path]
 
-    def _process_x11_open(self, packet):
+    def _process_x11_open(self, packet: SSHPacket) -> \
+            Tuple[SSHX11Channel, Awaitable[SSHX11ClientForwarder]]:
         """Process an inbound X11 channel open request"""
 
-        orig_host = packet.get_string()
+        orig_host_bytes = packet.get_string()
         orig_port = packet.get_uint32()
 
         packet.check_end()
 
+        try:
+            orig_host = orig_host_bytes.decode('utf-8')
+        except UnicodeDecodeError:
+            raise ProtocolError('Invalid forwarded X11 channel '
+                                'open request') from None
+
         if self._x11_listener:
             self.logger.info('Accepted X11 connection')
             self.logger.info('  Client address: %s', (orig_host, orig_port))
 
             chan = self.create_x11_channel()
 
             chan.set_inbound_peer_names(orig_host, orig_port)
 
             return chan, self._x11_listener.forward_connection()
         else:
             raise ChannelOpenError(OPEN_CONNECT_FAILED,
                                    'X11 forwarding disabled')
 
-    def _process_auth_agent_at_openssh_dot_com_open(self, packet):
+    def _process_auth_agent_at_openssh_dot_com_open(
+            self, packet: SSHPacket) -> \
+                Tuple[SSHUNIXChannel, Awaitable[SSHForwarder]]:
         """Process an inbound auth agent channel open request"""
 
         packet.check_end()
 
         if self._agent_forward_path:
             self.logger.info('Accepted SSH agent connection')
 
             return (self.create_unix_channel(),
                     self.forward_unix_connection(self._agent_forward_path))
         else:
             raise ChannelOpenError(OPEN_CONNECT_FAILED,
                                    'Auth agent forwarding disabled')
 
-    async def attach_x11_listener(self, chan, display, auth_path,
-                                  single_connection):
+    async def attach_x11_listener(self, chan: SSHClientChannel[AnyStr],
+                                  display: Optional[str],
+                                  auth_path: Optional[str],
+                                  single_connection: bool) -> \
+            Tuple[bytes, bytes, int]:
         """Attach a channel to a local X11 display"""
 
         if not display:
             display = os.environ.get('DISPLAY')
 
         if not display:
             raise ValueError('X11 display not set')
 
         if not self._x11_listener:
             self._x11_listener = await create_x11_client_listener(
                 self._loop, display, auth_path)
 
         return self._x11_listener.attach(display, chan, single_connection)
 
-    def detach_x11_listener(self, chan):
+    def detach_x11_listener(self, chan: SSHChannel[AnyStr]) -> None:
         """Detach a session from a local X11 listener"""
 
         if self._x11_listener:
             if self._x11_listener.detach(chan):
                 self._x11_listener = None
 
-    async def create_session(self, session_factory, command=(), *,
-                             subsystem=(), env=(), send_env=(),
-                             request_pty=(), term_type=(), term_size=(),
-                             term_modes=(), x11_forwarding=(),
-                             x11_display=(), x11_auth_path=(),
-                             x11_single_connection=(), encoding=(),
-                             errors=(), window=(), max_pktsize=()):
+    async def create_session(self, session_factory: SSHClientSessionFactory,
+                             command: DefTuple[Optional[str]] = (), *,
+                             subsystem: DefTuple[Optional[str]]= (),
+                             env: DefTuple[_Env] = (),
+                             send_env: DefTuple[_SendEnv] = (),
+                             request_pty: DefTuple[Union[bool, str]] = (),
+                             term_type: DefTuple[Optional[str]] = (),
+                             term_size: DefTuple[TermSizeArg] = (),
+                             term_modes: DefTuple[TermModesArg] = (),
+                             x11_forwarding: DefTuple[Union[int, str]] = (),
+                             x11_display: DefTuple[Optional[str]] = (),
+                             x11_auth_path: DefTuple[Optional[str]] = (),
+                             x11_single_connection: DefTuple[bool] = (),
+                             encoding: DefTuple[Optional[str]] = (),
+                             errors: DefTuple[str] = (),
+                             window: DefTuple[int] = (),
+                             max_pktsize: DefTuple[int] = ()) -> \
+            Tuple[SSHClientChannel, SSHClientSession]:
         """Create an SSH client session
 
            This method is a coroutine which can be called to create an SSH
            client session used to execute a command, start a subsystem
            such as sftp, or if no command or subsystem is specified run an
            interactive shell. Optional arguments allow terminal and
            environment information to be provided.
@@ -3364,20 +3723,20 @@
            :param window: (optional)
                The receive window size for this session.
            :param max_pktsize: (optional)
                The maximum packet size for this session.
            :type session_factory: `callable`
            :type command: `str`
            :type subsystem: `str`
-           :type env: `dict`
-           :type send_env: `str` or `list` of `str`
+           :type env: `dict` with `str` keys and values
+           :type send_env: `list` of `str`
            :type request_pty: `bool`, `'force'`, or `'auto'`
            :type term_type: `str`
            :type term_size: `tuple` of 2 or 4 `int` values
-           :type term_modes: `dict`
+           :type term_modes: `dict` with `int` keys and values
            :type x11_forwarding: `bool` or `'ignore_failure'`
            :type x11_display: `str`
            :type x11_auth_path: `str`
            :type x11_single_connection: `bool`
            :type encoding: `str`
            :type errors: `str`
            :type window: `int`
@@ -3433,76 +3792,98 @@
 
         if window == ():
             window = self._options.window
 
         if max_pktsize == ():
             max_pktsize = self._options.max_pktsize
 
-        new_env = {}
+        new_env: Dict[str, str] = {}
 
         if send_env:
             for key in send_env:
                 pattern = WildcardPattern(key)
                 new_env.update((key, value) for key, value in os.environ.items()
                                if pattern.matches(key))
 
         if env:
             try:
                 if isinstance(env, list):
-                    env = (item.split('=', 2) for item in env)
-
-                new_env.update(env)
+                    new_env.update((item.split('=', 2) for item in env))
+                else:
+                    new_env.update(cast(Mapping[str, str], env))
             except ValueError:
                 raise ValueError('Invalid environment value') from None
 
         if request_pty == 'force':
             request_pty = True
         elif request_pty == 'auto':
             request_pty = bool(term_type and not (command or subsystem))
         elif request_pty:
             request_pty = bool(term_type)
 
+        command: Optional[str]
+        subsystem: Optional[str]
+        request_pty: bool
+        term_type: Optional[str]
+        term_size: TermSizeArg
+        term_modes: TermModesArg
+        x11_forwarding: Union[bool, str]
+        x11_display: Optional[str]
+        x11_auth_path: Optional[str]
+        x11_single_connection: bool
+        encoding: Optional[str]
+        errors: str
+        window: int
+        max_pktsize: int
+
         chan = SSHClientChannel(self, self._loop, encoding, errors,
                                 window, max_pktsize)
 
         session = await chan.create(session_factory, command, subsystem,
                                     new_env, request_pty, term_type, term_size,
                                     term_modes or {}, x11_forwarding,
                                     x11_display, x11_auth_path,
                                     x11_single_connection,
                                     bool(self._agent_forward_path))
 
         return chan, session
 
-    async def open_session(self, *args, **kwargs):
+    async def open_session(self, *args: object, **kwargs: object) -> \
+            Tuple[SSHWriter, SSHReader, SSHReader]:
         """Open an SSH client session
 
            This method is a coroutine wrapper around :meth:`create_session`
            designed to provide a "high-level" stream interface for creating
            an SSH client session. Instead of taking a `session_factory`
            argument for constructing an object which will handle activity
            on the session via callbacks, it returns an :class:`SSHWriter`
            and two :class:`SSHReader` objects representing stdin, stdout,
            and stderr which can be used to perform I/O on the session. With
            the exception of `session_factory`, all of the arguments to
            :meth:`create_session` are supported and have the same meaning.
 
         """
 
-        chan, session = await self.create_session(SSHClientStreamSession,
-                                                  *args, **kwargs)
+        chan, session = await self.create_session(
+            SSHClientStreamSession, *args, **kwargs) # type: ignore
+
+        session: SSHClientStreamSession
 
         return (SSHWriter(session, chan), SSHReader(session, chan),
                 SSHReader(session, chan, EXTENDED_DATA_STDERR))
 
     # pylint: disable=redefined-builtin
     @async_context_manager
-    async def create_process(self, *args, bufsize=io.DEFAULT_BUFFER_SIZE,
-                             input=None, stdin=PIPE, stdout=PIPE, stderr=PIPE,
-                             **kwargs):
+    async def create_process(self, *args: object,
+                             bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                             input: Optional[AnyStr] = None,
+                             stdin: ProcessSource = PIPE,
+                             stdout: ProcessTarget = PIPE,
+                             stderr: ProcessTarget = PIPE,
+                             **kwargs: object) -> SSHClientProcess:
         """Create a process on the remote system
 
            This method is a coroutine wrapper around :meth:`create_session`
            which can be used to execute a command, start a subsystem,
            or start an interactive shell, optionally redirecting stdin,
            stdout, and stderr to and from files or pipes attached to
            other local and remote processes.
@@ -3546,29 +3927,39 @@
 
            :returns: :class:`SSHClientProcess`
 
            :raises: :exc:`ChannelOpenError` if the channel can't be opened
 
         """
 
-        chan, process = await self.create_session(SSHClientProcess,
-                                                  *args, **kwargs)
+        chan, process = await self.create_session(
+            SSHClientProcess, *args, **kwargs) # type: ignore
+
+        new_stdin: Optional[ProcessSource] = stdin
+        process: SSHClientProcess
 
         if input:
             chan.write(input)
             chan.write_eof()
-            stdin = None
+            new_stdin = None
 
-        await process.redirect(stdin, stdout, stderr, bufsize)
+        await process.redirect(new_stdin, stdout, stderr, bufsize)
 
         return process
 
-    async def create_subprocess(self, protocol_factory, *args, input=None,
-                                bufsize=io.DEFAULT_BUFFER_SIZE, encoding=None,
-                                stdin=PIPE, stdout=PIPE, stderr=PIPE, **kwargs):
+    async def create_subprocess(self, protocol_factory: SubprocessFactory,
+                                command: DefTuple[Optional[str]] = (),
+                                bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                                input: Optional[AnyStr] = None,
+                                stdin: ProcessSource = PIPE,
+                                stdout: ProcessTarget = PIPE,
+                                stderr: ProcessTarget = PIPE,
+                                encoding: Optional[str] = None,
+                                **kwargs: object) -> \
+            Tuple[SSHSubprocessTransport, SSHSubprocessProtocol]:
         """Create a subprocess on the remote system
 
            This method is a coroutine wrapper around :meth:`create_session`
            which can be used to execute a command, start a subsystem,
            or start an interactive shell, optionally redirecting stdin,
            stdout, and stderr to and from files or pipes attached to
            other local and remote processes similar to :meth:`create_process`.
@@ -3591,34 +3982,41 @@
            :returns: an :class:`SSHSubprocessTransport` and
                      :class:`SSHSubprocessProtocol`
 
            :raises: :exc:`ChannelOpenError` if the channel can't be opened
 
         """
 
-        def transport_factory():
+        def transport_factory() -> SSHSubprocessTransport:
             """Return a subprocess transport"""
 
             return SSHSubprocessTransport(protocol_factory)
 
-        _, transport = await self.create_session(
-            transport_factory, *args, encoding=encoding, **kwargs)
+        _, transport = await self.create_session(transport_factory, command,
+                                                 encoding=encoding,
+                                                 **kwargs) # type: ignore
+
+        new_stdin: Optional[ProcessSource] = stdin
+        transport: SSHSubprocessTransport
 
         if input:
-            stdin_pipe = transport.get_pipe_transport(0)
+            stdin_pipe = cast(SSHSubprocessWritePipe,
+                              transport.get_pipe_transport(0))
             stdin_pipe.write(input)
             stdin_pipe.write_eof()
-            stdin = None
+            new_stdin = None
 
-        await transport.redirect(stdin, stdout, stderr, bufsize)
+        await transport.redirect(new_stdin, stdout, stderr, bufsize)
 
         return transport, transport.get_protocol()
     # pylint: enable=redefined-builtin
 
-    async def run(self, *args, check=False, timeout=None, **kwargs):
+    async def run(self, *args: object, check: bool = False,
+                  timeout: Optional[float] = None,
+                  **kwargs: object) -> SSHCompletedProcess:
         """Run a command on the remote system and collect its output
 
            This method is a coroutine wrapper around :meth:`create_process`
            which can be used to run a process to completion when no
            interactivity is needed. All of the arguments to
            :meth:`create_process` can be passed in to provide input or
            redirect stdin, stdout, and stderr, but this method waits until
@@ -3650,22 +4048,25 @@
 
            :raises: | :exc:`ChannelOpenError` if the session can't be opened
                     | :exc:`ProcessError` if checking non-zero exit status
                     | :exc:`TimeoutError` if the timeout expires before exit
 
         """
 
-        process = await self.create_process(*args, **kwargs)
+        process = await self.create_process(*args, **kwargs) # type: ignore
 
         return await process.wait(check, timeout)
 
-    async def create_connection(self, session_factory, remote_host, remote_port,
-                                orig_host='', orig_port=0, *, encoding=None,
-                                errors='strict', window=_DEFAULT_WINDOW,
-                                max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_connection(
+            self, session_factory: SSHTCPSessionFactory[AnyStr],
+            remote_host: str, remote_port: int, orig_host: str = '',
+            orig_port: int = 0, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHTCPChannel[AnyStr], SSHTCPSession[AnyStr]]:
         """Create an SSH TCP direct connection
 
            This method is a coroutine which can be called to request that
            the server open a new outbound TCP connection to the specified
            destination host and port. If the connection is successfully
            opened, a new SSH channel will be opened with data being handled
            by a :class:`SSHTCPSession` object created by `session_factory`.
@@ -3680,15 +4081,15 @@
            argument can be passed in to select what Unicode error handling
            strategy to use.
 
            Other optional arguments include the SSH receive window size and
            max packet size which default to 2 MB and 32 KB, respectively.
 
            :param session_factory:
-               A `callable` which returns an :class:`SSHClientSession` object
+               A `callable` which returns an :class:`SSHTCPSession` object
                that will be created to handle activity on this session
            :param remote_host:
                The remote hostname or address to connect to
            :param remote_port:
                The remote port number to connect to
            :param orig_host: (optional)
                The hostname or address of the client requesting the connection
@@ -3725,15 +4126,16 @@
         chan = self.create_tcp_channel(encoding, errors, window, max_pktsize)
 
         session = await chan.connect(session_factory, remote_host, remote_port,
                                      orig_host, orig_port)
 
         return chan, session
 
-    async def open_connection(self, *args, **kwargs):
+    async def open_connection(self, *args: object, **kwargs: object) -> \
+            Tuple[SSHReader, SSHWriter]:
         """Open an SSH TCP direct connection
 
            This method is a coroutine wrapper around :meth:`create_connection`
            designed to provide a "high-level" stream interface for creating
            an SSH TCP direct connection. Instead of taking a
            `session_factory` argument for constructing an object which will
            handle activity on the session via callbacks, it returns
@@ -3746,53 +4148,56 @@
 
            :returns: an :class:`SSHReader` and :class:`SSHWriter`
 
            :raises: :exc:`ChannelOpenError` if the connection can't be opened
 
         """
 
-        chan, session = await self.create_connection(SSHTCPStreamSession,
-                                                     *args, **kwargs)
+        chan, session = await self.create_connection(
+            SSHTCPStreamSession, *args, **kwargs) # type: ignore
+
+        session: SSHTCPStreamSession
 
         return SSHReader(session, chan), SSHWriter(session, chan)
 
     @async_context_manager
-    async def create_server(self, session_factory, listen_host, listen_port, *,
-                            encoding=None, errors='strict',
-                            window=_DEFAULT_WINDOW,
-                            max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_server(
+            self, session_factory: TCPListenerFactory, listen_host: str,
+            listen_port: int, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> SSHListener:
         """Create a remote SSH TCP listener
 
            This method is a coroutine which can be called to request that
            the server listen on the specified remote address and port for
            incoming TCP connections. If the request is successful, the
            return value is an :class:`SSHListener` object which can be
            used later to shut down the listener. If the request fails,
            `None` is returned.
 
            :param session_factory:
                A `callable` or coroutine which takes arguments of the
                original host and port of the client and decides whether
                to accept the connection or not, either returning an
-               :class:`SSHTCPSession` object used to handle activity on
-               that connection or raising :exc:`ChannelOpenError` to
-               indicate that the connection should not be accepted
+               :class:`SSHTCPSession` object used to handle activity
+               on that connection or raising :exc:`ChannelOpenError`
+               to indicate that the connection should not be accepted
            :param listen_host:
                The hostname or address on the remote host to listen on
            :param listen_port:
                The port number on the remote host to listen on
            :param encoding: (optional)
                The Unicode encoding to use for data exchanged on the connection
            :param errors: (optional)
                The error handling strategy to apply on encode/decode errors
            :param window: (optional)
                The receive window size for this session
            :param max_pktsize: (optional)
                The maximum packet size for this session
-           :type session_factory: `callable` or coroutine
+           :type session_factory: `callable`
            :type listen_host: `str`
            :type listen_port: `int`
            :type encoding: `str`
            :type errors: `str`
            :type window: `int`
            :type max_pktsize: `int`
 
@@ -3822,32 +4227,34 @@
                 if len(packet.get_remaining_payload()) == 4: # pragma: no cover
                     packet.get_uint32()
 
                 dynamic = False
 
             packet.check_end()
 
-            listener = SSHTCPClientListener(self, session_factory,
-                                            listen_host, listen_port, encoding,
-                                            errors, window, max_pktsize)
+            listener = SSHTCPClientListener[AnyStr](self, session_factory,
+                                                    listen_host, listen_port,
+                                                    encoding, errors,
+                                                    window, max_pktsize)
 
             if dynamic:
                 self.logger.debug1('Assigning dynamic port %d', listen_port)
 
                 self._dynamic_remote_listeners[listen_host] = listener
 
             self._remote_listeners[listen_host, listen_port] = listener
             return listener
         else:
             packet.check_end()
             self.logger.debug1('Failed to create remote TCP listener')
             raise ChannelListenError('Failed to create remote TCP listener')
 
     @async_context_manager
-    async def start_server(self, handler_factory, *args, **kwargs):
+    async def start_server(self, handler_factory: _TCPServerHandlerFactory,
+                           *args: object, **kwargs: object) -> SSHListener:
         """Start a remote SSH TCP listener
 
            This method is a coroutine wrapper around :meth:`create_server`
            designed to provide a "high-level" stream interface for creating
            remote SSH TCP listeners. Instead of taking a `session_factory`
            argument for constructing an object which will handle activity on
            the session via callbacks, it takes a `handler_factory` which
@@ -3872,25 +4279,28 @@
 
            :returns: :class:`SSHListener`
 
            :raises: :class:`ChannelListenError` if the listener can't be opened
 
         """
 
-        def session_factory(orig_host, orig_port):
+        def session_factory(orig_host: str, orig_port: int) -> SSHTCPSession:
             """Return a TCP stream session handler"""
 
             return SSHTCPStreamSession(handler_factory(orig_host, orig_port))
 
-        return await self.create_server(session_factory, *args, **kwargs)
+        return await self.create_server(session_factory,
+                                        *args, **kwargs) # type: ignore
 
-    async def create_unix_connection(self, session_factory, remote_path, *,
-                                     encoding=None, errors='strict',
-                                     window=_DEFAULT_WINDOW,
-                                     max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_unix_connection(
+            self, session_factory: SSHUNIXSessionFactory[AnyStr],
+            remote_path: str, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHUNIXChannel[AnyStr], SSHUNIXSession[AnyStr]]:
         """Create an SSH UNIX domain socket direct connection
 
            This method is a coroutine which can be called to request that
            the server open a new outbound UNIX domain socket connection to
            the specified destination path. If the connection is successfully
            opened, a new SSH channel will be opened with data being handled
            by a :class:`SSHUNIXSession` object created by `session_factory`.
@@ -3902,15 +4312,15 @@
            errors argument can be passed in to select what Unicode error
            handling strategy to use.
 
            Other optional arguments include the SSH receive window size and
            max packet size which default to 2 MB and 32 KB, respectively.
 
            :param session_factory:
-               A `callable` which returns an :class:`SSHClientSession` object
+               A `callable` which returns an :class:`SSHUNIXSession` object
                that will be created to handle activity on this session
            :param remote_path:
                The remote path to connect to
            :param encoding: (optional)
                The Unicode encoding to use for data exchanged on the connection
            :param errors: (optional)
                The error handling strategy to apply on encode/decode errors
@@ -3935,15 +4345,16 @@
 
         chan = self.create_unix_channel(encoding, errors, window, max_pktsize)
 
         session = await chan.connect(session_factory, remote_path)
 
         return chan, session
 
-    async def open_unix_connection(self, *args, **kwargs):
+    async def open_unix_connection(self, *args: object, **kwargs: object) -> \
+            Tuple[SSHReader, SSHWriter]:
         """Open an SSH UNIX domain socket direct connection
 
            This method is a coroutine wrapper around
            :meth:`create_unix_connection` designed to provide a "high-level"
            stream interface for creating an SSH UNIX domain socket direct
            connection. Instead of taking a `session_factory` argument for
            constructing an object which will handle activity on the session
@@ -3958,50 +4369,52 @@
 
            :raises: :exc:`ChannelOpenError` if the connection can't be opened
 
         """
 
         chan, session = \
             await self.create_unix_connection(SSHUNIXStreamSession,
-                                              *args, **kwargs)
+                                              *args, **kwargs) # type: ignore
+
+        session: SSHUNIXStreamSession
 
         return SSHReader(session, chan), SSHWriter(session, chan)
 
     @async_context_manager
-    async def create_unix_server(self, session_factory, listen_path, *,
-                                 encoding=None, errors='strict',
-                                 window=_DEFAULT_WINDOW,
-                                 max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_unix_server(
+            self, session_factory: UNIXListenerFactory[AnyStr],
+            listen_path: str, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> SSHListener:
         """Create a remote SSH UNIX domain socket listener
 
            This method is a coroutine which can be called to request that
            the server listen on the specified remote path for incoming UNIX
            domain socket connections. If the request is successful, the
            return value is an :class:`SSHListener` object which can be
            used later to shut down the listener. If the request fails,
            `None` is returned.
 
            :param session_factory:
-               A `callable` or coroutine which takes arguments of the
-               original host and port of the client and decides whether
-               to accept the connection or not, either returning an
+               A `callable` or coroutine which decides whether to accept
+               the connection or not, either returning an
                :class:`SSHUNIXSession` object used to handle activity
                on that connection or raising :exc:`ChannelOpenError`
                to indicate that the connection should not be accepted
            :param listen_path:
                The path on the remote host to listen on
            :param encoding: (optional)
                The Unicode encoding to use for data exchanged on the connection
            :param errors: (optional)
                The error handling strategy to apply on encode/decode errors
            :param window: (optional)
                The receive window size for this session
            :param max_pktsize: (optional)
                The maximum packet size for this session
-           :type session_factory: `callable` or coroutine
+           :type session_factory: `callable`
            :type listen_path: `str`
            :type encoding: `str`
            :type errors: `str`
            :type window: `int`
            :type max_pktsize: `int`
 
            :returns: :class:`SSHListener`
@@ -4014,26 +4427,29 @@
 
         pkttype, packet = await self._make_global_request(
             b'streamlocal-forward@openssh.com', String(listen_path))
 
         packet.check_end()
 
         if pkttype == MSG_REQUEST_SUCCESS:
-            listener = SSHUNIXClientListener(self, session_factory,
-                                             listen_path, encoding, errors,
-                                             window, max_pktsize)
+            listener = SSHUNIXClientListener[AnyStr](self, session_factory,
+                                                     listen_path, encoding,
+                                                     errors, window,
+                                                     max_pktsize)
 
             self._remote_listeners[listen_path] = listener
             return listener
         else:
             self.logger.debug1('Failed to create remote UNIX listener')
             raise ChannelListenError('Failed to create remote UNIX listener')
 
     @async_context_manager
-    async def start_unix_server(self, handler_factory, *args, **kwargs):
+    async def start_unix_server(
+            self, handler_factory: _UNIXServerHandlerFactory,
+            *args: object, **kwargs: object) -> SSHListener:
         """Start a remote SSH UNIX domain socket listener
 
            This method is a coroutine wrapper around :meth:`create_unix_server`
            designed to provide a "high-level" stream interface for creating
            remote SSH UNIX domain socket listeners. Instead of taking a
            `session_factory` argument for constructing an object which
            will handle activity on the session via callbacks, it takes a
@@ -4046,110 +4462,120 @@
 
            With the exception of `handler_factory` replacing
            `session_factory`, all of the arguments to
            :meth:`create_unix_server` are supported and have the same
            meaning here.
 
            :param handler_factory:
-               A `callable` or coroutine which takes arguments of the
-               original host and port of the client and decides whether to
-               accept the connection or not, either returning a callback
-               or coroutine used to handle activity on that connection
-               or raising :exc:`ChannelOpenError` to indicate that the
-               connection should not be accepted
+               A `callable` or coroutine which decides whether to accept
+               the UNIX domain socket connection or not, either returning
+               a callback or coroutine used to handle activity on that
+               connection or raising :exc:`ChannelOpenError` to indicate
+               that the connection should not be accepted
            :type handler_factory: `callable` or coroutine
 
            :returns: :class:`SSHListener`
 
            :raises: :class:`ChannelListenError` if the listener can't be opened
 
         """
 
-        def session_factory():
+        def session_factory() -> SSHUNIXStreamSession:
             """Return a UNIX domain socket stream session handler"""
 
             return SSHUNIXStreamSession(handler_factory())
 
-        return await self.create_unix_server(session_factory, *args, **kwargs)
+        return await self.create_unix_server(session_factory,
+                                             *args, **kwargs) # type: ignore
 
-    async def create_ssh_connection(self, client_factory, host,
-                                    port=(), **kwargs):
+    async def create_ssh_connection(self, client_factory: _ClientFactory,
+                                    host: str, port: DefTuple[int] = (),
+                                    **kwargs: object) -> \
+                Tuple['SSHClientConnection', SSHClient]:
         """Create a tunneled SSH client connection
 
            This method is a coroutine which can be called to open an
            SSH client connection to the requested host and port tunneled
            inside this already established connection. It takes all the
            same arguments as :func:`create_connection` but requests
            that the upstream SSH server open the connection rather than
            connecting directly.
 
         """
 
         return (await create_connection(client_factory, host, port,
-                                        tunnel=self, **kwargs))
+                                        tunnel=self, **kwargs)) # type: ignore
 
     @async_context_manager
-    async def connect_ssh(self, host, port=(), **kwargs):
+    async def connect_ssh(self, host: str, port: DefTuple[int] = (),
+                          **kwargs: object) -> 'SSHClientConnection':
         """Make a tunneled SSH client connection
 
            This method is a coroutine which can be called to open an
            SSH client connection to the requested host and port tunneled
            inside this already established connection. It takes all the
            same arguments as :func:`connect` but requests that the upstream
            SSH server open the connection rather than connecting directly.
 
         """
 
-        return await connect(host, port, tunnel=self, **kwargs)
+        return await connect(host, port, tunnel=self, **kwargs) # type: ignore
 
     @async_context_manager
-    async def connect_reverse_ssh(self, host, port=(), **kwargs):
+    async def connect_reverse_ssh(self, host: str, port: DefTuple[int] = (),
+                                  **kwargs: object) -> 'SSHServerConnection':
         """Make a tunneled reverse direction SSH connection
 
            This method is a coroutine which can be called to open an
            SSH client connection to the requested host and port tunneled
            inside this already established connection. It takes all the
            same arguments as :func:`connect` but requests that the upstream
            SSH server open the connection rather than connecting directly.
 
         """
 
-        return await connect_reverse(host, port, tunnel=self, **kwargs)
+        return await connect_reverse(host, port, tunnel=self,
+                                     **kwargs) # type: ignore
 
     @async_context_manager
-    async def listen_ssh(self, host='', port=(), **kwargs):
+    async def listen_ssh(self, host: str = '', port: DefTuple[int] = (),
+                         **kwargs: object) -> SSHAcceptor:
         """Create a tunneled SSH listener
 
            This method is a coroutine which can be called to open a remote
            SSH listener on the requested host and port tunneled inside this
            already established connection. It takes all the same arguments as
            :func:`listen` but requests that the upstream SSH server open the
            listener rather than listening directly via TCP/IP.
 
         """
 
-        return await listen(host, port, tunnel=self, **kwargs)
+        return await listen(host, port, tunnel=self, **kwargs) # type: ignore
 
     @async_context_manager
-    async def listen_reverse_ssh(self, host='', port=(), **kwargs):
+    async def listen_reverse_ssh(self, host: str = '',
+                                 port: DefTuple[int] = (),
+                                 **kwargs: object) -> SSHAcceptor:
         """Create a tunneled reverse direction SSH listener
 
            This method is a coroutine which can be called to open a remote
            SSH listener on the requested host and port tunneled inside this
            already established connection. It takes all the same arguments as
            :func:`listen_reverse` but requests that the upstream SSH server
            open the listener rather than listening directly via TCP/IP.
 
         """
 
-        return await listen_reverse(host, port, tunnel=self, **kwargs)
+        return await listen_reverse(host, port, tunnel=self,
+                                    **kwargs) # type: ignore
 
     @async_context_manager
-    async def forward_remote_port(self, listen_host, listen_port,
-                                  dest_host, dest_port):
+    async def forward_remote_port(self, listen_host: str,
+                                  listen_port: int, dest_host: str,
+                                  dest_port: int) -> SSHListener:
         """Set up remote port forwarding
 
            This method is a coroutine which attempts to set up port
            forwarding from a remote listening port to a local host and port
            via the SSH connection. If the request is successful, the
            return value is an :class:`SSHListener` object which can be
            used later to shut down the port forwarding. If the request
@@ -4170,27 +4596,30 @@
 
            :returns: :class:`SSHListener`
 
            :raises: :class:`ChannelListenError` if the listener can't be opened
 
         """
 
-        def session_factory(_orig_host, _orig_port):
+        def session_factory(_orig_host: str,
+                            _orig_port: int) -> Awaitable[SSHTCPSession]:
             """Return an SSHTCPSession used to do remote port forwarding"""
 
-            return self.forward_connection(dest_host, dest_port)
+            return cast(Awaitable[SSHTCPSession],
+                        self.forward_connection(dest_host, dest_port))
 
         self.logger.info('Creating remote TCP forwarder from %s to %s',
                          (listen_host, listen_port), (dest_host, dest_port))
 
         return await self.create_server(session_factory, listen_host,
                                         listen_port)
 
     @async_context_manager
-    async def forward_remote_path(self, listen_path, dest_path):
+    async def forward_remote_path(self, listen_path: str,
+                                  dest_path: str) -> SSHListener:
         """Set up remote UNIX domain socket forwarding
 
            This method is a coroutine which attempts to set up UNIX domain
            socket forwarding from a remote listening path to a local path
            via the SSH connection. If the request is successful, the
            return value is an :class:`SSHListener` object which can be
            used later to shut down the port forwarding. If the request
@@ -4205,26 +4634,28 @@
 
            :returns: :class:`SSHListener`
 
            :raises: :class:`ChannelListenError` if the listener can't be opened
 
         """
 
-        def session_factory():
+        def session_factory() -> Awaitable[SSHUNIXSession[bytes]]:
             """Return an SSHUNIXSession used to do remote path forwarding"""
 
-            return self.forward_unix_connection(dest_path)
+            return cast(Awaitable[SSHUNIXSession[bytes]],
+                        self.forward_unix_connection(dest_path))
 
         self.logger.info('Creating remote UNIX forwarder from %s to %s',
                          listen_path, dest_path)
 
         return await self.create_unix_server(session_factory, listen_path)
 
     @async_context_manager
-    async def forward_socks(self, listen_host, listen_port):
+    async def forward_socks(self, listen_host: str,
+                            listen_port: int) -> SSHListener:
         """Set up local port forwarding via SOCKS
 
            This method is a coroutine which attempts to set up dynamic
            port forwarding via SOCKS on the specified local host and
            port. Each SOCKS request contains the destination host and
            port to connect to and triggers a request to tunnel traffic
            to the requested host and port via the SSH connection.
@@ -4242,16 +4673,18 @@
 
            :returns: :class:`SSHListener`
 
            :raises: :exc:`OSError` if the listener can't be opened
 
         """
 
-        async def tunnel_socks(session_factory, dest_host, dest_port,
-                               orig_host, orig_port):
+        async def tunnel_socks(session_factory: SSHTCPSessionFactory[bytes],
+                               dest_host: str, dest_port: int,
+                               orig_host: str, orig_port: int) -> \
+                Tuple[SSHTCPChannel[bytes], SSHTCPSession[bytes]]:
             """Forward a local SOCKS connection over SSH"""
 
             return await self.create_connection(session_factory,
                                                 dest_host, dest_port,
                                                 orig_host, orig_port)
 
         self.logger.info('Creating local SOCKS forwarder on %s',
@@ -4269,16 +4702,19 @@
             listen_port = listener.get_port()
 
         self._local_listeners[listen_host, listen_port] = listener
 
         return listener
 
     @async_context_manager
-    async def start_sftp_client(self, env=(), send_env=(),
-                                path_encoding='utf-8', path_errors='strict'):
+    async def start_sftp_client(self, env: DefTuple[_Env] = (),
+                                send_env: DefTuple[_SendEnv] = (),
+                                path_encoding: Optional[str] = 'utf-8',
+                                path_errors = 'strict',
+                                sftp_version = MIN_SFTP_VERSION) -> SFTPClient:
         """Start an SFTP client
 
            This method is a coroutine which attempts to start a secure
            file transfer session. If it succeeds, it returns an
            :class:`SFTPClient` object which can be used to copy and
            access files on the remote host.
 
@@ -4306,31 +4742,36 @@
                in the local environment. If a variable is present in both
                env and send_env, the value from env will be used.
            :param path_encoding:
                The Unicode encoding to apply when sending and receiving
                remote pathnames
            :param path_errors:
                The error handling strategy to apply on encode/decode errors
-           :type env: `dict`
+           :param sftp_version: (optional)
+               The maximum version of the SFTP protocol to support, currently
+               either 3 or 4, defaulting to 3.
+           :type env: `dict` with `str` keys and values
            :type send_env: `list` of `str`
            :type path_encoding: `str`
            :type path_errors: `str`
+           :type sftp_version: `int`
 
            :returns: :class:`SFTPClient`
 
            :raises: :exc:`SFTPError` if the session can't be opened
 
         """
 
         writer, reader, _ = await self.open_session(subsystem='sftp',
                                                     env=env, send_env=send_env,
                                                     encoding=None)
 
         return await start_sftp_client(self, self._loop, reader, writer,
-                                       path_encoding, path_errors)
+                                       path_encoding, path_errors,
+                                       sftp_version)
 
 
 class SSHServerConnection(SSHConnection):
     """SSH server connection
 
        This class represents an SSH server connection.
 
@@ -4359,84 +4800,92 @@
        <SSHServer.unix_connection_requested>` method and return a tuple of
        the :class:`SSHUNIXChannel` object returned from that and either
        an :class:`SSHUNIXSession` object or a coroutine which returns an
        :class:`SSHUNIXSession`.
 
     """
 
-    def __init__(self, loop, options, acceptor=None,
-                 error_handler=None, wait=None):
+    _options: 'SSHServerConnectionOptions'
+    _owner: SSHServer
+    _x11_listener: Optional[SSHX11ServerListener]
+
+    def __init__(self, loop: asyncio.AbstractEventLoop,
+                 options: 'SSHServerConnectionOptions',
+                 acceptor: _AcceptHandler = None,
+                 error_handler: _ErrorHandler = None,
+                 wait: Optional[str] = None):
         super().__init__(loop, options, acceptor, error_handler,
                          wait, server=True)
 
         self._options = options
 
         self._server_host_keys = options.server_host_keys
         self._server_host_key_algs = list(options.server_host_keys.keys())
         self._known_client_hosts = options.known_client_hosts
         self._trust_client_host = options.trust_client_host
-        self._client_keys = options.authorized_client_keys
+        self._authorized_client_keys = options.authorized_client_keys
         self._allow_pty = options.allow_pty
         self._line_editor = options.line_editor
         self._line_history = options.line_history
         self._max_line_length = options.max_line_length
         self._rdns_lookup = options.rdns_lookup
         self._x11_forwarding = options.x11_forwarding
         self._x11_auth_path = options.x11_auth_path
         self._agent_forwarding = options.agent_forwarding
         self._process_factory = options.process_factory
         self._session_factory = options.session_factory
         self._encoding = options.encoding
         self._errors = options.errors
         self._sftp_factory = options.sftp_factory
+        self._sftp_version = options.sftp_version
         self._allow_scp = options.allow_scp
         self._window = options.window
         self._max_pktsize = options.max_pktsize
 
         if options.gss_host:
             try:
                 self._gss = GSSServer(options.gss_host)
                 self._gss_kex = options.gss_kex
                 self._gss_auth = options.gss_auth
                 self._gss_mic_auth = self._gss_auth
             except GSSError:
                 pass
 
-        self._server_host_key = None
-        self._key_options = {}
-        self._cert_options = None
+        self._server_host_key: Optional[SSHKeyPair] = None
+        self._key_options: _KeyOrCertOptions = {}
+        self._cert_options: Optional[_KeyOrCertOptions] = None
         self._kbdint_password_auth = False
 
-        self._agent_listener = None
+        self._agent_listener: Optional[SSHAgentListener] = None
 
-    def _cleanup(self, exc):
+    def _cleanup(self, exc: Optional[Exception]) -> None:
         """Clean up this server connection"""
 
         if self._agent_listener:
             self._agent_listener.close()
             self._agent_listener = None
 
         super()._cleanup(exc)
 
-    def _connection_made(self):
+    def _connection_made(self) -> None:
         """Handle the opening of a new connection"""
 
         self.logger.info('Accepted SSH client connection')
 
         if self._options.proxy_command:
             proxy_command = ' '.join(shlex.quote(arg) for arg in
                                      self._options.proxy_command)
             self.logger.info('  Proxy command: %s', proxy_command)
         else:
             self.logger.info('  Local address: %s',
                              (self._local_addr, self._local_port))
             self.logger.info('  Peer address: %s',
                              (self._peer_addr, self._peer_port))
 
-    async def _reload_config(self):
+    async def reload_config(self) -> None:
         """Re-evaluate config with updated match options"""
 
         if self._rdns_lookup:
             self._peer_host, _ = await self._loop.getnameinfo(
                 (self._peer_addr, self._peer_port), socket.NI_NUMERICSERV)
 
         options = SSHServerConnectionOptions(
@@ -4448,26 +4897,27 @@
         self._options = options
 
         self._host_based_auth = options.host_based_auth
         self._public_key_auth = options.public_key_auth
         self._kbdint_auth = options.kbdint_auth
         self._password_auth = options.password_auth
 
-        self._client_keys = options.authorized_client_keys
+        self._authorized_client_keys = options.authorized_client_keys
         self._allow_pty = options.allow_pty
         self._x11_forwarding = options.x11_forwarding
         self._agent_forwarding = options.agent_forwarding
 
         self._rekey_bytes = options.rekey_bytes
         self._rekey_seconds = options.rekey_seconds
 
         self._keepalive_count_max = options.keepalive_count_max
         self._keepalive_interval = options.keepalive_interval
 
-    def _choose_server_host_key(self, peer_host_key_algs):
+    def choose_server_host_key(self,
+                                peer_host_key_algs: Sequence[bytes]) -> bool:
         """Choose the server host key to use
 
            Given a list of host key algorithms supported by the client,
            select the first compatible server host key we have and return
            whether or not we were able to find a match.
 
         """
@@ -4479,72 +4929,78 @@
                     keypair.set_sig_algorithm(alg)
 
                 self._server_host_key = keypair
                 return True
 
         return False
 
-    def get_server_host_key(self):
+    def get_server_host_key(self) -> Optional[SSHKeyPair]:
         """Return the chosen server host key
 
            This method returns a keypair object containing the
            chosen server host key and a corresponding public key
            or certificate.
 
         """
 
         return self._server_host_key
 
-    def gss_kex_auth_supported(self):
+    def gss_kex_auth_supported(self) -> bool:
         """Return whether GSS key exchange authentication is supported"""
 
-        return self._gss_kex_auth and self._gss.complete
+        if self._gss_kex_auth:
+            assert self._gss is not None
+            return self._gss.complete
+        else:
+            return False
 
-    def gss_mic_auth_supported(self):
+    def gss_mic_auth_supported(self) -> bool:
         """Return whether GSS MIC authentication is supported"""
 
         return self._gss_mic_auth
 
-    async def validate_gss_principal(self, username, user_principal,
-                                     host_principal):
+    async def validate_gss_principal(self, username: str, user_principal: str,
+                                     host_principal: str) -> bool:
         """Validate the GSS principal name for the specified user
 
            Return whether the user principal acquired during GSS
            authentication is valid for the specified user.
 
         """
 
         result = self._owner.validate_gss_principal(username, user_principal,
                                                     host_principal)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[bool], result)
 
-        return result
+        return cast(bool, result)
 
-    def host_based_auth_supported(self):
+    def host_based_auth_supported(self) -> bool:
         """Return whether or not host based authentication is supported"""
 
         return (self._host_based_auth and
                 (bool(self._known_client_hosts) or
                  self._owner.host_based_auth_supported()))
 
-    async def validate_host_based_auth(self, username, key_data, client_host,
-                                       client_username, msg, signature):
+    async def validate_host_based_auth(self, username: str, key_data: bytes,
+                                       client_host: str, client_username: str,
+                                       msg: bytes, signature: bytes) -> bool:
         """Validate host based authentication for the specified host and user"""
 
         # Remove a trailing '.' from the client host if present
         if client_host[-1:] == '.':
             client_host = client_host[:-1]
 
         if self._trust_client_host:
             resolved_host = client_host
         else:
             resolved_host, _ = await self._loop.getnameinfo(
-                self.get_extra_info('peername'), socket.NI_NUMERICSERV)
+                cast(SockAddr, self.get_extra_info('peername')),
+                socket.NI_NUMERICSERV)
 
             if resolved_host != client_host:
                 self.logger.info('Client host mismatch: received %s, '
                                  'resolved %s', client_host, resolved_host)
 
         if self._known_client_hosts:
             self._match_known_hosts(self._known_client_hosts, resolved_host,
@@ -4561,149 +5017,159 @@
             self.logger.debug1('Invalid host-based auth signature')
             return False
 
         result = self._owner.validate_host_based_user(username, client_host,
                                                       client_username)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[bool], result)
 
-        return result
+        return cast(bool, result)
 
-    async def _validate_openssh_certificate(self, username, cert):
+    async def _validate_openssh_certificate(
+            self, username: str, cert: SSHOpenSSHCertificate) -> \
+                Optional[SSHKey]:
         """Validate an OpenSSH client certificate for the specified user"""
 
-        options = None
+        options: Optional[_KeyOrCertOptions] = None
 
-        if self._client_keys:
-            options = self._client_keys.validate(cert.signing_key,
-                                                 self._peer_host,
-                                                 self._peer_addr,
-                                                 cert.principals, ca=True)
+        if self._authorized_client_keys:
+            options = self._authorized_client_keys.validate(
+                cert.signing_key, self._peer_host,
+                self._peer_addr, cert.principals, ca=True)
 
         if options is None:
             result = self._owner.validate_ca_key(username, cert.signing_key)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[bool], result)
 
             if not result:
                 return None
 
             options = {}
 
         self._key_options = options
 
         if self.get_key_option('principals'):
-            username = None
+            username = ''
 
         try:
             cert.validate(CERT_TYPE_USER, username)
         except ValueError:
             return None
 
-        allowed_addresses = cert.options.get('source-address')
+        allowed_addresses = cast(Sequence[IPNetwork],
+                                 cert.options.get('source-address'))
         if allowed_addresses:
             ip = ip_address(self._peer_addr)
             if not any(ip in network for network in allowed_addresses):
                 return None
 
         self._cert_options = cert.options
 
         cert.key.set_touch_required(
             not (self.get_key_option('no-touch-required', False) and
                  self.get_certificate_option('no-touch-required', False)))
 
         return cert.key
 
-    async def _validate_x509_certificate_chain(self, username, cert):
+    async def _validate_x509_certificate_chain(
+            self, username: str, cert: SSHX509CertificateChain) -> \
+                Optional[SSHKey]:
         """Validate an X.509 client certificate for the specified user"""
 
-        if not self._client_keys:
+        if not self._authorized_client_keys:
             return None
 
         options, trusted_cert = \
-            self._client_keys.validate_x509(cert, self._peer_host,
-                                            self._peer_addr)
+            self._authorized_client_keys.validate_x509(
+                cert, self._peer_host, self._peer_addr)
 
         if options is None:
             return None
 
         self._key_options = options
 
         if self.get_key_option('principals'):
-            username = None
+            username = ''
+
+        assert self._x509_trusted_certs is not None
+        trusted_certs = list(self._x509_trusted_certs)
 
         if trusted_cert:
-            trusted_certs = self._x509_trusted_certs + [trusted_cert]
-        else:
-            trusted_certs = self._x509_trusted_certs
+            trusted_certs += [trusted_cert]
 
         try:
             cert.validate_chain(trusted_certs, self._x509_trusted_cert_paths,
-                                None, self._x509_purposes,
+                                set(), self._x509_purposes,
                                 user_principal=username)
         except ValueError:
             return None
 
         return cert.key
 
-    async def _validate_client_certificate(self, username, key_data):
+    async def _validate_client_certificate(
+            self, username: str, key_data: bytes) -> Optional[SSHKey]:
         """Validate a client certificate for the specified user"""
 
         try:
             cert = decode_ssh_certificate(key_data)
         except KeyImportError:
             return None
 
         if cert.is_x509_chain:
-            return await self._validate_x509_certificate_chain(username, cert)
+            return await self._validate_x509_certificate_chain(
+                username, cast(SSHX509CertificateChain, cert))
         else:
-            return await self._validate_openssh_certificate(username, cert)
+            return await self._validate_openssh_certificate(
+                username, cast(SSHOpenSSHCertificate, cert))
 
-    async def _validate_client_public_key(self, username, key_data):
+    async def _validate_client_public_key(self, username: str,
+                                          key_data: bytes) -> Optional[SSHKey]:
         """Validate a client public key for the specified user"""
 
         try:
             key = decode_ssh_public_key(key_data)
         except KeyImportError:
             return None
 
-        options = None
+        options: Optional[_KeyOrCertOptions] = None
 
-        if self._client_keys:
-            options = self._client_keys.validate(key, self._peer_host,
-                                                 self._peer_addr)
+        if self._authorized_client_keys:
+            options = self._authorized_client_keys.validate(
+                key, self._peer_host, self._peer_addr)
 
         if options is None:
             result = self._owner.validate_public_key(username, key)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[bool], result)
 
             if not result:
                 return None
 
             options = {}
 
         self._key_options = options
 
         key.set_touch_required(
             not self.get_key_option('no-touch-required', False))
 
         return key
 
-    def public_key_auth_supported(self):
+    def public_key_auth_supported(self) -> bool:
         """Return whether or not public key authentication is supported"""
 
         return (self._public_key_auth and
-                (bool(self._client_keys) or
+                (bool(self._authorized_client_keys) or
                  self._owner.public_key_auth_supported()))
 
-    async def validate_public_key(self, username, key_data, msg, signature):
+    async def validate_public_key(self, username: str, key_data: bytes,
+                                  msg: bytes, signature: bytes) -> bool:
         """Validate the public key or certificate for the specified user
 
            This method validates that the public key or certificate provided
            is allowed for the specified user. If msg and signature are
            provided, the key is used to also validate the message signature.
            It returns `True` when the key is allowed and the signature (if
            present) is valid. Otherwise, it returns `False`.
@@ -4716,110 +5182,130 @@
         if key is None:
             return False
         elif msg:
             return key.verify(String(self._session_id) + msg, signature)
         else:
             return True
 
-    def password_auth_supported(self):
+    def password_auth_supported(self) -> bool:
         """Return whether or not password authentication is supported"""
 
         return self._password_auth and self._owner.password_auth_supported()
 
-    async def validate_password(self, username, password):
+    async def validate_password(self, username: str, password: str) -> bool:
         """Return whether password is valid for this user"""
 
         result = self._owner.validate_password(username, password)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[bool], result)
 
-        return result
+        return cast(bool, result)
 
-    async def change_password(self, username, old_password, new_password):
+    async def change_password(self, username: str, old_password: str,
+                              new_password: str) -> bool:
         """Handle a password change request for a user"""
 
         result = self._owner.change_password(username, old_password,
                                              new_password)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[bool], result)
 
-        return result
+        return cast(bool, result)
 
-    def kbdint_auth_supported(self):
+    def kbdint_auth_supported(self) -> bool:
         """Return whether or not keyboard-interactive authentication
            is supported"""
 
         result = self._kbdint_auth and self._owner.kbdint_auth_supported()
 
         if result is True:
             return True
         elif (result is NotImplemented and
               self._owner.password_auth_supported()):
             self._kbdint_password_auth = True
             return True
         else:
             return False
 
-    async def get_kbdint_challenge(self, username, lang, submethods):
+    async def get_kbdint_challenge(self, username: str, lang: str,
+                                   submethods: str) -> KbdIntChallenge:
         """Return a keyboard-interactive auth challenge"""
 
         if self._kbdint_password_auth:
-            result = ('', '', DEFAULT_LANG, (('Password:', False),))
+            challenge: KbdIntChallenge = ('', '', DEFAULT_LANG,
+                                          (('Password:', False),))
         else:
             result = self._owner.get_kbdint_challenge(username, lang,
                                                       submethods)
 
             if inspect.isawaitable(result):
-                result = await result
+                challenge = await cast(Awaitable[KbdIntChallenge], result)
+            else:
+                challenge = cast(KbdIntChallenge, result)
 
-        return result
+        return challenge
 
-    async def validate_kbdint_response(self, username, responses):
+    async def validate_kbdint_response(self, username: str,
+                                       responses: KbdIntResponse) -> \
+            KbdIntChallenge:
         """Return whether the keyboard-interactive response is valid
            for this user"""
 
+        next_challenge: KbdIntChallenge
+
         if self._kbdint_password_auth:
             if len(responses) != 1:
                 return False
 
             try:
-                result = self._owner.validate_password(username, responses[0])
+                pw_result = self._owner.validate_password(
+                    username, responses[0])
 
-                if inspect.isawaitable(result):
-                    result = await result
+                if inspect.isawaitable(pw_result):
+                    next_challenge = await cast(Awaitable[bool], pw_result)
+                else:
+                    next_challenge = cast(bool, pw_result)
             except PasswordChangeRequired:
                 # Don't support password change requests for now in
                 # keyboard-interactive auth
-                result = False
+                next_challenge = False
         else:
             result = self._owner.validate_kbdint_response(username, responses)
 
             if inspect.isawaitable(result):
-                result = await result
+                next_challenge = await cast(Awaitable[KbdIntChallenge], result)
+            else:
+                next_challenge = cast(KbdIntChallenge, result)
 
-        return result
+        return next_challenge
 
-    def _process_session_open(self, packet):
+    def _process_session_open(self, packet: SSHPacket) -> \
+            Tuple[SSHServerChannel, SSHServerSession]:
         """Process an incoming session open request"""
 
         packet.check_end()
 
+        chan: SSHServerChannel
+        session: SSHServerSession
+
         if self._process_factory or self._session_factory or self._sftp_factory:
             chan = self.create_server_channel(self._encoding, self._errors,
                                               self._window, self._max_pktsize)
 
             if self._process_factory:
                 session = SSHServerProcess(self._process_factory,
                                            self._sftp_factory,
+                                           self._sftp_version,
                                            self._allow_scp)
             else:
                 session = SSHServerStreamSession(self._session_factory,
                                                  self._sftp_factory,
+                                                 self._sftp_version,
                                                  self._allow_scp)
         else:
             result = self._owner.session_requested()
 
             if not result:
                 raise ChannelOpenError(OPEN_CONNECT_FAILED, 'Session refused')
 
@@ -4827,42 +5313,44 @@
                 chan, result = result
             else:
                 chan = self.create_server_channel(self._encoding, self._errors,
                                                   self._window,
                                                   self._max_pktsize)
 
             if callable(result):
-                session = SSHServerStreamSession(result, None, False)
+                session = SSHServerStreamSession(result)
             else:
-                session = result
+                session = cast(SSHServerSession, result)
 
         return chan, session
 
-    def _process_direct_tcpip_open(self, packet):
+    def _process_direct_tcpip_open(self, packet: SSHPacket) -> \
+            Tuple[SSHTCPChannel[bytes], SSHTCPSession[bytes]]:
         """Process an incoming direct TCP/IP open request"""
 
-        dest_host = packet.get_string()
+        dest_host_bytes = packet.get_string()
         dest_port = packet.get_uint32()
-        orig_host = packet.get_string()
+        orig_host_bytes = packet.get_string()
         orig_port = packet.get_uint32()
         packet.check_end()
 
         try:
-            dest_host = dest_host.decode('utf-8')
-            orig_host = orig_host.decode('utf-8')
+            dest_host = dest_host_bytes.decode('utf-8')
+            orig_host = orig_host_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid direct TCP/IP channel '
                                 'open request') from None
 
         if not self.check_key_permission('port-forwarding') or \
            not self.check_certificate_permission('port-forwarding'):
             raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
                                    'Port forwarding not permitted')
 
-        permitted_opens = self.get_key_option('permitopen')
+        permitted_opens = cast(Set[Tuple[str, int]],
+                               self.get_key_option('permitopen'))
 
         if permitted_opens and \
            (dest_host, dest_port) not in permitted_opens and \
            (dest_host, None) not in permitted_opens:
             raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
                                    'Port forwarding not permitted to %s '
                                    'port %s' % (dest_host, dest_port))
@@ -4870,66 +5358,69 @@
         result = self._owner.connection_requested(dest_host, dest_port,
                                                   orig_host, orig_port)
 
         if not result:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, 'Connection refused')
 
         if result is True:
-            result = self.forward_connection(dest_host, dest_port)
+            result = cast(SSHTCPSession[bytes],
+                          self.forward_connection(dest_host, dest_port))
 
         if isinstance(result, tuple):
             chan, result = result
         else:
             chan = self.create_tcp_channel()
 
+        session: SSHTCPSession[bytes]
+
         if callable(result):
-            session = SSHTCPStreamSession(result)
+            session = SSHTCPStreamSession[bytes](result)
         else:
-            session = result
+            session = cast(SSHTCPSession[bytes], result)
 
         self.logger.info('Accepted direct TCP connection request to %s',
                          (dest_host, dest_port))
         self.logger.info('  Client address: %s', (orig_host, orig_port))
 
         chan.set_inbound_peer_names(dest_host, dest_port, orig_host, orig_port)
 
         return chan, session
 
-    def _process_tcpip_forward_global_request(self, packet):
+    def _process_tcpip_forward_global_request(self, packet: SSHPacket) -> None:
         """Process an incoming TCP/IP port forwarding request"""
 
-        listen_host = packet.get_string()
+        listen_host_bytes = packet.get_string()
         listen_port = packet.get_uint32()
         packet.check_end()
 
         try:
-            listen_host = listen_host.decode('utf-8').lower()
+            listen_host = listen_host_bytes.decode('utf-8').lower()
         except UnicodeDecodeError:
             raise ProtocolError('Invalid TCP/IP forward request') from None
 
         if not self.check_key_permission('port-forwarding') or \
            not self.check_certificate_permission('port-forwarding'):
             self.logger.info('Request for TCP listener on %s denied: port '
                              'forwarding not permitted',
                              (listen_host, listen_port))
 
             self._report_global_response(False)
             return
 
-        result = self._owner.server_requested(listen_host, listen_port)
+        self.create_task(self._finish_port_forward(listen_host, listen_port))
 
-        self.create_task(self._finish_port_forward(result, listen_host,
-                                                   listen_port))
-
-    async def _finish_port_forward(self, listener, listen_host, listen_port):
+    async def _finish_port_forward(self, listen_host: str,
+                                   listen_port: int) -> None:
         """Finish processing a TCP/IP port forwarding request"""
 
+        listener = self._owner.server_requested(listen_host, listen_port)
+
         try:
             if inspect.isawaitable(listener):
-                listener = await listener
+                listener = await cast(Awaitable[_ListenerArg], listener)
 
             if listener is True:
                 listener = await self.forward_local_port(
                     listen_host, listen_port, listen_host, listen_port)
         except OSError:
             self.logger.debug1('Failed to create TCP listener')
             self._report_global_response(False)
@@ -4938,36 +5429,39 @@
         if not listener:
             self.logger.info('Request for TCP listener on %s denied by '
                              'application', (listen_host, listen_port))
 
             self._report_global_response(False)
             return
 
+        listener: SSHListener
+        result: Union[bool, bytes]
+
         if listen_port == 0:
             listen_port = listener.get_port()
             result = UInt32(listen_port)
         else:
             result = True
 
-        self._local_listeners[listen_host, listen_port] = listener
-
         self.logger.info('Created TCP listener on %s',
                          (listen_host, listen_port))
 
+        self._local_listeners[listen_host, listen_port] = listener
         self._report_global_response(result)
 
-    def _process_cancel_tcpip_forward_global_request(self, packet):
+    def _process_cancel_tcpip_forward_global_request(
+            self, packet: SSHPacket) -> None:
         """Process a request to cancel TCP/IP port forwarding"""
 
-        listen_host = packet.get_string()
+        listen_host_bytes = packet.get_string()
         listen_port = packet.get_uint32()
         packet.check_end()
 
         try:
-            listen_host = listen_host.decode('utf-8').lower()
+            listen_host = listen_host_bytes.decode('utf-8').lower()
         except UnicodeDecodeError:
             raise ProtocolError('Invalid TCP/IP cancel '
                                 'forward request') from None
 
         try:
             listener = self._local_listeners.pop((listen_host, listen_port))
         except KeyError:
@@ -4976,27 +5470,29 @@
         self.logger.info('Closed TCP listener on %s',
                          (listen_host, listen_port))
 
         listener.close()
 
         self._report_global_response(True)
 
-    def _process_direct_streamlocal_at_openssh_dot_com_open(self, packet):
+    def _process_direct_streamlocal_at_openssh_dot_com_open(
+            self, packet: SSHPacket) -> \
+                Tuple[SSHUNIXChannel[bytes], SSHUNIXSession[bytes]]:
         """Process an incoming direct UNIX domain socket open request"""
 
-        dest_path = packet.get_string()
+        dest_path_bytes = packet.get_string()
 
         # OpenSSH appears to have a bug which sends this extra data
         _ = packet.get_string()                         # originator
         _ = packet.get_uint32()                         # originator_port
 
         packet.check_end()
 
         try:
-            dest_path = dest_path.decode('utf-8')
+            dest_path = dest_path_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid direct UNIX domain channel '
                                 'open request') from None
 
         if not self.check_key_permission('port-forwarding') or \
            not self.check_certificate_permission('port-forwarding'):
             raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
@@ -5004,91 +5500,96 @@
 
         result = self._owner.unix_connection_requested(dest_path)
 
         if not result:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, 'Connection refused')
 
         if result is True:
-            result = self.forward_unix_connection(dest_path)
+            result = cast(SSHUNIXSession[bytes],
+                          self.forward_unix_connection(dest_path))
 
         if isinstance(result, tuple):
             chan, result = result
         else:
             chan = self.create_unix_channel()
 
+        session: SSHUNIXSession[bytes]
+
         if callable(result):
-            session = SSHUNIXStreamSession(result)
+            session = SSHUNIXStreamSession[bytes](result)
         else:
-            session = result
+            session = cast(SSHUNIXSession[bytes], result)
 
         self.logger.info('Accepted direct UNIX connection on %s', dest_path)
 
         chan.set_inbound_peer_names(dest_path)
 
         return chan, session
 
-    def _process_streamlocal_forward_at_openssh_dot_com_global_request(self,
-                                                                       packet):
+    def _process_streamlocal_forward_at_openssh_dot_com_global_request(
+            self, packet: SSHPacket) -> None:
         """Process an incoming UNIX domain socket forwarding request"""
 
-        listen_path = packet.get_string()
+        listen_path_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            listen_path = listen_path.decode('utf-8')
+            listen_path = listen_path_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid UNIX domain socket '
                                 'forward request') from None
 
         if not self.check_key_permission('port-forwarding') or \
            not self.check_certificate_permission('port-forwarding'):
             self.logger.info('Request for UNIX listener on %s denied: port '
                              'forwarding not permitted', listen_path)
 
             self._report_global_response(False)
             return
 
-        result = self._owner.unix_server_requested(listen_path)
+        self.create_task(self._finish_path_forward(listen_path))
 
-        if not result:
-            self.logger.info('Request for UNIX listener on %s denied by '
-                             'application', listen_path)
-
-            self._report_global_response(False)
-            return
-
-        self.logger.info('Creating UNIX listener on %s', listen_path)
-
-        if result is True:
-            result = self.forward_local_path(listen_path, listen_path)
-
-        self.create_task(self._finish_path_forward(result, listen_path))
-
-    async def _finish_path_forward(self, listener, listen_path):
+    async def _finish_path_forward(self, listen_path: str) -> None:
         """Finish processing a UNIX domain socket forwarding request"""
 
+        listener = self._owner.unix_server_requested(listen_path)
+
         try:
             if inspect.isawaitable(listener):
-                listener = await listener
+                listener = await cast(Awaitable[_ListenerArg], listener)
 
-            self._local_listeners[listen_path] = listener
-            self._report_global_response(True)
+            if listener is True:
+                listener = await self.forward_local_path(listen_path,
+                                                         listen_path)
         except OSError:
             self.logger.debug1('Failed to create UNIX listener')
             self._report_global_response(False)
+            return
+
+        if not listener:
+            self.logger.info('Request for UNIX listener on %s denied by '
+                             'application', listen_path)
+
+            self._report_global_response(False)
+            return
+
+        self.logger.info('Created UNIX listener on %s', listen_path)
+
+        self._local_listeners[listen_path] = cast(SSHListener, listener)
+        self._report_global_response(True)
 
     def _process_cancel_streamlocal_forward_at_openssh_dot_com_global_request(
-            self, packet):
+            self, packet: SSHPacket) -> None:
         """Process a request to cancel UNIX domain socket forwarding"""
 
-        listen_path = packet.get_string()
+        listen_path_bytes = packet.get_string()
         packet.check_end()
 
         try:
-            listen_path = listen_path.decode('utf-8')
+            listen_path = listen_path_bytes.decode('utf-8')
         except UnicodeDecodeError:
             raise ProtocolError('Invalid UNIX domain cancel '
                                 'forward request') from None
 
         try:
             listener = self._local_listeners.pop(listen_path)
         except KeyError:
@@ -5096,15 +5597,17 @@
 
         self.logger.info('Closed UNIX listener on %s', listen_path)
 
         listener.close()
 
         self._report_global_response(True)
 
-    async def attach_x11_listener(self, chan, auth_proto, auth_data, screen):
+    async def attach_x11_listener(self, chan: SSHServerChannel[AnyStr],
+                                  auth_proto: bytes, auth_data: bytes,
+                                  screen: int) -> Optional[str]:
         """Attach a channel to a remote X11 display"""
 
         if (not self._x11_forwarding or
                 not self.check_key_permission('X11-forwarding') or
                 not self.check_certificate_permission('X11-forwarding')):
             self.logger.info('X11 forwarding request denied: X11 '
                              'forwarding not permitted')
@@ -5116,22 +5619,22 @@
                 self, self._loop, self._x11_auth_path, auth_proto, auth_data)
 
         if self._x11_listener:
             return self._x11_listener.attach(chan, screen)
         else:
             return None
 
-    def detach_x11_listener(self, chan):
+    def detach_x11_listener(self, chan: SSHChannel[AnyStr]) -> None:
         """Detach a session from a remote X11 listener"""
 
         if self._x11_listener:
             if self._x11_listener.detach(chan):
                 self._x11_listener = None
 
-    async def create_agent_listener(self):
+    async def create_agent_listener(self) -> bool:
         """Create a listener for forwarding ssh-agent connections"""
 
         if (not self._agent_forwarding or
                 not self.check_key_permission('agent-forwarding') or
                 not self.check_certificate_permission('agent-forwarding')):
             self.logger.info('Agent forwarding request denied: Agent '
                              'forwarding not permitted')
@@ -5150,23 +5653,23 @@
 
             self._agent_listener = SSHAgentListener(tempdir, path,
                                                     unix_listener)
             return True
         except OSError:
             return False
 
-    def get_agent_path(self):
+    def get_agent_path(self) -> Optional[str]:
         """Return the path of the ssh-agent listener, if one exists"""
 
         if self._agent_listener:
             return self._agent_listener.get_path()
         else:
             return None
 
-    def send_auth_banner(self, msg, lang=DEFAULT_LANG):
+    def send_auth_banner(self, msg: str, lang: str = DEFAULT_LANG) -> None:
         """Send an authentication banner to the client
 
            This method can be called to send an authentication banner to
            the client, displaying information while authentication is
            in progress. It is an error to call this method after the
            authentication is complete.
 
@@ -5184,15 +5687,15 @@
         if self._auth_complete:
             raise OSError('Authentication already completed')
 
         self.logger.debug1('Sending authentication banner')
 
         self.send_packet(MSG_USERAUTH_BANNER, String(msg), String(lang))
 
-    def set_authorized_keys(self, authorized_keys):
+    def set_authorized_keys(self, authorized_keys: _AuthKeysArg) -> None:
         """Set the keys trusted for client public key authentication
 
            This method can be called to set the trusted user and
            CA keys for client public key authentication. It should
            generally be called from the :meth:`begin_auth
            <SSHServer.begin_auth>` method of :class:`SSHServer` to
            set the appropriate keys for the user attempting to
@@ -5203,17 +5706,17 @@
            :type authorized_keys: *see* :ref:`SpecifyingAuthorizedKeys`
 
         """
 
         if isinstance(authorized_keys, (str, list)):
             authorized_keys = read_authorized_keys(authorized_keys)
 
-        self._client_keys = authorized_keys
+        self._authorized_client_keys = authorized_keys
 
-    def get_key_option(self, option, default=None):
+    def get_key_option(self, option: str, default: object = None) -> object:
         """Return option from authorized_keys
 
            If a client key or certificate was presented during authentication,
            this method returns the value of the requested option in the
            corresponding authorized_keys entry if it was set. Otherwise, it
            returns the default value provided.
 
@@ -5240,15 +5743,15 @@
 
            :returns: The value of the option in authorized_keys, if set
 
         """
 
         return self._key_options.get(option, default)
 
-    def check_key_permission(self, permission):
+    def check_key_permission(self, permission: str) -> bool:
         """Check permissions in authorized_keys
 
            If a client key or certificate was presented during
            authentication, this method returns whether the specified
            permission is allowed by the corresponding authorized_keys
            entry. By default, all permissions are granted, but they
            can be revoked by specifying an option starting with
@@ -5275,15 +5778,16 @@
 
            :returns: A `bool` indicating if the permission is granted.
 
         """
 
         return not self._key_options.get('no-' + permission, False)
 
-    def get_certificate_option(self, option, default=None):
+    def get_certificate_option(self, option: str,
+                               default: object = None) -> object:
         """Return option from user certificate
 
            If a user certificate was presented during authentication,
            this method returns the value of the requested option in
            the certificate if it was set. Otherwise, it returns the
            default value provided.
 
@@ -5304,15 +5808,15 @@
         """
 
         if self._cert_options is not None:
             return self._cert_options.get(option, default)
         else:
             return default
 
-    def check_certificate_permission(self, permission):
+    def check_certificate_permission(self, permission: str) -> bool:
         """Check permissions in user certificate
 
            If a user certificate was presented during authentication,
            this method returns whether the specified permission was
            granted in the certificate. Otherwise, it acts as if all
            permissions are granted and returns `True`.
 
@@ -5333,21 +5837,24 @@
            :type permission: `str`
 
            :returns: A `bool` indicating if the permission is granted.
 
         """
 
         if self._cert_options is not None:
-            return self._cert_options.get('permit-' + permission, False)
+            return cast(bool, self._cert_options.get('permit-' + permission,
+                                                     False))
         else:
             return True
 
-    def create_server_channel(self, encoding='utf-8', errors='strict',
-                              window=_DEFAULT_WINDOW,
-                              max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def create_server_channel(self, encoding: Optional[str] = 'utf-8',
+                              errors: str = 'strict',
+                              window: int = _DEFAULT_WINDOW,
+                              max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+            SSHServerChannel:
         """Create an SSH server channel for a new SSH session
 
            This method can be called by :meth:`session_requested()
            <SSHServer.session_requested>` to create an
            :class:`SSHServerChannel` with the desired encoding, Unicode
            error handling strategy, window, and max packet size for a
            newly created SSH server session.
@@ -5373,18 +5880,21 @@
         """
 
         return SSHServerChannel(self, self._loop, self._allow_pty,
                                 self._line_editor, self._line_history,
                                 self._max_line_length, encoding, errors,
                                 window, max_pktsize)
 
-    async def create_connection(self, session_factory, remote_host, remote_port,
-                                orig_host='', orig_port=0, *, encoding=None,
-                                errors='strict', window=_DEFAULT_WINDOW,
-                                max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_connection(
+            self, session_factory: SSHTCPSessionFactory[AnyStr],
+            remote_host: str, remote_port: int, orig_host: str = '',
+            orig_port: int = 0, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHTCPChannel[AnyStr], SSHTCPSession[AnyStr]]:
         """Create an SSH TCP forwarded connection
 
            This method is a coroutine which can be called to notify the
            client about a new inbound TCP connection arriving on the
            specified remote host and port. If the connection is successfully
            opened, a new SSH channel will be opened with data being handled
            by a :class:`SSHTCPSession` object created by `session_factory`.
@@ -5399,15 +5909,15 @@
            set, an optional errors argument can be passed in to select
            what Unicode error handling strategy to use.
 
            Other optional arguments include the SSH receive window size and
            max packet size which default to 2 MB and 32 KB, respectively.
 
            :param session_factory:
-               A `callable` which returns an :class:`SSHClientSession` object
+               A `callable` which returns an :class:`SSHTCPSession` object
                that will be created to handle activity on this session
            :param remote_host:
                The hostname or address the connection was received on
            :param remote_port:
                The port number the connection was received on
            :param orig_host: (optional)
                The hostname or address of the client requesting the connection
@@ -5442,15 +5952,16 @@
         chan = self.create_tcp_channel(encoding, errors, window, max_pktsize)
 
         session = await chan.accept(session_factory, remote_host,
                                     remote_port, orig_host, orig_port)
 
         return chan, session
 
-    async def open_connection(self, *args, **kwargs):
+    async def open_connection(self, *args: object, **kwargs: object) -> \
+            Tuple[SSHReader, SSHWriter]:
         """Open an SSH TCP forwarded connection
 
            This method is a coroutine wrapper around :meth:`create_connection`
            designed to provide a "high-level" stream interface for creating
            an SSH TCP forwarded connection. Instead of taking a
            `session_factory` argument for constructing an object which will
            handle activity on the session via callbacks, it returns
@@ -5461,23 +5972,27 @@
            to :meth:`create_connection` are supported and have the same
            meaning here.
 
            :returns: an :class:`SSHReader` and :class:`SSHWriter`
 
         """
 
-        chan, session = await self.create_connection(SSHTCPStreamSession,
-                                                     *args, **kwargs)
+        chan, session = await self.create_connection(
+            SSHTCPStreamSession, *args, **kwargs) # type: ignore
+
+        session: SSHTCPStreamSession
 
         return SSHReader(session, chan), SSHWriter(session, chan)
 
-    async def create_unix_connection(self, session_factory, remote_path, *,
-                                     encoding=None, errors='strict',
-                                     window=_DEFAULT_WINDOW,
-                                     max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_unix_connection(
+            self, session_factory: SSHUNIXSessionFactory[AnyStr],
+            remote_path: str, *, encoding: Optional[str] = None,
+            errors: str = 'strict', window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHUNIXChannel[AnyStr], SSHUNIXSession[AnyStr]]:
         """Create an SSH UNIX domain socket forwarded connection
 
            This method is a coroutine which can be called to notify the
            client about a new inbound UNIX domain socket connection arriving
            on the specified remote path. If the connection is successfully
            opened, a new SSH channel will be opened with data being handled
            by a :class:`SSHUNIXSession` object created by `session_factory`.
@@ -5489,15 +6004,15 @@
            set, an optional errors argument can be passed in to select
            what Unicode error handling strategy to use.
 
            Other optional arguments include the SSH receive window size and
            max packet size which default to 2 MB and 32 KB, respectively.
 
            :param session_factory:
-               A `callable` which returns an :class:`SSHClientSession` object
+               A `callable` which returns an :class:`SSHUNIXSession` object
                that will be created to handle activity on this session
            :param remote_path:
                The path the connection was received on
            :param encoding: (optional)
                The Unicode encoding to use for data exchanged on the connection
            :param errors: (optional)
                The error handling strategy to apply on encode/decode errors
@@ -5520,15 +6035,16 @@
 
         chan = self.create_unix_channel(encoding, errors, window, max_pktsize)
 
         session = await chan.accept(session_factory, remote_path)
 
         return chan, session
 
-    async def open_unix_connection(self, *args, **kwargs):
+    async def open_unix_connection(self, *args: object, **kwargs: object) -> \
+            Tuple[SSHReader, SSHWriter]:
         """Open an SSH UNIX domain socket forwarded connection
 
            This method is a coroutine wrapper around
            :meth:`create_unix_connection` designed to provide a "high-level"
            stream interface for creating an SSH UNIX domain socket forwarded
            connection. Instead of taking a `session_factory` argument for
            constructing an object which will handle activity on the session
@@ -5540,156 +6056,225 @@
            meaning here.
 
            :returns: an :class:`SSHReader` and :class:`SSHWriter`
 
         """
 
         chan, session = \
-            await self.create_unix_connection(SSHUNIXStreamSession,
-                                              *args, **kwargs)
+            await self.create_unix_connection(
+                SSHUNIXStreamSession, *args, **kwargs) # type: ignore
+
+        session: SSHUNIXStreamSession
 
         return SSHReader(session, chan), SSHWriter(session, chan)
 
-    async def create_x11_connection(self, session_factory, orig_host='',
-                                    orig_port=0, *, window=_DEFAULT_WINDOW,
-                                    max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_x11_connection(
+            self, session_factory: SSHTCPSessionFactory[bytes],
+            orig_host: str = '', orig_port: int = 0, *,
+            window: int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHX11Channel, SSHTCPSession[bytes]]:
         """Create an SSH X11 forwarded connection"""
 
         self.logger.info('Opening forwarded X11 connection')
 
         chan = self.create_x11_channel(window, max_pktsize)
 
         session = await chan.open(session_factory, orig_host, orig_port)
 
         return chan, session
 
-    async def create_agent_connection(self, session_factory, *,
-                                      window=_DEFAULT_WINDOW,
-                                      max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    async def create_agent_connection(
+            self, session_factory: SSHUNIXSessionFactory[bytes], *,
+            window:int = _DEFAULT_WINDOW,
+            max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> \
+                Tuple[SSHAgentChannel, SSHUNIXSession[bytes]]:
         """Create a forwarded ssh-agent connection back to the client"""
 
         if not self._agent_listener:
             raise ChannelOpenError(OPEN_ADMINISTRATIVELY_PROHIBITED,
                                    'Agent forwarding not permitted')
 
         self.logger.info('Opening forwarded agent connection')
 
         chan = self.create_agent_channel(window, max_pktsize)
 
         session = await chan.open(session_factory)
 
         return chan, session
 
-    async def open_agent_connection(self):
+    async def open_agent_connection(self) -> \
+            Tuple[SSHReader[bytes], SSHWriter[bytes]]:
         """Open a forwarded ssh-agent connection back to the client"""
 
         chan, session = \
             await self.create_agent_connection(SSHUNIXStreamSession)
 
-        return SSHReader(session, chan), SSHWriter(session, chan)
+        session: SSHUNIXStreamSession[bytes]
+
+        return SSHReader[bytes](session, chan), SSHWriter[bytes](session, chan)
 
 
 class SSHConnectionOptions(Options):
     """SSH connection options"""
 
-    def __init__(self, options=None, **kwargs):
+    config: SSHConfig
+    waiter: Optional[asyncio.Future]
+    protocol_factory: _ProtocolFactory
+    version: bytes
+    host: str
+    port: int
+    tunnel: object
+    proxy_command: Optional[Sequence[str]]
+    family: int
+    local_addr: HostPort
+    tcp_keepalive: bool
+    kex_algs: Sequence[bytes]
+    encryption_algs: Sequence[bytes]
+    mac_algs: Sequence[bytes]
+    compression_algs: Sequence[bytes]
+    signature_algs: Sequence[bytes]
+    host_based_auth: bool
+    public_key_auth: bool
+    kbdint_auth: bool
+    password_auth: bool
+    x509_trusted_certs: Optional[Sequence[SSHX509Certificate]]
+    x509_trusted_cert_paths: Sequence[FilePath]
+    x509_purposes: Union[None, str, Sequence[str]]
+    rekey_bytes: int
+    rekey_seconds: float
+    connect_timeout: Optional[float]
+    login_timeout: float
+    keepalive_internal: float
+    keepalive_count_max: int
+
+    def __init__(self, options: Optional['SSHConnectionOptions'] = None,
+                 **kwargs: object):
         last_config = options.config if options else None
         super().__init__(options=options, last_config=last_config, **kwargs)
 
     # pylint: disable=arguments-differ
-    def prepare(self, config, protocol_factory, version, host, port, tunnel,
-                passphrase, proxy_command, family, local_addr, tcp_keepalive,
-                kex_algs, encryption_algs, mac_algs, compression_algs,
-                signature_algs, host_based_auth, public_key_auth, kbdint_auth,
-                password_auth, x509_trusted_certs, x509_trusted_cert_paths,
-                x509_purposes, rekey_bytes, rekey_seconds, connect_timeout,
-                login_timeout, keepalive_interval, keepalive_count_max):
+    def prepare(self, config: SSHConfig, # type: ignore
+                protocol_factory: _ProtocolFactory, version: _VersionArg,
+                host: str, port: DefTuple[int], tunnel: object,
+                passphrase: Optional[BytesOrStr],
+                proxy_command: DefTuple[_ProxyCommand], family: DefTuple[int],
+                local_addr: DefTuple[HostPort], tcp_keepalive: DefTuple[bool],
+                kex_algs: _AlgsArg, encryption_algs: _AlgsArg,
+                mac_algs: _AlgsArg, compression_algs: _AlgsArg,
+                signature_algs: _AlgsArg, host_based_auth: _AuthArg,
+                public_key_auth: _AuthArg, kbdint_auth: _AuthArg,
+                password_auth: _AuthArg, x509_trusted_certs: CertListArg,
+                x509_trusted_cert_paths: Sequence[FilePath],
+                x509_purposes: X509CertPurposes,
+                rekey_bytes: DefTuple[Union[int, str]],
+                rekey_seconds: DefTuple[Union[float, str]],
+                connect_timeout: Optional[Union[float, str]],
+                login_timeout: Union[float, str],
+                keepalive_interval: Union[float, str],
+                keepalive_count_max: int) -> None:
         """Prepare common connection configuration options"""
 
         self.config = config
         self.protocol_factory = protocol_factory
         self.version = _validate_version(version)
 
-        self.host = config.get('Hostname', host)
-        self.port = port if port != () else config.get('Port', DEFAULT_PORT)
+        self.host = cast(str, config.get('Hostname', host))
+        self.port = cast(int, port if port != () else
+            config.get('Port', DEFAULT_PORT))
 
         self.tunnel = tunnel if tunnel != () else config.get('ProxyJump')
         self.passphrase = passphrase
 
         if isinstance(proxy_command, str):
             proxy_command = shlex.split(proxy_command)
 
-        self.proxy_command = proxy_command or config.get('ProxyCommand')
+        self.proxy_command = proxy_command if proxy_command != () else \
+            cast(Sequence[str], config.get('ProxyCommand'))
+
+        self.family = cast(int, family if family != () else
+            config.get('AddressFamily', socket.AF_UNSPEC))
+
+        bind_addr = config.get('BindAddress')
+
+        self.local_addr = cast(HostPort, local_addr if local_addr != ()
+            else (bind_addr, 0) if bind_addr else None)
 
-        self.family = family if family != () else \
-            config.get('AddressFamily', socket.AF_UNSPEC)
-        self.local_addr = local_addr if local_addr != () else \
-            (config.get('BindAddress'), 0)
-        self.tcp_keepalive = tcp_keepalive if tcp_keepalive != () else \
-            config.get('TCPKeepAlive', True)
+        self.tcp_keepalive = cast(bool, tcp_keepalive if tcp_keepalive != ()
+            else config.get('TCPKeepAlive', True))
 
         self.kex_algs, self.encryption_algs, self.mac_algs, \
         self.compression_algs, self.signature_algs = \
             _validate_algs(config, kex_algs, encryption_algs, mac_algs,
                            compression_algs, signature_algs,
                            x509_trusted_certs is not None)
 
-        if host_based_auth == ():
-            host_based_auth = config.get('HostbasedAuthentication', True)
+        self.host_based_auth = \
+            cast(bool, host_based_auth if host_based_auth != () else
+                config.get('HostbasedAuthentication', True))
+
+        self.public_key_auth = \
+            cast(bool, public_key_auth if public_key_auth != () else
+                config.get('PubkeyAuthentication', True))
 
-        if public_key_auth == ():
-            public_key_auth = config.get('PubkeyAuthentication', True)
-
-        if kbdint_auth == ():
-            kbdint_auth = \
+        self.kbdint_auth = \
+            cast(bool, kbdint_auth if kbdint_auth != () else
                 config.get('KbdInteractiveAuthentication',
-                           config.get('ChallengeResponseAuthentication', True))
-
-        if password_auth == ():
-            password_auth = config.get('PasswordAuthentication', True)
+                    config.get('ChallengeResponseAuthentication', True)))
 
-        self.host_based_auth = host_based_auth
-        self.public_key_auth = public_key_auth
-        self.kbdint_auth = kbdint_auth
-        self.password_auth = password_auth
+        self.password_auth = \
+            cast(bool, password_auth if password_auth != () else
+                config.get('PasswordAuthentication', True))
 
         if x509_trusted_certs is not None:
-            x509_trusted_certs = load_certificates(x509_trusted_certs)
+            certs = load_certificates(x509_trusted_certs)
+
+            for cert in certs:
+                if not cert.is_x509:
+                    raise ValueError('OpenSSH certificates not allowed '
+                                    'in X.509 trusted certs')
+
+            x509_trusted_certs = cast(Sequence[SSHX509Certificate], certs)
 
         if x509_trusted_cert_paths:
             for path in x509_trusted_cert_paths:
                 if not Path(path).is_dir():
                     raise ValueError('Path not a directory: ' + str(path))
 
         self.x509_trusted_certs = x509_trusted_certs
         self.x509_trusted_cert_paths = x509_trusted_cert_paths
         self.x509_purposes = x509_purposes
 
         config_rekey_bytes, config_rekey_seconds = \
-            config.get('RekeyLimit', ((), ()))
+            cast(Tuple[DefTuple[int], DefTuple[int]],
+                 config.get('RekeyLimit', ((), ())))
 
         if rekey_bytes == ():
             rekey_bytes = config_rekey_bytes
 
         if rekey_bytes == ():
             rekey_bytes = _DEFAULT_REKEY_BYTES
         elif isinstance(rekey_bytes, str):
             rekey_bytes = parse_byte_count(rekey_bytes)
 
+        rekey_bytes: int
+
         if rekey_bytes <= 0:
             raise ValueError('Rekey bytes cannot be negative or zero')
 
         if rekey_seconds == ():
             rekey_seconds = config_rekey_seconds
 
         if rekey_seconds == ():
             rekey_seconds = _DEFAULT_REKEY_SECONDS
         elif isinstance(rekey_seconds, str):
             rekey_seconds = parse_time_interval(rekey_seconds)
 
+        rekey_seconds: float
+
         if rekey_seconds and rekey_seconds <= 0:
             raise ValueError('Rekey seconds cannot be negative or zero')
 
         if isinstance(connect_timeout, str):
             connect_timeout = parse_time_interval(connect_timeout)
 
         if connect_timeout and connect_timeout < 0:
@@ -5706,15 +6291,15 @@
 
         if keepalive_interval and keepalive_interval < 0:
             raise ValueError('Keepalive interval cannot be negative')
 
         if keepalive_count_max <= 0:
             raise ValueError('Keepalive count max cannot be negative or zero')
 
-        self.rekey_bytes = int(rekey_bytes)
+        self.rekey_bytes = rekey_bytes
         self.rekey_seconds = rekey_seconds
         self.connect_timeout = connect_timeout or None
         self.login_timeout = login_timeout
         self.keepalive_interval = keepalive_interval
         self.keepalive_count_max = keepalive_count_max
 
 
@@ -5818,21 +6403,23 @@
            the local IP address of the SSH connection will be used.
        :param client_username: (optional)
            The local username to use when performing host-based
            authentication. If not specified, the username of the currently
            logged in user will be used.
        :param client_keys: (optional)
            A list of keys which will be used to authenticate this client
-           via public key authentication. If no client keys are specified,
-           an attempt will be made to get them from an ssh-agent process
-           and/or load them from the files :file:`.ssh/id_ed25519_sk`,
-           :file:`.ssh/id_ecdsa_sk`, :file:`.ssh/id_ed448`,
-           :file:`.ssh/id_ed25519`, :file:`.ssh/id_ecdsa`,
-           :file:`.ssh/id_rsa`, and :file:`.ssh/id_dsa` in the user's
-           home directory, with optional certificates loaded from the files
+           via public key authentication. These keys will be used after
+           trying keys from a PKCS11 provider or an ssh-agent, if either
+           of those are configured. If no client keys are specified,
+           an attempt will be made to load them from the files
+           :file:`.ssh/id_ed25519_sk`, :file:`.ssh/id_ecdsa_sk`,
+           :file:`.ssh/id_ed448`, :file:`.ssh/id_ed25519`,
+           :file:`.ssh/id_ecdsa`, :file:`.ssh/id_rsa`, and
+           :file:`.ssh/id_dsa` in the user's home directory, with
+           optional certificates loaded from the files
            :file:`.ssh/id_ed25519_sk-cert.pub`,
            :file:`.ssh/id_ecdsa_sk-cert.pub`, :file:`.ssh/id_ed448-cert.pub`,
            :file:`.ssh/id_ed25519-cert.pub`, :file:`.ssh/id_ecdsa-cert.pub`,
            :file:`.ssh/id_rsa-cert.pub`, and :file:`.ssh/id_dsa-cert.pub`.
            If this argument is explicitly set to `None`, client public key
            authentication will not be performed.
        :param client_certs: (optional)
@@ -5897,17 +6484,16 @@
            by the server are allowed, including none.
        :param agent_path: (optional)
            The path of a UNIX domain socket to use to contact an ssh-agent
            process which will perform the operations needed for client
            public key authentication, or the :class:`SSHServerConnection`
            to use to forward ssh-agent requests over. If this is not
            specified and the environment variable `SSH_AUTH_SOCK` is
-           set, its value will be used as the path. If `client_keys`
-           is specified or this argument is explicitly set to `None`,
-           an ssh-agent will not be used.
+           set, its value will be used as the path. If this argument is
+           explicitly set to `None`, an ssh-agent will not be used.
        :param agent_identities: (optional)
            A list of identities used to restrict which SSH agent keys may
            be used. These may be specified as byte strings in binary SSH
            format or as public keys or certificates (*see*
            :ref:`SpecifyingPublicKeys` and :ref:`SpecifyingCertificates`).
            If set to `None`, all keys loaded into the SSH agent will be
            made available for use. This is the default.
@@ -6072,15 +6658,15 @@
                          doesn't depend on conditions that would change
                          between calls, this argument may be an option.
        :param options: (optional)
            A previous set of options to use as the base to incrementally
            build up a configuration. When an option is not explicitly
            specified, its value will be pulled from this options object
            (if present) before falling back to the default value.
-       :type client_factory: `callable`
+       :type client_factory: `callable` returning :class:`SSHClientConnection`
        :type proxy_command: `str` or `list` of `str`
        :type known_hosts: *see* :ref:`SpecifyingKnownHosts`
        :type host_key_alias: `str`
        :type server_host_key_algs: `str` or `list` of `str`
        :type x509_trusted_certs: *see* :ref:`SpecifyingCertificates`
        :type x509_trusted_cert_paths: `list` of `str`
        :type x509_purposes: *see* :ref:`SpecifyingX509Purposes`
@@ -6090,27 +6676,27 @@
        :type client_host_keys:
            *see* :ref:`SpecifyingPrivateKeys` or :ref:`SpecifyingPublicKeys`
        :type client_host_certs: *see* :ref:`SpecifyingCertificates`
        :type client_host: `str`
        :type client_username: `str`
        :type client_keys: *see* :ref:`SpecifyingPrivateKeys`
        :type client_certs: *see* :ref:`SpecifyingCertificates`
-       :type passphrase: `str`
+       :type passphrase: `str` or `bytes`
        :type ignore_encrypted: `bool`
        :type host_based_auth: `bool`
        :type public_key_auth: `bool`
        :type kbdint_auth: `bool`
        :type password_auth: `bool`
        :type gss_host: `str`
        :type gss_kex: `bool`
        :type gss_auth: `bool`
        :type gss_delegate_creds: `bool`
        :type preferred_auth: `str` or `list` of `str`
        :type disable_trivial_auth: `bool`
-       :type agent_path: `str` or :class:`SSHServerConnection`
+       :type agent_path: `str`
        :type agent_identities:
            *see* :ref:`SpecifyingPublicKeys` and :ref:`SpecifyingCertificates`
        :type agent_forwarding: `bool`
        :type pkcs11_provider: `str`
        :type pkcs11_pin: `str`
        :type client_version: `str`
        :type kex_algs: `str` or `list` of `str`
@@ -6122,59 +6708,138 @@
        :type rekey_seconds: *see* :ref:`SpecifyingTimeIntervals`
        :type connect_timeout: *see* :ref:`SpecifyingTimeIntervals`
        :type login_timeout: *see* :ref:`SpecifyingTimeIntervals`
        :type keepalive_interval: *see* :ref:`SpecifyingTimeIntervals`
        :type keepalive_count_max: `int`
        :type command: `str`
        :type subsystem: `str`
-       :type env: `dict`
-       :type send_env: `str` or `list` of `str`
+       :type env: `dict` with `str` keys and values
+       :type send_env: `list` of `str`
        :type request_pty: `bool`, `'force'`, or `'auto'`
        :type term_type: `str`
        :type term_size: `tuple` of 2 or 4 `int` values
-       :type term_modes: `dict`
+       :type term_modes: `dict` with `int` keys and values
        :type x11_forwarding: `bool` or `'ignore_failure'`
        :type x11_display: `str`
        :type x11_auth_path: `str`
        :type x11_single_connection: `bool`
        :type encoding: `str`
        :type errors: `str`
        :type window: `int`
        :type max_pktsize: `int`
        :type config: `list` of `str`
        :type options: :class:`SSHClientConnectionOptions`
 
     """
 
+    config: SSHClientConfig
+    client_factory: _ClientFactory
+    client_version: bytes
+    known_hosts: KnownHostsArg
+    host_key_alias: Optional[str]
+    server_host_key_algs: Union[str, Sequence[str]]
+    username: str
+    password: Optional[str]
+    client_host_keysign: Optional[str]
+    client_host_keypairs: Sequence[SSHKeyPair]
+    client_host_pubkeys: Sequence[Union[SSHKey, SSHCertificate]]
+    client_host: Optional[str]
+    client_username: str
+    client_keys: Optional[Sequence[SSHKeyPair]]
+    client_certs: Sequence[FilePath]
+    ignore_encrypted: bool
+    gss_host: DefTuple[Optional[str]]
+    gss_kex: bool
+    gss_auth: bool
+    gss_delegate_creds: bool
+    preferred_auth: Sequence[str]
+    disable_trivial_auth: bool
+    agent_path: Optional[str]
+    agent_identities: Optional[Sequence[bytes]]
+    agent_forward_path: Optional[str]
+    pkcs11_provider: Optional[FilePath]
+    pkcs11_pin: Optional[str]
+    command: Optional[str]
+    subsystem: Optional[str]
+    env: _Env
+    send_env: _SendEnv
+    request_pty: _RequestPTY
+    term_type: Optional[str]
+    term_size: TermSizeArg
+    term_modes: TermModesArg
+    x11_forwarding: Union[bool, str]
+    x11_display: Optional[str]
+    x11_auth_path: Optional[str]
+    x11_single_connection: bool
+    encoding: Optional[str]
+    errors: str
+    window: int
+    max_pktsize: int
+
     # pylint: disable=arguments-differ
-    def prepare(self, last_config=None, config=(), reload=False,
-                client_factory=None, client_version=(), host='', port=(),
-                tunnel=(), proxy_command=(), family=(), local_addr=(),
-                tcp_keepalive=(), kex_algs=(), encryption_algs=(), mac_algs=(),
-                compression_algs=(), signature_algs=(), host_based_auth=(),
-                public_key_auth=(), kbdint_auth=(), password_auth=(),
-                x509_trusted_certs=(), x509_trusted_cert_paths=(),
-                x509_purposes='secureShellServer', rekey_bytes=(),
-                rekey_seconds=(), connect_timeout=(),
-                login_timeout=_DEFAULT_LOGIN_TIMEOUT, keepalive_interval=(),
-                keepalive_count_max=(), known_hosts=(), host_key_alias=None,
-                server_host_key_algs=(), username=(), password=None,
-                client_host_keysign=(), client_host_keys=None,
-                client_host_certs=(), client_host=None, client_username=(),
-                client_keys=(), client_certs=(), passphrase=None,
-                ignore_encrypted=False, gss_host=(), gss_kex=(), gss_auth=(),
-                gss_delegate_creds=(), preferred_auth=(),
-                disable_trivial_auth=False, agent_path=(),
-                agent_identities=(), agent_forwarding=(), pkcs11_provider=(),
-                pkcs11_pin=None, command=(), subsystem=None, env=(),
-                send_env=(), request_pty=(), term_type=None, term_size=None,
-                term_modes=None, x11_forwarding=(), x11_display=None,
-                x11_auth_path=None, x11_single_connection=False,
-                encoding='utf-8', errors='strict', window=_DEFAULT_WINDOW,
-                max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def prepare(self, last_config: Optional[SSHConfig] = None, # type: ignore
+                config: DefTuple[ConfigPaths] = (), reload: bool = False,
+                client_factory: Optional[_ClientFactory] = None,
+                client_version: _VersionArg = (), host: str = '',
+                port: DefTuple[int] = (), tunnel: object = (),
+                proxy_command: DefTuple[_ProxyCommand] = (),
+                family: DefTuple[int] = (),
+                local_addr: DefTuple[HostPort] = (),
+                tcp_keepalive: DefTuple[bool] = (),
+                kex_algs: _AlgsArg = (), encryption_algs: _AlgsArg = (),
+                mac_algs: _AlgsArg = (), compression_algs: _AlgsArg = (),
+                signature_algs: _AlgsArg = (), host_based_auth: _AuthArg = (),
+                public_key_auth: _AuthArg = (), kbdint_auth: _AuthArg = (),
+                password_auth: _AuthArg = (),
+                x509_trusted_certs: CertListArg = (),
+                x509_trusted_cert_paths: Sequence[FilePath] = (),
+                x509_purposes: X509CertPurposes = 'secureShellServer',
+                rekey_bytes: DefTuple[Union[int, str]] = (),
+                rekey_seconds: DefTuple[Union[float, str]] = (),
+                connect_timeout: DefTuple[Optional[Union[float, str]]] = (),
+                login_timeout: Union[float, str] = _DEFAULT_LOGIN_TIMEOUT,
+                keepalive_interval: DefTuple[Union[float, str]] = (),
+                keepalive_count_max: DefTuple[int] = (),
+                known_hosts: KnownHostsArg = (),
+                host_key_alias: DefTuple[Optional[str]] = (),
+                server_host_key_algs: _AlgsArg = (),
+                username: DefTuple[str] = (), password: Optional[str] = None,
+                client_host_keysign: DefTuple[KeySignPath] = (),
+                client_host_keys: _ClientKeysArg = None,
+                client_host_certs: Sequence[FilePath] = (),
+                client_host: Optional[str] = None,
+                client_username: DefTuple[str] = (),
+                client_keys: _ClientKeysArg = (),
+                client_certs: Sequence[FilePath] = (),
+                passphrase: Optional[BytesOrStr] = None,
+                ignore_encrypted: bool = False,
+                gss_host: DefTuple[Optional[str]] = (),
+                gss_kex: DefTuple[bool] = (), gss_auth: DefTuple[bool] = (),
+                gss_delegate_creds: DefTuple[bool] = (),
+                preferred_auth: DefTuple[Union[str, Sequence[str]]] = (),
+                disable_trivial_auth: bool = False,
+                agent_path: DefTuple[Optional[str]] = (),
+                agent_identities: DefTuple[Optional[IdentityListArg]] = (),
+                agent_forwarding: DefTuple[bool] = (),
+                pkcs11_provider: DefTuple[Optional[FilePath]] = (),
+                pkcs11_pin: Optional[str] = None,
+                command: DefTuple[Optional[str]] = (),
+                subsystem: Optional[str] = None, env: DefTuple[_Env] = (),
+                send_env: DefTuple[_SendEnv] = (),
+                request_pty: DefTuple[_RequestPTY] = (),
+                term_type: Optional[str] = None,
+                term_size: TermSizeArg = None,
+                term_modes: TermModesArg = None,
+                x11_forwarding: DefTuple[Union[bool, str]] = (),
+                x11_display: Optional[str] = None,
+                x11_auth_path: Optional[str] = None,
+                x11_single_connection: bool = False,
+                encoding: Optional[str] = 'utf-8', errors: str = 'strict',
+                window: int = _DEFAULT_WINDOW,
+                max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> None:
         """Prepare client connection configuration options"""
 
         try:
             local_username = getpass.getuser()
         except KeyError:
             raise ValueError('Unknown local username: set one of '
                              'LOGNAME, USER, LNAME, or USERNAME in '
@@ -6197,183 +6862,195 @@
         if x509_trusted_cert_paths == ():
             default_x509_cert_path = Path('~', '.ssh', 'crt').expanduser()
 
             if default_x509_cert_path.is_dir():
                 x509_trusted_cert_paths = [str(default_x509_cert_path)]
 
         if connect_timeout == ():
-            connect_timeout = config.get('ConnectTimeout', None)
+            connect_timeout = cast(Optional[Union[float, str]],
+                                   config.get('ConnectTimeout', None))
+
+        connect_timeout: Optional[Union[float, str]]
 
         if keepalive_interval == ():
-            keepalive_interval = config.get('ServerAliveInterval',
-                                            _DEFAULT_KEEPALIVE_INTERVAL)
+            keepalive_interval = \
+                cast(Union[float, str], config.get('ServerAliveInterval',
+                                                   _DEFAULT_KEEPALIVE_INTERVAL))
+
+        keepalive_interval: Union[float, str]
 
         if keepalive_count_max == ():
-            keepalive_count_max = config.get('ServerAliveCountMax',
-                                             _DEFAULT_KEEPALIVE_COUNT_MAX)
+            keepalive_count_max = \
+                cast(int, config.get('ServerAliveCountMax',
+                                     _DEFAULT_KEEPALIVE_COUNT_MAX))
+
+        keepalive_count_max: int
 
         super().prepare(config, client_factory or SSHClient, client_version,
                         host, port, tunnel, passphrase, proxy_command, family,
                         local_addr, tcp_keepalive, kex_algs, encryption_algs,
                         mac_algs, compression_algs, signature_algs,
                         host_based_auth, public_key_auth, kbdint_auth,
                         password_auth, x509_trusted_certs,
                         x509_trusted_cert_paths, x509_purposes, rekey_bytes,
                         rekey_seconds, connect_timeout, login_timeout,
                         keepalive_interval, keepalive_count_max)
 
-        if known_hosts == ():
-            known_hosts = (config.get('UserKnownHostsFile', []) + \
-                           config.get('GlobalKnownHostsFile', [])) or ()
-
-        self.known_hosts = known_hosts
-        self.host_key_alias = host_key_alias or config.get('HostKeyAlias')
+        self.known_hosts = known_hosts if known_hosts != () else \
+            (cast(List[str], config.get('UserKnownHostsFile', [])) +
+             cast(List[str], config.get('GlobalKnownHostsFile', []))) or ()
+
+        self.host_key_alias = \
+            cast(Optional[str], host_key_alias if host_key_alias != () else
+                config.get('HostKeyAlias'))
 
         self.server_host_key_algs = server_host_key_algs
 
         # Just validate the input here -- the actual server host key
         # selection is done later, after the known_hosts lookup is done.
         _select_host_key_algs(server_host_key_algs,
-                              config.get('HostKeyAlgorithms', ()), [])
+            cast(DefTuple[str], config.get('HostKeyAlgorithms', ())), [])
 
-        if username == ():
-            username = config.get('User', local_username)
+        self.username = saslprep(cast(str, username if username != () else
+                                      config.get('User', local_username)))
 
-        self.username = saslprep(username)
         self.password = password
 
         if client_host_keysign == ():
-            client_host_keysign = config.get('EnableSSHKeySign', False)
+            client_host_keysign = \
+                cast(bool, config.get('EnableSSHKeySign', False))
 
         if client_host_keysign:
             client_host_keysign = find_keysign(client_host_keysign)
 
             if client_host_keys:
-                client_host_keys = load_public_keys(client_host_keys)
+                self.client_host_pubkeys = \
+                    load_public_keys(cast(KeyListArg, client_host_keys))
             else:
-                client_host_keys = load_default_host_public_keys()
+                self.client_host_pubkeys = load_default_host_public_keys()
         else:
-            client_host_keys = load_keypairs(client_host_keys, passphrase,
-                                             client_host_certs)
+            client_host_keysign = None
 
-        if client_username == ():
-            client_username = local_username
+            self.client_host_keypairs = \
+                load_keypairs(cast(KeyPairListArg, client_host_keys),
+                              passphrase, client_host_certs)
 
         self.client_host_keysign = client_host_keysign
-        self.client_host_keys = client_host_keys
         self.client_host = client_host
-        self.client_username = saslprep(client_username)
 
-        if gss_kex == ():
-            gss_kex = config.get('GSSAPIKeyExchange', True)
+        self.client_username = saslprep(cast(str, client_username
+                if client_username != () else local_username))
 
-        if gss_auth == ():
-            gss_auth = config.get('GSSAPIAuthentication', True)
+        self.gss_host = gss_host
 
-        if gss_delegate_creds == ():
-            gss_delegate_creds = config.get('GSSAPIDelegateCredentials', False)
+        self.gss_kex = cast(bool, gss_kex if gss_kex != () else
+            config.get('GSSAPIKeyExchange', True))
 
-        self.gss_host = gss_host
-        self.gss_kex = gss_kex
-        self.gss_auth = gss_auth
-        self.gss_delegate_creds = gss_delegate_creds
+        self.gss_auth = cast(bool, gss_auth if gss_auth != () else
+            config.get('GSSAPIAuthentication', True))
+
+        self.gss_delegate_creds = cast(bool,
+            gss_delegate_creds if gss_delegate_creds != () else
+                config.get('GSSAPIDelegateCredentials', False))
 
         if preferred_auth == ():
-            preferred_auth = config.get('PreferredAuthentications', ())
+            preferred_auth = \
+                cast(str, config.get('PreferredAuthentications', ()))
 
         if isinstance(preferred_auth, str):
             preferred_auth = preferred_auth.split(',')
 
+        preferred_auth: Sequence[str]
+
         self.preferred_auth = preferred_auth
 
         self.disable_trivial_auth = disable_trivial_auth
 
         if agent_path == ():
-            agent_path = config.get('IdentityAgent', ())
+            agent_path = cast(DefTuple[str], config.get('IdentityAgent', ()))
 
         if agent_path == ():
-            agent_path = os.environ.get('SSH_AUTH_SOCK', ())
+            agent_path = \
+                cast(DefTuple[str], os.environ.get('SSH_AUTH_SOCK', None))
 
-        if agent_path:
-            agent_path = str(Path(agent_path).expanduser())
+        agent_path = str(Path(agent_path).expanduser()) if agent_path else None
 
         if pkcs11_provider == ():
-            pkcs11_provider = config.get('PKCS11Provider')
+            pkcs11_provider = \
+                cast(Optional[FilePath], config.get('PKCS11Provider'))
 
-        self.agent_path = None
-        self.pkcs11_provider = None
-        self.pkcs11_pin = None
+        pkcs11_provider: Optional[FilePath]
 
         if client_keys == ():
-            client_keys = config.get('IdentityFile', ())
+            client_keys = cast(_ClientKeysArg, config.get('IdentityFile', ()))
 
         if client_certs == ():
-            client_certs = config.get('CertificateFile', ())
+            client_certs = \
+                cast(Sequence[FilePath], config.get('CertificateFile', ()))
 
-        identities_only = config.get('IdentitiesOnly')
+        identities_only = cast(bool, config.get('IdentitiesOnly'))
 
         if agent_identities == ():
             if identities_only:
-                agent_identities = client_keys
+                agent_identities = cast(KeyListArg, client_keys)
             else:
                 agent_identities = None
 
         if agent_identities:
             self.agent_identities = load_identities(agent_identities,
                                                     identities_only)
         elif agent_identities == ():
             self.agent_identities = load_default_identities()
         else:
             self.agent_identities = None
 
         if client_keys:
-            self.client_keys = load_keypairs(client_keys, passphrase,
-                                             client_certs, identities_only,
-                                             ignore_encrypted)
+            self.client_keys = \
+                load_keypairs(cast(KeyPairListArg, client_keys), passphrase,
+                              client_certs, identities_only, ignore_encrypted)
+        elif client_keys is not None:
+            self.client_keys = load_default_keypairs(passphrase, client_certs)
         else:
-            if client_keys == ():
-                client_keys = load_default_keypairs(passphrase, client_certs)
+            self.client_keys = None
 
-            self.client_keys = client_keys
-
-        if client_keys is not None:
+        if self.client_keys is not None:
             self.agent_path = agent_path
             self.pkcs11_provider = pkcs11_provider
             self.pkcs11_pin = pkcs11_pin
+        else:
+            self.agent_path = None
+            self.pkcs11_provider = None
+            self.pkcs11_pin = None
 
         if agent_forwarding == ():
-            agent_forwarding = config.get('ForwardAgent', False)
+            agent_forwarding = cast(bool, config.get('ForwardAgent', False))
 
         self.agent_forward_path = agent_path if agent_forwarding else None
 
-        if command == ():
-            command = config.get('RemoteCommand')
+        self.command = cast(Optional[str], command if command != () else
+            config.get('RemoteCommand'))
 
-        if env == ():
-            env = config.get('SetEnv')
+        self.subsystem = subsystem
 
-        if send_env == ():
-            send_env = config.get('SendEnv')
+        self.env = cast(_Env, env if env != () else config.get('SetEnv'))
 
-        if request_pty == ():
-            request_pty = config.get('RequestTTY', True)
+        self.send_env = cast(_SendEnv, send_env if send_env != () else
+            config.get('SendEnv'))
 
-        if x11_forwarding == ():
-            x11_forwarding = config.get('ForwardX11Trusted') and \
-                'ignore_failure'
+        self.request_pty = cast(_RequestPTY, request_pty if request_pty != ()
+            else config.get('RequestTTY', True))
 
-        self.command = command
-        self.subsystem = subsystem
-        self.env = env
-        self.send_env = send_env
-        self.request_pty = request_pty
         self.term_type = term_type
         self.term_size = term_size
         self.term_modes = term_modes
-        self.x11_forwarding = x11_forwarding
+
+        self.x11_forwarding = cast(Union[bool, str],
+            x11_forwarding if x11_forwarding != () else
+                config.get('ForwardX11Trusted') and 'ignore_failure')
+
         self.x11_display = x11_display
         self.x11_auth_path = x11_auth_path
         self.x11_single_connection = x11_single_connection
         self.encoding = encoding
         self.errors = errors
         self.window = window
         self.max_pktsize = max_pktsize
@@ -6532,14 +7209,17 @@
            to 'strict'.
        :param sftp_factory: (optional)
            A `callable` which returns an :class:`SFTPServer` object that
            will be created each time an SFTP session is requested by the
            client, or `True` to use the base :class:`SFTPServer` class
            to handle SFTP requests. If not specified, SFTP sessions are
            rejected by default.
+       :param sftp_version: (optional)
+           The maximum version of the SFTP protocol to support, currently
+           either 3 or 4, defaulting to 3.
        :param allow_scp: (optional)
            Whether or not to allow incoming scp requests to be accepted.
            This option can only be used in conjunction with `sftp_factory`.
            If not specified, scp requests will be passed as regular
            commands to the `process_factory` or `session_factory`.
            to the client when the client supports it, defaulting to `True`
        :param window: (optional)
@@ -6617,20 +7297,20 @@
                          doesn't depend on conditions that would change
                          between calls, this argument may be an option.
        :param options: (optional)
            A previous set of options to use as the base to incrementally
            build up a configuration. When an option is not explicitly
            specified, its value will be pulled from this options object
            (if present) before falling back to the default value.
-       :type server_factory: `callable`
+       :type server_factory: `callable` returning :class:`SSHServerConnection`
        :type proxy_command: `str` or `list` of `str`
        :type family: `socket.AF_UNSPEC`, `socket.AF_INET`, or `socket.AF_INET6`
        :type server_host_keys: *see* :ref:`SpecifyingPrivateKeys`
        :type server_host_certs: *see* :ref:`SpecifyingCertificates`
-       :type passphrase: `str`
+       :type passphrase: `str` or `bytes`
        :type known_client_hosts: *see* :ref:`SpecifyingKnownHosts`
        :type trust_client_host: `bool`
        :type authorized_client_keys: *see* :ref:`SpecifyingAuthorizedKeys`
        :type x509_trusted_certs: *see* :ref:`SpecifyingCertificates`
        :type x509_trusted_cert_paths: `list` of `str`
        :type x509_purposes: *see* :ref:`SpecifyingX509Purposes`
        :type host_based_auth: `bool`
@@ -6649,14 +7329,15 @@
        :type x11_auth_path: `str`
        :type agent_forwarding: `bool`
        :type process_factory: `callable`
        :type session_factory: `callable`
        :type encoding: `str`
        :type errors: `str`
        :type sftp_factory: `callable`
+       :type sftp_version: `int`
        :type allow_scp: `bool`
        :type window: `int`
        :type max_pktsize: `int`
        :type server_version: `str`
        :type kex_algs: `str` or `list` of `str`
        :type encryption_algs: `str` or `list` of `str`
        :type mac_algs: `str` or `list` of `str`
@@ -6669,70 +7350,136 @@
        :type keepalive_interval: *see* :ref:`SpecifyingTimeIntervals`
        :type keepalive_count_max: `int`
        :type config: `list` of `str`
        :type options: :class:`SSHServerConnectionOptions`
 
     """
 
+    config: SSHServerConfig
+    server_factory: _ServerFactory
+    server_version: bytes
+    server_host_keys: 'OrderedDict[bytes, SSHKeyPair]'
+    known_client_hosts: KnownHostsArg
+    trust_client_host: bool
+    authorized_client_keys: DefTuple[Optional[SSHAuthorizedKeys]]
+    gss_host: Optional[str]
+    gss_kex: bool
+    gss_auth: bool
+    allow_pty: bool
+    line_editor: bool
+    line_history: int
+    max_line_length: int
+    rdns_lookup: bool
+    x11_forwarding: bool
+    x11_auth_path: Optional[str]
+    agent_forwarding: bool
+    process_factory: Optional[SSHServerProcessFactory]
+    session_factory: Optional[SSHServerSessionFactory]
+    encoding: Optional[str]
+    errors: str
+    sftp_factory: Optional[SFTPServerFactory]
+    sftp_version: int
+    allow_scp: bool
+    window: int
+    max_pktsize: int
+
     # pylint: disable=arguments-differ
-    def prepare(self, last_config=None, config=(), reload=False,
-                accept_addr='', accept_port=0, username='', client_host=None,
-                client_addr='', server_factory=None, server_version=(),
-                host='', port=(), tunnel=(), proxy_command=(), family=(),
-                local_addr=(), tcp_keepalive=(), kex_algs=(),
-                encryption_algs=(), mac_algs=(), compression_algs=(),
-                signature_algs=(), host_based_auth=(), public_key_auth=(),
-                kbdint_auth=(), password_auth=(), x509_trusted_certs=(),
-                x509_trusted_cert_paths=(), x509_purposes='secureShellClient',
-                rekey_bytes=(), rekey_seconds=(), connect_timeout=None,
-                login_timeout=(), keepalive_interval=(),
-                keepalive_count_max=(), server_host_keys=(),
-                server_host_certs=(), passphrase=None,
-                known_client_hosts=None, trust_client_host=False,
-                authorized_client_keys=(), gss_host=(), gss_kex=(),
-                gss_auth=(), allow_pty=(), line_editor=True,
-                line_history=_DEFAULT_LINE_HISTORY,
-                max_line_length=_DEFAULT_MAX_LINE_LENGTH, rdns_lookup=(),
-                x11_forwarding=False, x11_auth_path=None, agent_forwarding=(),
-                process_factory=None, session_factory=None, encoding='utf-8',
-                errors='strict', sftp_factory=None, allow_scp=False,
-                window=_DEFAULT_WINDOW, max_pktsize=_DEFAULT_MAX_PKTSIZE):
+    def prepare(self, last_config: Optional[SSHConfig] = None, # type: ignore
+                config: DefTuple[ConfigPaths] = (), reload: bool = False,
+                accept_addr: str = '', accept_port: int = 0,
+                username: str = '', client_host: str = '',
+                client_addr: str = '',
+                server_factory: Optional[_ServerFactory] = None,
+                server_version: _VersionArg = (), host: str = '',
+                port: DefTuple[int] = (), tunnel: object = (),
+                proxy_command: DefTuple[_ProxyCommand] = (),
+                family: DefTuple[int] = (),
+                local_addr: DefTuple[HostPort] = (),
+                tcp_keepalive: DefTuple[bool] = (),
+                kex_algs: _AlgsArg = (), encryption_algs: _AlgsArg = (),
+                mac_algs: _AlgsArg = (), compression_algs: _AlgsArg = (),
+                signature_algs: _AlgsArg = (), host_based_auth: _AuthArg = (),
+                public_key_auth: _AuthArg = (), kbdint_auth: _AuthArg = (),
+                password_auth: _AuthArg = (),
+                x509_trusted_certs: CertListArg = (),
+                x509_trusted_cert_paths: Sequence[FilePath] = (),
+                x509_purposes: X509CertPurposes = 'secureShellClient',
+                rekey_bytes: DefTuple[Union[int, str]] = (),
+                rekey_seconds: DefTuple[Union[float, str]] = (),
+                connect_timeout: Optional[Union[float, str]] = None,
+                login_timeout: DefTuple[Union[float, str]] = (),
+                keepalive_interval: DefTuple[Union[float, str]] = (),
+                keepalive_count_max: DefTuple[int] = (),
+                server_host_keys: KeyPairListArg = (),
+                server_host_certs: CertListArg = (),
+                passphrase: Optional[BytesOrStr] = None,
+                known_client_hosts: KnownHostsArg = None,
+                trust_client_host: bool = False,
+                authorized_client_keys: _AuthKeysArg = (),
+                gss_host: DefTuple[Optional[str]] = (),
+                gss_kex: DefTuple[bool] = (),
+                gss_auth: DefTuple[bool] = (),
+                allow_pty: DefTuple[bool] = (),
+                line_editor: bool = True,
+                line_history: int = _DEFAULT_LINE_HISTORY,
+                max_line_length: int = _DEFAULT_MAX_LINE_LENGTH,
+                rdns_lookup: DefTuple[bool] = (),
+                x11_forwarding: bool = False,
+                x11_auth_path: Optional[str] = None,
+                agent_forwarding: DefTuple[bool] = (),
+                process_factory: Optional[SSHServerProcessFactory] = None,
+                session_factory: Optional[SSHServerSessionFactory] = None,
+                encoding: Optional[str] = 'utf-8', errors: str = 'strict',
+                sftp_factory: Optional[SFTPServerFactory] = None,
+                sftp_version: int = MIN_SFTP_VERSION,
+                allow_scp: bool = False, window: int = _DEFAULT_WINDOW,
+                max_pktsize: int = _DEFAULT_MAX_PKTSIZE) -> None:
         """Prepare server connection configuration options"""
 
         config = SSHServerConfig.load(last_config, config, reload,
                                       accept_addr, accept_port, username,
                                       client_host, client_addr)
 
         if login_timeout == ():
-            login_timeout = config.get('LoginGraceTime',
-                                       _DEFAULT_LOGIN_TIMEOUT)
+            login_timeout = \
+                cast(Union[float, str], config.get('LoginGraceTime',
+                                                   _DEFAULT_LOGIN_TIMEOUT))
+
+        login_timeout: Union[float, str]
 
         if keepalive_interval == ():
-            keepalive_interval = config.get('ClientAliveInterval',
-                                            _DEFAULT_KEEPALIVE_INTERVAL)
+            keepalive_interval = \
+                cast(Union[float, str], config.get('ClientAliveInterval',
+                                                   _DEFAULT_KEEPALIVE_INTERVAL))
+
+        keepalive_interval: Union[float, str]
 
         if keepalive_count_max == ():
-            keepalive_count_max = config.get('ClientAliveCountMax',
-                                             _DEFAULT_KEEPALIVE_COUNT_MAX)
+            keepalive_count_max = \
+                cast(int, config.get('ClientAliveCountMax',
+                                     _DEFAULT_KEEPALIVE_COUNT_MAX))
+
+        keepalive_count_max: int
 
         super().prepare(config, server_factory or SSHServer, server_version,
                         host, port, tunnel, passphrase, proxy_command, family,
                         local_addr, tcp_keepalive, kex_algs, encryption_algs,
                         mac_algs, compression_algs, signature_algs,
                         host_based_auth, public_key_auth, kbdint_auth,
                         password_auth, x509_trusted_certs,
                         x509_trusted_cert_paths, x509_purposes,
                         rekey_bytes, rekey_seconds, connect_timeout,
                         login_timeout, keepalive_interval, keepalive_count_max)
 
         if server_host_keys == ():
-            server_host_keys = config.get('HostKey')
+            server_host_keys = cast(Sequence[str], config.get('HostKey'))
 
         if server_host_certs == ():
-            server_host_certs = config.get('HostCertificate', ())
+            server_host_certs = cast(Sequence[str],
+                                     config.get('HostCertificate', ()))
 
         server_keys = load_keypairs(server_host_keys, passphrase,
                                     server_host_certs)
 
         self.server_host_keys = OrderedDict()
 
         for keypair in server_keys:
@@ -6743,71 +7490,78 @@
 
                 self.server_host_keys[alg] = keypair
 
         self.known_client_hosts = known_client_hosts
         self.trust_client_host = trust_client_host
 
         if authorized_client_keys == () and reload:
-            authorized_client_keys = config.get('AuthorizedKeysFile')
+            authorized_client_keys = \
+                cast(List[str], config.get('AuthorizedKeysFile'))
 
         if isinstance(authorized_client_keys, (str, list)):
             self.authorized_client_keys = \
                 read_authorized_keys(authorized_client_keys)
         else:
             self.authorized_client_keys = authorized_client_keys
 
         if gss_host == ():
             gss_host = socket.gethostname()
 
             if '.' not in gss_host:
                 gss_host = socket.getfqdn()
 
-        if gss_kex == ():
-            gss_kex = config.get('GSSAPIKeyExchange', True)
-
-        if gss_auth == ():
-            gss_auth = config.get('GSSAPIAuthentication', True)
+        gss_host: Optional[str]
 
         self.gss_host = gss_host
-        self.gss_kex = gss_kex
-        self.gss_auth = gss_auth
 
-        if not server_keys and not gss_host:
-            raise ValueError('No server host keys provided')
+        self.gss_kex = cast(bool, gss_kex if gss_kex != () else
+            config.get('GSSAPIKeyExchange', True))
 
-        if allow_pty == ():
-            allow_pty = config.get('PermitTTY', True)
+        self.gss_auth = cast(bool, gss_auth if gss_auth != () else
+            config.get('GSSAPIAuthentication', True))
 
-        if agent_forwarding == ():
-            agent_forwarding = config.get('AllowAgentForwarding', True)
+        if not server_keys and not gss_host:
+            raise ValueError('No server host keys provided')
 
-        if rdns_lookup == ():
-            rdns_lookup = config.get('UseDNS', False)
+        self.allow_pty = cast(bool, allow_pty if allow_pty != () else
+            config.get('PermitTTY', True))
 
-        self.allow_pty = allow_pty
         self.line_editor = line_editor
         self.line_history = line_history
         self.max_line_length = max_line_length
-        self.rdns_lookup = rdns_lookup
+
+        self.rdns_lookup = cast(bool, rdns_lookup if rdns_lookup != () else
+            config.get('UseDNS', False))
+
         self.x11_forwarding = x11_forwarding
         self.x11_auth_path = x11_auth_path
-        self.agent_forwarding = agent_forwarding
+
+        self.agent_forwarding = cast(bool,
+            agent_forwarding if agent_forwarding != () else
+                config.get('AllowAgentForwarding', True))
+
         self.process_factory = process_factory
         self.session_factory = session_factory
         self.encoding = encoding
         self.errors = errors
         self.sftp_factory = SFTPServer if sftp_factory is True else sftp_factory
+        self.sftp_version = sftp_version
         self.allow_scp = allow_scp
         self.window = window
         self.max_pktsize = max_pktsize
 
 
 @async_context_manager
-async def connect(host, port=(), *, tunnel=(), family=(), flags=0,
-                  local_addr=None, config=(), options=None, **kwargs):
+async def connect(host: str, port: DefTuple[int] = (), *,
+                  tunnel: DefTuple[_TunnelConnector] = (),
+                  family: DefTuple[int] = (), flags: int = 0,
+                  local_addr: DefTuple[HostPort] = (),
+                  config: DefTuple[ConfigPaths] = (),
+                  options: Optional[SSHClientConnectionOptions] = None,
+                  **kwargs: object) -> SSHClientConnection:
     """Make an SSH client connection
 
        This function is a coroutine which can be run to create an outbound SSH
        client connection to the specified host and port.
 
        When successful, the following steps occur:
 
@@ -6873,35 +7627,41 @@
        :type config: `list` of `str`
        :type options: :class:`SSHClientConnectionOptions`
 
        :returns: :class:`SSHClientConnection`
 
     """
 
-    def conn_factory():
+    def conn_factory() -> SSHClientConnection:
         """Return an SSH client connection factory"""
 
-        return SSHClientConnection(loop, options, wait='auth')
+        return SSHClientConnection(loop, new_options, wait='auth')
 
     loop = asyncio.get_event_loop()
 
-    options = SSHClientConnectionOptions(options, config=config, host=host,
-                                         port=port, tunnel=tunnel,
-                                         family=family, local_addr=local_addr,
-                                         **kwargs)
+    new_options = SSHClientConnectionOptions(options, config=config, host=host,
+                                             port=port, tunnel=tunnel,
+                                             family=family,
+                                             local_addr=local_addr, **kwargs)
 
     return await asyncio.wait_for(
-        _connect(options, loop, flags, conn_factory,
+        _connect(new_options, loop, flags, conn_factory,
                  'Opening SSH connection to'),
-        timeout=options.connect_timeout)
+        timeout=new_options.connect_timeout)
 
 
 @async_context_manager
-async def connect_reverse(host, port=(), *, tunnel=(), family=(), flags=0,
-                          local_addr=None, config=(), options=None, **kwargs):
+async def connect_reverse(
+        host: str, port: DefTuple[int] = (), *,
+        tunnel: DefTuple[_TunnelConnector] = (),
+        family: DefTuple[int] = (), flags: int = 0,
+        local_addr: DefTuple[HostPort] = (),
+        config: DefTuple[ConfigPaths] = (),
+        options: Optional[SSHServerConnectionOptions] = None,
+        **kwargs: object) -> SSHServerConnection:
     """Create a reverse direction SSH connection
 
        This function is a coroutine which behaves similar to :func:`connect`,
        making an outbound TCP connection to a remote server. However, instead
        of starting up an SSH client which runs on that outbound connection,
        this function starts up an SSH server, expecting the remote system to
        start up a reverse-direction SSH client.
@@ -6951,37 +7711,42 @@
        :type config: `list` of `str`
        :type options: :class:`SSHServerConnectionOptions`
 
        :returns: :class:`SSHServerConnection`
 
     """
 
-    def conn_factory():
+    def conn_factory() -> SSHServerConnection:
         """Return an SSH client connection factory"""
 
-        return SSHServerConnection(loop, options, wait='auth')
+        return SSHServerConnection(loop, new_options, wait='auth')
 
     loop = asyncio.get_event_loop()
 
-    options = SSHServerConnectionOptions(options, config=config, host=host,
-                                         port=port, tunnel=tunnel,
-                                         family=family, local_addr=local_addr,
-                                         **kwargs)
+    new_options = SSHServerConnectionOptions(options, config=config, host=host,
+                                             port=port, tunnel=tunnel,
+                                             family=family,
+                                             local_addr=local_addr, **kwargs)
 
     return await asyncio.wait_for(
-        _connect(options, loop, flags, conn_factory,
+        _connect(new_options, loop, flags, conn_factory,
                  'Opening reverse SSH connection to'),
-        timeout=options.connect_timeout)
+        timeout=new_options.connect_timeout)
 
 
 @async_context_manager
-async def listen(host='', port=(), tunnel=(), family=(),
-                 flags=socket.AI_PASSIVE, backlog=100, reuse_address=None,
-                 reuse_port=None, acceptor=None, error_handler=None,
-                 config=(), options=None, **kwargs):
+async def listen(host: str = '', port: DefTuple[int] = (), *,
+                 tunnel: DefTuple[_TunnelListener] = (),
+                 family: DefTuple[int] = (), flags:int = socket.AI_PASSIVE,
+                 backlog: int = 100, reuse_address: bool = False,
+                 reuse_port: bool = False, acceptor: _AcceptHandler = None,
+                 error_handler: _ErrorHandler = None,
+                 config: DefTuple[ConfigPaths] = (),
+                 options: Optional[SSHServerConnectionOptions] = None,
+                 **kwargs: object) -> SSHAcceptor:
     """Start an SSH server
 
        This function is a coroutine which can be run to create an SSH server
        listening on the specified host and port. The return value is an
        :class:`SSHAcceptor` which can be used to shut down the listener.
 
        :param host: (optional)
@@ -7033,15 +7798,14 @@
            configuration files will be loaded. See
            :ref:`SupportedServerConfigOptions` for details on what
            configuration options are currently supported.
        :param options: (optional)
            Options to use when accepting SSH server connections. These
            options can be specified either through this parameter or
            as direct keyword arguments to this function.
-       :type protocol_factory: `callable`
        :type host: `str`
        :type port: `int`
        :type tunnel: :class:`SSHClientConnection` or `str`
        :type family: `socket.AF_UNSPEC`, `socket.AF_INET`, or `socket.AF_INET6`
        :type flags: flags to pass to :meth:`getaddrinfo() <socket.getaddrinfo>`
        :type backlog: `int`
        :type reuse_address: `bool`
@@ -7049,40 +7813,45 @@
        :type config: `list` of `str`
        :type options: :class:`SSHServerConnectionOptions`
 
        :returns: :class:`SSHAcceptor`
 
     """
 
-    def conn_factory():
+    def conn_factory() -> SSHServerConnection:
         """Return an SSH client connection factory"""
 
-        return SSHServerConnection(loop, options, acceptor, error_handler)
+        return SSHServerConnection(loop, new_options, acceptor, error_handler)
 
     loop = asyncio.get_event_loop()
 
-    options = SSHServerConnectionOptions(options, config=config, host=host,
-                                         port=port, tunnel=tunnel,
-                                         family=family, **kwargs)
+    new_options = SSHServerConnectionOptions(options, config=config, host=host,
+                                             port=port, tunnel=tunnel,
+                                             family=family, **kwargs)
 
     # pylint: disable=attribute-defined-outside-init
-    options.proxy_command = None
+    new_options.proxy_command = None
 
     return await asyncio.wait_for(
-        _listen(options, loop, flags, backlog, reuse_address,
+        _listen(new_options, loop, flags, backlog, reuse_address,
                 reuse_port, conn_factory, 'Creating SSH listener on'),
-        timeout=options.connect_timeout)
+        timeout=new_options.connect_timeout)
 
 
 @async_context_manager
-async def listen_reverse(host='', port=(), *, tunnel=(), family=(),
-                         flags=socket.AI_PASSIVE, backlog=100,
-                         reuse_address=None, reuse_port=None,
-                         acceptor=None, error_handler=None, config=(),
-                         options=None, **kwargs):
+async def listen_reverse(host: str = '', port: DefTuple[int] = (), *,
+                         tunnel: DefTuple[_TunnelListener] = (),
+                         family: DefTuple[int] = (),
+                         flags:int = socket.AI_PASSIVE, backlog: int = 100,
+                         reuse_address: bool = False, reuse_port: bool = False,
+                         acceptor: _AcceptHandler = None,
+                         error_handler: _ErrorHandler = None,
+                         config: DefTuple[ConfigPaths] = (),
+                         options: Optional[SSHClientConnectionOptions] = None,
+                         **kwargs: object) -> SSHAcceptor:
     """Create a reverse-direction SSH listener
 
        This function is a coroutine which behaves similar to :func:`listen`,
        creating a listener which accepts inbound connections on the specified
        host and port. However, instead of starting up an SSH server on each
        inbound connection, it starts up a reverse-direction SSH client,
        expecting the remote system making the connection to start up a
@@ -7146,15 +7915,14 @@
            `None`, no OpenSSH configuration files will be loaded. See
            :ref:`SupportedClientConfigOptions` for details on what
            configuration options are currently supported.
        :param options: (optional)
            Options to use when starting reverse-direction SSH clients.
            These options can be specified either through this parameter
            or as direct keyword arguments to this function.
-       :type client_factory: `callable`
        :type host: `str`
        :type port: `int`
        :type tunnel: :class:`SSHClientConnection` or `str`
        :type family: `socket.AF_UNSPEC`, `socket.AF_INET`, or `socket.AF_INET6`
        :type flags: flags to pass to :meth:`getaddrinfo() <socket.getaddrinfo>`
        :type backlog: `int`
        :type reuse_address: `bool`
@@ -7162,77 +7930,89 @@
        :type config: `list` of `str`
        :type options: :class:`SSHClientConnectionOptions`
 
        :returns: :class:`SSHAcceptor`
 
     """
 
-    def conn_factory():
+    def conn_factory() -> SSHClientConnection:
         """Return an SSH client connection factory"""
 
-        return SSHClientConnection(loop, options, acceptor, error_handler)
+        return SSHClientConnection(loop, new_options, acceptor, error_handler)
 
     loop = asyncio.get_event_loop()
 
-    options = SSHClientConnectionOptions(options, config=config, host=host,
-                                         port=port, tunnel=tunnel,
-                                         family=family, **kwargs)
+    new_options = SSHClientConnectionOptions(options, config=config, host=host,
+                                             port=port, tunnel=tunnel,
+                                             family=family, **kwargs)
 
     # pylint: disable=attribute-defined-outside-init
-    options.proxy_command = None
+    new_options.proxy_command = None
 
     return await asyncio.wait_for(
-        _listen(options, loop, flags, backlog,
+        _listen(new_options, loop, flags, backlog,
                 reuse_address, reuse_port, conn_factory,
                 'Creating reverse direction SSH listener on'),
-        timeout=options.connect_timeout)
+        timeout=new_options.connect_timeout)
 
 
-async def create_connection(client_factory, host, port=(), **kwargs):
+async def create_connection(client_factory: _ClientFactory,
+                            host: str, port: DefTuple[int] = (),
+                            **kwargs: object) -> \
+        Tuple[SSHClientConnection, SSHClient]:
     """Create an SSH client connection
 
        This is a coroutine which wraps around :func:`connect`, providing
        backward compatibility with older AsyncSSH releases. The only
        differences are that the `client_factory` argument is the first
        positional argument in this call rather than being a keyword argument
        or specified via an :class:`SSHClientConnectionOptions` object and
        the return value is a tuple of an :class:`SSHClientConnection` and
        :class:`SSHClient` rather than just the connection, mirroring
-       :meth:`asyncio.BaseEventLoop.create_connection`.
+       :meth:`asyncio.AbstractEventLoop.create_connection`.
 
        :returns: An :class:`SSHClientConnection` and :class:`SSHClient`
 
     """
 
-    conn = await connect(host, port, client_factory=client_factory, **kwargs)
+    conn = await connect(host, port, client_factory=client_factory,
+                         **kwargs) # type: ignore
 
-    return conn, conn.get_owner()
+    return conn, cast(SSHClient, conn.get_owner())
 
 
 @async_context_manager
-async def create_server(server_factory, host='', port=(), **kwargs):
+async def create_server(server_factory: _ServerFactory,
+                        host: str = '', port: DefTuple[int] = (),
+                        **kwargs: object) -> SSHAcceptor:
     """Create an SSH server
 
        This is a coroutine which wraps around :func:`listen`, providing
        backward compatibility with older AsyncSSH releases. The only
        difference is that the `server_factory` argument is the first
        positional argument in this call rather than being a keyword argument
        or specified via an :class:`SSHServerConnectionOptions` object,
-       mirroring :meth:`asyncio.BaseEventLoop.create_server`.
+       mirroring :meth:`asyncio.AbstractEventLoop.create_server`.
 
     """
 
-    return await listen(host, port, server_factory=server_factory, **kwargs)
+    return await listen(host, port, server_factory=server_factory,
+                        **kwargs) # type: ignore
 
 
-async def get_server_host_key(host, port=(), *, tunnel=(), proxy_command=(),
-                              family=(), flags=0, local_addr=None,
-                              client_version=(), kex_algs=(),
-                              server_host_key_algs=(), config=(),
-                              options=None):
+async def get_server_host_key(
+        host: str, port: DefTuple[int] = (), *,
+        tunnel: DefTuple[_TunnelConnector] = (),
+        proxy_command: DefTuple[str] = (), family: DefTuple[int] = (),
+        flags: int = 0, local_addr: DefTuple[HostPort] = (),
+        client_version: DefTuple[BytesOrStr] = (),
+        kex_algs: _AlgsArg = (), server_host_key_algs: _AlgsArg = (),
+        config: DefTuple[ConfigPaths] = (),
+        options: Optional[SSHClientConnectionOptions] = None) \
+            -> Optional[SSHKey]:
     """Retrieve an SSH server's host key
 
        This is a coroutine which can be run to connect to an SSH server and
        return the server host key presented during the SSH handshake.
 
        A list of server host key algorithms can be provided to specify
        which host key types the server is allowed to choose from. If the
@@ -7309,33 +8089,33 @@
        :type config: `list` of `str`
        :type options: :class:`SSHClientConnectionOptions`
 
        :returns: An :class:`SSHKey` public key or `None`
 
     """
 
-    def conn_factory():
+    def conn_factory() -> SSHClientConnection:
         """Return an SSH client connection factory"""
 
-        return SSHClientConnection(loop, options, wait='kex')
+        return SSHClientConnection(loop, new_options, wait='kex')
 
     loop = asyncio.get_event_loop()
 
-    options = SSHClientConnectionOptions(
+    new_options = SSHClientConnectionOptions(
         options, config=config, host=host, port=port, tunnel=tunnel,
         proxy_command=proxy_command, family=family, local_addr=local_addr,
         known_hosts=None, server_host_key_algs=server_host_key_algs,
         x509_trusted_certs=None, x509_trusted_cert_paths=None,
         x509_purposes='any', gss_host=None, kex_algs=kex_algs,
         client_version=client_version)
 
     conn = await asyncio.wait_for(
-        _connect(options, loop, flags, conn_factory,
+        _connect(new_options, loop, flags, conn_factory,
                  'Fetching server host key from'),
-        timeout=options.connect_timeout)
+        timeout=new_options.connect_timeout)
 
     server_host_key = conn.get_server_host_key()
 
     conn.abort()
 
     await conn.wait_closed()
```

### Comparing `asyncssh-2.8.1/asyncssh/kex_dh.py` & `asyncssh-2.9.0/asyncssh/kex_dh.py`

 * *Files 7% similar despite different names*

```diff
@@ -17,22 +17,45 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH Diffie-Hellman, ECDH, and Edwards DH key exchange handlers"""
 
 from hashlib import sha1, sha224, sha256, sha384, sha512
+from typing import TYPE_CHECKING, Callable, Mapping, Optional, cast
+from typing_extensions import Protocol
 
 from .constants import DEFAULT_LANG
 from .crypto import curve25519_available, curve448_available
 from .crypto import Curve25519DH, Curve448DH, ECDH
 from .gss import GSSError
 from .kex import Kex, register_kex_alg, register_gss_kex_alg
-from .misc import KeyExchangeFailed, ProtocolError, get_symbol_names, randrange
-from .packet import Boolean, MPInt, String, UInt32
+from .misc import HashType, KeyExchangeFailed, ProtocolError
+from .misc import get_symbol_names, randrange
+from .packet import Boolean, MPInt, String, UInt32, SSHPacket
+from .public_key import SigningKey, VerifyingKey
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .connection import SSHConnection, SSHClientConnection
+    from .connection import SSHServerConnection
+
+
+class DHKey(Protocol):
+    """Protocol for performing Diffie-Hellman key exchange"""
+
+    def get_public(self) -> bytes:
+        """Return the public key to send to the peer"""
+
+    def get_shared(self, peer_public: bytes) -> int:
+        """Return the shared key from the peer's public key"""
+
+
+_ECDHClass = Callable[..., DHKey]
 
 
 # pylint: disable=line-too-long
 
 # SSH KEX DH message values
 MSG_KEXDH_INIT             = 30
 MSG_KEXDH_REPLY            = 31
@@ -95,106 +118,106 @@
 
 # pylint: enable=line-too-long
 
 
 class _KexDHBase(Kex):
     """Abstract base class for Diffie-Hellman key exchange"""
 
-    _init_type = None
-    _reply_type = None
+    _init_type: int = 0
+    _reply_type: int = 0
 
-    def __init__(self, alg, conn, hash_alg):
+    def __init__(self, alg: bytes, conn: 'SSHConnection', hash_alg: HashType):
         super().__init__(alg, conn, hash_alg)
 
-        self._g = None
-        self._p = None
-        self._q = None
-        self._x = None
-        self._e = None
-        self._f = None
+        self._g = 0
+        self._p = 0
+        self._q = 0
+        self._x = 0
+        self._e = 0
+        self._f = 0
         self._gex_data = b''
 
-    def _init_group(self, g, p):
+    def _init_group(self, g: int, p: int) -> None:
         """Initialize DH group parameters"""
 
         self._g = g
         self._p = p
         self._q = (p - 1) // 2
 
-    def _compute_hash(self, host_key_data, k):
+    def _compute_hash(self, host_key_data: bytes, k: int) -> bytes:
         """Compute a hash of key information associated with the connection"""
 
         hash_obj = self._hash_alg()
         hash_obj.update(self._conn.get_hash_prefix())
         hash_obj.update(String(host_key_data))
         hash_obj.update(self._gex_data)
         hash_obj.update(self._format_client_key())
         hash_obj.update(self._format_server_key())
         hash_obj.update(MPInt(k))
         return hash_obj.digest()
 
-    def _parse_client_key(self, packet):
+    def _parse_client_key(self, packet: SSHPacket) -> None:
         """Parse a DH client key"""
 
         if not self._p:
             raise ProtocolError('Kex DH p not specified')
 
         self._e = packet.get_mpint()
 
-    def _parse_server_key(self, packet):
+    def _parse_server_key(self, packet: SSHPacket) -> None:
         """Parse a DH server key"""
 
         if not self._p:
             raise ProtocolError('Kex DH p not specified')
 
         self._f = packet.get_mpint()
 
-    def _format_client_key(self):
+    def _format_client_key(self) -> bytes:
         """Format a DH client key"""
 
         return MPInt(self._e)
 
-    def _format_server_key(self):
+    def _format_server_key(self) -> bytes:
         """Format a DH server key"""
 
         return MPInt(self._f)
 
-    def _send_init(self):
+    def _send_init(self) -> None:
         """Send a DH init message"""
 
         self.send_packet(self._init_type, self._format_client_key())
 
-    def _send_reply(self, key_data, sig):
+    def _send_reply(self, key_data: bytes, sig: bytes) -> None:
         """Send a DH reply message"""
 
         self.send_packet(self._reply_type, String(key_data),
                          self._format_server_key(), String(sig))
 
-    def _perform_init(self):
+    def _perform_init(self) -> None:
         """Compute e and send init message"""
 
         self._x = randrange(2, self._q)
         self._e = pow(self._g, self._x, self._p)
 
         self._send_init()
 
-    def _compute_client_shared(self):
+    def _compute_client_shared(self) -> int:
         """Compute client shared key"""
 
         if not 1 <= self._f < self._p:
             raise ProtocolError('Kex DH f out of range')
 
         k = pow(self._f, self._x, self._p)
 
         if k < 1: # pragma: no cover, shouldn't be possible with valid p
             raise ProtocolError('Kex DH k out of range')
 
         return k
 
-    def _compute_server_shared(self):
+    def _compute_server_shared(self) -> int:
         """Compute server shared key"""
 
         if not 1 <= self._e < self._p:
             raise ProtocolError('Kex DH e out of range')
 
         y = randrange(2, self._q)
         self._f = pow(self._g, y, self._p)
@@ -202,81 +225,89 @@
         k = pow(self._e, y, self._p)
 
         if k < 1: # pragma: no cover, shouldn't be possible with valid p
             raise ProtocolError('Kex DH k out of range')
 
         return k
 
-    def _perform_reply(self, key, key_data):
+    def _perform_reply(self, key: SigningKey, key_data: bytes) -> None:
         """Compute f and send reply message"""
 
         k = self._compute_server_shared()
         h = self._compute_hash(key_data, k)
         self._send_reply(key_data, key.sign(h))
 
         self._conn.send_newkeys(k, h)
 
-    def _verify_reply(self, key, key_data, sig):
+    def _verify_reply(self, key: VerifyingKey, key_data: bytes,
+                      sig: bytes) -> None:
         """Verify a DH reply message"""
 
         k = self._compute_client_shared()
         h = self._compute_hash(key_data, k)
 
         if not key.verify(h, sig):
             raise KeyExchangeFailed('Key exchange hash mismatch')
 
         self._conn.send_newkeys(k, h)
 
-    def _process_init(self, _pkttype, _pktid, packet):
+    def _process_init(self, _pkttype: int, _pktid: int,
+                      packet: SSHPacket) -> None:
         """Process a DH init message"""
 
         if self._conn.is_client():
             raise ProtocolError('Unexpected kex init msg')
 
         self._parse_client_key(packet)
         packet.check_end()
 
-        host_key = self._conn.get_server_host_key()
+        server_conn = cast('SSHServerConnection', self._conn)
+        host_key = server_conn.get_server_host_key()
+        assert host_key is not None
+
         self._perform_reply(host_key, host_key.public_data)
 
-    def _process_reply(self, _pkttype, _pktid, packet):
+    def _process_reply(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a DH reply message"""
 
         if self._conn.is_server():
             raise ProtocolError('Unexpected kex reply msg')
 
         host_key_data = packet.get_string()
         self._parse_server_key(packet)
         sig = packet.get_string()
         packet.check_end()
 
-        host_key = self._conn.validate_server_host_key(host_key_data)
+        client_conn = cast('SSHClientConnection', self._conn)
+        host_key = client_conn.validate_server_host_key(host_key_data)
         self._verify_reply(host_key, host_key_data, sig)
 
-    def start(self):
+    def start(self) -> None:
         """Start DH key exchange"""
 
         if self._conn.is_client():
             self._perform_init()
 
 
 class _KexDH(_KexDHBase):
     """Handler for Diffie-Hellman key exchange"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_KEXDH_')
 
     _init_type = MSG_KEXDH_INIT
     _reply_type = MSG_KEXDH_REPLY
 
-    def __init__(self, alg, conn, hash_alg, g, p):
+    def __init__(self, alg: bytes, conn: 'SSHConnection',
+                 hash_alg: HashType, g: int, p: int):
         super().__init__(alg, conn, hash_alg)
 
         self._init_group(g, p)
 
-    _packet_handlers = {
+    _packet_handlers: Mapping[int, Callable]= {
         MSG_KEXDH_INIT:     _KexDHBase._process_init,
         MSG_KEXDH_REPLY:    _KexDHBase._process_reply
     }
 
 
 class _KexDHGex(_KexDHBase):
     """Handler for Diffie-Hellman group exchange"""
@@ -284,21 +315,23 @@
     _handler_names = get_symbol_names(globals(), 'MSG_KEX_DH_GEX_')
 
     _init_type = MSG_KEX_DH_GEX_INIT
     _reply_type = MSG_KEX_DH_GEX_REPLY
     _request_type = MSG_KEX_DH_GEX_REQUEST
     _group_type = MSG_KEX_DH_GEX_GROUP
 
-    def __init__(self, alg, conn, hash_alg, preferred_size=None, max_size=None):
+    def __init__(self, alg: bytes, conn: 'SSHConnection', hash_alg: HashType,
+                 preferred_size: Optional[int] = None,
+                 max_size: Optional[int] = None):
         super().__init__(alg, conn, hash_alg)
 
         self._pref_size = preferred_size
         self._max_size = max_size
 
-    def _send_request(self):
+    def _send_request(self) -> None:
         """Send a DH gex request message"""
 
         if self._pref_size and not self._max_size:
             # Send old request message for unit test
             pkttype = MSG_KEX_DH_GEX_REQUEST_OLD
             args = UInt32(self._pref_size)
         else:
@@ -306,15 +339,16 @@
             args = (UInt32(KEX_DH_GEX_MIN_SIZE) +
                     UInt32(self._pref_size or KEX_DH_GEX_PREFERRED_SIZE) +
                     UInt32(self._max_size or KEX_DH_GEX_MAX_SIZE))
 
         self._gex_data = args
         self.send_packet(pkttype, args)
 
-    def _process_request(self, pkttype, _pktid, packet):
+    def _process_request(self, pkttype: int, _pktid: int,
+                         packet: SSHPacket) -> None:
         """Process a DH gex request message"""
 
         if self._conn.is_client():
             raise ProtocolError('Unexpected kex request msg')
 
         self._gex_data = packet.get_remaining_payload()
 
@@ -339,35 +373,36 @@
                 if gex_size >= preferred_size:
                     break
 
         self._init_group(g, p)
         self._gex_data += MPInt(p) + MPInt(g)
         self.send_packet(self._group_type, MPInt(p), MPInt(g))
 
-    def _process_group(self, _pkttype, _pktid, packet):
+    def _process_group(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a DH gex group message"""
 
         if self._conn.is_server():
             raise ProtocolError('Unexpected kex group msg')
 
         p = packet.get_mpint()
         g = packet.get_mpint()
         packet.check_end()
 
         self._init_group(g, p)
         self._gex_data += MPInt(p) + MPInt(g)
         self._perform_init()
 
-    def start(self):
+    def start(self) -> None:
         """Start DH group exchange"""
 
         if self._conn.is_client():
             self._send_request()
 
-    _packet_handlers = {
+    _packet_handlers: Mapping[int, Callable] = {
         MSG_KEX_DH_GEX_REQUEST_OLD: _process_request,
         MSG_KEX_DH_GEX_GROUP:       _process_group,
         MSG_KEX_DH_GEX_INIT:        _KexDHBase._process_init,
         MSG_KEX_DH_GEX_REPLY:       _KexDHBase._process_reply,
         MSG_KEX_DH_GEX_REQUEST:     _process_request
     }
 
@@ -376,119 +411,121 @@
     """Handler for elliptic curve Diffie-Hellman key exchange"""
 
     _handler_names = get_symbol_names(globals(), 'MSG_KEX_ECDH_')
 
     _init_type = MSG_KEX_ECDH_INIT
     _reply_type = MSG_KEX_ECDH_REPLY
 
-    def __init__(self, alg, conn, hash_alg, ecdh_class, *args):
+    def __init__(self, alg: bytes, conn: 'SSHConnection', hash_alg: HashType,
+                 ecdh_class: _ECDHClass, *args: object):
         super().__init__(alg, conn, hash_alg)
 
         self._priv = ecdh_class(*args)
         pub = self._priv.get_public()
 
         if conn.is_client():
             self._client_pub = pub
         else:
             self._server_pub = pub
 
-    def _parse_client_key(self, packet):
+    def _parse_client_key(self, packet: SSHPacket) -> None:
         """Parse an ECDH client key"""
 
         self._client_pub = packet.get_string()
 
-    def _parse_server_key(self, packet):
+    def _parse_server_key(self, packet: SSHPacket) -> None:
         """Parse an ECDH server key"""
 
         self._server_pub = packet.get_string()
 
-    def _format_client_key(self):
+    def _format_client_key(self) -> bytes:
         """Format an ECDH client key"""
 
         return String(self._client_pub)
 
-    def _format_server_key(self):
+    def _format_server_key(self) -> bytes:
         """Format an ECDH server key"""
 
         return String(self._server_pub)
 
-    def _compute_client_shared(self):
+    def _compute_client_shared(self) -> int:
         """Compute client shared key"""
 
         try:
             return self._priv.get_shared(self._server_pub)
         except ValueError:
             raise ProtocolError('Invalid ECDH server public key') from None
 
-    def _compute_server_shared(self):
+    def _compute_server_shared(self) -> int:
         """Compute server shared key"""
 
         try:
             return self._priv.get_shared(self._client_pub)
         except ValueError:
             raise ProtocolError('Invalid ECDH client public key') from None
 
-    def start(self):
+    def start(self) -> None:
         """Start ECDH key exchange"""
 
         if self._conn.is_client():
             self._send_init()
 
-    _packet_handlers = {
+    _packet_handlers: Mapping[int, Callable] = {
         MSG_KEX_ECDH_INIT:  _KexDHBase._process_init,
         MSG_KEX_ECDH_REPLY: _KexDHBase._process_reply
     }
 
 
 class _KexGSSBase(_KexDHBase):
     """Handler for GSS key exchange"""
 
-    def __init__(self, alg, conn, hash_alg, *args):
+    def __init__(self, alg: bytes, conn: 'SSHConnection',
+                 hash_alg: HashType, *args: object):
         super().__init__(alg, conn, hash_alg, *args)
 
         self._gss = conn.get_gss_context()
-        self._token = None
+        self._token: Optional[bytes] = None
         self._host_key_data = b''
 
-    def _check_secure(self):
+    def _check_secure(self) -> None:
         """Check that GSS context is secure enough for key exchange"""
 
         if (not self._gss.provides_mutual_auth or
                 not self._gss.provides_integrity):
             raise ProtocolError('GSS context not secure')
 
-    def _send_init(self):
+    def _send_init(self) -> None:
         """Send a GSS init message"""
 
         if not self._token:
             raise ProtocolError('Empty GSS token in init')
 
         self.send_packet(MSG_KEXGSS_INIT, String(self._token),
                          self._format_client_key())
 
-    def _send_reply(self, key_data, sig):
+    def _send_reply(self, key_data: bytes, sig: bytes) -> None:
         """Send a GSS reply message"""
 
         if self._token:
             token_data = Boolean(True) + String(self._token)
         else:
             token_data = Boolean(False)
 
         self.send_packet(MSG_KEXGSS_COMPLETE, self._format_server_key(),
                          String(sig), token_data)
 
-    def _send_continue(self):
+    def _send_continue(self) -> None:
         """Send a GSS continue message"""
 
         if not self._token:
             raise ProtocolError('Empty GSS token in continue')
 
         self.send_packet(MSG_KEXGSS_CONTINUE, String(self._token))
 
-    def _process_token(self, token=None):
+    def _process_token(self, token: Optional[bytes] = None) -> None:
         """Process a GSS token"""
 
         try:
             self._token = self._gss.step(token)
         except GSSError as exc:
             if self._conn.is_server():
                 self.send_packet(MSG_KEXGSS_ERROR, UInt32(exc.maj_code),
@@ -496,25 +533,27 @@
                                  String(DEFAULT_LANG))
 
             if exc.token:
                 self.send_packet(MSG_KEXGSS_CONTINUE, String(exc.token))
 
             raise KeyExchangeFailed(str(exc)) from None
 
-    def _process_init(self, _pkttype, _pktid, packet):
+    def _process_init(self, _pkttype: int, _pktid: int,
+                      packet: SSHPacket) -> None:
         """Process a GSS init message"""
 
         if self._conn.is_client():
             raise ProtocolError('Unexpected kexgss init msg')
 
         token = packet.get_string()
         self._parse_client_key(packet)
         packet.check_end()
 
-        host_key = self._conn.get_server_host_key()
+        server_conn = cast('SSHServerConnection', self._conn)
+        host_key = server_conn.get_server_host_key()
 
         if host_key:
             self._host_key_data = host_key.public_data
             self.send_packet(MSG_KEXGSS_HOSTKEY, String(self._host_key_data))
         else:
             self._host_key_data = b''
 
@@ -523,15 +562,16 @@
         if self._gss.complete:
             self._check_secure()
             self._perform_reply(self._gss, self._host_key_data)
             self._conn.enable_gss_kex_auth()
         else:
             self._send_continue()
 
-    def _process_continue(self, _pkttype, _pktid, packet):
+    def _process_continue(self, _pkttype: int, _pktid: int,
+                          packet: SSHPacket) -> None:
         """Process a GSS continue message"""
 
         token = packet.get_string()
         packet.check_end()
 
         if self._conn.is_client() and self._gss.complete:
             raise ProtocolError('Unexpected kexgss continue msg')
@@ -540,15 +580,16 @@
 
         if self._conn.is_server() and self._gss.complete:
             self._check_secure()
             self._perform_reply(self._gss, self._host_key_data)
         else:
             self._send_continue()
 
-    def _process_complete(self, _pkttype, _pktid, packet):
+    def _process_complete(self, _pkttype: int, _pktid: int,
+                          packet: SSHPacket) -> None:
         """Process a GSS complete message"""
 
         if self._conn.is_server():
             raise ProtocolError('Unexpected kexgss complete msg')
 
         self._parse_server_key(packet)
         mic = packet.get_string()
@@ -568,36 +609,38 @@
         if not self._gss.complete:
             raise ProtocolError('GSS exchange failed to complete')
 
         self._check_secure()
         self._verify_reply(self._gss, self._host_key_data, mic)
         self._conn.enable_gss_kex_auth()
 
-    def _process_hostkey(self, _pkttype, _pktid, packet):
+    def _process_hostkey(self, _pkttype: int, _pktid: int,
+                         packet: SSHPacket) -> None:
         """Process a GSS hostkey message"""
 
         self._host_key_data = packet.get_string()
         packet.check_end()
 
-    def _process_error(self, _pkttype, _pktid, packet):
+    def _process_error(self, _pkttype: int, _pktid: int,
+                       packet: SSHPacket) -> None:
         """Process a GSS error message"""
 
         if self._conn.is_server():
             raise ProtocolError('Unexpected kexgss error msg')
 
         _ = packet.get_uint32()         # major_status
         _ = packet.get_uint32()         # minor_status
         msg = packet.get_string()
         _ = packet.get_string()         # lang
         packet.check_end()
 
         self._conn.logger.debug1('GSS error: %s',
                                  msg.decode('utf-8', errors='ignore'))
 
-    def start(self):
+    def start(self) -> None:
         """Start GSS key exchange"""
 
         if self._conn.is_client():
             self._process_token()
             super().start()
```

### Comparing `asyncssh-2.8.1/asyncssh/pkcs11.py` & `asyncssh-2.9.0/asyncssh/pkcs11.py`

 * *Files 16% similar despite different names*

```diff
@@ -16,27 +16,36 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """PKCS#11 smart card handler"""
 
-import codecs
+from types import TracebackType
+from typing import Dict, List, Optional, Sequence, Tuple, Type, Union, cast
 
 try:
     import pkcs11
     from pkcs11 import Attribute, KeyType, Mechanism, ObjectClass
+    from pkcs11 import PrivateKey, Token
     from pkcs11.util.rsa import encode_rsa_public_key
     from pkcs11.util.ec import encode_ec_public_key
     pkcs11_available = True
 except (ImportError, ModuleNotFoundError): # pragma: no cover
     pkcs11_available = False
 
+from .misc import BytesOrStr
 from .packet import MPInt, String
-from .public_key import SSHKeyPair, import_certificate_chain, import_public_key
+from .public_key import SSHCertificate, SSHKey, SSHKeyPair
+from .public_key import import_certificate_chain, import_public_key
+
+
+_AttrDict = Dict['Attribute', Union[bool, bytes, str, 'ObjectClass']]
+_TokenID = Tuple[str, bytes]
+_SessionMap = Dict[_TokenID, 'SSHPKCS11Session']
 
 
 if pkcs11_available:
     encoders = {KeyType.RSA: encode_rsa_public_key,
                 KeyType.EC:  encode_ec_public_key}
 
     mechanisms = {b'ssh-rsa':                Mechanism.SHA1_RSA_PKCS,
@@ -54,138 +63,151 @@
 
 
     class SSHPKCS11KeyPair(SSHKeyPair):
         """Surrogate for a key accessed via a PKCS#11 provider"""
 
         _key_type = 'pkcs11'
 
-        def __init__(self, session, key, pubkey, cert=None):
+        def __init__(self, session: 'SSHPKCS11Session', privkey: PrivateKey,
+                     pubkey: SSHKey, cert: SSHCertificate = None):
             super().__init__(pubkey.algorithm, pubkey.algorithm,
                              pubkey.sig_algorithms, pubkey.sig_algorithms,
-                             pubkey.public_data, key.label, cert,
+                             pubkey.public_data, privkey.label, cert,
                              use_executor=True)
 
             self._session = session
-            self._key = key
+            self._privkey = privkey
 
-        def __del__(self):
+        def __del__(self) -> None:
             self._session.close()
 
-        def sign(self, data):
+        def sign(self, data: bytes) -> bytes:
             """Sign a block of data with this private key"""
 
             sig_algorithm = self.sig_algorithm
 
             if sig_algorithm.startswith(b'x509v3-'):
                 sig_algorithm = sig_algorithm[7:]
 
-            sig = self._key.sign(data, mechanism=mechanisms[sig_algorithm])
+            sig = self._privkey.sign(data, mechanism=mechanisms[sig_algorithm])
 
-            if self._key.key_type == KeyType.EC:
+            if self._privkey.key_type == KeyType.EC:
                 length = len(sig) // 2
                 r = int.from_bytes(sig[:length], 'big')
                 s = int.from_bytes(sig[length:], 'big')
                 sig = MPInt(r) + MPInt(s)
 
             return String(sig_algorithm) + String(sig)
 
 
     class SSHPKCS11Session:
         """Work around PKCS#11 sesssions not supporting simultaneous opens"""
 
-        _sessions = {}
+        _sessions: _SessionMap = {}
 
-        def __init__(self, token_id, token, pin):
+        def __init__(self, token_id: _TokenID, token: Token,
+                     pin: Optional[str]):
             self._token_id = token_id
             self._session = token.open(user_pin=pin)
             self._refcount = 0
 
-        def __enter__(self):
+        def __enter__(self) -> 'SSHPKCS11Session':
             """Allow SSHPKCS11Session to be used as a context manager"""
 
             return self
 
-        def __exit__(self, *exc_info):
+        def __exit__(self, _exc_type: Type[BaseException],
+                     _exc_value: BaseException,
+                     _traceback: TracebackType) -> None:
             """Drop one reference to the session when exiting"""
 
             self.close()
 
         @classmethod
-        def open(cls, token, pin):
+        def open(cls, token: Token, pin: Optional[str]) -> 'SSHPKCS11Session':
             """Open a new session, or return an already-open one"""
 
             token_id = (token.manufacturer_id, token.serial)
 
             try:
                 session = cls._sessions[token_id]
             except KeyError:
                 session = cls(token_id, token, pin)
                 cls._sessions[token_id] = session
 
             session._refcount += 1
             return session
 
-        def close(self):
+        def close(self) -> None:
             """Drop one reference to an open session"""
 
             self._refcount -= 1
 
             if self._refcount == 0:
                 self._session.close()
                 del self._sessions[self._token_id]
 
-        def get_keys(self, load_certs, key_label, key_id):
+        def get_keys(self, load_certs: bool, key_label: Optional[str],
+                     key_id: Optional[BytesOrStr]) -> \
+                Sequence[SSHPKCS11KeyPair]:
             """Return the private keys found on this token"""
 
             if isinstance(key_id, str):
-                key_id = codecs.decode(key_id, 'hex')
+                key_id = bytes.fromhex(key_id)
 
-            key_attrs = {Attribute.CLASS: ObjectClass.PRIVATE_KEY,
-                         Attribute.SIGN: True}
+            key_attrs: _AttrDict = {Attribute.CLASS: ObjectClass.PRIVATE_KEY,
+                                    Attribute.SIGN: True}
 
             if key_label is not None:
                 key_attrs[Attribute.LABEL] = key_label
 
             if key_id is not None:
                 key_attrs[Attribute.OBJECT_ID] = key_id
 
-            cert_attrs = {Attribute.CLASS: ObjectClass.CERTIFICATE}
+            cert_attrs: _AttrDict = {Attribute.CLASS: ObjectClass.CERTIFICATE}
 
             if load_certs:
-                certs = [import_certificate_chain(cert[Attribute.VALUE])
+                certs = [import_certificate_chain(
+                         cast(bytes, cert[Attribute.VALUE]))
                          for cert in self._session.get_objects(cert_attrs)]
 
                 certdict = {cert.key.public_data: cert for cert in certs
-                            if 'Attest' not in str(cert.subject)}
+                            if cert and 'Attest' not in str(cert.subject)}
             else:
                 certdict = {}
 
             keys = []
 
             for key in self._session.get_objects(key_attrs):
-                encoder = encoders.get(key.key_type)
+                privkey = cast(PrivateKey, key)
+                encoder = encoders.get(privkey.key_type)
 
                 if encoder:
-                    pubkey = import_public_key(encoder(key))
+                    pubkey = import_public_key(encoder(privkey))
 
                     cert = certdict.get(pubkey.public_data)
 
                     if cert:
-                        keys.append(SSHPKCS11KeyPair(self, key, pubkey, cert))
+                        keys.append(SSHPKCS11KeyPair(self, privkey,
+                                                     pubkey, cert))
 
-                    keys.append(SSHPKCS11KeyPair(self, key, pubkey))
+                    keys.append(SSHPKCS11KeyPair(self, privkey, pubkey))
 
             self._refcount += len(keys)
 
             return keys
 
 
-    def load_pkcs11_keys(provider, pin=None, *, load_certs=True,
-                         token_label=None, token_serial=None,
-                         key_label=None, key_id=None):
+    def load_pkcs11_keys(provider: str, pin: str = None, *,
+                         load_certs: bool = True,
+                         token_label: str = None,
+                         token_serial: BytesOrStr = None,
+                         key_label: str = None,
+                         key_id: BytesOrStr = None) -> \
+            Sequence[SSHPKCS11KeyPair]:
         """Load PIV keys and X.509 certificates from a PKCS#11 token
 
            This function loads a list of SSH keypairs with optional X.509
            cerificates from attached PKCS#11 security tokens. The PKCS#11
            provider must be specified, along with a user PIN if the
            tokens are set to require one.
 
@@ -234,27 +256,35 @@
            :type pin: `str`
            :type load_certs: `bool`
            :type token_label: `str`
            :type token_serial: `bytes` or `str`
            :type key_label: `str`
            :type key_id: `bytes` or `str`
 
+           :returns: list of class:`SSHKeyPair`
+
         """
 
         lib = pkcs11.lib(provider)
 
-        keys = []
+        keys: List[SSHPKCS11KeyPair] = []
 
         if isinstance(token_serial, str):
             token_serial = token_serial.encode('utf-8')
 
         for token in lib.get_tokens(token_label=token_label,
                                     token_serial=token_serial):
             with SSHPKCS11Session.open(token, pin) as session:
                 keys.extend(session.get_keys(load_certs, key_label, key_id))
 
         return keys
 else: # pragma: no cover
-    def load_pkcs11_keys(*args, **kwargs):
+    def load_pkcs11_keys(provider: str, pin: str = None, *,
+                         load_certs: bool = True,
+                         token_label: str = None,
+                         token_serial: BytesOrStr = None,
+                         key_label: str = None,
+                         key_id: BytesOrStr = None) -> \
+            Sequence['SSHPKCS11KeyPair']:
         """Report that PKCS#11 support is not available"""
 
         raise ValueError('PKCS#11 support not available') from None
```

### Comparing `asyncssh-2.8.1/asyncssh/keysign.py` & `asyncssh-2.9.0/asyncssh/keysign.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2018-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2018-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -19,42 +19,49 @@
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH keysign client"""
 
 import asyncio
 from pathlib import Path
 import subprocess
+from typing import Iterable, Sequence, Union, cast
 
+from .misc import FilePath
 from .packet import Byte, String, UInt32, PacketDecodeError, SSHPacket
-from .public_key import SSHKeyPair
+from .public_key import SSHKey, SSHKeyPair, SSHCertificate
+
+
+_KeySignKey = Union[SSHKey, SSHCertificate]
+KeySignPath = Union[None, bool, FilePath]
 
 
 KEYSIGN_VERSION = 2
 
 _DEFAULT_KEYSIGN_DIRS = ('/opt/local/libexec', '/usr/local/libexec',
                          '/usr/libexec', '/usr/libexec/openssh',
                          '/usr/lib/openssh')
 
 
 class SSHKeySignKeyPair(SSHKeyPair):
     """Surrogate for a key where signing is done via ssh-keysign"""
 
-    def __init__(self, keysign_path, sock_fd, key_or_cert):
+    def __init__(self, keysign_path: str, sock_fd: int,
+                 key_or_cert: _KeySignKey):
         algorithm = key_or_cert.algorithm
         sig_algorithms = key_or_cert.sig_algorithms[:1]
         public_data = key_or_cert.public_data
         comment = key_or_cert.get_comment_bytes()
 
         super().__init__(algorithm, algorithm, sig_algorithms, sig_algorithms,
                          public_data, comment)
 
         self._keysign_path = keysign_path
         self._sock_fd = sock_fd
 
-    async def sign(self, data):
+    async def sign_async(self, data: bytes) -> bytes:
         """Use ssh-keysign to sign a block of data with this key"""
 
         proc = await asyncio.create_subprocess_exec(
             self._keysign_path, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
             stderr=subprocess.PIPE, pass_fds=[self._sock_fd])
 
         request = String(Byte(KEYSIGN_VERSION) + UInt32(self._sock_fd) +
@@ -79,28 +86,30 @@
                 raise ValueError('unexpected version')
 
             return sig
         except PacketDecodeError:
             raise ValueError('invalid response') from None
 
 
-def find_keysign(path):
+def find_keysign(path: KeySignPath) -> str:
     """Return path to ssh-keysign executable"""
 
     if path is True:
         for keysign_dir in _DEFAULT_KEYSIGN_DIRS:
             path = Path(keysign_dir, 'ssh-keysign')
             if path.exists():
                 break
         else:
             raise ValueError('Keysign not found')
     else:
-        if not Path(path).exists():
+        if not path or not Path(cast(FilePath, path)).exists():
             raise ValueError('Keysign not found')
 
     return str(path)
 
 
-def get_keysign_keys(keysign_path, sock_fd, keys):
+def get_keysign_keys(keysign_path: str, sock_fd: int,
+                     keys: Iterable[_KeySignKey]) -> \
+        Sequence[SSHKeySignKeyPair]:
     """Return keypair objects which invoke ssh-keysign"""
 
     return [SSHKeySignKeyPair(keysign_path, sock_fd, key) for key in keys]
```

### Comparing `asyncssh-2.8.1/asyncssh/saslprep.py` & `asyncssh-2.9.0/asyncssh/saslprep.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -27,22 +27,23 @@
 
 """
 
 # The stringprep module should not be flagged as deprecated
 # pylint: disable=deprecated-module
 import stringprep
 # pylint: enable=deprecated-module
+from typing import Callable, Sequence
 import unicodedata
 
 
 class SASLPrepError(ValueError):
     """Invalid data provided to saslprep"""
 
 
-def _check_bidi(s):
+def _check_bidi(s: str) -> None:
     """Enforce bidirectional character check from RFC 3454 (stringprep)"""
 
     r_and_al_cat = False
     l_cat = False
 
     for c in s:
         if not r_and_al_cat and stringprep.in_table_d1(c):
@@ -55,20 +56,19 @@
         raise SASLPrepError('Both RandALCat and LCat characters present')
 
     if r_and_al_cat and not (stringprep.in_table_d1(s[0]) and
                              stringprep.in_table_d1(s[-1])):
         raise SASLPrepError('RandALCat character not at both start and end')
 
 
-def _stringprep(s, check_unassigned, mapping, normalization, prohibited, bidi):
+def _stringprep(s: str, check_unassigned: bool, mapping: Callable[[str], str],
+                normalization: str, prohibited: Sequence[Callable[[str], bool]],
+                bidi: bool) -> str:
     """Implement a stringprep profile as defined in RFC 3454"""
 
-    if not isinstance(s, str):
-        raise TypeError('argument 0 must be str, not %s' % type(s).__name__)
-
     if check_unassigned: # pragma: no branch
         for c in s:
             if stringprep.in_table_a1(c):
                 raise SASLPrepError('Unassigned character: %r' % c)
 
     if mapping: # pragma: no branch
         s = mapping(s)
@@ -84,29 +84,29 @@
 
     if bidi: # pragma: no branch
         _check_bidi(s)
 
     return s
 
 
-def _map_saslprep(s):
+def _map_saslprep(s: str) -> str:
     """Map stringprep table B.1 to nothing and C.1.2 to ASCII space"""
 
     r = []
 
     for c in s:
         if stringprep.in_table_c12(c):
             r.append(' ')
         elif not stringprep.in_table_b1(c):
             r.append(c)
 
     return ''.join(r)
 
 
-def saslprep(s):
+def saslprep(s: str) -> str:
     """Implement SASLprep profile defined in RFC 4013"""
 
     prohibited = (stringprep.in_table_c12, stringprep.in_table_c21_c22,
                   stringprep.in_table_c3, stringprep.in_table_c4,
                   stringprep.in_table_c5, stringprep.in_table_c6,
                   stringprep.in_table_c7, stringprep.in_table_c8,
                   stringprep.in_table_c9)
```

### Comparing `asyncssh-2.8.1/asyncssh/gss_unix.py` & `asyncssh-2.9.0/asyncssh/gss_unix.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2017-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2017-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,139 +16,155 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """GSSAPI wrapper for UNIX"""
 
-from gssapi import Credentials, Name, NameType
+from typing import Optional, Sequence
+
+from gssapi import Credentials, Name, NameType, OID
 from gssapi import RequirementFlag, SecurityContext
 from gssapi.exceptions import GSSError
 
 from .asn1 import OBJECT_IDENTIFIER
 
 
-def _mech_to_oid(mech):
+def _mech_to_oid(mech: OID) -> bytes:
     """Return a DER-encoded OID corresponding to the requested GSS mechanism"""
 
-    mech = bytes(mech)
-    return bytes((OBJECT_IDENTIFIER, len(mech))) + mech
+    mech_bytes = bytes(mech)
+    return bytes((OBJECT_IDENTIFIER, len(mech_bytes))) + mech_bytes
 
 
-class _GSSBase:
+class GSSBase:
     """GSS base class"""
 
-    def __init__(self, host, usage):
+    def __init__(self, host: str, usage: str):
         if '@' in host:
             self._host = Name(host)
         else:
             self._host = Name('host@' + host, NameType.hostbased_service)
 
         if usage == 'initiate':
             self._creds = Credentials(usage=usage)
         else:
             self._creds = Credentials(name=self._host, usage=usage)
 
         self._mechs = [_mech_to_oid(mech) for mech in self._creds.mechs]
-        self._ctx = None
+        self._ctx: Optional[SecurityContext] = None
 
-    def _init_context(self):
+    def _init_context(self) -> None:
         """Abstract method to construct GSS security context"""
 
         raise NotImplementedError
 
     @property
-    def mechs(self):
+    def mechs(self) -> Sequence[bytes]:
         """Return GSS mechanisms available for this host"""
 
         return self._mechs
 
     @property
-    def complete(self):
+    def complete(self) -> bool:
         """Return whether or not GSS negotiation is complete"""
 
-        return self._ctx and self._ctx.complete
+        return self._ctx.complete if self._ctx else False
 
     @property
-    def provides_mutual_auth(self):
+    def provides_mutual_auth(self) -> bool:
         """Return whether or not this context provides mutual authentication"""
 
+        assert self._ctx is not None
+
         return (RequirementFlag.mutual_authentication in
                 self._ctx.actual_flags)
 
     @property
-    def provides_integrity(self):
+    def provides_integrity(self) -> bool:
         """Return whether or not this context provides integrity protection"""
 
+        assert self._ctx is not None
+
         return RequirementFlag.integrity in self._ctx.actual_flags
 
     @property
-    def user(self):
+    def user(self) -> str:
         """Return user principal associated with this context"""
 
+        assert self._ctx is not None
+
         return str(self._ctx.initiator_name)
 
     @property
-    def host(self):
+    def host(self) -> str:
         """Return host principal associated with this context"""
 
+        assert self._ctx is not None
+
         return str(self._ctx.target_name)
 
-    def reset(self):
+    def reset(self) -> None:
         """Reset GSS security context"""
 
         self._ctx = None
 
-    def step(self, token=None):
+    def step(self, token: Optional[bytes] = None) -> Optional[bytes]:
         """Perform next step in GSS security exchange"""
 
         if not self._ctx:
             self._init_context()
 
+        assert self._ctx is not None
+
         return self._ctx.step(token)
 
-    def sign(self, data):
+    def sign(self, data: bytes) -> bytes:
         """Sign a block of data"""
 
+        assert self._ctx is not None
+
         return self._ctx.get_signature(data)
 
-    def verify(self, data, sig):
+    def verify(self, data: bytes, sig: bytes) -> bool:
         """Verify a signature for a block of data"""
 
+        assert self._ctx is not None
+
         try:
             self._ctx.verify_signature(data, sig)
             return True
         except GSSError:
             return False
 
 
-class GSSClient(_GSSBase):
+class GSSClient(GSSBase):
     """GSS client"""
 
-    def __init__(self, host, delegate_creds):
+    def __init__(self, host: str, delegate_creds: bool):
         super().__init__(host, 'initiate')
 
         flags = set((RequirementFlag.mutual_authentication,
                      RequirementFlag.integrity))
 
         if delegate_creds:
             flags.add(RequirementFlag.delegate_to_peer)
 
         self._flags = flags
 
-    def _init_context(self):
+    def _init_context(self) -> None:
         """Construct GSS client security context"""
 
         self._ctx = SecurityContext(name=self._host, creds=self._creds,
                                     flags=self._flags)
 
 
-class GSSServer(_GSSBase):
+class GSSServer(GSSBase):
     """GSS server"""
 
-    def __init__(self, host):
+    def __init__(self, host: str):
         super().__init__(host, 'accept')
 
-    def _init_context(self):
+    def _init_context(self) -> None:
         """Construct GSS server security context"""
 
         self._ctx = SecurityContext(creds=self._creds)
```

### Comparing `asyncssh-2.8.1/asyncssh/socks.py` & `asyncssh-2.9.0/asyncssh/socks.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,16 +17,26 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SOCKS forwarding support"""
 
 from ipaddress import ip_address
+from typing import TYPE_CHECKING, Callable, Optional
+
+from .forward import SSHForwarderCoro, SSHLocalForwarder
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .connection import SSHConnection
+
+
+_RecvHandler = Optional[Callable[[bytes], None]]
 
-from .forward import SSHLocalForwarder
 
 SOCKS4                  = 0x04
 SOCKS5                  = 0x05
 
 SOCKS_CONNECT           = 0x01
 
 SOCKS4_OK               = 0x5a
@@ -43,109 +53,117 @@
 
 _socks5_addr_len = { SOCKS5_ADDR_IPV4: 4, SOCKS5_ADDR_IPV6: 16 }
 
 
 class SSHSOCKSForwarder(SSHLocalForwarder):
     """SOCKS dynamic port forwarding connection handler"""
 
-    def __init__(self, conn, coro):
+    def __init__(self, conn: 'SSHConnection', coro: SSHForwarderCoro):
         super().__init__(conn, coro)
 
         self._inpbuf = b''
         self._bytes_needed = 2
-        self._recv_handler = self._recv_version
+        self._recv_handler: _RecvHandler = self._recv_version
         self._addrtype = 0
         self._host = ''
         self._port = 0
 
-    def _connect(self):
+    def _connect(self) -> None:
         """Send request to open a new tunnel connection"""
 
+        assert self._transport is not None
+
         self._recv_handler = None
 
         orig_host, orig_port = self._transport.get_extra_info('peername')[:2]
         self.forward(self._host, self._port, orig_host, orig_port)
 
-    def _send_socks4_ok(self):
+    def _send_socks4_ok(self) -> None:
         """Send SOCKS4 success response"""
 
+        assert self._transport is not None
+
         self._transport.write(SOCKS4_OK_RESPONSE)
 
-    def _send_socks5_ok(self):
+    def _send_socks5_ok(self) -> None:
         """Send SOCKS5 success response"""
 
+        assert self._transport is not None
+
         addrlen = _socks5_addr_len[self._addrtype] + 2
 
         self._transport.write(SOCKS5_OK_RESPONSE_HDR +
                               bytes((self._addrtype,)) +
                               addrlen * b'\0')
 
-    def _recv_version(self, data):
+    def _recv_version(self, data: bytes) -> None:
         """Parse SOCKS version"""
 
         if data[0] == SOCKS4:
             if data[1] == SOCKS_CONNECT:
                 self._bytes_needed = 6
                 self._recv_handler = self._recv_socks4_addr
             else:
                 self.close()
         elif data[0] == SOCKS5:
             self._bytes_needed = data[1]
             self._recv_handler = self._recv_socks5_authlist
         else:
             self.close()
 
-    def _recv_socks4_addr(self, data):
+    def _recv_socks4_addr(self, data: bytes) -> None:
         """Parse SOCKSv4 address and port"""
 
         self._port = (data[0] << 8) + data[1]
 
         # If address is 0.0.0.x, read a hostname later
         if data[2:5] != b'\0\0\0' or data[5] == 0:
             self._host = str(ip_address(data[2:]))
 
         self._bytes_needed = -1
         self._recv_handler = self._recv_socks4_user
 
-    def _recv_socks4_user(self, data):
+    def _recv_socks4_user(self, data: bytes) -> None:
         """Parse SOCKSv4 username"""
 
         # pylint: disable=unused-argument
 
         if self._host:
             self._send_socks4_ok()
             self._connect()
         else:
             self._bytes_needed = -1
             self._recv_handler = self._recv_socks4_hostname
 
-    def _recv_socks4_hostname(self, data):
+    def _recv_socks4_hostname(self, data: bytes) -> None:
         """Parse SOCKSv4 hostname"""
 
         try:
             self._host = data.decode('utf-8')
         except UnicodeDecodeError:
             self.close()
             return
 
         self._send_socks4_ok()
         self._connect()
 
-    def _recv_socks5_authlist(self, data):
+    def _recv_socks5_authlist(self, data: bytes) -> None:
         """Parse SOCKSv5 list of authentication methods"""
 
+        assert self._transport is not None
+
         if SOCKS5_AUTH_NONE in data:
             self._transport.write(bytes((SOCKS5, SOCKS5_AUTH_NONE)))
 
             self._bytes_needed = 4
             self._recv_handler = self._recv_socks5_command
         else:
             self.close()
 
-    def _recv_socks5_command(self, data):
+    def _recv_socks5_command(self, data: bytes) -> None:
         """Parse SOCKSv5 command"""
 
         if data[0] == SOCKS5 and data[1] == SOCKS_CONNECT and data[2] == 0:
             if data[3] == SOCKS5_ADDR_HOSTNAME:
                 self._bytes_needed = 1
                 self._recv_handler = self._recv_socks5_hostlen
                 self._addrtype = SOCKS5_ADDR_IPV4
@@ -157,48 +175,48 @@
                     self._recv_handler = self._recv_socks5_addr
                     self._addrtype = data[3]
                 else:
                     self.close()
         else:
             self.close()
 
-    def _recv_socks5_addr(self, data):
+    def _recv_socks5_addr(self, data: bytes) -> None:
         """Parse SOCKSv5 address"""
 
         self._host = str(ip_address(data))
 
         self._bytes_needed = 2
         self._recv_handler = self._recv_socks5_port
 
-    def _recv_socks5_hostlen(self, data):
+    def _recv_socks5_hostlen(self, data: bytes) -> None:
         """Parse SOCKSv5 host length"""
 
         self._bytes_needed = data[0]
         self._recv_handler = self._recv_socks5_host
 
-    def _recv_socks5_host(self, data):
+    def _recv_socks5_host(self, data: bytes) -> None:
         """Parse SOCKSv5 host"""
 
         try:
             self._host = data.decode('utf-8')
         except UnicodeDecodeError:
             self.close()
             return
 
         self._bytes_needed = 2
         self._recv_handler = self._recv_socks5_port
 
-    def _recv_socks5_port(self, data):
+    def _recv_socks5_port(self, data: bytes) -> None:
         """Parse SOCKSv5 port"""
 
         self._port = (data[0] << 8) + data[1]
         self._send_socks5_ok()
         self._connect()
 
-    def data_received(self, data, datatype=None):
+    def data_received(self, data: bytes, datatype: int = None) -> None:
         """Handle incoming data from the SOCKS client"""
 
         if self._recv_handler:
             self._inpbuf += data
 
             while self._recv_handler:
                 if self._bytes_needed < 0:
```

### Comparing `asyncssh-2.8.1/asyncssh/ecdsa.py` & `asyncssh-2.9.0/asyncssh/ecdsa.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,70 +16,79 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """ECDSA public key encryption handler"""
 
+from typing import Dict, Optional, Tuple, Union, cast
+
 from .asn1 import ASN1DecodeError, BitString, ObjectIdentifier, TaggedDERObject
 from .asn1 import der_encode, der_decode
+from .crypto import CryptoKey, ECDSAPrivateKey, ECDSAPublicKey
 from .crypto import lookup_ec_curve_by_params
-from .crypto import ECDSAPrivateKey, ECDSAPublicKey
 from .packet import MPInt, String, SSHPacket
 from .public_key import SSHKey, SSHOpenSSHCertificateV01
 from .public_key import KeyImportError, KeyExportError
 from .public_key import register_public_key_alg, register_certificate_alg
 from .public_key import register_x509_certificate_alg
 
+
+_PrivateKeyArgs = Tuple[bytes, Union[bytes, int], bytes]
+_PublicKeyArgs = Tuple[bytes, bytes]
+
+
 # OID for EC prime fields
 PRIME_FIELD = ObjectIdentifier('1.2.840.10045.1.1')
 
 _hash_algs = {b'1.3.132.0.10': 'sha256',
               b'nistp256':     'sha256',
               b'nistp384':     'sha384',
               b'nistp521':     'sha512'}
 
-_alg_oids = {}
-_alg_oid_map = {}
+_alg_oids: Dict[bytes, ObjectIdentifier] = {}
+_alg_oid_map: Dict[ObjectIdentifier, bytes] = {}
 
 
 class _ECKey(SSHKey):
     """Handler for elliptic curve public key encryption"""
 
-    default_hash_alg = 'sha256'
+    _key: Union[ECDSAPrivateKey, ECDSAPublicKey]
+
+    default_hash_name = 'sha256'
     pem_name = b'EC'
     pkcs8_oid = ObjectIdentifier('1.2.840.10045.2.1')
 
-    def __init__(self, key):
+    def __init__(self, key: CryptoKey):
         super().__init__(key)
 
-        self.algorithm = b'ecdsa-sha2-' + key.curve_id
+        self.algorithm = b'ecdsa-sha2-' + self._key.curve_id
         self.sig_algorithms = (self.algorithm,)
         self.x509_algorithms = (b'x509v3-' + self.algorithm,)
         self.all_sig_algorithms = set(self.sig_algorithms)
 
-        self._alg_oid = _alg_oids[key.curve_id]
-        self._hash_alg = _hash_algs[key.curve_id]
+        self._alg_oid = _alg_oids[self._key.curve_id]
+        self._hash_alg = _hash_algs[self._key.curve_id]
 
-    def __eq__(self, other):
+    def __eq__(self, other: object) -> bool:
         # This isn't protected access - both objects are _ECKey instances
         # pylint: disable=protected-access
 
         return (isinstance(other, type(self)) and
                 self._key.curve_id == other._key.curve_id and
                 self._key.x == other._key.x and
                 self._key.y == other._key.y and
                 self._key.d == other._key.d)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self._key.curve_id, self._key.x,
                      self._key.y, self._key.d))
 
     @classmethod
-    def _lookup_curve(cls, alg_params):
+    def _lookup_curve(cls, alg_params: object) -> bytes:
         """Look up an EC curve matching the specified parameters"""
 
         if isinstance(alg_params, ObjectIdentifier):
             try:
                 curve_id = _alg_oid_map[alg_params]
             except KeyError:
                 raise KeyImportError('Unknown elliptic curve OID %s' %
@@ -104,68 +113,80 @@
                 raise KeyImportError(str(exc)) from None
         else:
             raise KeyImportError('Invalid EC curve parameters')
 
         return curve_id
 
     @classmethod
-    def generate(cls, algorithm):
+    def generate(cls, algorithm: bytes) -> '_ECKey': # type: ignore
         """Generate a new EC private key"""
 
+        # pylint: disable=arguments-differ
+
         # Strip 'ecdsa-sha2-' prefix of algorithm to get curve_id
         return cls(ECDSAPrivateKey.generate(algorithm[11:]))
 
     @classmethod
-    def make_private(cls, curve_id, private_value, public_value):
+    def make_private(cls, key_params: object) -> SSHKey:
         """Construct an EC private key"""
 
+        curve_id, private_value, public_value = \
+            cast(_PrivateKeyArgs, key_params)
+
         if isinstance(private_value, bytes):
             private_value = int.from_bytes(private_value, 'big')
 
         return cls(ECDSAPrivateKey.construct(curve_id, public_value,
                                              private_value))
 
     @classmethod
-    def make_public(cls, curve_id, public_value):
+    def make_public(cls, key_params: object) -> SSHKey:
         """Construct an EC public key"""
 
+        curve_id, public_value = cast(_PublicKeyArgs, key_params)
+
         return cls(ECDSAPublicKey.construct(curve_id, public_value))
 
     @classmethod
-    def decode_pkcs1_private(cls, key_data):
+    def decode_pkcs1_private(cls, key_data: object) -> \
+            Optional[_PrivateKeyArgs]:
         """Decode a PKCS#1 format EC private key"""
 
         if (isinstance(key_data, tuple) and len(key_data) > 2 and
                 key_data[0] == 1 and isinstance(key_data[1], bytes) and
                 isinstance(key_data[2], TaggedDERObject) and
                 key_data[2].tag == 0):
             alg_params = key_data[2].value
             private_key = key_data[1]
 
             if (len(key_data) > 3 and
                     isinstance(key_data[3], TaggedDERObject) and
                     key_data[3].tag == 1 and
                     isinstance(key_data[3].value, BitString) and
                     key_data[3].value.unused == 0):
-                public_key = key_data[3].value.value
+                public_key: bytes = key_data[3].value.value
             else:
-                public_key = None
+                public_key = b''
 
             return cls._lookup_curve(alg_params), private_key, public_key
         else:
             return None
 
     @classmethod
-    def decode_pkcs1_public(cls, _key_data):
+    def decode_pkcs1_public(cls, key_data: object) -> \
+            Optional[_PublicKeyArgs]:
         """Decode a PKCS#1 format EC public key"""
 
+        # pylint: disable=unused-argument
+
         raise KeyImportError('PKCS#1 not supported for EC public keys')
 
     @classmethod
-    def decode_pkcs8_private(cls, alg_params, data):
+    def decode_pkcs8_private(cls, alg_params: object,
+                             data: bytes) -> Optional[_PrivateKeyArgs]:
         """Decode a PKCS#8 format EC private key"""
 
         try:
             key_data = der_decode(data)
         except ASN1DecodeError:
             key_data = None
 
@@ -176,118 +197,121 @@
             if (len(key_data) > 2 and
                     isinstance(key_data[2], TaggedDERObject) and
                     key_data[2].tag == 1 and
                     isinstance(key_data[2].value, BitString) and
                     key_data[2].value.unused == 0):
                 public_key = key_data[2].value.value
             else:
-                public_key = None
+                public_key = b''
 
             return cls._lookup_curve(alg_params), private_key, public_key
         else:
             return None
 
     @classmethod
-    def decode_pkcs8_public(cls, alg_params, key_data):
+    def decode_pkcs8_public(cls, alg_params: object,
+                            data: bytes) -> Optional[_PublicKeyArgs]:
         """Decode a PKCS#8 format EC public key"""
 
         if isinstance(alg_params, ObjectIdentifier):
-            return cls._lookup_curve(alg_params), key_data
+            return cls._lookup_curve(alg_params), data
         else:
             return None
 
     @classmethod
-    def decode_ssh_private(cls, packet):
+    def decode_ssh_private(cls, packet: SSHPacket) -> _PrivateKeyArgs:
         """Decode an SSH format EC private key"""
 
         curve_id = packet.get_string()
         public_key = packet.get_string()
         private_key = packet.get_mpint()
 
         return curve_id, private_key, public_key
 
     @classmethod
-    def decode_ssh_public(cls, packet):
+    def decode_ssh_public(cls, packet: SSHPacket) -> _PublicKeyArgs:
         """Decode an SSH format EC public key"""
 
         curve_id = packet.get_string()
         public_key = packet.get_string()
 
         return curve_id, public_key
 
-    def encode_public_tagged(self):
+    def encode_public_tagged(self) -> object:
         """Encode an EC public key blob as a tagged bitstring"""
 
         return TaggedDERObject(1, BitString(self._key.public_value))
 
-    def encode_pkcs1_private(self):
+    def encode_pkcs1_private(self) -> object:
         """Encode a PKCS#1 format EC private key"""
 
         if not self._key.private_value:
             raise KeyExportError('Key is not private')
 
         return (1, self._key.private_value,
                 TaggedDERObject(0, self._alg_oid),
                 self.encode_public_tagged())
 
-    def encode_pkcs1_public(self):
+    def encode_pkcs1_public(self) -> object:
         """Encode a PKCS#1 format EC public key"""
 
         raise KeyExportError('PKCS#1 is not supported for EC public keys')
 
-    def encode_pkcs8_private(self):
+    def encode_pkcs8_private(self) -> Tuple[object, object]:
         """Encode a PKCS#8 format EC private key"""
 
         if not self._key.private_value:
             raise KeyExportError('Key is not private')
 
         return self._alg_oid, der_encode((1, self._key.private_value,
                                           self.encode_public_tagged()))
 
-    def encode_pkcs8_public(self):
+    def encode_pkcs8_public(self) -> Tuple[object, object]:
         """Encode a PKCS#8 format EC public key"""
 
         return self._alg_oid, self._key.public_value
 
-    def encode_ssh_private(self):
+    def encode_ssh_private(self) -> bytes:
         """Encode an SSH format EC private key"""
 
         if not self._key.d:
             raise KeyExportError('Key is not private')
 
         return b''.join((String(self._key.curve_id),
                          String(self._key.public_value),
                          MPInt(self._key.d)))
 
-    def encode_ssh_public(self):
+    def encode_ssh_public(self) -> bytes:
         """Encode an SSH format EC public key"""
 
         return b''.join((String(self._key.curve_id),
                          String(self._key.public_value)))
 
-    def encode_agent_cert_private(self):
+    def encode_agent_cert_private(self) -> bytes:
         """Encode ECDSA certificate private key data for agent"""
 
         if not self._key.d:
             raise KeyExportError('Key is not private')
 
         return MPInt(self._key.d)
 
-    def sign_ssh(self, data, sig_algorithm):
+    def sign_ssh(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Compute an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         if not self._key.private_value:
             raise ValueError('Private key needed for signing')
 
-        r, s = der_decode(self._key.sign(data, self._hash_alg))
+        sig = der_decode(self._key.sign(data, self._hash_alg))
+        r, s = cast(Tuple[int, int], sig)
         return String(MPInt(r) + MPInt(s))
 
-    def verify_ssh(self, data, sig_algorithm, packet):
+    def verify_ssh(self, data: bytes, sig_algorithm: bytes,
+                   packet: SSHPacket) -> bool:
         """Verify an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         sig = packet.get_string()
         packet.check_end()
 
@@ -295,23 +319,23 @@
         r = packet.get_mpint()
         s = packet.get_mpint()
         packet.check_end()
 
         return self._key.verify(data, der_encode((r, s)), self._hash_alg)
 
 
-for _curve_id, _oid in ((b'nistp521', '1.3.132.0.35'),
-                        (b'nistp384', '1.3.132.0.34'),
-                        (b'nistp256', '1.2.840.10045.3.1.7'),
-                        (b'1.3.132.0.10', '1.3.132.0.10')):
+for _curve_id, _oid_str in ((b'nistp521', '1.3.132.0.35'),
+                            (b'nistp384', '1.3.132.0.34'),
+                            (b'nistp256', '1.2.840.10045.3.1.7'),
+                            (b'1.3.132.0.10', '1.3.132.0.10')):
     _algorithm = b'ecdsa-sha2-' + _curve_id
     _cert_algorithm = _algorithm + b'-cert-v01@openssh.com'
     _x509_algorithm = b'x509v3-' + _algorithm
 
-    _oid = ObjectIdentifier(_oid)
+    _oid = ObjectIdentifier(_oid_str)
     _alg_oids[_curve_id] = _oid
     _alg_oid_map[_oid] = _curve_id
 
     register_public_key_alg(_algorithm, _ECKey, True, (_algorithm,))
     register_certificate_alg(1, _algorithm, _cert_algorithm,
                              _ECKey, SSHOpenSSHCertificateV01, True)
     register_x509_certificate_alg(_x509_algorithm, True)
```

### Comparing `asyncssh-2.8.1/asyncssh/pbe.py` & `asyncssh-2.9.0/asyncssh/pbe.py`

 * *Files 8% similar despite different names*

```diff
@@ -16,20 +16,33 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """Asymmetric key password based encryption functions"""
 
-import os
-
 from hashlib import md5, sha1
+import os
+from typing import Callable, Dict, Sequence, Tuple, Union
 
 from .asn1 import ASN1DecodeError, ObjectIdentifier, der_encode, der_decode
 from .crypto import BasicCipher, get_cipher_params, pbkdf2_hmac
+from .misc import BytesOrStr, HashType
+
+
+_Cipher = Union[BasicCipher, '_RFC1423Pad']
+
+_PKCS8CipherHandler = Callable[[object, BytesOrStr, Callable, str], _Cipher]
+_PKCS8Cipher = Tuple[_PKCS8CipherHandler, Callable, str]
+
+_PBES2CipherHandler = Callable[[Sequence, str, bytes], _Cipher]
+_PBES2Cipher = Tuple[_PBES2CipherHandler, str]
+
+_PBES2KDFHandler = Callable[[Sequence, BytesOrStr, int], bytes]
+_PBES2KDF = Tuple[_PBES2KDFHandler, Tuple[object, ...]]
 
 
 _ES1_MD5_DES    = ObjectIdentifier('1.2.840.113549.1.5.3')
 _ES1_SHA1_DES   = ObjectIdentifier('1.2.840.113549.1.5.10')
 
 _ES2            = ObjectIdentifier('1.2.840.113549.1.5.13')
 
@@ -50,28 +63,28 @@
 
 _ES2_SHA1       = ObjectIdentifier('1.2.840.113549.2.7')
 _ES2_SHA224     = ObjectIdentifier('1.2.840.113549.2.8')
 _ES2_SHA256     = ObjectIdentifier('1.2.840.113549.2.9')
 _ES2_SHA384     = ObjectIdentifier('1.2.840.113549.2.10')
 _ES2_SHA512     = ObjectIdentifier('1.2.840.113549.2.11')
 
-_pkcs1_cipher = {}
-_pkcs1_dek_name = {}
+_pkcs1_cipher: Dict[bytes, str] = {}
+_pkcs1_dek_name: Dict[str, bytes] = {}
 
-_pkcs8_handler = {}
-_pkcs8_cipher_oid = {}
+_pkcs8_handler: Dict[ObjectIdentifier, _PKCS8Cipher] = {}
+_pkcs8_cipher_oid: Dict[Tuple[str, str], ObjectIdentifier] = {}
 
-_pbes2_cipher = {}
-_pbes2_cipher_oid = {}
+_pbes2_cipher: Dict[ObjectIdentifier, _PBES2Cipher] = {}
+_pbes2_cipher_oid: Dict[str, ObjectIdentifier] = {}
 
-_pbes2_kdf = {}
-_pbes2_kdf_oid = {}
+_pbes2_kdf: Dict[ObjectIdentifier, _PBES2KDF] = {}
+_pbes2_kdf_oid: Dict[str, ObjectIdentifier] = {}
 
-_pbes2_prf = {}
-_pbes2_prf_oid = {}
+_pbes2_prf: Dict[ObjectIdentifier, str] = {}
+_pbes2_prf_oid: Dict[str, ObjectIdentifier] = {}
 
 
 class KeyEncryptionError(ValueError):
     """Key encryption error
 
        This exception is raised by key decryption functions when the data
        provided is not a valid encrypted private key.
@@ -85,40 +98,42 @@
        This class implements RFC 1423 padding for encryption and
        decryption of data by block ciphers. On encryption, the data is
        padded by between 1 and the cipher's block size number of bytes,
        with the padding value being equal to the length of the padding.
 
     """
 
-    def __init__(self, cipher_name, block_size, key, iv):
+    def __init__(self, cipher_name: str, block_size: int,
+                 key: bytes, iv: bytes):
         self._cipher = BasicCipher(cipher_name, key, iv)
         self._block_size = block_size
 
-    def encrypt(self, data):
+    def encrypt(self, data: bytes) -> bytes:
         """Pad data before encrypting it"""
 
         pad = self._block_size - (len(data) % self._block_size)
         data += pad * bytes((pad,))
         return self._cipher.encrypt(data)
 
-    def decrypt(self, data):
+    def decrypt(self, data: bytes) -> bytes:
         """Remove padding from data after decrypting it"""
 
         data = self._cipher.decrypt(data)
 
         if data:
             pad = data[-1]
             if (1 <= pad <= self._block_size and
                     data[-pad:] == pad * bytes((pad,))):
                 return data[:-pad]
 
         raise KeyEncryptionError('Unable to decrypt key')
 
 
-def _pbkdf1(hash_alg, passphrase, salt, count, key_size):
+def _pbkdf1(hash_alg: HashType, passphrase: BytesOrStr, salt: bytes,
+            count: int, key_size: int) -> bytes:
     """PKCS#5 v1.5 key derivation function for password-based encryption
 
        This function implements the PKCS#5 v1.5 algorithm for deriving
        an encryption key from a passphrase and salt.
 
        The standard PBKDF1 function cannot generate more key bytes than
        the hash digest size, but 3DES uses a modified form of it which
@@ -137,23 +152,24 @@
     if len(key) <= key_size:
         return key + _pbkdf1(hash_alg, key + passphrase, salt, count,
                              key_size - len(key))
     else:
         return key[:key_size]
 
 
-def _pbkdf_p12(hash_alg, passphrase, salt, count, key_size, idx):
+def _pbkdf_p12(hash_alg: HashType, passphrase: BytesOrStr, salt: bytes,
+               count: int, key_size: int, idx: int) -> bytes:
     """PKCS#12 key derivation function for password-based encryption
 
        This function implements the PKCS#12 algorithm for deriving an
        encryption key from a passphrase and salt.
 
     """
 
-    def _make_block(data, v):
+    def _make_block(data: bytes, v: int) -> bytes:
         """Make a block a multiple of v bytes long by repeating data"""
 
         l = len(data)
         size = ((l + v - 1) // v) * v
         return (((size + l - 1) // l) * data)[:size]
 
     v = hash_alg().block_size
@@ -176,15 +192,16 @@
             I[i:i+v] = x.to_bytes(v, 'big')
 
         key += A
 
     return key[:key_size]
 
 
-def _pbes1(params, passphrase, hash_alg, cipher_name):
+def _pbes1(params: object, passphrase: BytesOrStr, hash_alg: HashType,
+           cipher_name: str) -> _Cipher:
     """PKCS#5 v1.5 cipher selection function for password-based encryption
 
        This function implements the PKCS#5 v1.5 algorithm for password-based
        encryption. It returns a cipher object which can be used to encrypt
        or decrypt data based on the specified encryption parameters,
        passphrase, and salt.
 
@@ -200,15 +217,16 @@
     key_size, iv_size, block_size = get_cipher_params(cipher_name)
     key = _pbkdf1(hash_alg, passphrase, salt, count, key_size + iv_size)
     key, iv = key[:key_size], key[key_size:]
 
     return _RFC1423Pad(cipher_name, block_size, key, iv)
 
 
-def _pbe_p12(params, passphrase, hash_alg, cipher_name):
+def _pbe_p12(params: object, passphrase: BytesOrStr, hash_alg: HashType,
+             cipher_name: str) -> _Cipher:
     """PKCS#12 cipher selection function for password-based encryption
 
        This function implements the PKCS#12 algorithm for password-based
        encryption. It returns a cipher object which can be used to encrypt
        or decrypt data based on the specified encryption parameters,
        passphrase, and salt.
 
@@ -221,23 +239,23 @@
 
     salt, count = params
 
     key_size, iv_size, block_size = get_cipher_params(cipher_name)
     key = _pbkdf_p12(hash_alg, passphrase, salt, count, key_size, 1)
 
     if block_size == 1:
-        cipher = BasicCipher(cipher_name, key, b'')
+        cipher: _Cipher = BasicCipher(cipher_name, key, b'')
     else:
         iv = _pbkdf_p12(hash_alg, passphrase, salt, count, iv_size, 2)
         cipher = _RFC1423Pad(cipher_name, block_size, key, iv)
 
     return cipher
 
 
-def _pbes2_iv(enc_params, cipher_name, key):
+def _pbes2_iv(enc_params: Sequence, cipher_name: str, key: bytes) -> _Cipher:
     """PKCS#5 v2.0 handler for PBES2 ciphers with an IV as a parameter
 
        This function returns the appropriate cipher object to use for
        PBES2 encryption for ciphers that have only an IV as an encryption
        parameter.
 
     """
@@ -249,15 +267,16 @@
 
     if len(enc_params[0]) != iv_size:
         raise KeyEncryptionError('Invalid length IV for PBES2 encryption')
 
     return _RFC1423Pad(cipher_name, block_size, key, enc_params[0])
 
 
-def _pbes2_pbkdf2(kdf_params, passphrase, default_key_size):
+def _pbes2_pbkdf2(kdf_params: Sequence, passphrase: BytesOrStr,
+                  default_key_size: int) -> bytes:
     """PKCS#5 v2.0 handler for PBKDF2 key derivation
 
        This function parses the PBKDF2 arguments from a PKCS#8 encrypted key
        and returns the encryption key to use for encryption.
 
     """
 
@@ -296,15 +315,15 @@
 
     if isinstance(passphrase, str):
         passphrase = passphrase.encode('utf-8')
 
     return pbkdf2_hmac(hash_name, passphrase, salt, count, key_size)
 
 
-def _pbes2(params, passphrase):
+def _pbes2(params: object, passphrase: BytesOrStr) -> _Cipher:
     """PKCS#5 v2.0 cipher selection function for password-based encryption
 
        This function implements the PKCS#5 v2.0 algorithm for password-based
        encryption. It returns a cipher object which can be used to encrypt
        or decrypt data based on the specified encryption parameters and
        passphrase.
 
@@ -331,52 +350,59 @@
     enc_handler, cipher_name = _pbes2_cipher[enc_alg]
     default_key_size, _, _ = get_cipher_params(cipher_name)
 
     key = kdf_handler(kdf_params, passphrase, default_key_size, *kdf_args)
     return enc_handler(enc_params, cipher_name, key)
 
 
-def register_pkcs1_cipher(pkcs1_cipher_name, pkcs1_dek_name, cipher_name):
+def register_pkcs1_cipher(pkcs1_cipher_name: str, pkcs1_dek_name: bytes,
+                          cipher_name: str) -> None:
     """Register a cipher used for PKCS#1 private key encryption"""
 
     _pkcs1_cipher[pkcs1_dek_name] = cipher_name
     _pkcs1_dek_name[pkcs1_cipher_name] = pkcs1_dek_name
 
 
-def register_pkcs8_cipher(pkcs8_cipher_name, hash_name, pkcs8_cipher_oid,
-                          handler, hash_alg, cipher_name):
+def register_pkcs8_cipher(pkcs8_cipher_name: str, hash_name: str,
+                          pkcs8_cipher_oid: ObjectIdentifier,
+                          handler: _PKCS8CipherHandler, hash_alg: HashType,
+                          cipher_name: str) -> None:
     """Register a cipher used for PKCS#8 private key encryption"""
 
     _pkcs8_handler[pkcs8_cipher_oid] = (handler, hash_alg, cipher_name)
     _pkcs8_cipher_oid[pkcs8_cipher_name, hash_name] = pkcs8_cipher_oid
 
 
-def register_pbes2_cipher(pbes2_cipher_name, pbes2_cipher_oid,
-                          handler, cipher_name):
+def register_pbes2_cipher(pbes2_cipher_name: str,
+                          pbes2_cipher_oid: ObjectIdentifier,
+                          handler: _PBES2CipherHandler,
+                          cipher_name: str) -> None:
     """Register a PBES2 encryption algorithm"""
 
     _pbes2_cipher[pbes2_cipher_oid] = (handler, cipher_name)
     _pbes2_cipher_oid[pbes2_cipher_name] = pbes2_cipher_oid
 
 
-def register_pbes2_kdf(kdf_name, kdf_oid, handler, *args):
+def register_pbes2_kdf(kdf_name: str, kdf_oid: ObjectIdentifier,
+                       handler: _PBES2KDFHandler, *args: object) -> None:
     """Register a PBES2 key derivation function"""
 
     _pbes2_kdf[kdf_oid] = (handler, args)
     _pbes2_kdf_oid[kdf_name] = kdf_oid
 
 
-def register_pbes2_prf(hash_name, prf_oid):
+def register_pbes2_prf(hash_name: str, prf_oid: ObjectIdentifier) -> None:
     """Register a PBES2 pseudo-random function"""
 
     _pbes2_prf[prf_oid] = hash_name
     _pbes2_prf_oid[hash_name] = prf_oid
 
 
-def pkcs1_encrypt(data, pkcs1_cipher_name, passphrase):
+def pkcs1_encrypt(data: bytes, pkcs1_cipher_name: str,
+                  passphrase: BytesOrStr) -> Tuple[bytes, bytes, bytes]:
     """Encrypt PKCS#1 key data
 
        This function encrypts PKCS#1 key data using the specified cipher
        and passphrase. Available ciphers include:
 
            aes128-cbc, aes192-cbc, aes256-cbc, des-cbc, des3-cbc
 
@@ -392,15 +418,16 @@
 
         cipher = _RFC1423Pad(cipher_name, block_size, key, iv)
         return pkcs1_dek_name, iv, cipher.encrypt(data)
     else:
         raise KeyEncryptionError('Unknown PKCS#1 encryption algorithm')
 
 
-def pkcs1_decrypt(data, pkcs1_dek_name, iv, passphrase):
+def pkcs1_decrypt(data: bytes, pkcs1_dek_name: bytes, iv: bytes,
+                  passphrase: BytesOrStr) -> bytes:
     """Decrypt PKCS#1 key data
 
        This function decrypts PKCS#1 key data using the specified algorithm,
        initialization vector, and passphrase. The algorithm name and IV
        should be taken from the PEM DEK-Info header.
 
     """
@@ -412,15 +439,16 @@
 
         cipher = _RFC1423Pad(cipher_name, block_size, key, iv)
         return cipher.decrypt(data)
     else:
         raise KeyEncryptionError('Unknown PKCS#1 encryption algorithm')
 
 
-def pkcs8_encrypt(data, pkcs8_cipher_name, hash_name, version, passphrase):
+def pkcs8_encrypt(data: bytes, pkcs8_cipher_name: str, hash_name: str,
+                  version: int, passphrase: BytesOrStr) -> bytes:
     """Encrypt PKCS#8 key data
 
        This function encrypts PKCS#8 key data using the specified cipher,
        hash, encryption version, and passphrase.
 
        Available ciphers include:
 
@@ -438,15 +466,15 @@
     """
 
     if version == 1 and (pkcs8_cipher_name, hash_name) in _pkcs8_cipher_oid:
         pkcs8_cipher_oid = _pkcs8_cipher_oid[pkcs8_cipher_name, hash_name]
         handler, hash_alg, cipher_name = _pkcs8_handler[pkcs8_cipher_oid]
 
         alg = pkcs8_cipher_oid
-        params = (os.urandom(8), 2048)
+        params: object = (os.urandom(8), 2048)
         cipher = handler(params, passphrase, hash_alg, cipher_name)
     elif version == 2 and pkcs8_cipher_name in _pbes2_cipher_oid:
         pbes2_cipher_oid = _pbes2_cipher_oid[pkcs8_cipher_name]
         _, cipher_name = _pbes2_cipher[pbes2_cipher_oid]
         _, iv_size, _ = get_cipher_params(cipher_name)
 
         kdf_params = [os.urandom(8), 2048]
@@ -464,15 +492,15 @@
         cipher = _pbes2(params, passphrase)
     else:
         raise KeyEncryptionError('Unknown PKCS#8 encryption algorithm')
 
     return der_encode(((alg, params), cipher.encrypt(data)))
 
 
-def pkcs8_decrypt(key_data, passphrase):
+def pkcs8_decrypt(key_data: object, passphrase: BytesOrStr) -> object:
     """Decrypt PKCS#8 key data
 
        This function decrypts key data in PKCS#8 EncryptedPrivateKeyInfo
        format using the specified passphrase.
 
     """
```

### Comparing `asyncssh-2.8.1/asyncssh/agent.py` & `asyncssh-2.9.0/asyncssh/agent.py`

 * *Files 8% similar despite different names*

```diff
@@ -20,30 +20,69 @@
 
 """SSH agent client"""
 
 import asyncio
 import errno
 import os
 import sys
+from types import TracebackType
+from typing import TYPE_CHECKING, List, Optional, Sequence, Tuple, Type, Union
+from typing_extensions import Protocol
 
+from .listener import SSHForwardListener
 from .misc import async_context_manager, maybe_wait_closed
 from .packet import Byte, String, UInt32, PacketDecodeError, SSHPacket
-from .public_key import SSHKeyPair, load_default_keypairs, load_keypairs
+from .public_key import KeyPairListArg, SSHCertificate, SSHKeyPair
+from .public_key import load_default_keypairs, load_keypairs
+
+if TYPE_CHECKING:
+    from tempfile import TemporaryDirectory
+
+
+class AgentReader(Protocol):
+    """Protocol for reading from an SSH agent"""
+
+    async def readexactly(self, n: int) -> bytes:
+        """Read exactly n bytes from the SSH agent"""
+
+
+class AgentWriter(Protocol):
+    """Protocol for writing to an SSH agent"""
+
+    def write(self, data: bytes) -> None:
+        """Write bytes to the SSH agent"""
+
+    def close(self) -> None:
+        """Close connection to the SSH agent"""
+
+    async def wait_closed(self) -> None:
+        """Wait for the connection to the SSH agent to close"""
 
 
 try:
     if sys.platform == 'win32': # pragma: no cover
         from .agent_win32 import open_agent
     else:
         from .agent_unix import open_agent
 except ImportError as _exc: # pragma: no cover
-    async def open_agent(_agent_path, reason=str(_exc)):
+    async def open_agent(agent_path: Optional[str]) -> \
+            Tuple[AgentReader, AgentWriter]:
         """Dummy function if we're unable to import agent support"""
 
-        raise OSError(errno.ENOENT, 'Agent support unavailable: %s' % reason)
+        raise OSError(errno.ENOENT, 'Agent support unavailable: %s' % str(_exc))
+
+
+class _SupportsOpenAgentConnection(Protocol):
+    """A class that supports open_agent_connection"""
+
+    async def open_agent_connection(self) -> Tuple[AgentReader, AgentWriter]:
+        """Open a forwarded ssh-agent connection back to the client"""
+
+
+_AgentPath = Union[None, str, _SupportsOpenAgentConnection]
 
 
 # Client request message numbers
 SSH_AGENTC_REQUEST_IDENTITIES            = 11
 SSH_AGENTC_SIGN_REQUEST                  = 13
 SSH_AGENTC_ADD_IDENTITY                  = 17
 SSH_AGENTC_REMOVE_IDENTITY               = 18
@@ -74,145 +113,155 @@
 
 
 class SSHAgentKeyPair(SSHKeyPair):
     """Surrogate for a key managed by the SSH agent"""
 
     _key_type = 'agent'
 
-    def __init__(self, agent, algorithm, public_data, comment):
+    def __init__(self, agent: 'SSHAgentClient', algorithm: bytes,
+                 public_data: bytes, comment: bytes):
         is_cert = algorithm.endswith(b'-cert-v01@openssh.com')
 
         if is_cert:
             if algorithm.startswith(b'sk-'):
                 sig_algorithm = algorithm[:-21] + b'@openssh.com'
             else:
                 sig_algorithm = algorithm[:-21]
         else:
             sig_algorithm = algorithm
 
         # Neither Pageant nor the Win10 OpenSSH agent seems to support the
         # ssh-agent protocol flags used to request RSA SHA2 signatures yet
         if sig_algorithm == b'ssh-rsa' and sys.platform != 'win32':
-            sig_algorithms = (b'rsa-sha2-256', b'rsa-sha2-512', b'ssh-rsa')
+            sig_algorithms: Sequence[bytes] = \
+                (b'rsa-sha2-256', b'rsa-sha2-512', b'ssh-rsa')
         else:
             sig_algorithms = (sig_algorithm,)
 
         if is_cert:
-            host_key_algorithms = (algorithm,)
+            host_key_algorithms: Sequence[bytes] = (algorithm,)
         else:
             host_key_algorithms = sig_algorithms
 
         super().__init__(algorithm, sig_algorithm, sig_algorithms,
                          host_key_algorithms, public_data, comment)
 
         self._agent = agent
         self._is_cert = is_cert
         self._flags = 0
 
-    def set_certificate(self, cert):
+    def set_certificate(self, cert: SSHCertificate) -> None:
         """Set certificate to use with this key"""
 
         super().set_certificate(cert)
 
         self._is_cert = True
 
-    def set_sig_algorithm(self, sig_algorithm):
+    def set_sig_algorithm(self, sig_algorithm: bytes) -> None:
         """Set the signature algorithm to use when signing data"""
 
         super().set_sig_algorithm(sig_algorithm)
 
         if sig_algorithm == b'rsa-sha2-256':
             self._flags |= SSH_AGENT_RSA_SHA2_256
         elif sig_algorithm == b'rsa-sha2-512':
             self._flags |= SSH_AGENT_RSA_SHA2_512
 
-    async def sign(self, data):
-        """Sign a block of data with this private key"""
+    async def sign_async(self, data: bytes) -> bytes:
+        """Asynchronously sign a block of data with this private key"""
 
         return await self._agent.sign(self.key_public_data, data, self._flags)
 
-    async def remove(self):
+    async def remove(self) -> None:
         """Remove this key pair from the agent"""
 
         await self._agent.remove_keys([self])
 
 
 class SSHAgentClient:
     """SSH agent client"""
 
-    def __init__(self, agent_path):
+    def __init__(self, agent_path: _AgentPath):
         self._agent_path = agent_path
-        self._reader = None
-        self._writer = None
+        self._reader: Optional[AgentReader] = None
+        self._writer: Optional[AgentWriter] = None
         self._lock = asyncio.Lock()
 
-    async def __aenter__(self):
+    async def __aenter__(self) -> 'SSHAgentClient':
         """Allow SSHAgentClient to be used as an async context manager"""
 
         return self
 
-    async def __aexit__(self, *exc_info):
+    async def __aexit__(self, exc_type: Optional[Type[BaseException]],
+                        exc_value: Optional[BaseException],
+                        traceback: Optional[TracebackType]) -> bool:
         """Wait for connection close when used as an async context manager"""
 
         await self._cleanup()
+        return False
 
-    async def _cleanup(self):
+    async def _cleanup(self) -> None:
         """Clean up this SSH agent client"""
 
         self.close()
         await self.wait_closed()
 
     @staticmethod
-    def encode_constraints(lifetime, confirm):
+    def encode_constraints(lifetime: Optional[int], confirm: bool) -> bytes:
         """Encode key constraints"""
 
         result = b''
 
         if lifetime:
             result += Byte(SSH_AGENT_CONSTRAIN_LIFETIME) + UInt32(lifetime)
 
         if confirm:
             result += Byte(SSH_AGENT_CONSTRAIN_CONFIRM)
 
         return result
 
-    async def connect(self):
+    async def connect(self) -> None:
         """Connect to the SSH agent"""
 
-        if hasattr(self._agent_path, 'open_agent_connection'):
+        if isinstance(self._agent_path, str) or self._agent_path is None:
+            self._reader, self._writer = await open_agent(self._agent_path)
+        else:
             self._reader, self._writer = \
                 await self._agent_path.open_agent_connection()
-        else:
-            self._reader, self._writer = await open_agent(self._agent_path)
 
-    async def _make_request(self, msgtype, *args):
+    async def _make_request(self, msgtype: int, *args: bytes) -> \
+            Tuple[int, SSHPacket]:
         """Send an SSH agent request"""
 
         async with self._lock:
             try:
                 if not self._writer:
                     await self.connect()
 
-                payload = Byte(msgtype) + b''.join(args)
-                self._writer.write(UInt32(len(payload)) + payload)
+                reader = self._reader
+                writer = self._writer
 
-                resplen = await self._reader.readexactly(4)
-                resplen = int.from_bytes(resplen, 'big')
+                assert reader is not None
+                assert writer is not None
 
-                resp = await self._reader.readexactly(resplen)
-                resp = SSHPacket(resp)
+                payload = Byte(msgtype) + b''.join(args)
+                writer.write(UInt32(len(payload)) + payload)
 
+                resplen = int.from_bytes((await reader.readexactly(4)), 'big')
+
+                resp = SSHPacket((await reader.readexactly(resplen)))
                 resptype = resp.get_byte()
 
                 return resptype, resp
             except (OSError, EOFError, PacketDecodeError) as exc:
                 await self._cleanup()
                 raise ValueError(str(exc)) from None
 
-    async def get_keys(self, identities=()):
+    async def get_keys(self, identities: Optional[Sequence[bytes]] = None) -> \
+            Sequence[SSHKeyPair]:
         """Request the available client keys
 
            This method is a coroutine which returns a list of client keys
            available in the ssh-agent.
 
            :param identities: (optional)
                A list of allowed byte string identities to return. If empty,
@@ -222,15 +271,15 @@
 
         """
 
         resptype, resp = \
             await self._make_request(SSH_AGENTC_REQUEST_IDENTITIES)
 
         if resptype == SSH_AGENT_IDENTITIES_ANSWER:
-            result = []
+            result: List[SSHKeyPair] = []
 
             num_keys = resp.get_uint32()
             for _ in range(num_keys):
                 key_blob = resp.get_string()
                 comment = resp.get_string()
 
                 if identities and key_blob not in identities:
@@ -243,15 +292,16 @@
                                               key_blob, comment))
 
             resp.check_end()
             return result
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def sign(self, key_blob, data, flags=0):
+    async def sign(self, key_blob: bytes, data: bytes,
+                   flags: int = 0) -> bytes:
         """Sign a block of data with the requested key"""
 
         resptype, resp = await self._make_request(SSH_AGENTC_SIGN_REQUEST,
                                                   String(key_blob),
                                                   String(data), UInt32(flags))
 
         if resptype == SSH_AGENT_SIGN_RESPONSE:
@@ -259,16 +309,17 @@
             resp.check_end()
             return sig
         elif resptype == SSH_AGENT_FAILURE:
             raise ValueError('Unable to sign with requested key')
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def add_keys(self, keylist=(), passphrase=None,
-                       lifetime=None, confirm=False):
+    async def add_keys(self, keylist: KeyPairListArg = (),
+                       passphrase: str = None, lifetime: int = None,
+                       confirm: bool = False) -> None:
         """Add keys to the agent
 
            This method adds a list of local private keys and optional
            matching certificates to the agent.
 
            :param keylist: (optional)
                The list of keys to add. If not specified, an attempt will
@@ -339,16 +390,17 @@
                 resp.check_end()
             elif resptype == SSH_AGENT_FAILURE:
                 if not ignore_failures:
                     raise ValueError('Unable to add key')
             else:
                 raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def add_smartcard_keys(self, provider, pin=None,
-                                 lifetime=None, confirm=False):
+    async def add_smartcard_keys(self, provider: str, pin: str = None,
+                                 lifetime: int = None,
+                                 confirm: bool = False) -> None:
         """Store keys associated with a smart card in the agent
 
            :param provider:
                The name of the smart card provider
            :param pin: (optional)
                The PIN to use to unlock the smart card
            :param lifetime: (optional)
@@ -378,15 +430,15 @@
         if resptype == SSH_AGENT_SUCCESS:
             resp.check_end()
         elif resptype == SSH_AGENT_FAILURE:
             raise ValueError('Unable to add keys')
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def remove_keys(self, keylist):
+    async def remove_keys(self, keylist: Sequence[SSHKeyPair]) -> None:
         """Remove a key stored in the agent
 
            :param keylist:
                The list of keys to remove.
            :type keylist: `list` of :class:`SSHKeyPair`
 
            :raises: :exc:`ValueError` if any keys are not found
@@ -401,15 +453,16 @@
             if resptype == SSH_AGENT_SUCCESS:
                 resp.check_end()
             elif resptype == SSH_AGENT_FAILURE:
                 raise ValueError('Key not found')
             else:
                 raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def remove_smartcard_keys(self, provider, pin=None):
+    async def remove_smartcard_keys(self, provider: str,
+                                    pin: str = None) -> None:
         """Remove keys associated with a smart card stored in the agent
 
            :param provider:
                The name of the smart card provider
            :param pin: (optional)
                The PIN to use to unlock the smart card
            :type provider: `str`
@@ -426,15 +479,15 @@
         if resptype == SSH_AGENT_SUCCESS:
             resp.check_end()
         elif resptype == SSH_AGENT_FAILURE:
             raise ValueError('Keys not found')
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def remove_all(self):
+    async def remove_all(self) -> None:
         """Remove all keys stored in the agent
 
            :raises: :exc:`ValueError` if the keys can't be removed
 
         """
 
         resptype, resp = \
@@ -443,15 +496,15 @@
         if resptype == SSH_AGENT_SUCCESS:
             resp.check_end()
         elif resptype == SSH_AGENT_FAILURE:
             raise ValueError('Unable to remove all keys')
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def lock(self, passphrase):
+    async def lock(self, passphrase: str) -> None:
         """Lock the agent using the specified passphrase
 
            .. note:: The lock and unlock actions don't appear to be
                      supported on the Windows 10 OpenSSH agent.
 
            :param passphrase:
                The passphrase required to later unlock the agent
@@ -467,15 +520,15 @@
         if resptype == SSH_AGENT_SUCCESS:
             resp.check_end()
         elif resptype == SSH_AGENT_FAILURE:
             raise ValueError('Unable to lock SSH agent')
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def unlock(self, passphrase):
+    async def unlock(self, passphrase: str) -> None:
         """Unlock the agent using the specified passphrase
 
            .. note:: The lock and unlock actions don't appear to be
                      supported on the Windows 10 OpenSSH agent.
 
            :param passphrase:
                The passphrase to use to unlock the agent
@@ -491,15 +544,15 @@
         if resptype == SSH_AGENT_SUCCESS:
             resp.check_end()
         elif resptype == SSH_AGENT_FAILURE:
             raise ValueError('Unable to unlock SSH agent')
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    async def query_extensions(self):
+    async def query_extensions(self) -> Sequence[str]:
         """Return a list of extensions supported by the agent
 
            :returns: A list of strings of supported extension names
 
         """
 
         resptype, resp = await self._make_request(SSH_AGENTC_EXTENSION,
@@ -508,39 +561,39 @@
         if resptype == SSH_AGENT_SUCCESS:
             result = []
 
             while resp:
                 exttype = resp.get_string()
 
                 try:
-                    exttype = exttype.decode('utf-8')
+                    exttype_str = exttype.decode('utf-8')
                 except UnicodeDecodeError:
                     raise ValueError('Invalid extension type name') from None
 
-                result.append(exttype)
+                result.append(exttype_str)
 
             return result
         elif resptype == SSH_AGENT_FAILURE:
             return []
         else:
             raise ValueError('Unknown SSH agent response: %d' % resptype)
 
-    def close(self):
+    def close(self) -> None:
         """Close the SSH agent connection
 
            This method closes the connection to the ssh-agent. Any
            attempts to use this :class:`SSHAgentClient` or the key
            pairs it previously returned will result in an error.
 
         """
 
         if self._writer:
             self._writer.close()
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this agent connection to close
 
            This method is a coroutine which can be called to block until
            the connection to the agent has finished closing.
 
         """
 
@@ -550,33 +603,34 @@
             self._reader = None
             self._writer = None
 
 
 class SSHAgentListener:
     """Listener used to forward agent connections"""
 
-    def __init__(self, tempdir, path, unix_listener):
+    def __init__(self, tempdir: 'TemporaryDirectory[str]', path: str,
+                 unix_listener: SSHForwardListener):
         self._tempdir = tempdir
         self._path = path
         self._unix_listener = unix_listener
 
-    def get_path(self):
+    def get_path(self) -> str:
         """Return the path being listened on"""
 
         return self._path
 
-    def close(self):
+    def close(self) -> None:
         """Close the agent listener"""
 
         self._unix_listener.close()
         self._tempdir.cleanup()
 
 
 @async_context_manager
-async def connect_agent(agent_path=None):
+async def connect_agent(agent_path: _AgentPath = None) -> 'SSHAgentClient':
     """Make a connection to the SSH agent
 
        This function attempts to connect to an ssh-agent process
        listening on a UNIX domain socket at `agent_path`. If not
        provided, it will attempt to get the path from the `SSH_AUTH_SOCK`
        environment variable.
```

### Comparing `asyncssh-2.8.1/asyncssh/sk_eddsa.py` & `asyncssh-2.9.0/asyncssh/sk_eddsa.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2019-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2019-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,139 +17,154 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """U2F EdDSA public key encryption handler"""
 
 from hashlib import sha256
+from typing import Optional, Tuple, cast
 
 from .crypto import EdDSAPublicKey, ed25519_available
-from .packet import Byte, String, UInt32
+from .packet import Byte, String, UInt32, SSHPacket
 from .public_key import KeyExportError, SSHKey, SSHOpenSSHCertificateV01
 from .public_key import register_public_key_alg, register_certificate_alg
 from .public_key import register_sk_alg
 from .sk import SSH_SK_ED25519, SSH_SK_USER_PRESENCE_REQD, sk_enroll, sk_sign
 
 
+_PrivateKeyArgs = Tuple[bytes, bytes, int, bytes, bytes]
+_PublicKeyArgs = Tuple[bytes, bytes]
+
+
 class _SKEd25519Key(SSHKey):
     """Handler for U2F Ed25519 public key encryption"""
 
+    _key: EdDSAPublicKey
+
     algorithm = b'sk-ssh-ed25519@openssh.com'
     sig_algorithms = (algorithm,)
     all_sig_algorithms = set(sig_algorithms)
     use_executor = True
 
-    def __init__(self, public_value, application, flags=None,
-                 key_handle=None, reserved=None):
+    def __init__(self, public_value: bytes, application: bytes,
+                 flags: int = 0, key_handle: bytes = None,
+                 reserved: bytes = b''):
         super().__init__(EdDSAPublicKey.construct(b'ed25519', public_value))
 
         self._application = application
         self._flags = flags
         self._key_handle = key_handle
         self._reserved = reserved
 
-    def __eq__(self, other):
+    def __eq__(self, other: object) -> bool:
         # This isn't protected access - both objects are _SKEd25519Key instances
         # pylint: disable=protected-access
 
         return (isinstance(other, type(self)) and
                 self._key.public_value == other._key.public_value and
                 self._application == other._application and
                 self._flags == other._flags and
                 self._key_handle == other._key_handle and
                 self._reserved == other._reserved)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self._key.public_value, self._application, self._flags,
                      self._key_handle, self._reserved))
 
     @classmethod
-    def generate(cls, algorithm, application='ssh:', user='AsyncSSH',
-                 pin=None, resident=False, touch_required=True):
+    def generate(cls, algorithm: bytes, *, # type: ignore
+                 application: str = 'ssh:', user: str = 'AsyncSSH',
+                 pin: Optional[str] = None, resident: bool = False,
+                 touch_required: bool = True) -> '_SKEd25519Key':
         """Generate a new U2F Ed25519 private key"""
 
-        # pylint: disable=unused-argument
+        # pylint: disable=arguments-differ
 
         application = application.encode('utf-8')
         flags = SSH_SK_USER_PRESENCE_REQD if touch_required else 0
 
         public_value, key_handle = sk_enroll(SSH_SK_ED25519, application,
                                              user, pin, resident)
 
         return cls(public_value, application, flags, key_handle, b'')
 
     @classmethod
-    def make_private(cls, public_value, application,
-                     flags, key_handle, reserved):
+    def make_private(cls, key_params: object) -> SSHKey:
         """Construct a U2F Ed25519 private key"""
 
+        public_value, application, flags, key_handle, reserved = \
+            cast(_PrivateKeyArgs, key_params)
+
         return cls(public_value, application, flags, key_handle, reserved)
 
     @classmethod
-    def make_public(cls, public_value, application):
+    def make_public(cls, key_params: object) -> SSHKey:
         """Construct a U2F Ed25519 public key"""
 
+        public_value, application = cast(_PublicKeyArgs, key_params)
+
         return cls(public_value, application)
 
     @classmethod
-    def decode_ssh_private(cls, packet):
+    def decode_ssh_private(cls, packet: SSHPacket) -> _PrivateKeyArgs:
         """Decode an SSH format U2F Ed25519 private key"""
 
         public_value = packet.get_string()
         application = packet.get_string()
         flags = packet.get_byte()
         key_handle = packet.get_string()
         reserved = packet.get_string()
 
         return public_value, application, flags, key_handle, reserved
 
     @classmethod
-    def decode_ssh_public(cls, packet):
+    def decode_ssh_public(cls, packet: SSHPacket) -> _PublicKeyArgs:
         """Decode an SSH format U2F Ed25519 public key"""
 
         public_value = packet.get_string()
         application = packet.get_string()
 
         return public_value, application
 
-    def encode_ssh_private(self):
+    def encode_ssh_private(self) -> bytes:
         """Encode an SSH format U2F Ed25519 private key"""
 
         if self._key_handle is None:
             raise KeyExportError('Key is not private')
 
         return b''.join((String(self._key.public_value),
                          String(self._application), Byte(self._flags),
                          String(self._key_handle), String(self._reserved)))
 
-    def encode_ssh_public(self):
+    def encode_ssh_public(self) -> bytes:
         """Encode an SSH format U2F Ed25519 public key"""
 
         return b''.join((String(self._key.public_value),
                          String(self._application)))
 
-    def encode_agent_cert_private(self):
+    def encode_agent_cert_private(self) -> bytes:
         """Encode U2F Ed25519 certificate private key data for agent"""
 
         return self.encode_ssh_private()
 
-    def sign_ssh(self, data, sig_algorithm):
+    def sign_ssh(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Compute an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         if self._key_handle is None:
             raise ValueError('Key handle needed for signing')
 
         flags, counter, sig = sk_sign(sha256(data).digest(), self._application,
                                       self._key_handle, self._flags)
 
         return String(sig) + Byte(flags) + UInt32(counter)
 
-    def verify_ssh(self, data, sig_algorithm, packet):
+    def verify_ssh(self, data: bytes, sig_algorithm: bytes,
+                   packet: SSHPacket) -> bool:
         """Verify an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         sig = packet.get_string()
         flags = packet.get_byte()
         counter = packet.get_uint32()
```

### Comparing `asyncssh-2.8.1/asyncssh/sk.py` & `asyncssh-2.9.0/asyncssh/sk.py`

 * *Files 26% similar despite different names*

```diff
@@ -19,93 +19,111 @@
 #     Ron Frederick - initial implementation, API, and documentation
 
 """U2F security key handler"""
 
 from hashlib import sha256
 import hmac
 import time
+from typing import Callable, List, Mapping, NoReturn, Optional
+from typing import Sequence, Tuple, TypeVar, cast
+
+
+_PollResult = TypeVar('_PollResult')
+_SKResidentKey = Tuple[int, str, bytes, bytes]
+
 
 _CTAP1_POLL_INTERVAL = 0.1
 
 _dummy_hash = 32 * b'\0'
 
 # Flags
 SSH_SK_USER_PRESENCE_REQD = 0x01
 
 # Algorithms
 SSH_SK_ECDSA = -7
 SSH_SK_ED25519 = -8
 
 
-def _decode_public_key(alg, public_key):
+def _decode_public_key(alg: int, public_key: Mapping[int, object]) -> bytes:
     """Decode algorithm and public value from a CTAP public key"""
 
+    result = cast(bytes, public_key[-2])
+
     if alg == SSH_SK_ED25519:
-        return  public_key[-2]
+        return  result
     else:
-        return  b'\x04' + public_key[-2] + public_key[-3]
+        return  b'\x04' + result + cast(bytes, public_key[-3])
 
 
-def _ctap1_poll(poll_interval, func, *args):
+def _ctap1_poll(poll_interval: float, func: Callable[..., _PollResult],
+                *args: object) -> _PollResult:
     """Poll until a CTAP1 response is received"""
 
     while True:
         try:
             return func(*args)
         except ApduError as exc:
             if exc.code != APDU.USE_NOT_SATISFIED:
                 raise
 
             time.sleep(poll_interval)
 
 
-def _ctap1_enroll(dev, alg, application):
+def _ctap1_enroll(dev: 'CtapHidDevice', alg: int,
+                  application: bytes) -> Tuple[bytes, bytes]:
     """Enroll a new security key using CTAP version 1"""
 
     ctap1 = Ctap1(dev)
 
     if alg != SSH_SK_ECDSA:
         raise ValueError('Unsupported algorithm')
 
     app_hash = sha256(application).digest()
     registration = _ctap1_poll(_CTAP1_POLL_INTERVAL, ctap1.register,
                                _dummy_hash, app_hash)
 
     return registration.public_key, registration.key_handle
 
 
-def _ctap2_enroll(dev, alg, application, user, pin, resident):
+def _ctap2_enroll(dev: 'CtapHidDevice', alg: int, application: bytes,
+                  user: str, pin: Optional[str],
+                  resident: bool) -> Tuple[bytes, bytes]:
     """Enroll a new security key using CTAP version 2"""
 
     ctap2 = Ctap2(dev)
 
     application = application.decode('utf-8')
     rp = {'id': application, 'name': application}
-    user = {'id': user.encode('utf-8'), 'name': user}
+    user_cred = {'id': user.encode('utf-8'), 'name': user}
     key_params = [{'type': 'public-key', 'alg': alg}]
     options = {'rk': resident}
 
+    pin_protocol: Optional[PinProtocolV1]
+    pin_auth: Optional[bytes]
+
     if pin:
         pin_protocol = PinProtocolV1()
         pin_token = ClientPin(ctap2, pin_protocol).get_pin_token(pin)
         pin_auth = hmac.new(pin_token, _dummy_hash, sha256).digest()[:16]
     else:
         pin_protocol = None
         pin_auth = None
 
-    cred = ctap2.make_credential(_dummy_hash, rp, user, key_params,
+    pin_version = pin_protocol.VERSION if pin_protocol else None
+    cred = ctap2.make_credential(_dummy_hash, rp, user_cred, key_params,
                                  options=options, pin_uv_param=pin_auth,
-                                 pin_uv_protocol=pin_protocol)
+                                 pin_uv_protocol=pin_version)
     cdata = cred.auth_data.credential_data
 
     # pylint: disable=no-member
     return _decode_public_key(alg, cdata.public_key), cdata.credential_id
 
 
-def _ctap1_sign(dev, message_hash, application, key_handle):
+def _ctap1_sign(dev: 'CtapHidDevice', message_hash: bytes, application: bytes,
+                key_handle: bytes) -> Tuple[int, int, bytes]:
     """Sign a message with a security key using CTAP version 1"""
 
     ctap1 = Ctap1(dev)
 
     app_hash = sha256(application).digest()
 
     auth_response = _ctap1_poll(_CTAP1_POLL_INTERVAL, ctap1.authenticate,
@@ -114,58 +132,62 @@
     flags = auth_response[0]
     counter = int.from_bytes(auth_response[1:5], 'big')
     sig = auth_response[5:]
 
     return flags, counter, sig
 
 
-def _ctap2_sign(dev, message_hash, application, key_handle, touch_required):
+def _ctap2_sign(dev: 'CtapHidDevice', message_hash: bytes,
+                application: bytes, key_handle: bytes,
+                touch_required: bool) -> Tuple[int, int, bytes]:
     """Sign a message with a security key using CTAP version 2"""
 
     ctap2 = Ctap2(dev)
 
     application = application.decode('utf-8')
     allow_creds = [{'type': 'public-key', 'id': key_handle}]
     options = {'up': touch_required}
 
-    assertion = ctap2.get_assertions(application, message_hash,
-                                     allow_creds, options=options)[0]
+    assertion = ctap2.get_assertions(application, message_hash, allow_creds,
+                                     options=options)[0]
 
     auth_data = assertion.auth_data
 
     return auth_data.flags, auth_data.counter, assertion.signature
 
 
-def sk_enroll(alg, application, user, pin, resident):
+def sk_enroll(alg: int, application: bytes, user: str,
+              pin: Optional[str], resident: bool) -> Tuple[bytes, bytes]:
     """Enroll a new security key"""
 
-    dev = next(CtapHidDevice.list_devices(), None)
-
-    if not dev:
-        raise ValueError('No security key found')
+    try:
+        dev = next(CtapHidDevice.list_devices())
+    except StopIteration:
+        raise ValueError('No security key found') from None
 
     try:
         return _ctap2_enroll(dev, alg, application, user, pin, resident)
     except CtapError as exc:
         if exc.code == CtapError.ERR.PIN_REQUIRED:
             raise ValueError('PIN required') from None
         elif exc.code == CtapError.ERR.PIN_INVALID:
             raise ValueError('Invalid PIN') from None
         else:
             raise ValueError(str(exc)) from None
-    except ValueError:
+    except ValueError as exc:
         try:
             return _ctap1_enroll(dev, alg, application)
         except ApduError as exc:
             raise ValueError(str(exc)) from None
     finally:
         dev.close()
 
 
-def sk_sign(message_hash, application, key_handle, flags):
+def sk_sign(message_hash: bytes, application: bytes, key_handle: bytes,
+            flags: int) -> Tuple[int, int, bytes]:
     """Sign a message with a security key"""
 
     touch_required = bool(flags & SSH_SK_USER_PRESENCE_REQD)
 
     for dev in CtapHidDevice.list_devices():
         try:
             return _ctap2_sign(dev, message_hash, application,
@@ -181,39 +203,45 @@
                     raise ValueError(str(exc)) from None
         finally:
             dev.close()
 
     raise ValueError('Security key credential not found')
 
 
-def sk_get_resident(application, user, pin):
+def sk_get_resident(application: bytes, user: Optional[str],
+                    pin: str) -> Sequence[_SKResidentKey]:
     """Get keys resident on a security key"""
 
     app_hash = sha256(application).digest()
-    result = []
+    result: List[_SKResidentKey] = []
 
     for dev in CtapHidDevice.list_devices():
         try:
             ctap2 = Ctap2(dev)
 
             pin_protocol = PinProtocolV1()
             pin_token = ClientPin(ctap2, pin_protocol).get_pin_token(pin)
             cred_mgmt = CredentialManagement(ctap2, pin_protocol, pin_token)
 
             for cred in cred_mgmt.enumerate_creds(app_hash):
-                name = cred[CredentialManagement.RESULT.USER]['name']
+                user_info = cast(Mapping[str, object],
+                                 cred[CredentialManagement.RESULT.USER])
+                name = cast(str, user_info['name'])
 
                 if user and name != user:
                     continue
 
-                cred_id = cred[CredentialManagement.RESULT.CREDENTIAL_ID]
-                key_handle = cred_id['id']
+                cred_id = cast(Mapping[str, object],
+                               cred[CredentialManagement.RESULT.CREDENTIAL_ID])
+                key_handle = cast(bytes, cred_id['id'])
+
+                public_key = cast(Mapping[int, object],
+                                  cred[CredentialManagement.RESULT.PUBLIC_KEY])
 
-                public_key = cred[CredentialManagement.RESULT.PUBLIC_KEY]
-                alg = public_key[3]
+                alg = cast(int, public_key[3])
                 public_value = _decode_public_key(alg, public_key)
 
                 result.append((alg, name, public_value, key_handle))
         except CtapError as exc:
             if exc.code == CtapError.ERR.NO_CREDENTIALS:
                 continue
             elif exc.code == CtapError.ERR.PIN_INVALID:
@@ -235,15 +263,15 @@
     from fido2.ctap2 import Ctap2, ClientPin, PinProtocolV1
     from fido2.ctap2 import CredentialManagement
 
     sk_available = True
 except (ImportError, OSError, AttributeError): # pragma: no cover
     sk_available = False
 
-    def _sk_not_available(*args, **kwargs):
+    def _sk_not_available(*args: object, **kwargs: object) -> NoReturn:
         """Report that security key support is unavailable"""
 
         raise ValueError('Security key support not available')
 
     sk_enroll = _sk_not_available
     sk_sign = _sk_not_available
     sk_get_resident = _sk_not_available
```

### Comparing `asyncssh-2.8.1/asyncssh/forward.py` & `asyncssh-2.9.0/asyncssh/forward.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,115 +16,135 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH port forwarding handlers"""
 
+import asyncio
 import socket
+from typing import TYPE_CHECKING, Awaitable, Callable, Optional, cast
 
-from .misc import ChannelOpenError
+from .misc import ChannelOpenError, SockAddr
 
 
-class SSHForwarder:
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .connection import SSHConnection
+
+
+SSHForwarderCoro = Callable[..., Awaitable]
+
+
+class SSHForwarder(asyncio.BaseProtocol):
     """SSH port forwarding connection handler"""
 
-    def __init__(self, peer=None):
+    def __init__(self, peer: Optional['SSHForwarder'] = None):
         self._peer = peer
-        self._transport = None
+        self._transport: Optional[asyncio.Transport] = None
         self._inpbuf = b''
         self._eof_received = False
 
         if peer:
             peer.set_peer(self)
 
-    def set_peer(self, peer):
+    def set_peer(self, peer: 'SSHForwarder') -> None:
         """Set the peer forwarder to exchange data with"""
 
         self._peer = peer
 
-    def write(self, data):
+    def write(self, data: bytes) -> None:
         """Write data to the transport"""
 
+        assert self._transport is not None
         self._transport.write(data)
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Write end of file to the transport"""
 
+        assert self._transport is not None
+
         try:
             self._transport.write_eof()
         except OSError: # pragma: no cover
             pass
 
-    def was_eof_received(self):
+    def was_eof_received(self) -> bool:
         """Return whether end of file has been received or not"""
 
         return self._eof_received
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause reading from the transport"""
 
+        assert self._transport is not None
         self._transport.pause_reading()
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume reading on the transport"""
 
+        assert self._transport is not None
         self._transport.resume_reading()
 
-    def connection_made(self, transport):
+    def connection_made(self, transport: asyncio.BaseTransport) -> None:
         """Handle a newly opened connection"""
 
-        self._transport = transport
+        self._transport = cast(Optional['asyncio.Transport'], transport)
 
-        sock = transport.get_extra_info('socket')
+        sock = cast(socket.socket, transport.get_extra_info('socket'))
 
         if sock and sock.family in {socket.AF_INET, socket.AF_INET6}:
             sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
 
-    def connection_lost(self, _exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         """Handle an incoming connection close"""
 
+        # pylint: disable=unused-argument
+
         self.close()
 
-    def session_started(self):
+    def session_started(self) -> None:
         """Handle session start"""
 
-    def data_received(self, data, datatype=None):
+    def data_received(self, data: bytes,
+                      datatype: int = None) -> None:
         """Handle incoming data from the transport"""
 
         # pylint: disable=unused-argument
 
         if self._peer:
             self._peer.write(data)
         else:
             self._inpbuf += data
 
-    def eof_received(self):
+    def eof_received(self) -> bool:
         """Handle an incoming end of file from the transport"""
 
         self._eof_received = True
 
         if self._peer:
             self._peer.write_eof()
 
             return not self._peer.was_eof_received()
         else:
             return True
 
-    def pause_writing(self):
+    def pause_writing(self) -> None:
         """Pause writing by asking peer to pause reading"""
 
-        self._peer.pause_reading()
+        if self._peer: # pragma: no branch
+            self._peer.pause_reading()
 
-    def resume_writing(self):
+    def resume_writing(self) -> None:
         """Resume writing by asking peer to resume reading"""
 
-        self._peer.resume_reading()
+        if self._peer: # pragma: no branch
+            self._peer.resume_reading()
 
-    def close(self):
+    def close(self) -> None:
         """Close this port forwarder"""
 
         if self._transport:
             self._transport.close()
             self._transport = None
 
         if self._peer:
@@ -132,63 +152,65 @@
             self._peer = None
             peer.close()
 
 
 class SSHLocalForwarder(SSHForwarder):
     """Local forwarding connection handler"""
 
-    def __init__(self, conn, coro):
+    def __init__(self, conn: 'SSHConnection', coro: SSHForwarderCoro):
         super().__init__()
         self._conn = conn
         self._coro = coro
 
-    async def _forward(self, *args):
+    async def _forward(self, *args: object) -> None:
         """Begin local forwarding"""
 
-        def session_factory():
+        def session_factory() -> SSHForwarder:
             """Return an SSH forwarder"""
 
             return SSHForwarder(self)
 
         try:
             await self._coro(session_factory, *args)
         except ChannelOpenError as exc:
             self.connection_lost(exc)
             return
 
+        assert self._peer is not None
+
         if self._inpbuf:
             self._peer.write(self._inpbuf)
             self._inpbuf = b''
 
         if self._eof_received:
             self._peer.write_eof()
 
-    def forward(self, *args):
+    def forward(self, *args: object) -> None:
         """Start a task to begin local forwarding"""
 
         self._conn.create_task(self._forward(*args))
 
 
 class SSHLocalPortForwarder(SSHLocalForwarder):
     """Local TCP port forwarding connection handler"""
 
-    def connection_made(self, transport):
+    def connection_made(self, transport: asyncio.BaseTransport) -> None:
         """Handle a newly opened connection"""
 
         super().connection_made(transport)
 
-        peername = transport.get_extra_info('peername')
+        peername = cast(SockAddr, transport.get_extra_info('peername'))
 
         if peername: # pragma: no branch
             orig_host, orig_port = peername[:2]
 
         self.forward(orig_host, orig_port)
 
 
 class SSHLocalPathForwarder(SSHLocalForwarder):
     """Local UNIX domain socket forwarding connection handler"""
 
-    def connection_made(self, transport):
+    def connection_made(self, transport: asyncio.BaseTransport) -> None:
         """Handle a newly opened connection"""
 
         super().connection_made(transport)
         self.forward()
```

### Comparing `asyncssh-2.8.1/asyncssh/packet.py` & `asyncssh-2.9.0/asyncssh/packet.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,161 +16,180 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH packet encoding and decoding functions"""
 
+from typing import Any, Callable, Iterable, Mapping, Optional, Sequence, Union
+
+from .logging import SSHLogger
 from .misc import plural
 
 
+_LoggedPacket = Union[bytes, 'SSHPacket']
+_PacketHandler = Callable[[Any, int, int, 'SSHPacket'], None]
+
+
 class PacketDecodeError(ValueError):
     """Packet decoding error"""
 
 
-def Byte(value):
+def Byte(value: int) -> bytes:
     """Encode a single byte"""
 
     return bytes((value,))
 
 
-def Boolean(value):
+def Boolean(value: bool) -> bytes:
     """Encode a boolean value"""
 
     return Byte(bool(value))
 
 
-def UInt32(value):
+def UInt16(value: int) -> bytes:
+    """Encode a 16-bit integer value"""
+
+    return value.to_bytes(2, 'big')
+
+
+def UInt32(value: int) -> bytes:
     """Encode a 32-bit integer value"""
 
     return value.to_bytes(4, 'big')
 
 
-def UInt64(value):
+def UInt64(value: int) -> bytes:
     """Encode a 64-bit integer value"""
 
     return value.to_bytes(8, 'big')
 
 
-def String(value):
+def String(value: Union[bytes, str]) -> bytes:
     """Encode a byte string or UTF-8 string value"""
 
     if isinstance(value, str):
         value = value.encode('utf-8', errors='strict')
 
     return len(value).to_bytes(4, 'big') + value
 
 
-def MPInt(value):
+def MPInt(value: int) -> bytes:
     """Encode a multiple precision integer value"""
 
     l = value.bit_length()
     l += (l % 8 == 0 and value != 0 and value != -1 << (l - 1))
     l = (l + 7) // 8
 
     return l.to_bytes(4, 'big') + value.to_bytes(l, 'big', signed=True)
 
 
-def NameList(value):
+def NameList(value: Iterable[bytes]) -> bytes:
     """Encode a comma-separated list of byte strings"""
 
     return String(b','.join(value))
 
 
 class SSHPacket:
     """Decoder class for SSH packets"""
 
-    def __init__(self, packet):
+    def __init__(self, packet: bytes):
         self._packet = packet
         self._idx = 0
         self._len = len(packet)
 
-    def __bool__(self):
+    def __bool__(self) -> bool:
         return self._idx != self._len
 
-    def check_end(self):
+    def check_end(self) -> None:
         """Confirm that all of the data in the packet has been consumed"""
 
         if self:
             raise PacketDecodeError('Unexpected data at end of packet')
 
-    def get_consumed_payload(self):
+    def get_consumed_payload(self) -> bytes:
         """Return the portion of the packet consumed so far"""
 
         return self._packet[:self._idx]
 
-    def get_remaining_payload(self):
+    def get_remaining_payload(self) -> bytes:
         """Return the portion of the packet not yet consumed"""
 
         return self._packet[self._idx:]
 
-    def get_full_payload(self):
+    def get_full_payload(self) -> bytes:
         """Return the full packet"""
 
         return self._packet
 
-    def get_bytes(self, size):
+    def get_bytes(self, size: int) -> bytes:
         """Extract the requested number of bytes from the packet"""
 
         if self._idx + size > self._len:
             raise PacketDecodeError('Incomplete packet')
 
         value = self._packet[self._idx:self._idx+size]
         self._idx += size
         return value
 
-    def get_byte(self):
+    def get_byte(self) -> int:
         """Extract a single byte from the packet"""
 
         return self.get_bytes(1)[0]
 
-    def get_boolean(self):
+    def get_boolean(self) -> bool:
         """Extract a boolean from the packet"""
 
         return bool(self.get_byte())
 
-    def get_uint32(self):
+    def get_uint16(self) -> int:
+        """Extract a 16-bit integer from the packet"""
+
+        return int.from_bytes(self.get_bytes(2), 'big')
+
+    def get_uint32(self) -> int:
         """Extract a 32-bit integer from the packet"""
 
         return int.from_bytes(self.get_bytes(4), 'big')
 
-    def get_uint64(self):
+    def get_uint64(self) -> int:
         """Extract a 64-bit integer from the packet"""
 
         return int.from_bytes(self.get_bytes(8), 'big')
 
-    def get_string(self):
+    def get_string(self) -> bytes:
         """Extract a UTF-8 string from the packet"""
 
         return self.get_bytes(self.get_uint32())
 
-    def get_mpint(self):
+    def get_mpint(self) -> int:
         """Extract a multiple precision integer from the packet"""
 
         return int.from_bytes(self.get_string(), 'big', signed=True)
 
-    def get_namelist(self):
+    def get_namelist(self) -> Sequence[bytes]:
         """Extract a comma-separated list of byte strings from the packet"""
 
         namelist = self.get_string()
         return namelist.split(b',') if namelist else []
 
 
 class SSHPacketLogger:
     """Parent class for SSH packet loggers"""
 
-    _handler_names = {}
+    _handler_names: Mapping[int, str] = {}
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """The logger to use for packet logging"""
 
         raise NotImplementedError
 
-    def _log_packet(self, msg, pkttype, pktid, packet, note):
+    def _log_packet(self, msg: str, pkttype: int, pktid: Optional[int],
+                    packet: _LoggedPacket, note: str) -> None:
         """Log a sent/received packet"""
 
         if isinstance(packet, SSHPacket):
             packet = packet.get_full_payload()
 
         try:
             name = '%s (%d)' % (self._handler_names[pkttype], pkttype)
@@ -181,38 +200,41 @@
 
         if note:
             note = ' (%s)' % note
 
         self.logger.packet(pktid, packet, '%s %s, %s%s',
                            msg, name, count, note)
 
-    def log_sent_packet(self, pkttype, pktid, packet, note=''):
+    def log_sent_packet(self, pkttype: int, pktid: Optional[int],
+                        packet: _LoggedPacket, note: str = '') -> None:
         """Log a sent packet"""
 
         self._log_packet('Sent', pkttype, pktid, packet, note)
 
 
-    def log_received_packet(self, pkttype, pktid, packet, note=''):
+    def log_received_packet(self, pkttype: int, pktid: Optional[int],
+                            packet: _LoggedPacket, note: str = '') -> None:
         """Log a received packet"""
 
         self._log_packet('Received', pkttype, pktid, packet, note)
 
 
 class SSHPacketHandler(SSHPacketLogger):
     """Parent class for SSH packet handlers"""
 
-    _packet_handlers = {}
+    _packet_handlers: Mapping[int, _PacketHandler] = {}
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """The logger associated with this packet handler"""
 
         raise NotImplementedError
 
-    def process_packet(self, pkttype, pktid, packet):
+    def process_packet(self, pkttype: int, pktid: int,
+                       packet: SSHPacket) -> bool:
         """Log and process a received packet"""
 
         if pkttype in self._packet_handlers:
             self._packet_handlers[pkttype](self, pkttype, pktid, packet)
             return True
         else:
             return False
```

### Comparing `asyncssh-2.8.1/asyncssh/process.py` & `asyncssh-2.9.0/asyncssh/process.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,420 +25,535 @@
 import codecs
 import inspect
 import io
 import os
 from pathlib import PurePath
 import socket
 import stat
-from typing import Mapping, Optional, Tuple
+from types import TracebackType
+from typing import Any, AnyStr, Callable, Dict, Generic, IO
+from typing import Iterable, Mapping, Optional, Set, TextIO
+from typing import Tuple, Type, TypeVar, Union, cast
+from typing_extensions import Protocol
+
+from .channel import SSHChannel, SSHClientChannel, SSHServerChannel
 
 from .constants import DEFAULT_LANG, EXTENDED_DATA_STDERR
-from .misc import BytesOrStr, Error, ProtocolError, Record, open_file
+
+from .logging import SSHLogger
+
+from .misc import BytesOrStr, Error, MaybeAwait
+from .misc import ProtocolError, Record, open_file
+
+from .session import DataType, TermModes, TermSize
+
+from .stream import SSHReader, SSHWriter, SSHStreamSession
 from .stream import SSHClientStreamSession, SSHServerStreamSession
-from .stream import SSHReader, SSHWriter
+from .stream import SFTPServerFactory
+
+
+_AnyStrContra = TypeVar('_AnyStrContra', bytes, str, contravariant=True)
+
+_File = Union[IO[bytes], '_AsyncFileProtocol[bytes]']
+
+ProcessSource = Union[int, str, socket.socket, PurePath, SSHReader[bytes],
+                      asyncio.StreamReader, _File]
+
+ProcessTarget = Union[int, str, socket.socket, PurePath, SSHWriter[bytes],
+                      asyncio.StreamWriter, _File]
+
+SSHServerProcessFactory = Callable[['SSHServerProcess[AnyStr]'], None]
+
+
+class _AsyncFileProtocol(Protocol[AnyStr]):
+    """Protocol for an async file"""
+
+    async def read(self, n: int = -1) -> AnyStr:
+        """Read from an async file"""
+
+    async def write(self, data: AnyStr) -> None:
+        """Write to an async file"""
+
+    async def close(self) -> None:
+        """Close an async file"""
+
+
+class _ReaderProtocol(Protocol):
+    """A class that can be used as a reader in SSHProcess"""
+
+    def pause_reading(self) -> None:
+        """Pause reading"""
+
+    def resume_reading(self) -> None:
+        """Resume reading"""
 
+    def close(self) -> None:
+        """Stop forwarding data"""
 
-def _is_regular_file(file):
+
+class _WriterProtocol(Protocol[_AnyStrContra]):
+    """A class that can be used as a writer in SSHProcess"""
+
+    def write(self, data: _AnyStrContra) -> None:
+        """Write data"""
+
+    def write_eof(self) -> None:
+        """Close output when end of file is received"""
+
+    def close(self) -> None:
+        """Stop forwarding data"""
+
+
+def _is_regular_file(file: IO[bytes]) -> bool:
     """Return if argument is a regular file or file-like object"""
 
     try:
         return stat.S_ISREG(os.fstat(file.fileno()).st_mode)
     except OSError:
         return True
 
-
-class _UnicodeReader:
+class _UnicodeReader(Generic[AnyStr]):
     """Handle buffering partial Unicode data"""
 
-    def __init__(self, encoding, errors, textmode=False):
+    def __init__(self, encoding: Optional[str], errors: str,
+                 textmode: bool = False):
         if encoding and not textmode:
-            self._decoder = codecs.getincrementaldecoder(encoding)(errors)
+            self._decoder: Optional[codecs.IncrementalDecoder] = \
+                codecs.getincrementaldecoder(encoding)(errors)
         else:
             self._decoder = None
 
-    def decode(self, data, final=False):
+    def decode(self, data: bytes, final: bool = False) -> AnyStr:
         """Decode Unicode bytes when reading from binary sources"""
 
         if self._decoder:
             try:
-                data = self._decoder.decode(data, final)
-            except UnicodeDecodeError as unicode_exc:
-                raise ProtocolError(str(unicode_exc)) from None
+                decoded_data = cast(AnyStr, self._decoder.decode(data, final))
+            except UnicodeDecodeError as exc:
+                raise ProtocolError(str(exc)) from None
+        else:
+            decoded_data = cast(AnyStr, data)
 
-        return data
+        return decoded_data
 
-    def check_partial(self):
+    def check_partial(self) -> None:
         """Check if there's partial Unicode data left at EOF"""
 
         self.decode(b'', True)
 
-    def close(self):
+    def close(self) -> None:
         """Perform necessary cleanup on error (provided by derived classes)"""
 
 
-class _UnicodeWriter:
+class _UnicodeWriter(Generic[AnyStr]):
     """Handle encoding Unicode data before writing it"""
 
-    def __init__(self, encoding, errors, textmode=False):
+    def __init__(self, encoding: Optional[str], errors: str,
+                 textmode: bool = False):
         if encoding and not textmode:
-            self._encoder = codecs.getincrementalencoder(encoding)(errors)
+            self._encoder: Optional[codecs.IncrementalEncoder] = \
+                codecs.getincrementalencoder(encoding)(errors)
         else:
             self._encoder = None
 
-    def encode(self, data):
+    def encode(self, data: AnyStr) -> bytes:
         """Encode Unicode bytes when writing to binary targets"""
 
         if self._encoder:
-            data = self._encoder.encode(data)
+            assert self._encoder is not None
+            encoded_data = cast(bytes, self._encoder.encode(cast(str, data)))
+        else:
+            encoded_data = cast(bytes, data)
 
-        return data
+        return encoded_data
 
 
-class _FileReader(_UnicodeReader):
+class _FileReader(_UnicodeReader[AnyStr]):
     """Forward data from a file"""
 
-    def __init__(self, process, file, bufsize, datatype, encoding, errors):
+    def __init__(self, process: 'SSHProcess[AnyStr]', file: IO[bytes],
+                 bufsize: int, datatype: DataType,
+                 encoding: Optional[str], errors: str):
         super().__init__(encoding, errors, hasattr(file, 'encoding'))
 
-        self._process = process
+        self._process: 'SSHProcess[AnyStr]' = process
         self._file = file
         self._bufsize = bufsize
         self._datatype = datatype
         self._paused = False
 
-    def feed(self):
+    def feed(self) -> None:
         """Feed file data"""
 
         while not self._paused:
             data = self._file.read(self._bufsize)
 
             if data:
                 self._process.feed_data(self.decode(data), self._datatype)
             else:
                 self.check_partial()
                 self._process.feed_eof(self._datatype)
                 break
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause reading from the file"""
 
         self._paused = True
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume reading from the file"""
 
         self._paused = False
         self.feed()
 
-    def close(self):
+    def close(self) -> None:
         """Stop forwarding data from the file"""
 
         self._file.close()
 
 
-class _AsyncFileReader(_FileReader):
+class _AsyncFileReader(_UnicodeReader[AnyStr]):
     """Forward data from an aiofile"""
 
-    def __init__(self, process, file, bufsize, datatype, encoding, errors):
-        super().__init__(process, file, bufsize, datatype, encoding, errors)
+    def __init__(self, process: 'SSHProcess[AnyStr]',
+                 file: _AsyncFileProtocol[bytes],
+                 bufsize: int, datatype: DataType,
+                 encoding: Optional[str], errors: str):
+        super().__init__(encoding, errors, hasattr(file, 'encoding'))
 
         self._conn = process.channel.get_connection()
+        self._process: 'SSHProcess[AnyStr]' = process
+        self._file = file
+        self._bufsize = bufsize
+        self._datatype = datatype
+        self._paused = False
 
-    async def _feed(self):
+    async def _feed(self) -> None:
         """Feed file data"""
 
         while not self._paused:
             data = await self._file.read(self._bufsize)
 
             if data:
                 self._process.feed_data(self.decode(data), self._datatype)
             else:
                 self.check_partial()
                 self._process.feed_eof(self._datatype)
                 break
 
-    def feed(self):
+    def feed(self) -> None:
         """Start feeding file data"""
 
         self._conn.create_task(self._feed())
 
-    def close(self):
+    def pause_reading(self) -> None:
+        """Pause reading from the file"""
+
+        self._paused = True
+
+    def resume_reading(self) -> None:
+        """Resume reading from the file"""
+
+        self._paused = False
+        self.feed()
+
+    def close(self) -> None:
         """Stop forwarding data from the file"""
 
         self._conn.create_task(self._file.close())
 
 
-class _FileWriter(_UnicodeWriter):
+class _FileWriter(_UnicodeWriter[AnyStr]):
     """Forward data to a file"""
 
-    def __init__(self, file, encoding, errors):
+    def __init__(self, file: IO[bytes], encoding: Optional[str], errors: str):
         super().__init__(encoding, errors, hasattr(file, 'encoding'))
 
         self._file = file
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Write data to the file"""
 
         self._file.write(self.encode(data))
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Close output file when end of file is received"""
 
         self.close()
 
-    def close(self):
+    def close(self) -> None:
         """Stop forwarding data to the file"""
 
         self._file.close()
 
 
-class _AsyncFileWriter(_FileWriter):
+class _AsyncFileWriter(_UnicodeWriter[AnyStr]):
     """Forward data to an aiofile"""
 
-    def __init__(self, process, file, encoding, errors):
-        super().__init__(file, encoding, errors)
+    def __init__(self, process: 'SSHProcess[AnyStr]',
+                 file: _AsyncFileProtocol[bytes],
+                 encoding: Optional[str], errors: str):
+        super().__init__(encoding, errors, hasattr(file, 'encoding'))
 
         self._conn = process.channel.get_connection()
+        self._file = file
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Write data to the file"""
 
         self._conn.create_task(self._file.write(self.encode(data)))
 
-    def close(self):
+    def write_eof(self) -> None:
+        """Close output file when end of file is received"""
+
+        self.close()
+
+    def close(self) -> None:
         """Stop forwarding data to the file"""
 
         self._conn.create_task(self._file.close())
 
 
-class _PipeReader(_UnicodeReader, asyncio.Protocol):
+class _PipeReader(_UnicodeReader[AnyStr], asyncio.BaseProtocol):
     """Forward data from a pipe"""
 
-    def __init__(self, process, datatype, encoding, errors):
+    def __init__(self, process: 'SSHProcess[AnyStr]', datatype: DataType,
+                 encoding: Optional[str], errors: str):
         super().__init__(encoding, errors)
 
-        self._process = process
+        self._process: 'SSHProcess[AnyStr]' = process
         self._datatype = datatype
-        self._transport = None
+        self._transport: Optional[asyncio.ReadTransport] = None
 
-    def connection_made(self, transport):
+    def connection_made(self, transport: asyncio.BaseTransport) -> None:
         """Handle a newly opened pipe"""
 
-        self._transport = transport
+        self._transport = cast(asyncio.ReadTransport, transport)
 
-    def data_received(self, data):
+    def data_received(self, data: bytes) -> None:
         """Forward data from the pipe"""
 
         self._process.feed_data(self.decode(data), self._datatype)
 
-    def eof_received(self):
+    def eof_received(self) -> None:
         """Forward EOF from the pipe"""
 
         self.check_partial()
         self._process.feed_eof(self._datatype)
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause reading from the pipe"""
 
+        assert self._transport is not None
         self._transport.pause_reading()
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume reading from the pipe"""
 
+        assert self._transport is not None
         self._transport.resume_reading()
 
-    def close(self):
+    def close(self) -> None:
         """Stop forwarding data from the pipe"""
 
+        assert self._transport is not None
         self._transport.close()
 
 
-class _PipeWriter(_UnicodeWriter, asyncio.BaseProtocol):
+class _PipeWriter(_UnicodeWriter[AnyStr], asyncio.BaseProtocol):
     """Forward data to a pipe"""
 
-    def __init__(self, process, datatype, encoding, errors):
+    def __init__(self, process: 'SSHProcess[AnyStr]', datatype: DataType,
+                 encoding: Optional[str], errors: str):
         super().__init__(encoding, errors)
 
-        self._process = process
+        self._process: 'SSHProcess[AnyStr]' = process
         self._datatype = datatype
-        self._transport = None
+        self._transport: Optional[asyncio.WriteTransport] = None
 
-    def connection_made(self, transport):
+    def connection_made(self, transport: asyncio.BaseTransport) -> None:
         """Handle a newly opened pipe"""
 
-        self._transport = transport
+        self._transport = cast(asyncio.WriteTransport, transport)
 
-    def pause_writing(self):
+    def pause_writing(self) -> None:
         """Pause writing to the pipe"""
 
         self._process.pause_feeding(self._datatype)
 
-    def resume_writing(self):
+    def resume_writing(self) -> None:
         """Resume writing to the pipe"""
 
         self._process.resume_feeding(self._datatype)
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Write data to the pipe"""
 
+        assert self._transport is not None
         self._transport.write(self.encode(data))
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Write EOF to the pipe"""
 
+        assert self._transport is not None
         self._transport.write_eof()
 
-    def close(self):
+    def close(self) -> None:
         """Stop forwarding data to the pipe"""
 
+        assert self._transport is not None
         self._transport.close()
 
 
-class _ProcessReader:
+class _ProcessReader(Generic[AnyStr]):
     """Forward data from another SSH process"""
 
-    def __init__(self, process, datatype):
-        self._process = process
+    def __init__(self, process: 'SSHProcess[AnyStr]', datatype: DataType):
+        self._process: 'SSHProcess[AnyStr]' = process
         self._datatype = datatype
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause reading from the other channel"""
 
         self._process.pause_feeding(self._datatype)
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume reading from the other channel"""
 
         self._process.resume_feeding(self._datatype)
 
-    def close(self):
+    def close(self) -> None:
         """Stop forwarding data from the other channel"""
 
         self._process.clear_writer(self._datatype)
 
 
-class _ProcessWriter:
+class _ProcessWriter(Generic[AnyStr]):
     """Forward data to another SSH process"""
 
-    def __init__(self, process, datatype):
-        self._process = process
+    def __init__(self, process: 'SSHProcess[AnyStr]', datatype: DataType):
+        self._process: 'SSHProcess[AnyStr]' = process
         self._datatype = datatype
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Write data to the other channel"""
 
         self._process.feed_data(data, self._datatype)
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Write EOF to the other channel"""
 
         self._process.feed_eof(self._datatype)
 
-    def close(self):
+    def close(self) -> None:
         """Stop forwarding data to the other channel"""
 
         self._process.clear_reader(self._datatype)
 
 
-class _StreamReader(_UnicodeReader):
+class _StreamReader(_UnicodeReader[AnyStr]):
     """Forward data from an asyncio stream"""
 
-    def __init__(self, process, reader, bufsize, datatype, encoding, errors):
+    def __init__(self, process: 'SSHProcess[AnyStr]',
+                 reader: asyncio.StreamReader,
+                 bufsize: int, datatype: DataType,
+                 encoding: Optional[str], errors: str):
         super().__init__(encoding, errors)
 
-        self._process = process
+        self._process: 'SSHProcess[AnyStr]' = process
         self._conn = process.channel.get_connection()
         self._reader = reader
         self._bufsize = bufsize
         self._datatype = datatype
         self._paused = False
 
-    async def _feed(self):
+    async def _feed(self) -> None:
         """Feed stream data"""
 
         while not self._paused:
             data = await self._reader.read(self._bufsize)
 
             if data:
                 self._process.feed_data(self.decode(data), self._datatype)
             else:
                 self.check_partial()
                 self._process.feed_eof(self._datatype)
                 break
 
-    def feed(self):
+    def feed(self) -> None:
         """Start feeding stream data"""
 
         self._conn.create_task(self._feed())
 
-    def pause_reading(self):
+    def pause_reading(self) -> None:
         """Pause reading from the stream"""
 
         self._paused = True
 
-    def resume_reading(self):
+    def resume_reading(self) -> None:
         """Resume reading from the stream"""
 
         self._paused = False
         self.feed()
 
-    def close(self):
+    def close(self) -> None:
         """Ignore close -- the caller must clean up the associated transport"""
 
 
-class _StreamWriter(_UnicodeWriter):
+class _StreamWriter(_UnicodeWriter[AnyStr]):
     """Forward data to an asyncio stream"""
 
-    def __init__(self, writer, encoding, errors):
+    def __init__(self, writer: asyncio.StreamWriter,
+                 encoding: Optional[str], errors: str):
         super().__init__(encoding, errors)
 
         self._writer = writer
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Write data to the stream"""
 
         self._writer.write(self.encode(data))
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Write EOF to the stream"""
 
         self._writer.write_eof()
 
-    def close(self):
+    def close(self) -> None:
         """Ignore close -- the caller must clean up the associated transport"""
 
 
-class _DevNullWriter:
+class _DevNullWriter(Generic[AnyStr]):
     """Discard data"""
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Discard data being written"""
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Ignore end of file"""
 
-    def close(self):
+    def close(self) -> None:
         """Ignore close"""
 
 
-class _StdoutWriter:
+class _StdoutWriter(Generic[AnyStr]):
     """Forward data to an SSH process' stdout instead of stderr"""
 
-    def __init__(self, process):
-        self._process = process
+    def __init__(self, process: 'SSHProcess[AnyStr]'):
+        self._process: 'SSHProcess[AnyStr]' = process
 
-    def write(self, data):
+    def write(self, data: AnyStr) -> None:
         """Pretend data was received on stdout"""
 
         self._process.data_received(data, None)
 
-    def write_eof(self):
+    def write_eof(self) -> None:
         """Ignore end of file"""
 
-    def close(self):
+    def close(self) -> None:
         """Ignore close"""
 
 
 class ProcessError(Error):
     """SSH Process error
 
        This exception is raised when an :class:`SSHClientProcess` exits
@@ -470,17 +585,21 @@
                       stdout (if not redirected)
          stderr       The output sent by the process to       `str` or `bytes`
                       stderr (if not redirected)
          ============ ======================================= =================
 
     """
 
-    def __init__(self, env, command, subsystem, exit_status,
-                 exit_signal, returncode, stdout, stderr,
-                 reason='', lang=DEFAULT_LANG):
+    def __init__(self, env: Optional[Mapping[str, str]],
+                 command: Optional[str], subsystem: Optional[str],
+                 exit_status: Optional[int],
+                 exit_signal: Optional[Tuple[str, bool, str, str]],
+                 returncode: Optional[int], stdout: BytesOrStr,
+                 stderr: BytesOrStr, reason: str = '',
+                 lang: str = DEFAULT_LANG):
         self.env = env
         self.command = command
         self.subsystem = subsystem
         self.exit_status = exit_status
         self.exit_signal = exit_signal
         self.returncode = returncode
         self.stdout = stdout
@@ -491,15 +610,15 @@
             reason = 'Process exited with signal %s%s%s' % \
                 (signal, ': ' + msg if msg else '',
                  ' (core dumped)' if core_dumped else '')
         elif exit_status:
             reason = 'Process exited with non-zero exit status %s' % \
                 exit_status
 
-        super().__init__(exit_status, reason, lang)
+        super().__init__(exit_status or 0, reason, lang)
 
 
 # pylint: disable=redefined-builtin
 class TimeoutError(ProcessError, asyncio.TimeoutError):
     """SSH Process timeout error
 
        This exception is raised when a timeout occurs when calling the
@@ -556,340 +675,316 @@
     exit_status: Optional[int]
     exit_signal: Optional[Tuple[str, bool, str, str]]
     returncode: Optional[int]
     stdout: Optional[BytesOrStr]
     stderr: Optional[BytesOrStr]
 
 
-class SSHProcess:
+class SSHProcess(SSHStreamSession, Generic[AnyStr]):
     """SSH process handler"""
 
-    # Pylint doesn't know that all SSHProcess instances will always be
-    # subclasses of SSHStreamSession.
-    # pylint: disable=no-member
+    def __init__(self, *args) -> None:
+        super().__init__(*args)
 
-    def __init__(self):
-        self._readers = {}
-        self._send_eof = {}
-
-        self._writers = {}
-        self._paused_write_streams = set()
-
-        self._stdin = None
-        self._stdout = None
-        self._stderr = None
-
-    async def __aenter__(self):
-        """Allow SSHProcess to be used as an async context manager"""
+        self._readers: Dict[Optional[int], _ReaderProtocol] = {}
+        self._send_eof: Dict[Optional[int], bool] = {}
 
-        return self
-
-    async def __aexit__(self, *exc_info):
-        """Wait for a full channel close when exiting the async context"""
-
-        self.close()
-        await self._chan.wait_closed()
+        self._writers: Dict[Optional[int], _WriterProtocol[AnyStr]] = {}
+        self._paused_write_streams: Set[Optional[int]] = set()
 
     @property
-    def channel(self):
+    def channel(self) -> SSHChannel[AnyStr]:
         """The channel associated with the process"""
 
+        assert self._chan is not None
         return self._chan
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """The logger associated with the process"""
 
+        assert self._chan is not None
         return self._chan.logger
 
     @property
-    def command(self):
+    def command(self) -> Optional[str]:
         """The command the client requested to execute, if any
 
            If the client did not request that a command be executed,
            this property will be set to `None`.
 
         """
 
+        assert self._chan is not None
         return self._chan.get_command()
 
     @property
-    def subsystem(self):
+    def subsystem(self) -> Optional[str]:
         """The subsystem the client requested to open, if any
 
            If the client did not request that a subsystem be opened,
            this property will be set to `None`.
 
         """
 
+        assert self._chan is not None
         return self._chan.get_subsystem()
 
     @property
-    def env(self):
+    def env(self) -> Mapping[str, str]:
         """A mapping containing the environment set by the client"""
 
+        assert self._chan is not None
         return self._chan.get_environment()
 
-    @property
-    def term_type(self):
-        """The terminal type set by the client
-
-           If the client didn't request a pseudo-terminal, this
-           property will be set to `None`.
-
-        """
-
-        return self._chan.get_terminal_type()
-
-    @property
-    def term_size(self):
-        """The terminal size set by the client
-
-           This property contains a tuple of four `int` values
-           representing the width and height of the terminal in
-           characters followed by the width and height of the
-           terminal in pixels. If the client hasn't set terminal
-           size information, the values will be set to zero.
-
-        """
-
-        return self._chan.get_terminal_size()
-
-    @property
-    def term_modes(self):
-        """A mapping containing the TTY modes set by the client
-
-           If the client didn't request a pseudo-terminal, this
-           property will be set to an empty mapping.
-
-        """
-
-        return self._chan.get_terminal_modes()
-
-    def get_extra_info(self, name, default=None):
+    def get_extra_info(self, name: str, default: Any = None) -> Any:
         """Return additional information about this process
 
            This method returns extra information about the channel
            associated with this process. See :meth:`get_extra_info()
            <SSHClientChannel.get_extra_info>` on :class:`SSHClientChannel`
            for additional information.
 
         """
 
+        assert self._chan is not None
         return self._chan.get_extra_info(name, default)
 
-    async def _create_reader(self, source, bufsize, send_eof, datatype=None):
+    async def _create_reader(self, source: ProcessSource,
+                             bufsize: int, send_eof: bool,
+                             datatype: DataType = None) -> None:
         """Create a reader to forward data to the SSH channel"""
 
-        def pipe_factory():
+        def pipe_factory() -> _PipeReader:
             """Return a pipe read handler"""
 
             return _PipeReader(self, datatype, self._encoding, self._errors)
 
         if source == PIPE:
-            reader = None
+            reader: Optional[_ReaderProtocol] = None
         elif source == DEVNULL:
+            assert self._chan is not None
             self._chan.write_eof()
             reader = None
         elif isinstance(source, SSHReader):
-            reader_process, reader_datatype = source.get_redirect_info()
-            writer = _ProcessWriter(self, datatype)
+            reader_stream, reader_datatype = source.get_redirect_info()
+            reader_process = cast('SSHProcess[AnyStr]', reader_stream)
+            writer = _ProcessWriter[AnyStr](self, datatype)
             reader_process.set_writer(writer, reader_datatype)
             reader = _ProcessReader(reader_process, reader_datatype)
         elif isinstance(source, asyncio.StreamReader):
             reader = _StreamReader(self, source, bufsize, datatype,
                                    self._encoding, self._errors)
         else:
+            file: _File
+
             if isinstance(source, str):
                 file = open_file(source, 'rb', buffering=bufsize)
             elif isinstance(source, PurePath):
                 file = open_file(str(source), 'rb', buffering=bufsize)
             elif isinstance(source, int):
                 file = os.fdopen(source, 'rb', buffering=bufsize)
             elif isinstance(source, socket.socket):
                 file = os.fdopen(source.detach(), 'rb', buffering=bufsize)
             else:
                 file = source
 
             if hasattr(file, 'read') and \
                     (asyncio.iscoroutinefunction(file.read) or
                      inspect.isgeneratorfunction(file.read)):
-                reader = _AsyncFileReader(self, file, bufsize, datatype,
-                                          self._encoding, self._errors)
-            elif _is_regular_file(file):
-                reader = _FileReader(self, file, bufsize, datatype,
-                                     self._encoding, self._errors)
+                reader = _AsyncFileReader(self, cast(_AsyncFileProtocol, file),
+                                          bufsize, datatype, self._encoding,
+                                          self._errors)
+            elif _is_regular_file(cast(IO[bytes], file)):
+                reader = _FileReader(self, cast(IO[bytes], file), bufsize,
+                                     datatype, self._encoding, self._errors)
             else:
                 if hasattr(source, 'buffer'):
                     # If file was opened in text mode, remove that wrapper
-                    file = source.buffer
+                    file = cast(TextIO, source).buffer
 
-                _, reader = \
+                assert self._loop is not None
+                _, protocol = \
                     await self._loop.connect_read_pipe(pipe_factory, file)
+                reader = cast(_PipeReader, protocol)
 
         self.set_reader(reader, send_eof, datatype)
 
-        if isinstance(reader, (_FileReader, _StreamReader)):
+        if isinstance(reader, (_FileReader, _AsyncFileReader, _StreamReader)):
             reader.feed()
         elif isinstance(reader, _ProcessReader):
             reader_process.feed_recv_buf(reader_datatype, writer)
 
-    async def _create_writer(self, target, bufsize, send_eof, datatype=None):
+    async def _create_writer(self, target: ProcessTarget,
+                             bufsize: int, send_eof: bool,
+                             datatype: DataType = None) -> None:
         """Create a writer to forward data from the SSH channel"""
 
-        def pipe_factory():
+        def pipe_factory() -> _PipeWriter:
             """Return a pipe write handler"""
 
             return _PipeWriter(self, datatype, self._encoding, self._errors)
 
-        if target == DEVNULL:
+        if target == PIPE:
+            writer: Optional[_WriterProtocol[AnyStr]] = None
+        elif target == DEVNULL:
             writer = _DevNullWriter()
-        elif target == PIPE:
-            writer = None
         elif target == STDOUT:
             writer = _StdoutWriter(self)
         elif isinstance(target, SSHWriter):
-            writer_process, writer_datatype = target.get_redirect_info()
+            writer_stream, writer_datatype = target.get_redirect_info()
+            writer_process = cast('SSHProcess[AnyStr]', writer_stream)
             reader = _ProcessReader(self, datatype)
             writer_process.set_reader(reader, send_eof, writer_datatype)
-            writer = _ProcessWriter(writer_process, writer_datatype)
+            writer = _ProcessWriter[AnyStr](writer_process, writer_datatype)
         elif isinstance(target, asyncio.StreamWriter):
             writer = _StreamWriter(target, self._encoding, self._errors)
         else:
+            file: _File
+
             if isinstance(target, str):
                 file = open_file(target, 'wb', buffering=bufsize)
             elif isinstance(target, PurePath):
                 file = open_file(str(target), 'wb', buffering=bufsize)
             elif isinstance(target, int):
                 file = os.fdopen(target, 'wb', buffering=bufsize)
             elif isinstance(target, socket.socket):
                 file = os.fdopen(target.detach(), 'wb', buffering=bufsize)
             else:
                 file = target
 
             if hasattr(file, 'write') and \
                     (asyncio.iscoroutinefunction(file.write) or
                      inspect.isgeneratorfunction(file.write)):
-                writer = _AsyncFileWriter(self, file, self._encoding,
-                                          self._errors)
-            elif _is_regular_file(file):
-                writer = _FileWriter(file, self._encoding, self._errors)
+                writer = _AsyncFileWriter(self, cast(_AsyncFileProtocol, file),
+                                          self._encoding, self._errors)
+            elif _is_regular_file(cast(IO[bytes], file)):
+                writer = _FileWriter(cast(IO[bytes], file), self._encoding,
+                                     self._errors)
             else:
                 if hasattr(target, 'buffer'):
                     # If file was opened in text mode, remove that wrapper
-                    file = target.buffer
+                    file = cast(TextIO, target).buffer
 
-                _, writer = await self._loop.connect_write_pipe(pipe_factory,
-                                                                file)
+                assert self._loop is not None
+                _, protocol = \
+                    await self._loop.connect_write_pipe(pipe_factory, file)
+                writer = cast(_PipeWriter, protocol)
 
         self.set_writer(writer, datatype)
 
         if writer:
             self.feed_recv_buf(datatype, writer)
 
-    def _should_block_drain(self, datatype):
+    def _should_block_drain(self, datatype: DataType) -> bool:
         """Return whether output is still being written to the channel"""
 
         return (datatype in self._readers or
                 super()._should_block_drain(datatype))
 
-    def _should_pause_reading(self):
+    def _should_pause_reading(self) -> bool:
         """Return whether to pause reading from the channel"""
 
-        return self._paused_write_streams or super()._should_pause_reading()
+        return bool(self._paused_write_streams) or \
+            super()._should_pause_reading()
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         """Handle a close of the SSH channel"""
 
-        super().connection_lost(exc)
+        super().connection_lost(exc) # type: ignore
 
         for reader in list(self._readers.values()):
             reader.close()
 
         for writer in list(self._writers.values()):
             writer.close()
 
         self._readers = {}
         self._writers = {}
 
-    def data_received(self, data, datatype):
+    def data_received(self, data: AnyStr, datatype: DataType) -> None:
         """Handle incoming data from the SSH channel"""
 
         writer = self._writers.get(datatype)
 
         if writer:
             writer.write(data)
         else:
             super().data_received(data, datatype)
 
-    def eof_received(self):
+    def eof_received(self) -> bool:
         """Handle an incoming end of file from the SSH channel"""
 
         for writer in list(self._writers.values()):
             writer.write_eof()
 
         return super().eof_received()
 
-    def pause_writing(self):
+    def pause_writing(self) -> None:
         """Pause forwarding data to the channel"""
 
         super().pause_writing()
 
         for reader in list(self._readers.values()):
             reader.pause_reading()
 
-    def resume_writing(self):
+    def resume_writing(self) -> None:
         """Resume forwarding data to the channel"""
 
         super().resume_writing()
 
         for reader in list(self._readers.values()):
             reader.resume_reading()
 
-    def feed_data(self, data, datatype):
+    def feed_data(self, data: AnyStr, datatype: DataType) -> None:
         """Feed data to the channel"""
 
+        assert self._chan is not None
         self._chan.write(data, datatype)
 
-    def feed_eof(self, datatype):
+    def feed_eof(self, datatype: DataType) -> None:
         """Feed EOF to the channel"""
 
         if self._send_eof[datatype]:
+            assert self._chan is not None
             self._chan.write_eof()
 
         self._readers[datatype].close()
         self.clear_reader(datatype)
 
-    def feed_recv_buf(self, datatype, writer):
+    def feed_recv_buf(self, datatype: DataType,
+                      writer: _WriterProtocol[AnyStr]) -> None:
         """Feed current receive buffer to a newly set writer"""
 
-        for data in self._recv_buf[datatype]:
+        for buf in self._recv_buf[datatype]:
+            data = cast(AnyStr, buf)
             writer.write(data)
             self._recv_buf_len -= len(data)
 
         self._recv_buf[datatype].clear()
 
         if self._eof_received:
             writer.write_eof()
 
         self._maybe_resume_reading()
 
-    def pause_feeding(self, datatype):
+    def pause_feeding(self, datatype: DataType) -> None:
         """Pause feeding data from the channel"""
 
         self._paused_write_streams.add(datatype)
         self._maybe_pause_reading()
 
-    def resume_feeding(self, datatype):
+    def resume_feeding(self, datatype: DataType) -> None:
         """Resume feeding data from the channel"""
 
         self._paused_write_streams.remove(datatype)
         self._maybe_resume_reading()
 
-    def set_reader(self, reader, send_eof, datatype):
+    def set_reader(self, reader: Optional[_ReaderProtocol],
+                   send_eof: bool, datatype: DataType) -> None:
         """Set a reader used to forward data to the channel"""
 
         old_reader = self._readers.get(datatype)
 
         if old_reader:
             old_reader.close()
 
@@ -898,122 +993,152 @@
             self._send_eof[datatype] = send_eof
 
             if self._write_paused:
                 reader.pause_reading()
         elif old_reader:
             self.clear_reader(datatype)
 
-    def clear_reader(self, datatype):
+    def clear_reader(self, datatype: DataType) -> None:
         """Clear a reader forwarding data to the channel"""
 
         del self._readers[datatype]
         del self._send_eof[datatype]
         self._unblock_drain(datatype)
 
-    def set_writer(self, writer, datatype):
+    def set_writer(self, writer: Optional[_WriterProtocol[AnyStr]],
+                   datatype: DataType) -> None:
         """Set a writer used to forward data from the channel"""
 
         old_writer = self._writers.get(datatype)
 
         if old_writer:
             old_writer.close()
             self.clear_writer(datatype)
 
         if writer:
             self._writers[datatype] = writer
 
-    def clear_writer(self, datatype):
+    def clear_writer(self, datatype: DataType) -> None:
         """Clear a writer forwarding data from the channel"""
 
         if datatype in self._paused_write_streams:
             self.resume_feeding(datatype)
 
         del self._writers[datatype]
 
-    def close(self):
+    def close(self) -> None:
         """Shut down the process"""
 
+        assert self._chan is not None
         self._chan.close()
 
-    def is_closing(self):
+    def is_closing(self) -> bool:
         """Return if the channel is closing or is closed"""
 
+        assert self._chan is not None
         return self._chan.is_closing()
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for the process to finish shutting down"""
 
+        assert self._chan is not None
         await self._chan.wait_closed()
 
 
-class SSHClientProcess(SSHProcess, SSHClientStreamSession):
+class SSHClientProcess(SSHProcess[AnyStr], SSHClientStreamSession[AnyStr]):
     """SSH client process handler"""
 
-    def __init__(self):
-        SSHProcess.__init__(self)
-        SSHClientStreamSession.__init__(self)
+    _chan: SSHClientChannel[AnyStr]
+    channel: SSHClientChannel[AnyStr]
+
+    def __init__(self) -> None:
+        super().__init__()
+
+        self._stdin: Optional[SSHWriter[AnyStr]] = None
+        self._stdout: Optional[SSHReader[AnyStr]] = None
+        self._stderr: Optional[SSHReader[AnyStr]] = None
 
-    def _collect_output(self, datatype=None):
+    async def __aenter__(self) -> 'SSHClientProcess[AnyStr]':
+        """Allow SSHProcess to be used as an async context manager"""
+
+        return self
+
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
+        """Wait for a full channel close when exiting the async context"""
+
+        self.close()
+        await self._chan.wait_closed()
+        return False
+
+    def _collect_output(self, datatype: DataType = None) -> AnyStr:
         """Return output from the process"""
 
         recv_buf = self._recv_buf[datatype]
 
         if recv_buf and isinstance(recv_buf[-1], Exception):
             recv_buf, self._recv_buf[datatype] = recv_buf[:-1], recv_buf[-1:]
         else:
             self._recv_buf[datatype] = []
 
-        buf = '' if self._encoding else b''
-        return buf.join(recv_buf)
+        buf = cast(AnyStr, '' if self._encoding else b'')
+        return buf.join(cast(Iterable[AnyStr], recv_buf))
 
-    def session_started(self):
+    def session_started(self) -> None:
         """Start a process for this newly opened client channel"""
 
-        self._stdin = SSHWriter(self, self._chan)
-        self._stdout = SSHReader(self, self._chan)
-        self._stderr = SSHReader(self, self._chan, EXTENDED_DATA_STDERR)
+        self._stdin = SSHWriter[AnyStr](self, self._chan)
+        self._stdout = SSHReader[AnyStr](self, self._chan)
+        self._stderr = SSHReader[AnyStr](self, self._chan, EXTENDED_DATA_STDERR)
 
     @property
-    def exit_status(self):
+    def exit_status(self) -> Optional[int]:
         """The exit status of the process"""
 
         return self._chan.get_exit_status()
 
     @property
-    def exit_signal(self):
+    def exit_signal(self) -> Optional[Tuple[str, bool, str, str]]:
         """Exit signal information for the process"""
 
         return self._chan.get_exit_signal()
 
     @property
-    def returncode(self):
+    def returncode(self) -> Optional[int]:
         """The exit status or negative exit signal number for the process"""
 
         return self._chan.get_returncode()
 
     @property
-    def stdin(self):
+    def stdin(self) -> SSHWriter[AnyStr]:
         """The :class:`SSHWriter` to use to write to stdin of the process"""
 
+        assert self._stdin is not None
         return self._stdin
 
     @property
-    def stdout(self):
+    def stdout(self) -> SSHReader[AnyStr]:
         """The :class:`SSHReader` to use to read from stdout of the process"""
 
+        assert self._stdout is not None
         return self._stdout
 
     @property
-    def stderr(self):
+    def stderr(self) -> SSHReader[AnyStr]:
         """The :class:`SSHReader` to use to read from stderr of the process"""
 
+        assert self._stderr is not None
         return self._stderr
 
-    async def redirect(self, stdin=None, stdout=None, stderr=None,
-                       bufsize=io.DEFAULT_BUFFER_SIZE, send_eof=True):
+    async def redirect(self, stdin: Optional[ProcessSource] = None,
+                       stdout: Optional[ProcessTarget] = None,
+                       stderr: Optional[ProcessTarget] = None,
+                       bufsize: int =io.DEFAULT_BUFFER_SIZE,
+                       send_eof: bool = True) -> None:
         """Perform I/O redirection for the process
 
            This method redirects data going to or from any or all of
            standard input, standard output, and standard error for
            the process.
 
            The `stdin` argument can be any of the following:
@@ -1076,33 +1201,36 @@
         if stdout:
             await self._create_writer(stdout, bufsize, send_eof)
 
         if stderr:
             await self._create_writer(stderr, bufsize, send_eof,
                                       EXTENDED_DATA_STDERR)
 
-    async def redirect_stdin(self, source, bufsize=io.DEFAULT_BUFFER_SIZE,
-                             send_eof=True):
+    async def redirect_stdin(self, source: ProcessSource,
+                             bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                             send_eof : bool = True) -> None:
         """Redirect standard input of the process"""
 
         await self.redirect(source, None, None, bufsize, send_eof)
 
-    async def redirect_stdout(self, target, bufsize=io.DEFAULT_BUFFER_SIZE,
-                              send_eof=True):
+    async def redirect_stdout(self, target: ProcessTarget,
+                              bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                              send_eof: bool = True) -> None:
         """Redirect standard output of the process"""
 
         await self.redirect(None, target, None, bufsize, send_eof)
 
-    async def redirect_stderr(self, target, bufsize=io.DEFAULT_BUFFER_SIZE,
-                              send_eof=True):
+    async def redirect_stderr(self, target: ProcessTarget,
+                              bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                              send_eof: bool = True) -> None:
         """Redirect standard error of the process"""
 
         await self.redirect(None, None, target, bufsize, send_eof)
 
-    def collect_output(self):
+    def collect_output(self) -> Tuple[AnyStr, AnyStr]:
         """Collect output from the process without blocking
 
            This method returns a tuple of the output that the process
            has written to stdout and stderr which has not yet been read.
            It is intended to be called instead of read() by callers
            that want to collect received data without blocking.
 
@@ -1110,15 +1238,16 @@
 
         """
 
         return (self._collect_output(),
                 self._collect_output(EXTENDED_DATA_STDERR))
 
     # pylint: disable=redefined-builtin
-    async def communicate(self, input=None):
+    async def communicate(self, input: Optional[AnyStr] = None) -> \
+            Tuple[AnyStr, AnyStr]:
         """Send input to and/or collect output from the process
 
            This method is a coroutine which optionally provides input
            to the process and then waits for the process to exit,
            returning a tuple of the data written to stdout and stderr.
 
            :param input:
@@ -1126,27 +1255,28 @@
                should be a `str` if encoding is set, or `bytes` if not.
            :type input: `str` or `bytes`
 
            :returns: A tuple of output to stdout and stderr
 
         """
 
-        self._limit = None
+        self._limit = 0
         self._maybe_resume_reading()
 
         if input:
             self._chan.write(input)
             self._chan.write_eof()
 
         await self._chan.wait_closed()
 
         return self.collect_output()
     # pylint: enable=redefined-builtin
 
-    def change_terminal_size(self, width, height, pixwidth=0, pixheight=0):
+    def change_terminal_size(self, width: int, height: int,
+                             pixwidth: int = 0, pixheight: int = 0) -> None:
         """Change the terminal window size for this process
 
            This method changes the width and height of the terminal
            associated with this process.
 
            :param width:
                The width of the terminal in characters
@@ -1163,59 +1293,60 @@
 
            :raises: :exc:`OSError` if the SSH channel is not open
 
         """
 
         self._chan.change_terminal_size(width, height, pixwidth, pixheight)
 
-    def send_break(self, msec):
+    def send_break(self, msec: int) -> None:
         """Send a break to the process
 
            :param msec:
                The duration of the break in milliseconds
            :type msec: `int`
 
            :raises: :exc:`OSError` if the SSH channel is not open
 
         """
 
         self._chan.send_break(msec)
 
-    def send_signal(self, signal):
+    def send_signal(self, signal: str) -> None:
         """Send a signal to the process
 
            :param signal:
                The signal to deliver
            :type signal: `str`
 
            :raises: :exc:`OSError` if the SSH channel is not open
 
         """
 
         self._chan.send_signal(signal)
 
-    def terminate(self):
+    def terminate(self) -> None:
         """Terminate the process
 
            :raises: :exc:`OSError` if the SSH channel is not open
 
         """
 
         self._chan.terminate()
 
-    def kill(self):
+    def kill(self) -> None:
         """Forcibly kill the process
 
            :raises: :exc:`OSError` if the SSH channel is not open
 
         """
 
         self._chan.kill()
 
-    async def wait(self, check=False, timeout=None):
+    async def wait(self, check: bool = False,
+                   timeout: Optional[float] = None) -> SSHCompletedProcess:
         """Wait for process to exit
 
            This method is a coroutine which waits for the process to
            exit. It returns an :class:`SSHCompletedProcess` object with
            the exit status or signal information and the output sent
            to stdout and stderr if those are redirected to pipes.
 
@@ -1262,53 +1393,119 @@
         else:
             return SSHCompletedProcess(self.env, self.command, self.subsystem,
                                        self.exit_status, self.exit_signal,
                                        self.returncode, stdout_data,
                                        stderr_data)
 
 
-class SSHServerProcess(SSHProcess, SSHServerStreamSession):
+class SSHServerProcess(SSHProcess[AnyStr], SSHServerStreamSession[AnyStr]):
     """SSH server process handler"""
 
-    def __init__(self, process_factory, sftp_factory, allow_scp):
-        SSHProcess.__init__(self)
-        SSHServerStreamSession.__init__(self, self._start_process,
-                                        sftp_factory, allow_scp)
+    _chan: SSHServerChannel[AnyStr]
+    channel: SSHServerChannel[AnyStr]
+
+    def __init__(self, process_factory: SSHServerProcessFactory,
+                 sftp_factory: Optional[SFTPServerFactory],
+                 sftp_version: int, allow_scp: bool):
+        super().__init__(self._start_process, sftp_factory,
+                         sftp_version, allow_scp)
 
         self._process_factory = process_factory
 
-    def _start_process(self, stdin, stdout, stderr):
+        self._stdin: Optional[SSHReader[AnyStr]] = None
+        self._stdout: Optional[SSHWriter[AnyStr]] = None
+        self._stderr: Optional[SSHWriter[AnyStr]] = None
+
+    async def __aenter__(self) -> 'SSHServerProcess[AnyStr]':
+        """Allow SSHProcess to be used as an async context manager"""
+
+        return self
+
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
+        """Wait for a full channel close when exiting the async context"""
+
+        self.close()
+        await self._chan.wait_closed()
+        return False
+
+    def _start_process(self, stdin: SSHReader[AnyStr],
+                       stdout: SSHWriter[AnyStr],
+                       stderr: SSHWriter[AnyStr]) -> MaybeAwait[None]:
         """Start a new server process"""
 
         self._stdin = stdin
         self._stdout = stdout
         self._stderr = stderr
 
         return self._process_factory(self)
 
     @property
-    def stdin(self):
+    def term_type(self) -> Optional[str]:
+        """The terminal type set by the client
+
+           If the client didn't request a pseudo-terminal, this
+           property will be set to `None`.
+
+        """
+
+        return self._chan.get_terminal_type()
+
+    @property
+    def term_size(self) -> TermSize:
+        """The terminal size set by the client
+
+           This property contains a tuple of four `int` values
+           representing the width and height of the terminal in
+           characters followed by the width and height of the
+           terminal in pixels. If the client hasn't set terminal
+           size information, the values will be set to zero.
+
+        """
+
+        return self._chan.get_terminal_size()
+
+    @property
+    def term_modes(self) -> TermModes:
+        """A mapping containing the TTY modes set by the client
+
+           If the client didn't request a pseudo-terminal, this
+           property will be set to an empty mapping.
+
+        """
+
+        return self._chan.get_terminal_modes()
+
+    @property
+    def stdin(self) -> SSHReader[AnyStr]:
         """The :class:`SSHReader` to use to read from stdin of the process"""
 
+        assert self._stdin is not None
         return self._stdin
 
     @property
-    def stdout(self):
+    def stdout(self) -> SSHWriter[AnyStr]:
         """The :class:`SSHWriter` to use to write to stdout of the process"""
 
+        assert self._stdout is not None
         return self._stdout
 
     @property
-    def stderr(self):
+    def stderr(self) -> SSHWriter[AnyStr]:
         """The :class:`SSHWriter` to use to write to stderr of the process"""
 
+        assert self._stderr is not None
         return self._stderr
 
-    async def redirect(self, stdin=None, stdout=None, stderr=None,
-                       bufsize=io.DEFAULT_BUFFER_SIZE, send_eof=True):
+    async def redirect(self, stdin: Optional[ProcessTarget] = None,
+                       stdout: Optional[ProcessSource] = None,
+                       stderr: Optional[ProcessSource] = None,
+                       bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                       send_eof: bool = True) -> None:
         """Perform I/O redirection for the process
 
            This method redirects data going to or from any or all of
            standard input, standard output, and standard error for
            the process.
 
            The `stdin` argument can be any of the following:
@@ -1368,62 +1565,65 @@
         if stdout:
             await self._create_reader(stdout, bufsize, send_eof)
 
         if stderr:
             await self._create_reader(stderr, bufsize, send_eof,
                                       EXTENDED_DATA_STDERR)
 
-    async def redirect_stdin(self, target, bufsize=io.DEFAULT_BUFFER_SIZE,
-                             send_eof=True):
+    async def redirect_stdin(self, target: ProcessTarget,
+                             bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                             send_eof: bool = True) -> None:
         """Redirect standard input of the process"""
 
         await self.redirect(target, None, None, bufsize, send_eof)
 
-    async def redirect_stdout(self, source, bufsize=io.DEFAULT_BUFFER_SIZE,
-                              send_eof=True):
+    async def redirect_stdout(self, source: ProcessSource,
+                              bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                              send_eof: bool = True) -> None:
         """Redirect standard output of the process"""
 
         await self.redirect(None, source, None, bufsize, send_eof)
 
-    async def redirect_stderr(self, source, bufsize=io.DEFAULT_BUFFER_SIZE,
-                              send_eof=True):
+    async def redirect_stderr(self, source: ProcessSource,
+                              bufsize: int = io.DEFAULT_BUFFER_SIZE,
+                              send_eof: bool = True) -> None:
         """Redirect standard error of the process"""
 
         await self.redirect(None, None, source, bufsize, send_eof)
 
-    def get_terminal_type(self):
+    def get_terminal_type(self) -> Optional[str]:
         """Return the terminal type set by the client for the process
 
            This method returns the terminal type set by the client
            when the process was started. If the client didn't request
            a pseudo-terminal, this method will return `None`.
 
            :returns: A `str` containing the terminal type or `None` if
                      no pseudo-terminal was requested
 
         """
 
         return self.term_type
 
-    def get_terminal_size(self):
+    def get_terminal_size(self) -> Tuple[int, int, int, int]:
         """Return the terminal size set by the client for the process
 
            This method returns the latest terminal size information set
            by the client. If the client didn't set any terminal size
            information, all values returned will be zero.
 
            :returns: A tuple of four `int` values containing the width and
                      height of the terminal in characters and the width
                      and height of the terminal in pixels
 
         """
 
         return self.term_size
 
-    def get_terminal_mode(self, mode):
+    def get_terminal_mode(self, mode: int) -> Optional[int]:
         """Return the requested TTY mode for this session
 
            This method looks up the value of a POSIX terminal mode
            set by the client when the process was started. If the client
            didn't request a pseudo-terminal or didn't set the requested
            TTY mode opcode, this method will return `None`.
 
@@ -1436,30 +1636,30 @@
                      POSIX terminal mode or `None` if the requested
                      mode was not set
 
         """
 
         return self.term_modes.get(mode)
 
-    def exit(self, status):
+    def exit(self, status: int) -> None:
         """Send exit status and close the channel
 
            This method can be called to report an exit status for the
            process back to the client and close the channel.
 
            :param status:
                The exit status to report to the client
            :type status: `int`
 
         """
 
         self._chan.exit(status)
 
-    def exit_with_signal(self, signal, core_dumped=False,
-                         msg='', lang=DEFAULT_LANG):
+    def exit_with_signal(self, signal: str, core_dumped: bool = False,
+                         msg: str = '', lang: str = DEFAULT_LANG) -> None:
         """Send exit signal and close the channel
 
            This method can be called to report that the process
            terminated abnormslly with a signal. A more detailed
            error message may also provided, along with an indication
            of whether or not the process dumped core. After
            reporting the signal, the channel is closed.
```

### Comparing `asyncssh-2.8.1/asyncssh/agent_unix.py` & `asyncssh-2.9.0/examples/scp_client.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,10 @@
-# Copyright (c) 2016-2019 by Ron Frederick <ronf@timeheart.net> and others.
+#!/usr/bin/env python3.6
+#
+# Copyright (c) 2017-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -14,20 +16,16 @@
 #    that license
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
-"""SSH agent support code for UNIX"""
-
-import asyncio
-import errno
-
-
-async def open_agent(agent_path):
-    """Open a connection to ssh-agent"""
+import asyncio, asyncssh, sys
 
-    if not agent_path:
-        raise OSError(errno.ENOENT, 'Agent not found')
+async def run_client() -> None:
+    await asyncssh.scp('localhost:example.txt', '.')
 
-    return await asyncio.open_unix_connection(agent_path)
+try:
+    asyncio.get_event_loop().run_until_complete(run_client())
+except (OSError, asyncssh.Error) as exc:
+    sys.exit('SFTP operation failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/asyncssh/sk_ecdsa.py` & `asyncssh-2.9.0/asyncssh/sk_ecdsa.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2019-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2019-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,154 +17,171 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """U2F ECDSA public key encryption handler"""
 
 from hashlib import sha256
+from typing import Optional, Tuple, cast
 
 from .asn1 import der_encode, der_decode
 from .crypto import ECDSAPublicKey
 from .packet import Byte, MPInt, String, UInt32, SSHPacket
 from .public_key import KeyExportError, SSHKey, SSHOpenSSHCertificateV01
 from .public_key import register_public_key_alg, register_certificate_alg
 from .public_key import register_sk_alg
 from .sk import SSH_SK_ECDSA, SSH_SK_USER_PRESENCE_REQD, sk_enroll, sk_sign
 
 
+_PrivateKeyArgs = Tuple[bytes, bytes, bytes, int, bytes, bytes]
+_PublicKeyArgs = Tuple[bytes, bytes, bytes]
+
+
 class _SKECDSAKey(SSHKey):
     """Handler for elliptic curve public key encryption"""
 
+    _key: ECDSAPublicKey
+
     use_executor = True
 
-    def __init__(self, curve_id, public_value, application, flags=None,
-                 key_handle=None, reserved=None):
+    def __init__(self, curve_id: bytes, public_value: bytes,
+                 application: bytes, flags: int = 0,
+                 key_handle: bytes = None, reserved: bytes = b''):
         super().__init__(ECDSAPublicKey.construct(curve_id, public_value))
 
         self.algorithm = b'sk-ecdsa-sha2-' + curve_id + b'@openssh.com'
         self.sig_algorithms = (self.algorithm,)
         self.all_sig_algorithms = set(self.sig_algorithms)
 
         self._application = application
         self._flags = flags
         self._key_handle = key_handle
         self._reserved = reserved
 
-    def __eq__(self, other):
+    def __eq__(self, other: object) -> bool:
         # This isn't protected access - both objects are _SKECDSAKey instances
         # pylint: disable=protected-access
 
         return (isinstance(other, type(self)) and
                 self._key.curve_id == other._key.curve_id and
                 self._key.public_value == other._key.public_value and
                 self._application == other._application and
                 self._flags == other._flags and
                 self._key_handle == other._key_handle and
                 self._reserved == other._reserved)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self._key.curve_id, self._key.public_value,
                      self._application, self._flags, self._key_handle,
                      self._reserved))
 
     @classmethod
-    def generate(cls, algorithm, application='ssh:', user='AsyncSSH',
-                 pin=None, resident=False, touch_required=True):
+    def generate(cls, algorithm: bytes, *, # type: ignore
+                 application: str = 'ssh:', user: str = 'AsyncSSH',
+                 pin: Optional[str] = None, resident: bool = False,
+                 touch_required: bool = True) -> '_SKECDSAKey':
         """Generate a new SK ECDSA private key"""
 
+        # pylint: disable=arguments-differ
+
         application = application.encode('utf-8')
         flags = SSH_SK_USER_PRESENCE_REQD if touch_required else 0
 
         public_value, key_handle = sk_enroll(SSH_SK_ECDSA, application,
                                              user, pin, resident)
 
         # Strip prefix and suffix of algorithm to get curve_id
         return cls(algorithm[14:-12], public_value, application,
                    flags, key_handle, b'')
 
     @classmethod
-    def make_private(cls, curve_id, public_value, application,
-                     flags, key_handle, reserved):
+    def make_private(cls, key_params: object) -> SSHKey:
         """Construct a U2F ECDSA private key"""
 
+        curve_id, public_value, application, flags, key_handle, reserved = \
+            cast(_PrivateKeyArgs, key_params)
+
         return cls(curve_id, public_value, application,
                    flags, key_handle, reserved)
 
     @classmethod
-    def make_public(cls, curve_id, public_value, application):
+    def make_public(cls, key_params: object) -> SSHKey:
         """Construct a U2F ECDSA public key"""
 
+        curve_id, public_value, application = cast(_PublicKeyArgs, key_params)
+
         return cls(curve_id, public_value, application)
 
     @classmethod
-    def decode_ssh_private(cls, packet):
+    def decode_ssh_private(cls, packet: SSHPacket) -> _PrivateKeyArgs:
         """Decode an SSH format SK ECDSA private key"""
 
         curve_id = packet.get_string()
         public_value = packet.get_string()
         application = packet.get_string()
         flags = packet.get_byte()
         key_handle = packet.get_string()
         reserved = packet.get_string()
 
         return curve_id, public_value, application, flags, key_handle, reserved
 
     @classmethod
-    def decode_ssh_public(cls, packet):
+    def decode_ssh_public(cls, packet: SSHPacket) -> _PublicKeyArgs:
         """Decode an SSH format SK ECDSA public key"""
 
         curve_id = packet.get_string()
         public_value = packet.get_string()
         application = packet.get_string()
 
         return curve_id, public_value, application
 
-    def encode_ssh_private(self):
+    def encode_ssh_private(self) -> bytes:
         """Encode an SSH format SK ECDSA private key"""
 
         if self._key_handle is None:
             raise KeyExportError('Key is not private')
 
         return b''.join((String(self._key.curve_id),
                          String(self._key.public_value),
                          String(self._application), Byte(self._flags),
                          String(self._key_handle), String(self._reserved)))
 
-    def encode_ssh_public(self):
+    def encode_ssh_public(self) -> bytes:
         """Encode an SSH format SK ECDSA public key"""
 
         return b''.join((String(self._key.curve_id),
                          String(self._key.public_value),
                          String(self._application)))
 
-    def encode_agent_cert_private(self):
+    def encode_agent_cert_private(self) -> bytes:
         """Encode U2F ECDSA certificate private key data for agent"""
 
         if self._key_handle is None:
             raise KeyExportError('Key is not private')
 
         return b''.join((String(self._application), Byte(self._flags),
                          String(self._key_handle), String(self._reserved)))
 
-    def sign_ssh(self, data, sig_algorithm):
+    def sign_ssh(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Compute an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         if self._key_handle is None:
             raise ValueError('Key handle needed for signing')
 
         flags, counter, sig = sk_sign(sha256(data).digest(), self._application,
                                       self._key_handle, self._flags)
 
-        r, s = der_decode(sig)
+        r, s = cast(Tuple[int, int], der_decode(sig))
 
         return String(MPInt(r) + MPInt(s)) + Byte(flags) + UInt32(counter)
 
-    def verify_ssh(self, data, sig_algorithm, packet):
+    def verify_ssh(self, data: bytes, sig_algorithm: bytes,
+                   packet: SSHPacket) -> bool:
         """Verify an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         sig = packet.get_string()
         flags = packet.get_byte()
         counter = packet.get_uint32()
```

### Comparing `asyncssh-2.8.1/asyncssh/sftp.py` & `asyncssh-2.9.0/asyncssh/sftp.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2022 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -29,63 +29,469 @@
 import os
 from os import SEEK_SET, SEEK_CUR, SEEK_END
 from pathlib import PurePath
 import posixpath
 import stat
 import sys
 import time
-from typing import Optional, Sequence, Tuple
+from types import TracebackType
+from typing import TYPE_CHECKING, AnyStr, AsyncIterator, Awaitable, Callable
+from typing import Dict, Generic, IO, Iterable, List, Mapping, Optional
+from typing import Sequence, Set, Tuple, Type, TypeVar, Union, cast, overload
+from typing_extensions import Literal, Protocol
 
+from . import constants
 from .constants import DEFAULT_LANG
 
 from .constants import FXP_INIT, FXP_VERSION, FXP_OPEN, FXP_CLOSE, FXP_READ
 from .constants import FXP_WRITE, FXP_LSTAT, FXP_FSTAT, FXP_SETSTAT
 from .constants import FXP_FSETSTAT, FXP_OPENDIR, FXP_READDIR, FXP_REMOVE
 from .constants import FXP_MKDIR, FXP_RMDIR, FXP_REALPATH, FXP_STAT, FXP_RENAME
-from .constants import FXP_READLINK, FXP_SYMLINK, FXP_STATUS, FXP_HANDLE
-from .constants import FXP_DATA, FXP_NAME, FXP_ATTRS, FXP_EXTENDED
-from .constants import FXP_EXTENDED_REPLY
+from .constants import FXP_READLINK, FXP_SYMLINK, FXP_LINK, FXP_BLOCK
+from .constants import FXP_UNBLOCK, FXP_STATUS, FXP_HANDLE, FXP_DATA
+from .constants import FXP_NAME, FXP_ATTRS, FXP_EXTENDED, FXP_EXTENDED_REPLY
+
+from .constants import FXR_OVERWRITE
+
+from .constants import FXRP_NO_CHECK, FXRP_STAT_IF_EXISTS, FXRP_STAT_ALWAYS
 
 from .constants import FXF_READ, FXF_WRITE, FXF_APPEND
 from .constants import FXF_CREAT, FXF_TRUNC, FXF_EXCL
 
+from .constants import FXF_ACCESS_DISPOSITION, FXF_CREATE_NEW
+from .constants import FXF_CREATE_TRUNCATE, FXF_OPEN_EXISTING
+from .constants import FXF_OPEN_OR_CREATE, FXF_TRUNCATE_EXISTING
+from .constants import FXF_APPEND_DATA
+
+from .constants import ACE4_READ_DATA, ACE4_WRITE_DATA, ACE4_APPEND_DATA
+from .constants import ACE4_READ_ATTRIBUTES, ACE4_WRITE_ATTRIBUTES
+
 from .constants import FILEXFER_ATTR_SIZE, FILEXFER_ATTR_UIDGID
 from .constants import FILEXFER_ATTR_PERMISSIONS, FILEXFER_ATTR_ACMODTIME
-from .constants import FILEXFER_ATTR_EXTENDED, FILEXFER_ATTR_UNDEFINED
+from .constants import FILEXFER_ATTR_EXTENDED, FILEXFER_ATTR_DEFINED_V3
+
+from .constants import FILEXFER_ATTR_ACCESSTIME, FILEXFER_ATTR_CREATETIME
+from .constants import FILEXFER_ATTR_MODIFYTIME, FILEXFER_ATTR_ACL
+from .constants import FILEXFER_ATTR_OWNERGROUP, FILEXFER_ATTR_SUBSECOND_TIMES
+from .constants import FILEXFER_ATTR_DEFINED_V4
+
+from .constants import FILEXFER_ATTR_BITS, FILEXFER_ATTR_DEFINED_V5
+
+from .constants import FILEXFER_ATTR_ALLOCATION_SIZE, FILEXFER_ATTR_TEXT_HINT
+from .constants import FILEXFER_ATTR_MIME_TYPE, FILEXFER_ATTR_LINK_COUNT
+from .constants import FILEXFER_ATTR_UNTRANSLATED_NAME, FILEXFER_ATTR_CTIME
+from .constants import FILEXFER_ATTR_DEFINED_V6
 
 from .constants import FX_OK, FX_EOF, FX_NO_SUCH_FILE, FX_PERMISSION_DENIED
 from .constants import FX_FAILURE, FX_BAD_MESSAGE, FX_NO_CONNECTION
-from .constants import FX_CONNECTION_LOST, FX_OP_UNSUPPORTED
+from .constants import FX_CONNECTION_LOST, FX_OP_UNSUPPORTED, FX_V3_END
+from .constants import FX_INVALID_HANDLE, FX_NO_SUCH_PATH
+from .constants import FX_FILE_ALREADY_EXISTS, FX_WRITE_PROTECT, FX_NO_MEDIA
+from .constants import FX_V4_END, FX_NO_SPACE_ON_FILESYSTEM, FX_QUOTA_EXCEEDED
+from .constants import FX_UNKNOWN_PRINCIPAL, FX_LOCK_CONFLICT, FX_V5_END
+from .constants import FX_DIR_NOT_EMPTY, FX_NOT_A_DIRECTORY
+from .constants import FX_INVALID_FILENAME, FX_LINK_LOOP, FX_CANNOT_DELETE
+from .constants import FX_INVALID_PARAMETER, FX_FILE_IS_A_DIRECTORY
+from .constants import FX_BYTE_RANGE_LOCK_CONFLICT, FX_BYTE_RANGE_LOCK_REFUSED
+from .constants import FX_DELETE_PENDING, FX_FILE_CORRUPT, FX_OWNER_INVALID
+from .constants import FX_GROUP_INVALID, FX_NO_MATCHING_BYTE_RANGE_LOCK
+from .constants import FX_V6_END
+
+from .constants import FILEXFER_TYPE_REGULAR, FILEXFER_TYPE_DIRECTORY
+from .constants import FILEXFER_TYPE_SYMLINK, FILEXFER_TYPE_SPECIAL
+from .constants import FILEXFER_TYPE_UNKNOWN, FILEXFER_TYPE_SOCKET
+from .constants import FILEXFER_TYPE_CHAR_DEVICE, FILEXFER_TYPE_BLOCK_DEVICE
+from .constants import FILEXFER_TYPE_FIFO
+
+from .logging import SSHLogger
+
+from .misc import BytesOrStr, Error, FilePath, MaybeAwait, OptExcInfo, Record
+from .misc import ConnectionLost
+from .misc import async_context_manager, get_symbol_names, hide_empty, plural
+
+from .packet import Boolean, Byte, String, UInt16, UInt32, UInt64
+from .packet import PacketDecodeError, SSHPacket, SSHPacketLogger
+
+from .version import __author__, __version__
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHServerChannel
+    from .connection import SSHClientConnection, SSHServerConnection
+    from .stream import SSHReader, SSHWriter
+
+
+if TYPE_CHECKING:
+    _RequestWaiter = asyncio.Future[Tuple[int, SSHPacket]]
+else:
+    _RequestWaiter = asyncio.Future
+
+if sys.platform == 'win32': # pragma: no cover
+    _LocalPath = str
+else:
+    _LocalPath = bytes
+
+_SFTPFileObj = IO[bytes]
+_SFTPPath = Union[bytes, FilePath]
+_SFTPStatFunc = Callable[[_SFTPPath], Awaitable['SFTPAttrs']]
+
+_SFTPNames = Tuple[Sequence['SFTPName'], bool]
+_SFTPOSAttrs = Union[os.stat_result, 'SFTPAttrs']
+_SFTPOSVFSAttrs = Union[os.statvfs_result, 'SFTPVFSAttrs']
+
+_SFTPOnErrorHandler = Callable[[Callable, bytes, OptExcInfo], None]
+_SFTPPacketHandler = Callable[['SFTPServerHandler', SSHPacket],
+                              Awaitable[object]]
+
+SFTPErrorHandler = Union[None, Literal[False], Callable[[Exception], None]]
+SFTPProgressHandler = Optional[Callable[[bytes, bytes, int, int], None]]
 
-from .misc import BytesOrStr, Error, Record, async_context_manager
-from .misc import get_symbol_names, hide_empty, plural, to_hex
 
-from .packet import Byte, String, UInt32, UInt64, PacketDecodeError
-from .packet import SSHPacket, SSHPacketLogger
+MIN_SFTP_VERSION = 3
+MAX_SFTP_VERSION = 6
 
 SFTP_BLOCK_SIZE = 16384
+_MAX_SFTP_READ_SIZE = 4*1024*1024    # 4 MiB
 
-_SFTP_VERSION = 3
 _MAX_SFTP_REQUESTS = 128
 _MAX_READDIR_NAMES = 128
 
+_NSECS_IN_SEC = 1_000_000_000
+
+_T = TypeVar('_T')
+
+
+_const_dict: Mapping[str, int] = constants.__dict__
+
+_valid_attr_flags = {
+    3: FILEXFER_ATTR_DEFINED_V3,
+    4: FILEXFER_ATTR_DEFINED_V4,
+    5: FILEXFER_ATTR_DEFINED_V5,
+    6: FILEXFER_ATTR_DEFINED_V6
+}
+
 _open_modes = {
     'r':  FXF_READ,
     'w':  FXF_WRITE | FXF_CREAT | FXF_TRUNC,
     'a':  FXF_WRITE | FXF_CREAT | FXF_APPEND,
     'x':  FXF_WRITE | FXF_CREAT | FXF_EXCL,
 
     'r+': FXF_READ | FXF_WRITE,
     'w+': FXF_READ | FXF_WRITE | FXF_CREAT | FXF_TRUNC,
     'a+': FXF_READ | FXF_WRITE | FXF_CREAT | FXF_APPEND,
     'x+': FXF_READ | FXF_WRITE | FXF_CREAT | FXF_EXCL
 }
 
+_file_types = {k: v.lower() for k, v in
+               get_symbol_names(_const_dict, 'FILEXFER_TYPE_', 14).items()}
+
+
+class _SupportsEncode(Protocol):
+    """Protocol for applying encoding to path names"""
+
+    def encode(self, sftp_version: int) -> bytes:
+        """Encode result as bytes in an SSH packet"""
+
+
+class _SFTPGlobProtocol(Protocol):
+    """Protocol for getting files to perform glob matching against"""
+
+    async def stat(self, path: bytes) -> 'SFTPAttrs':
+        """Get attributes of a file"""
+
+    async def listdir(self, path: bytes) -> Sequence[bytes]:
+        """List the contents of a directory"""
+
+
+class SFTPFileProtocol(Protocol):
+    """Protocol for accessing a file via an SFTP server"""
+
+    async def __aenter__(self) -> 'SFTPFileProtocol':
+        """Allow SFTPFileProtocol to be used as an async context manager"""
+
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
+        """Wait for file close when used as an async context manager"""
+
+    async def read(self, size: int, offset: int) -> bytes:
+        """Read data from the local file"""
+
+    async def write(self, data: bytes, offset: int) -> int:
+        """Write data to the local file"""
+
+    async def close(self) -> None:
+        """Close the local file"""
+
+
+class _SFTPFSProtocol(Protocol):
+    """Protocol for accessing a filesystem via an SFTP server"""
+
+    @staticmethod
+    def basename(path: bytes) -> bytes:
+        """Return the final component of a POSIX-style path"""
+
+    def encode(self, path: _SFTPPath) -> bytes:
+        """Encode path name using configured path encoding"""
+
+    def compose_path(self, path: bytes,
+                     parent: Optional[bytes] = None) -> bytes:
+        """Compose a path"""
+
+    async def stat(self, path: bytes) -> 'SFTPAttrs':
+        """Get attributes of a file or directory, following symlinks"""
+
+    async def lstat(self, path: bytes) -> 'SFTPAttrs':
+        """Get attributes of a file or directory"""
+
+    async def setstat(self, path: bytes, attrs: 'SFTPAttrs') -> None:
+        """Set attributes of a file or directory"""
+
+    async def exists(self, path: bytes) -> bool:
+        """Return if a path exists"""
+
+    async def isdir(self, path: bytes) -> bool:
+        """Return if the path refers to a directory"""
+
+    async def listdir(self, path: bytes) -> Sequence[bytes]:
+        """List the contents of a directory"""
+
+    async def mkdir(self, path: bytes) -> None:
+        """Create a directory"""
+
+    async def readlink(self, path: bytes) -> bytes:
+        """Return the target of a symbolic link"""
+
+    async def symlink(self, oldpath: bytes, newpath: bytes) -> None:
+        """Create a symbolic link"""
+
+    @async_context_manager
+    async def open(self, path: bytes, mode: str) -> SFTPFileProtocol:
+        """Open a file"""
+
+
+def _parse_acl_supported(data: bytes) -> int:
+    """Parse an SFTPv6 "acl-supported" extension"""
+
+    packet = SSHPacket(data)
+    capabilities = packet.get_uint32()
+    packet.check_end()
+
+    return capabilities
+
+
+def _parse_supported(data: bytes) -> \
+        Tuple[int, int, int, int, int, Sequence[bytes]]:
+    """Parse an SFTPv5 "supported" extension"""
+
+    packet = SSHPacket(data)
+    attr_mask = packet.get_uint32()
+    attrib_mask = packet.get_uint32()
+    open_flags = packet.get_uint32()
+    access_mask = packet.get_uint32()
+    max_read_size = packet.get_uint32()
+
+    ext_names: List[bytes] = []
+
+    while packet:
+        name = packet.get_string()
+        ext_names.append(name)
+
+    return (attr_mask, attrib_mask, open_flags, access_mask,
+            max_read_size, ext_names)
+
+
+def _parse_supported2(data: bytes) -> Tuple[int, int, int, int, int, int, int,
+                                            Sequence[bytes], Sequence[bytes]]:
+    """Parse an SFTPv6 "supported2" extension"""
+
+    packet = SSHPacket(data)
+    attr_mask = packet.get_uint32()
+    attrib_mask = packet.get_uint32()
+    open_flags = packet.get_uint32()
+    access_mask = packet.get_uint32()
+    max_read_size = packet.get_uint32()
+    open_block_vector = packet.get_uint16()
+    block_vector = packet.get_uint16()
+
+    attrib_ext_count = packet.get_uint32()
+    attrib_ext_names: List[bytes] = []
+
+    for _ in range(attrib_ext_count):
+        attrib_ext_names.append(packet.get_string())
+
+    ext_count = packet.get_uint32()
+    ext_names: List[bytes] = []
+
+    for _ in range(ext_count):
+        ext_names.append(packet.get_string())
+
+    packet.check_end()
+
+    return (attr_mask, attrib_mask, open_flags, access_mask,
+            max_read_size, open_block_vector, block_vector,
+            attrib_ext_names, ext_names)
+
+
+def _parse_vendor_id(data: bytes) -> Tuple[str, str, str, int]:
+    """Parse a "vendor-id" extension"""
+
+    packet = SSHPacket(data)
+
+    vendor_name = packet.get_string().decode('utf-8', 'backslashreplace')
+    product_name = packet.get_string().decode('utf-8', 'backslashreplace')
+    product_version = packet.get_string().decode('utf-8', 'backslashreplace')
+    product_build = packet.get_uint64()
+
+    return vendor_name, product_name, product_version, product_build
+
+
+def _stat_mode_to_filetype(mode: int) -> int:
+    """Convert stat mode/permissions to file type"""
+
+    if stat.S_ISREG(mode):
+        filetype = FILEXFER_TYPE_REGULAR
+    elif stat.S_ISDIR(mode):
+        filetype = FILEXFER_TYPE_DIRECTORY
+    elif stat.S_ISLNK(mode):
+        filetype = FILEXFER_TYPE_SYMLINK
+    elif stat.S_ISSOCK(mode):
+        filetype = FILEXFER_TYPE_SOCKET
+    elif stat.S_ISCHR(mode):
+        filetype = FILEXFER_TYPE_CHAR_DEVICE
+    elif stat.S_ISBLK(mode):
+        filetype = FILEXFER_TYPE_BLOCK_DEVICE
+    elif stat.S_ISFIFO(mode):
+        filetype = FILEXFER_TYPE_FIFO
+    elif stat.S_IFMT(mode) != 0:
+        filetype = FILEXFER_TYPE_SPECIAL
+    else:
+        filetype = FILEXFER_TYPE_UNKNOWN
+
+    return filetype
+
+
+def _nsec_to_tuple(nsec: int) -> Tuple[int, int]:
+    """Convert nanoseconds since epoch to seconds & remainder"""
+
+    return divmod(nsec, _NSECS_IN_SEC)
 
-def _mode_to_pflags(mode):
+
+def _float_sec_to_tuple(sec: float) -> Tuple[int, int]:
+    """Convert float seconds since epoch to seconds & remainder"""
+
+    return (int(sec), int((sec % 1) * _NSECS_IN_SEC))
+
+
+def _tuple_to_float_sec(sec: int, nsec: Optional[int]) -> float:
+    """Convert seconds and remainder to float seconds since epoch"""
+
+    return sec + float(nsec or 0) / _NSECS_IN_SEC
+
+
+def _tuple_to_nsec(sec: int, nsec: Optional[int]) -> int:
+    """Convert seconds and remainder to nanoseconds since epoch"""
+
+    return sec * _NSECS_IN_SEC + (nsec or 0)
+
+
+def _utime_to_attrs(times: Optional[Tuple[float, float]] = None,
+                    ns: Optional[Tuple[int, int]] = None) -> 'SFTPAttrs':
+    """Convert utime arguments to SFTPAttrs"""
+
+    if ns:
+        atime, atime_ns = _nsec_to_tuple(ns[0])
+        mtime, mtime_ns = _nsec_to_tuple(ns[1])
+    elif times:
+        atime, atime_ns = _float_sec_to_tuple(times[0])
+        mtime, mtime_ns = _float_sec_to_tuple(times[1])
+    else:
+        if hasattr(time, 'time_ns'):
+            atime, atime_ns = _nsec_to_tuple(time.time_ns())
+        else:
+            atime, atime_ns = _float_sec_to_tuple(time.time())
+
+        mtime, mtime_ns = atime, atime_ns
+
+    return SFTPAttrs(atime=atime, atime_ns=atime_ns,
+                     mtime=mtime, mtime_ns=mtime_ns)
+
+
+def _lookup_uid(user: Optional[str]) -> Optional[int]:
+    """Return the uid associated with a user name"""
+
+    if user is not None:
+        try:
+            # pylint: disable=import-outside-toplevel
+            import pwd
+            uid = pwd.getpwnam(user).pw_uid
+        except (ImportError, KeyError):
+            try:
+                uid = int(user)
+            except ValueError:
+                raise SFTPOwnerInvalid('Invalid owner: %s' % user) from None
+    else:
+        uid = None
+
+    return uid
+
+
+def _lookup_gid(group: Optional[str]) -> Optional[int]:
+    """Return the gid associated with a group name"""
+
+    if group is not None:
+        try:
+            # pylint: disable=import-outside-toplevel
+            import grp
+            gid = grp.getgrnam(group).gr_gid
+        except (ImportError, KeyError):
+            try:
+                gid = int(group)
+            except ValueError:
+                raise SFTPGroupInvalid('Invalid group: %s' % group) from None
+    else:
+        gid = None
+
+    return gid
+
+
+def _lookup_user(uid: Optional[int]) -> str:
+    """Return the user name associated with a uid"""
+
+    if uid is not None:
+        try:
+            # pylint: disable=import-outside-toplevel
+            import pwd
+            user = pwd.getpwuid(uid).pw_name
+        except (ImportError, KeyError):
+            user = str(uid)
+    else:
+        user = ''
+
+    return user
+
+
+def _lookup_group(gid: Optional[int]) -> str:
+    """Return the group name associated with a gid"""
+
+    if gid is not None:
+        try:
+            # pylint: disable=import-outside-toplevel
+            import grp
+            group = grp.getgrgid(gid).gr_name
+        except (ImportError, KeyError):
+            group = str(gid)
+    else:
+        group = ''
+
+    return group
+
+
+def _mode_to_pflags(mode: str) -> Tuple[int, bool]:
     """Convert open mode to SFTP open flags"""
 
     if 'b' in mode:
         mode = mode.replace('b', '')
         binary = True
     else:
         binary = False
@@ -94,68 +500,119 @@
 
     if not pflags:
         raise ValueError('Invalid mode: %r' % mode)
 
     return pflags, binary
 
 
-def _from_local_path(path):
+def _pflags_to_flags(pflags: int) -> Tuple[int, int]:
+    """Convert SFTPv3 pflags to SFTPv5 desired-access and flags"""
+
+    desired_access = 0
+    flags = 0
+
+    if pflags & (FXF_CREAT | FXF_EXCL) == (FXF_CREAT | FXF_EXCL):
+        flags = FXF_CREATE_NEW
+    elif pflags & (FXF_CREAT | FXF_TRUNC) == (FXF_CREAT | FXF_TRUNC):
+        flags = FXF_CREATE_TRUNCATE
+    elif pflags & FXF_CREAT:
+        flags = FXF_OPEN_OR_CREATE
+    elif pflags & FXF_TRUNC:
+        flags = FXF_TRUNCATE_EXISTING
+    else:
+        flags = FXF_OPEN_EXISTING
+
+    if pflags & FXF_READ:
+        desired_access |= ACE4_READ_DATA | ACE4_READ_ATTRIBUTES
+
+    if pflags & FXF_WRITE:
+        desired_access |= ACE4_WRITE_DATA | ACE4_WRITE_ATTRIBUTES
+
+    if pflags & FXF_APPEND:
+        desired_access |= ACE4_APPEND_DATA
+        flags |= FXF_APPEND_DATA
+
+    return desired_access, flags
+
+
+def _from_local_path(path: _SFTPPath) -> bytes:
     """Convert local path to SFTP path"""
 
     path = os.fsencode(path)
 
     if sys.platform == 'win32': # pragma: no cover
         path = path.replace(b'\\', b'/')
 
         if path[:1] != b'/' and path[1:2] == b':':
             path = b'/' + path
 
     return path
 
 
-def _to_local_path(path):
+def _to_local_path(path: bytes) -> _LocalPath:
     """Convert SFTP path to local path"""
 
-    if isinstance(path, PurePath): # pragma: no branch
-        path = str(path)
-
     if sys.platform == 'win32': # pragma: no cover
         path = os.fsdecode(path)
 
         if path[:1] == '/' and path[2:3] == ':':
             path = path[1:]
 
         path = path.replace('/', '\\')
+    else:
+        path = os.fsencode(path)
 
     return path
 
 
-def _setstat(path, attrs):
+def _setstat(path: Union[int, _SFTPPath], attrs: 'SFTPAttrs') -> None:
     """Utility function to set file attributes"""
 
     if attrs.size is not None:
         os.truncate(path, attrs.size)
 
-    if attrs.uid is not None and attrs.gid is not None:
+    uid = _lookup_uid(attrs.owner) if attrs.uid is None else attrs.uid
+    gid = _lookup_gid(attrs.group) if attrs.gid is None else attrs.gid
+
+    atime_ns = _tuple_to_nsec(attrs.atime, attrs.atime_ns) \
+        if attrs.atime is not None else None
+
+    mtime_ns = _tuple_to_nsec(attrs.mtime, attrs.mtime_ns) \
+        if attrs.mtime is not None else None
+
+    if ((atime_ns is None and mtime_ns is not None) or
+            (atime_ns is not None and mtime_ns is None)):
+        stat_result = os.stat(path)
+
+        if atime_ns is None and mtime_ns is not None:
+            atime_ns = stat_result.st_atime_ns
+
+        if atime_ns is not None and mtime_ns is None:
+            mtime_ns = stat_result.st_mtime_ns
+
+    if uid is not None and gid is not None:
         try:
-            os.chown(path, attrs.uid, attrs.gid)
+            os.chown(path, uid, gid)
         except AttributeError: # pragma: no cover
             raise NotImplementedError from None
 
     if attrs.permissions is not None:
         os.chmod(path, stat.S_IMODE(attrs.permissions))
 
-    if attrs.atime is not None and attrs.mtime is not None:
-        os.utime(path, times=(attrs.atime, attrs.mtime))
+    if atime_ns is not None and mtime_ns is not None:
+        os.utime(path, ns=(atime_ns, mtime_ns))
 
 
-def _split_path_by_globs(pattern):
+def _split_path_by_globs(pattern: bytes) -> \
+        Tuple[Optional[bytes], Sequence[object]]:
     """Split path grouping parts without glob pattern"""
 
-    basedir, patlist, plain = None, [], []
+    basedir: Optional[bytes] = None
+    patlist: List[object] = []
+    plain: List[bytes] = []
 
     for current in pattern.split(b'/'):
         if any(c in current for c in b'*?[]'):
             if plain:
                 if patlist:
                     patlist.append(plain)
                 else:
@@ -169,24 +626,25 @@
 
     if plain:
         patlist.append(plain)
 
     return basedir, patlist
 
 
-async def _glob(fs, basedir, patlist, result):
+async def _glob(fs: _SFTPGlobProtocol, basedir: Optional[bytes],
+                patlist: Sequence[object], result: List[bytes]) -> None:
     """Recursively match a glob pattern"""
 
     pattern, newpatlist = patlist[0], patlist[1:]
 
     names = await fs.listdir(basedir or b'.')
 
     if isinstance(pattern, list):
         if len(pattern) == 1 and not pattern[0] and not newpatlist:
-            result.append(basedir)
+            result.append(basedir or b'.')
             return
 
         for name in names:
             if name == pattern[0]:
                 newbase = posixpath.join(basedir or b'', *pattern)
                 await fs.stat(newbase)
 
@@ -199,228 +657,101 @@
         if pattern == b'**':
             await _glob(fs, basedir, newpatlist, result)
 
         for name in names:
             if name in (b'.', b'..'):
                 continue
 
-            if fnmatch(name, pattern):
+            if fnmatch(name, cast(bytes, pattern)):
                 newbase = posixpath.join(basedir or b'', name)
 
                 if not newpatlist or (len(newpatlist) == 1 and
                                       not newpatlist[0]):
                     result.append(newbase)
                 else:
                     attrs = await fs.stat(newbase)
 
-                    if stat.S_ISDIR(attrs.permissions):
+                    if attrs.type == FILEXFER_TYPE_DIRECTORY:
                         if pattern == b'**':
                             await _glob(fs, newbase, patlist, result)
                         else:
                             await _glob(fs, newbase, newpatlist, result)
 
 
-async def match_glob(fs, pattern, error_handler=None):
+async def match_glob(fs: _SFTPGlobProtocol, pattern: bytes,
+                     error_handler: SFTPErrorHandler = None,
+                     sftp_version = MIN_SFTP_VERSION) -> Sequence[bytes]:
     """Match a glob pattern"""
 
-    names = []
+    names: List[bytes] = []
 
     try:
         if any(c in pattern for c in b'*?[]'):
             basedir, patlist = _split_path_by_globs(pattern)
             await _glob(fs, basedir, patlist, names)
 
             if not names:
-                raise SFTPNoSuchFile('No matches found')
+                exc = SFTPNoSuchPath if sftp_version >= 4 else SFTPNoSuchFile
+                raise exc('No matches found')
         else:
             await fs.stat(pattern)
             names.append(pattern)
     except (OSError, SFTPError) as exc:
-        # pylint: disable=attribute-defined-outside-init
-        exc.srcpath = pattern
+        setattr(exc, 'srcpath', pattern)
 
         if error_handler:
             error_handler(exc)
         else:
             raise
 
     return names
 
 
-class LocalFile:
-    """A coroutine wrapper around local file I/O"""
-
-    def __init__(self, f):
-        self._file = f
-
-    @classmethod
-    def basename(cls, path):
-        """Return the final component of a local file path"""
-
-        return os.path.basename(path)
-
-    @classmethod
-    def encode(cls, path):
-        """Encode path name using filesystem native encoding
-
-           This method has no effect if the path is already bytes.
-
-        """
-
-        if isinstance(path, PurePath): # pragma: no branch
-            path = str(path)
-
-        return os.fsencode(path)
-
-    @classmethod
-    def decode(cls, path):
-        """Decode path name using filesystem native encoding
-
-           This method has no effect if the path is already a string.
-
-        """
-
-        return os.fsdecode(path)
-
-    @classmethod
-    def compose_path(cls, path, parent=None):
-        """Compose a path
-
-           If parent is not specified, just encode the path.
-
-        """
-
-        return posixpath.join(parent, path) if parent else path
-
-    @classmethod
-    async def open(cls, path, *args, block_size=None):
-        """Open a local file"""
-
-        # pylint: disable=unused-argument
-
-        return cls(open(_to_local_path(path), *args))
-
-    @classmethod
-    async def stat(cls, path):
-        """Get attributes of a local file or directory, following symlinks"""
-
-        return SFTPAttrs.from_local(os.stat(_to_local_path(path)))
-
-    @classmethod
-    async def lstat(cls, path):
-        """Get attributes of a local file, directory, or symlink"""
-
-        return SFTPAttrs.from_local(os.lstat(_to_local_path(path)))
-
-    @classmethod
-    async def setstat(cls, path, attrs):
-        """Set attributes of a local file or directory"""
-
-        _setstat(_to_local_path(path), attrs)
-
-    @classmethod
-    async def exists(cls, path):
-        """Return if the local path exists and isn't a broken symbolic link"""
-
-        return os.path.exists(_to_local_path(path))
-
-    @classmethod
-    async def isdir(cls, path):
-        """Return if the local path refers to a directory"""
-
-        return os.path.isdir(_to_local_path(path))
-
-    @classmethod
-    async def listdir(cls, path):
-        """Read the names of the files in a local directory"""
-
-        files = os.listdir(_to_local_path(path))
-
-        if sys.platform == 'win32': # pragma: no cover
-            files = [os.fsencode(f) for f in files]
-
-        return files
-
-    @classmethod
-    async def mkdir(cls, path):
-        """Create a local directory with the specified attributes"""
-
-        os.mkdir(_to_local_path(path))
-
-    @classmethod
-    async def readlink(cls, path):
-        """Return the target of a local symbolic link"""
-
-        return _from_local_path(os.readlink(_to_local_path(path)))
-
-    @classmethod
-    async def symlink(cls, oldpath, newpath):
-        """Create a local symbolic link"""
-
-        os.symlink(_to_local_path(oldpath), _to_local_path(newpath))
-
-    async def read(self, size, offset):
-        """Read data from the local file"""
-
-        self._file.seek(offset)
-        return self._file.read(size)
-
-    async def write(self, data, offset):
-        """Write data to the local file"""
-
-        self._file.seek(offset)
-        return self._file.write(data)
-
-    async def close(self):
-        """Close the local file"""
-
-        self._file.close()
-
-
-class _SFTPParallelIO:
+class _SFTPParallelIO(Generic[_T]):
     """Parallelize I/O requests on files
 
        This class issues parallel read and wite requests on files.
 
     """
 
-    def __init__(self, block_size, max_requests, offset, size):
+    def __init__(self, block_size: int, max_requests: int,
+                 offset: int, size: int):
         self._block_size = block_size
         self._max_requests = max_requests
         self._offset = offset
         self._bytes_left = size
-        self._pending = set()
+        self._pending: Set['asyncio.Task[None]'] = set()
 
-    def _start_tasks(self):
+    def _start_tasks(self) -> None:
         """Create parallel file I/O tasks"""
 
         while self._bytes_left and len(self._pending) < self._max_requests:
             size = min(self._bytes_left, self._block_size)
 
             task = asyncio.ensure_future(self.run_task(self._offset, size))
             self._pending.add(task)
 
             self._offset += size
             self._bytes_left -= size
 
-    async def start(self):
+    async def start(self) -> None:
         """Start parallel I/O"""
 
-    async def run_task(self, offset, size):
+    async def run_task(self, offset: int, size: int) -> None:
         """Perform file I/O on a particular byte range"""
 
         raise NotImplementedError
 
-    async def finish(self):
+    async def finish(self) -> _T:
         """Finish parallel I/O"""
 
-    async def cleanup(self):
+    async def cleanup(self) -> None:
         """Clean up parallel I/O"""
 
-    async def run(self):
+    async def run(self) -> _T:
         """Perform all file I/O and return result or exception"""
 
         try:
             await self.start()
 
             self._start_tasks()
 
@@ -445,61 +776,65 @@
                 self._start_tasks()
 
             return await self.finish()
         finally:
             await self.cleanup()
 
 
-class _SFTPFileReader(_SFTPParallelIO):
+class _SFTPFileReader(_SFTPParallelIO[bytes]):
     """Parallelized SFTP file reader"""
 
-    def __init__(self, block_size, max_requests, handler, handle, offset, size):
+    def __init__(self, block_size: int, max_requests: int,
+                 handler: 'SFTPClientHandler', handle: bytes,
+                 offset: int, size: int):
         super().__init__(block_size, max_requests, offset, size)
 
         self._handler = handler
         self._handle = handle
         self._start = offset
         self._data = bytearray()
 
-    async def run_task(self, offset, size):
+    async def run_task(self, offset: int, size: int) -> None:
         """Read a block of the file"""
 
         while size:
-            data = await self._handler.read(self._handle, offset, size)
+            data, _ = await self._handler.read(self._handle, offset, size)
 
             pos = offset - self._start
             pad = pos - len(self._data)
 
             if pad > 0:
                 self._data += pad * b'\0'
 
             datalen = len(data)
             self._data[pos:pos+datalen] = data
 
             offset += datalen
             size -= datalen
 
-    async def finish(self):
+    async def finish(self) -> bytes:
         """Finish parallel read"""
 
         return bytes(self._data)
 
 
-class _SFTPFileWriter(_SFTPParallelIO):
+class _SFTPFileWriter(_SFTPParallelIO[None]):
     """Parallelized SFTP file writer"""
 
-    def __init__(self, block_size, max_requests, handler, handle, offset, data):
+    def __init__(self, block_size: int, max_requests: int,
+                 handler: 'SFTPClientHandler', handle: bytes,
+                 offset: int, data: bytes):
         super().__init__(block_size, max_requests, offset, len(data))
 
         self._handler = handler
         self._handle = handle
         self._start = offset
         self._data = data
 
-    async def run_task(self, offset, size):
+    async def run_task(self, offset: int, size: int) -> None:
         """Write a block to the file"""
 
         pos = offset - self._start
         await self._handler.write(self._handle, offset,
                                   self._data[pos:pos+size])
 
 
@@ -507,52 +842,56 @@
     """SFTP file copier
 
        This class parforms an SFTP file copy, initiating multiple
        read and write requests to copy chunks of the file in parallel.
 
     """
 
-    def __init__(self, block_size, max_requests, offset, total_bytes,
-                 srcfs, dstfs, srcpath, dstpath, progress_handler):
+    def __init__(self, block_size: int, max_requests: int, offset: int,
+                 total_bytes: int, srcfs: _SFTPFSProtocol,
+                 dstfs: _SFTPFSProtocol, srcpath: bytes, dstpath: bytes,
+                 progress_handler: SFTPProgressHandler):
         super().__init__(block_size, max_requests, offset, total_bytes)
 
         self._srcfs = srcfs
         self._dstfs = dstfs
 
         self._srcpath = srcpath
         self._dstpath = dstpath
 
-        self._src = None
-        self._dst = None
+        self._src: Optional[SFTPFileProtocol] = None
+        self._dst: Optional[SFTPFileProtocol] = None
 
         self._bytes_copied = 0
         self._total_bytes = total_bytes
         self._progress_handler = progress_handler
 
-    async def start(self):
+    async def start(self) -> None:
         """Start parallel copy"""
 
-        self._src = await self._srcfs.open(self._srcpath, 'rb', block_size=None)
-        self._dst = await self._dstfs.open(self._dstpath, 'wb', block_size=None)
+        self._src = await self._srcfs.open(self._srcpath, 'rb')
+        self._dst = await self._dstfs.open(self._dstpath, 'wb')
 
         if self._progress_handler and self._total_bytes == 0:
             self._progress_handler(self._srcpath, self._dstpath, 0, 0)
 
-    async def run_task(self, offset, size):
+    async def run_task(self, offset: int, size: int) -> None:
         """Copy the next block of the file"""
 
+        assert self._src is not None
+        assert self._dst is not None
+
         while size:
             data = await self._src.read(size, offset)
 
             if not data:
                 exc = SFTPFailure('Unexpected EOF during file copy')
 
-                # pylint: disable=attribute-defined-outside-init
-                exc.filename = self._srcpath
-                exc.offset = offset
+                setattr(exc, 'filename', self._srcpath)
+                setattr(exc, 'offset', offset)
 
                 raise exc
 
             await self._dst.write(data, offset)
 
             datalen = len(data)
 
@@ -560,15 +899,15 @@
                 self._bytes_copied += datalen
                 self._progress_handler(self._srcpath, self._dstpath,
                                        self._bytes_copied, self._total_bytes)
 
             offset += datalen
             size -= datalen
 
-    async def cleanup(self):
+    async def cleanup(self) -> None:
         """Clean up parallel copy"""
 
         try:
             if self._src: # pragma: no branch
                 await self._src.close()
         finally:
             if self._dst: # pragma: no branch
@@ -591,14 +930,67 @@
            The language the reason is in
        :type code: `int`
        :type reason: `str`
        :type lang: `str`
 
     """
 
+    @staticmethod
+    def construct(packet: SSHPacket) -> Optional['SFTPError']:
+        """Construct an SFTPError from an FXP_STATUS response"""
+
+        code = packet.get_uint32()
+
+        if packet:
+            try:
+                reason = packet.get_string().decode('utf-8')
+                lang = packet.get_string().decode('ascii')
+            except UnicodeDecodeError:
+                raise SFTPBadMessage('Invalid status message') from None
+        else:
+            # Some servers may not always send reason and lang (usually
+            # when responding with FX_OK). Tolerate this, automatically
+            # filling in empty strings for them if they're not present.
+
+            reason = ''
+            lang = ''
+
+        if code == FX_OK:
+            return None
+        else:
+            try:
+                exc = _sftp_error_map[code](reason, lang)
+            except KeyError:
+                exc = SFTPError(code, '%s (error %d)' % (reason, code), lang)
+
+            exc.decode(packet)
+            return exc
+
+    def encode(self, version: int) -> bytes:
+        """Encode an SFTPError as bytes in an SSHPacket"""
+
+        if self.code == FX_NOT_A_DIRECTORY and version < 6:
+            code = FX_NO_SUCH_FILE
+        elif (self.code <= FX_V6_END and
+                ((self.code > FX_V3_END and version <= 3) or
+                 (self.code > FX_V4_END and version <= 4) or
+                 (self.code > FX_V5_END and version <= 5))):
+            code = FX_FAILURE
+        else:
+            code = self.code
+
+        return UInt32(code) + String(self.reason) + String(self.lang)
+
+    def decode(self, packet: SSHPacket) -> None:
+        """Decode error-specific data"""
+
+        # pylint: disable=no-self-use
+
+        # By default, expect no error-specific data
+
 
 class SFTPEOFError(SFTPError):
     """SFTP EOF error
 
        This exception is raised when end of file is reached when
        reading a file or directory.
 
@@ -607,15 +999,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason='', lang=DEFAULT_LANG):
+    def __init__(self, reason: str = '', lang: str = DEFAULT_LANG):
         super().__init__(FX_EOF, reason, lang)
 
 
 class SFTPNoSuchFile(SFTPError):
     """SFTP no such file
 
        This exception is raised when the requested file is not found.
@@ -625,15 +1017,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_NO_SUCH_FILE, reason, lang)
 
 
 class SFTPPermissionDenied(SFTPError):
     """SFTP permission denied
 
        This exception is raised when the permissions are not available
@@ -644,15 +1036,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_PERMISSION_DENIED, reason, lang)
 
 
 class SFTPFailure(SFTPError):
     """SFTP failure
 
        This exception is raised when an unexpected SFTP failure occurs.
@@ -662,15 +1054,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_FAILURE, reason, lang)
 
 
 class SFTPBadMessage(SFTPError):
     """SFTP bad message
 
        This exception is raised when an invalid SFTP message is
@@ -681,15 +1073,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_BAD_MESSAGE, reason, lang)
 
 
 class SFTPNoConnection(SFTPError):
     """SFTP no connection
 
        This exception is raised when an SFTP request is made on a
@@ -700,15 +1092,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_NO_CONNECTION, reason, lang)
 
 
 class SFTPConnectionLost(SFTPError):
     """SFTP connection lost
 
        This exception is raised when the SSH connection is lost or
@@ -719,15 +1111,15 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_CONNECTION_LOST, reason, lang)
 
 
 class SFTPOpUnsupported(SFTPError):
     """SFTP operation unsupported
 
        This exception is raised when the requested SFTP operation
@@ -738,163 +1130,866 @@
        :param lang: (optional)
            The language the reason is in
        :type reason: `str`
        :type lang: `str`
 
     """
 
-    def __init__(self, reason, lang=DEFAULT_LANG):
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
         super().__init__(FX_OP_UNSUPPORTED, reason, lang)
 
 
-_sftp_error_map = {
+class SFTPInvalidHandle(SFTPError):
+    """SFTP invalid handle (SFTPv4+)
+
+       This exception is raised when the handle provided is invalid.
+
+       :param reason:
+           Details about the invalid handle
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_INVALID_HANDLE, reason, lang)
+
+
+class SFTPNoSuchPath(SFTPError):
+    """SFTP no such path (SFTPv4+)
+
+       This exception is raised when the requested path is not found.
+
+       :param reason:
+           Details about the missing path
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_NO_SUCH_PATH, reason, lang)
+
+
+class SFTPFileAlreadyExists(SFTPError):
+    """SFTP file already exists (SFTPv4+)
+
+       This exception is raised when the requested file already exists.
+
+       :param reason:
+           Details about the existing file
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_FILE_ALREADY_EXISTS, reason, lang)
+
+
+class SFTPWriteProtect(SFTPError):
+    """SFTP write protect (SFTPv4+)
+
+       This exception is raised when a write is attempted to a file
+       on read-only or write protected media.
+
+       :param reason:
+           Details about the requested file
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_WRITE_PROTECT, reason, lang)
+
+
+class SFTPNoMedia(SFTPError):
+    """SFTP no media (SFTPv4+)
+
+       This exception is raised when there is no media in the
+       requested drive.
+
+       :param reason:
+           Details about the requested drive
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_NO_MEDIA, reason, lang)
+
+
+class SFTPNoSpaceOnFilesystem(SFTPError):
+    """SFTP no space on filesystem (SFTPv5+)
+
+       This exception is raised when there is no space available
+       on the filesystem a file is being written to.
+
+       :param reason:
+           Details about the filesystem which has filled up
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_NO_SPACE_ON_FILESYSTEM, reason, lang)
+
+
+class SFTPQuotaExceeded(SFTPError):
+    """SFTP quota exceeded (SFTPv5+)
+
+       This exception is raised when the user's storage quota
+       is exceeded.
+
+       :param reason:
+           Details about the exceeded quota
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_QUOTA_EXCEEDED, reason, lang)
+
+
+class SFTPUnknownPrincipal(SFTPError):
+    """SFTP unknown principal (SFTPv5+)
+
+       This exception is raised when a file owner or group is
+       not reocgnized.
+
+       :param reason:
+           Details about the unknown principal
+       :param lang: (optional)
+           The language the reason is in
+       :param unknown_names: (optional)
+           A list of unknown principal names
+       :type reason: `str`
+       :type lang: `str`
+       :type unknown_names: list of `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG,
+                 unknown_names: Sequence[str] = ()):
+        super().__init__(FX_UNKNOWN_PRINCIPAL, reason, lang)
+        self.unknown_names = unknown_names
+
+    def encode(self, version: int) -> bytes:
+        """Encode an SFTPUnknownPrincipal as bytes in an SSHPacket"""
+
+        return super().encode(version) + \
+            b''.join(String(name) for name in self.unknown_names)
+
+    def decode(self, packet: SSHPacket) -> None:
+        """Decode error-specific data"""
+
+        self.unknown_names = []
+
+        try:
+            while packet:
+                self.unknown_names.append(
+                    packet.get_string().decode('utf-8'))
+        except UnicodeDecodeError:
+            raise SFTPBadMessage('Invalid status message') from None
+
+
+class SFTPLockConflict(SFTPError):
+    """SFTP lock conflict (SFTPv5+)
+
+       This exception is raised when a requested lock is held by
+       another process.
+
+       :param reason:
+           Details about the conflicting lock
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_LOCK_CONFLICT, reason, lang)
+
+
+class SFTPDirNotEmpty(SFTPError):
+    """SFTP directory not empty (SFTPv6+)
+
+       This exception is raised when a directory is not empty.
+
+       :param reason:
+           Details about the non-empty directory
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_DIR_NOT_EMPTY, reason, lang)
+
+
+class SFTPNotADirectory(SFTPError):
+    """SFTP not a directory (SFTPv6+)
+
+       This exception is raised when a specified file is
+       not a directory where one was expected.
+
+       :param reason:
+           Details about the file expected to be a directory
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_NOT_A_DIRECTORY, reason, lang)
+
+
+class SFTPInvalidFilename(SFTPError):
+    """SFTP invalid filename (SFTPv6+)
+
+       This exception is raised when a filename is not valid.
+
+       :param reason:
+           Details about the invalid filename
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_INVALID_FILENAME, reason, lang)
+
+
+class SFTPLinkLoop(SFTPError):
+    """SFTP link loop (SFTPv6+)
+
+       This exception is raised when a symbolic link loop is detected.
+
+       :param reason:
+           Details about the link loop
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_LINK_LOOP, reason, lang)
+
+
+class SFTPCannotDelete(SFTPError):
+    """SFTP cannot delete (SFTPv6+)
+
+       This exception is raised when a file cannot be deleted.
+
+       :param reason:
+           Details about the undeletable file
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_CANNOT_DELETE, reason, lang)
+
+
+class SFTPInvalidParameter(SFTPError):
+    """SFTP invalid parameter (SFTPv6+)
+
+       This exception is raised when paramters in a request are
+       out of range or incompatible with one another.
+
+       :param reason:
+           Details about the invalid paramter
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_INVALID_PARAMETER, reason, lang)
+
+
+class SFTPFileIsADirectory(SFTPError):
+    """SFTP file is a directory (SFTPv6+)
+
+       This exception is raised when a specified file is a
+       directory where one isn't allowed.
+
+       :param reason:
+           Details about the unexpected directory
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_FILE_IS_A_DIRECTORY, reason, lang)
+
+
+class SFTPByteRangeLockConflict(SFTPError):
+    """SFTP byte range lock conflict (SFTPv6+)
+
+       This exception is raised when a read or write request overlaps
+       a byte range lock held by another process.
+
+       :param reason:
+           Details about the conflicting byte range lock
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_BYTE_RANGE_LOCK_CONFLICT, reason, lang)
+
+
+class SFTPByteRangeLockRefused(SFTPError):
+    """SFTP byte range lock refused (SFTPv6+)
+
+       This exception is raised when a request for a byte range
+       lock was refused.
+
+       :param reason:
+           Details about the refused byte range lock
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_BYTE_RANGE_LOCK_REFUSED, reason, lang)
+
+
+class SFTPDeletePending(SFTPError):
+    """SFTP delete pending (SFTPv6+)
+
+       This exception is raised when an operation was attempted
+       on a file for which a delete operation is pending.
+       another process.
+
+       :param reason:
+           Details about the file being deleted
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_DELETE_PENDING, reason, lang)
+
+
+class SFTPFileCorrupt(SFTPError):
+    """SFTP file corrupt (SFTPv6+)
+
+       This exception is raised when filesystem corruption is detected.
+
+       :param reason:
+           Details about the corrupted filesystem
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_FILE_CORRUPT, reason, lang)
+
+
+class SFTPOwnerInvalid(SFTPError):
+    """SFTP owner invalid (SFTPv6+)
+
+       This exception is raised when a principal cannot be assigned
+       as the owner of a file.
+
+       :param reason:
+           Details about the principal being set as a file's owner
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_OWNER_INVALID, reason, lang)
+
+
+class SFTPGroupInvalid(SFTPError):
+    """SFTP group invalid (SFTPv6+)
+
+       This exception is raised when a principal cannot be assigned
+       as the primary group of a file.
+
+       :param reason:
+           Details about the principal being set as a file's group
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_GROUP_INVALID, reason, lang)
+
+
+class SFTPNoMatchingByteRangeLock(SFTPError):
+    """SFTP no matching byte range lock (SFTPv6+)
+
+       This exception is raised when an unlock is requested for a
+       byte range lock which is not currently held.
+
+       :param reason:
+           Details about the byte range lock being released
+       :param lang: (optional)
+           The language the reason is in
+       :type reason: `str`
+       :type lang: `str`
+
+    """
+
+    def __init__(self, reason: str, lang: str = DEFAULT_LANG):
+        super().__init__(FX_NO_MATCHING_BYTE_RANGE_LOCK, reason, lang)
+
+
+_sftp_error_map: Dict[int, Callable[[str, str], SFTPError]] = {
     FX_EOF: SFTPEOFError,
     FX_NO_SUCH_FILE: SFTPNoSuchFile,
     FX_PERMISSION_DENIED: SFTPPermissionDenied,
     FX_FAILURE: SFTPFailure,
     FX_BAD_MESSAGE: SFTPBadMessage,
     FX_NO_CONNECTION: SFTPNoConnection,
     FX_CONNECTION_LOST: SFTPConnectionLost,
-    FX_OP_UNSUPPORTED: SFTPOpUnsupported
+    FX_OP_UNSUPPORTED: SFTPOpUnsupported,
+    FX_INVALID_HANDLE: SFTPInvalidHandle,
+    FX_NO_SUCH_PATH: SFTPNoSuchPath,
+    FX_FILE_ALREADY_EXISTS: SFTPFileAlreadyExists,
+    FX_WRITE_PROTECT: SFTPWriteProtect,
+    FX_NO_MEDIA: SFTPNoMedia,
+    FX_NO_SPACE_ON_FILESYSTEM: SFTPNoSpaceOnFilesystem,
+    FX_QUOTA_EXCEEDED: SFTPQuotaExceeded,
+    FX_UNKNOWN_PRINCIPAL: SFTPUnknownPrincipal,
+    FX_LOCK_CONFLICT: SFTPLockConflict,
+    FX_DIR_NOT_EMPTY: SFTPDirNotEmpty,
+    FX_NOT_A_DIRECTORY: SFTPNotADirectory,
+    FX_INVALID_FILENAME: SFTPInvalidFilename,
+    FX_LINK_LOOP: SFTPLinkLoop,
+    FX_CANNOT_DELETE: SFTPCannotDelete,
+    FX_INVALID_PARAMETER: SFTPInvalidParameter,
+    FX_FILE_IS_A_DIRECTORY: SFTPFileIsADirectory,
+    FX_BYTE_RANGE_LOCK_CONFLICT: SFTPByteRangeLockConflict,
+    FX_BYTE_RANGE_LOCK_REFUSED: SFTPByteRangeLockRefused,
+    FX_DELETE_PENDING: SFTPDeletePending,
+    FX_FILE_CORRUPT: SFTPFileCorrupt,
+    FX_OWNER_INVALID: SFTPOwnerInvalid,
+    FX_GROUP_INVALID: SFTPGroupInvalid,
+    FX_NO_MATCHING_BYTE_RANGE_LOCK: SFTPNoMatchingByteRangeLock
 }
 
 
-def _construct_sftp_error(code, reason, lang):
-    """Map SFTP error code to appropriate SFTPError exception"""
-
-    try:
-        return _sftp_error_map[code](reason, lang)
-    except KeyError:
-        return SFTPError(code, '%s (error %d)' % (reason, code), lang)
-
-
 class SFTPAttrs(Record):
     """SFTP file attributes
 
        SFTPAttrs is a simple record class with the following fields:
 
-         ============ =========================================== ======
-         Field        Description                                 Type
-         ============ =========================================== ======
-         size         File size in bytes                          uint64
-         uid          User id of file owner                       uint32
-         gid          Group id of file owner                      uint32
-         permissions  Bit mask of POSIX file permissions,         uint32
-         atime        Last access time, UNIX epoch seconds        uint32
-         mtime        Last modification time, UNIX epoch seconds  uint32
-         ============ =========================================== ======
-
-       In addition to the above, an `nlink` field is provided which
-       stores the number of links to this file, but it is not encoded
-       in the SFTP protocol. It's included here only so that it can be
-       used to create the default `longname` string in :class:`SFTPName`
-       objects.
+         ============ ================================================= ======
+         Field        Description                                       Type
+         ============ ================================================= ======
+         type         File type (SFTPv4+)                               byte
+         size         File size in bytes                                uint64
+         alloc_size   Allocation file size in bytes (SFTPv6+)           uint64
+         uid          User id of file owner                             uint32
+         gid          Group id of file owner                            uint32
+         owner        User name of file owner (SFTPv4+)                 string
+         group        Group name of file owner (SFTPv4+)                string
+         permissions  Bit mask of POSIX file permissions                uint32
+         atime        Last access time, UNIX epoch seconds              uint64
+         atime_ns     Last access time, nanoseconds (SFTPv4+)           uint32
+         crtime       Creation time, UNIX epoch seconds (SFTPv4+)       uint64
+         crtime_ns    Creation time, nanoseconds (SFTPv4+)              uint32
+         mtime        Last modify time, UNIX epoch seconds              uint64
+         mtime_ns     Last modify time, nanoseconds (SFTPv4+)           uint32
+         ctime        Last change time, UNIX epoch seconds (SFTPv6+)    uint64
+         ctime_ns     Last change time, nanoseconds (SFTPv6+)           uint32
+         acl          Access control list for file (SFTPv4+)            bytes
+         attrib_bits  Attribute bits set for file (SFTPv5+)             uint32
+         attrib_valid Valid attribute bits for file (SFTPv5+)           uint32
+         text_hint    Text/binary hint for file (SFTPv6+)               byte
+         mime_type    MIME type for file (SFTPv6+)                      string
+         nlink        Link count for file (SFTPv6+)                     uint32
+         untrans_name Untranslated name for file (SFTPv6+)              bytes
+         ============ ================================================= ======
 
        Extended attributes can also be added via a field named
-       `extended` which is a list of string name/value pairs.
+       `extended` which is a list of bytes name/value pairs.
 
        When setting attributes using an :class:`SFTPAttrs`, only fields
        which have been initialized will be changed on the selected file.
 
     """
 
+    type: int = FILEXFER_TYPE_UNKNOWN
     size: Optional[int]
+    alloc_size: Optional[int]
     uid: Optional[int]
     gid: Optional[int]
+    owner: Optional[str]
+    group: Optional[str]
     permissions: Optional[int]
     atime: Optional[int]
+    atime_ns: Optional[int]
+    crtime: Optional[int]
+    crtime_ns: Optional[int]
     mtime: Optional[int]
+    mtime_ns: Optional[int]
+    ctime: Optional[int]
+    ctime_ns: Optional[int]
+    acl: Optional[bytes]
+    attrib_bits: Optional[int]
+    attrib_valid: Optional[int]
+    text_hint: Optional[int]
+    mime_type: Optional[str]
     nlink: Optional[int]
+    untrans_name: Optional[bytes]
     extended: Sequence[Tuple[bytes, bytes]] = ()
 
-    def _format(self, k, v):
+    def _format_ns(self, k: str):
+        """Convert epoch seconds & nanoseconds to a string date & time"""
+
+        result = time.ctime(getattr(self, k))
+        nsec = getattr(self, k + '_ns')
+
+        if result and nsec:
+            result = result[:19] + f'.{nsec:09d}' + result[19:]
+
+        return result
+
+    def _format(self, k: str, v: object) -> Optional[str]:
         """Convert attributes to more readable values"""
 
         if v is None or k == 'extended' and not v:
             return None
 
-        if k == 'permissions':
-            return '{:06o}'.format(v)
-        elif k in ('atime', 'mtime'):
-            return time.ctime(v)
+        if k == 'type':
+            return _file_types.get(cast(int, v), str(v)) \
+                if v != FILEXFER_TYPE_UNKNOWN else None
+        elif k == 'permissions':
+            return '{:04o}'.format(cast(int, v))
+        elif k in ('atime', 'crtime', 'mtime', 'ctime'):
+            return self._format_ns(k)
+        elif k in ('atime_ns', 'crtime_ns', 'mtime_ns', 'ctime_ns'):
+            return None
         else:
-            return str(v)
+            return str(v) or None
 
-    def encode(self):
+    def encode(self, sftp_version: int) -> bytes:
         """Encode SFTP attributes as bytes in an SSH packet"""
 
         flags = 0
         attrs = []
 
+        if sftp_version >= 4:
+            if sftp_version < 5 and self.type >= FILEXFER_TYPE_SOCKET:
+                filetype = FILEXFER_TYPE_SPECIAL
+            else:
+                filetype = self.type
+
+            attrs.append(Byte(filetype))
+
         if self.size is not None:
             flags |= FILEXFER_ATTR_SIZE
             attrs.append(UInt64(self.size))
 
-        if self.uid is not None and self.gid is not None:
-            flags |= FILEXFER_ATTR_UIDGID
-            attrs.append(UInt32(self.uid) + UInt32(self.gid))
+        if self.alloc_size is not None:
+            flags |= FILEXFER_ATTR_ALLOCATION_SIZE
+            attrs.append(UInt64(self.alloc_size))
+
+        if sftp_version == 3:
+            if self.uid is not None and self.gid is not None:
+                flags |= FILEXFER_ATTR_UIDGID
+                attrs.append(UInt32(self.uid) + UInt32(self.gid))
+            elif self.owner is not None and self.group is not None:
+                raise ValueError('Setting owner and group requires SFTPv4 '
+                                 'or later')
+        else:
+            if self.owner is not None and self.group is not None:
+                flags |= FILEXFER_ATTR_OWNERGROUP
+                attrs.append(String(self.owner) + String(self.group))
+            elif self.uid is not None and self.gid is not None:
+                flags |= FILEXFER_ATTR_OWNERGROUP
+                attrs.append(String(str(self.uid)) + String(str(self.gid)))
 
         if self.permissions is not None:
             flags |= FILEXFER_ATTR_PERMISSIONS
             attrs.append(UInt32(self.permissions))
 
-        if self.atime is not None and self.mtime is not None:
-            flags |= FILEXFER_ATTR_ACMODTIME
-            attrs.append(UInt32(int(self.atime)) + UInt32(int(self.mtime)))
+        if sftp_version == 3:
+            if self.atime is not None and self.mtime is not None:
+                flags |= FILEXFER_ATTR_ACMODTIME
+                attrs.append(UInt32(int(self.atime)) + UInt32(int(self.mtime)))
+        else:
+            subsecond = (self.atime_ns is not None or
+                         self.crtime_ns is not None or
+                         self.mtime_ns is not None or
+                         self.ctime_ns is not None)
+
+            if subsecond:
+                flags |= FILEXFER_ATTR_SUBSECOND_TIMES
+
+            if self.atime is not None:
+                flags |= FILEXFER_ATTR_ACCESSTIME
+                attrs.append(UInt64(int(self.atime)))
+
+                if subsecond:
+                    attrs.append(UInt32(self.atime_ns or 0))
+
+            if self.crtime is not None:
+                flags |= FILEXFER_ATTR_CREATETIME
+                attrs.append(UInt64(int(self.crtime)))
+
+                if subsecond:
+                    attrs.append(UInt32(self.crtime_ns or 0))
+
+            if self.mtime is not None:
+                flags |= FILEXFER_ATTR_MODIFYTIME
+                attrs.append(UInt64(int(self.mtime)))
+
+                if subsecond:
+                    attrs.append(UInt32(self.mtime_ns or 0))
+
+            if sftp_version >= 6 and self.ctime is not None:
+                flags |= FILEXFER_ATTR_CTIME
+                attrs.append(UInt64(int(self.ctime)))
+
+                if subsecond:
+                    attrs.append(UInt32(self.ctime_ns or 0))
+
+        if sftp_version >= 4 and self.acl is not None:
+            flags |= FILEXFER_ATTR_ACL
+            attrs.append(String(self.acl))
+
+        if sftp_version >= 5 and \
+                self.attrib_bits is not None and \
+                self.attrib_valid is not None:
+            flags |= FILEXFER_ATTR_BITS
+            attrs.append(UInt32(self.attrib_bits) + UInt32(self.attrib_valid))
+
+        if sftp_version >= 6:
+            if self.text_hint is not None:
+                flags |= FILEXFER_ATTR_TEXT_HINT
+                attrs.append(Byte(self.text_hint))
+
+            if self.mime_type is not None:
+                flags |= FILEXFER_ATTR_MIME_TYPE
+                attrs.append(String(self.mime_type))
+
+            if self.nlink is not None:
+                flags |= FILEXFER_ATTR_LINK_COUNT
+                attrs.append(UInt32(self.nlink))
+
+            if self.untrans_name is not None:
+                flags |= FILEXFER_ATTR_UNTRANSLATED_NAME
+                attrs.append(String(self.untrans_name))
 
         if self.extended:
             flags |= FILEXFER_ATTR_EXTENDED
             attrs.append(UInt32(len(self.extended)))
             attrs.extend(String(type) + String(data)
                          for type, data in self.extended)
 
         return UInt32(flags) + b''.join(attrs)
 
     @classmethod
-    def decode(cls, packet):
+    def decode(cls, packet: SSHPacket, sftp_version: int) -> 'SFTPAttrs':
         """Decode bytes in an SSH packet as SFTP attributes"""
 
         flags = packet.get_uint32()
         attrs = cls()
 
-        if flags & FILEXFER_ATTR_UNDEFINED:
-            raise SFTPBadMessage('Unsupported attribute flags')
+        unsupported_attrs = flags & ~_valid_attr_flags[sftp_version]
+
+        if unsupported_attrs:
+            raise SFTPBadMessage('Unsupported attribute flags: 0x%08x' %
+                                 unsupported_attrs)
+
+        if sftp_version >= 4:
+            attrs.type = packet.get_byte()
 
         if flags & FILEXFER_ATTR_SIZE:
             attrs.size = packet.get_uint64()
 
-        if flags & FILEXFER_ATTR_UIDGID:
-            attrs.uid = packet.get_uint32()
-            attrs.gid = packet.get_uint32()
+        if flags & FILEXFER_ATTR_ALLOCATION_SIZE:
+            attrs.alloc_size = packet.get_uint64()
+
+        if sftp_version == 3:
+            if flags & FILEXFER_ATTR_UIDGID:
+                attrs.uid = packet.get_uint32()
+                attrs.gid = packet.get_uint32()
+        else:
+            if flags & FILEXFER_ATTR_OWNERGROUP:
+                owner = packet.get_string()
+
+                try:
+                    attrs.owner = owner.decode('utf-8')
+                except UnicodeDecodeError:
+                    raise SFTPOwnerInvalid('Invalid owner name: %s' %
+                        owner.decode('utf-8', 'backslashreplace')) from None
+
+                group = packet.get_string()
+
+                try:
+                    attrs.group = group.decode('utf-8')
+                except UnicodeDecodeError:
+                    raise SFTPGroupInvalid('Invalid group name: %s' %
+                        group.decode('utf-8', 'backslashreplace')) from None
 
         if flags & FILEXFER_ATTR_PERMISSIONS:
-            attrs.permissions = packet.get_uint32() & 0xffff
+            mode = packet.get_uint32()
+
+            if sftp_version == 3:
+                attrs.type = _stat_mode_to_filetype(mode)
+                attrs.permissions = mode & 0xffff
+            else:
+                attrs.permissions = mode & 0xfff
+
+        if sftp_version == 3:
+            if flags & FILEXFER_ATTR_ACMODTIME:
+                attrs.atime = packet.get_uint32()
+                attrs.mtime = packet.get_uint32()
+        else:
+            if flags & FILEXFER_ATTR_ACCESSTIME:
+                attrs.atime = packet.get_uint64()
+
+                if flags & FILEXFER_ATTR_SUBSECOND_TIMES:
+                    attrs.atime_ns = packet.get_uint32()
+
+            if flags & FILEXFER_ATTR_CREATETIME:
+                attrs.crtime = packet.get_uint64()
+
+                if flags & FILEXFER_ATTR_SUBSECOND_TIMES:
+                    attrs.crtime_ns = packet.get_uint32()
+
+            if flags & FILEXFER_ATTR_MODIFYTIME:
+                attrs.mtime = packet.get_uint64()
+
+                if flags & FILEXFER_ATTR_SUBSECOND_TIMES:
+                    attrs.mtime_ns = packet.get_uint32()
+
+            if flags & FILEXFER_ATTR_CTIME:
+                attrs.ctime = packet.get_uint64()
+
+                if flags & FILEXFER_ATTR_SUBSECOND_TIMES:
+                    attrs.ctime_ns = packet.get_uint32()
+
+        if flags & FILEXFER_ATTR_ACL:
+            attrs.acl = packet.get_string()
+
+        if flags & FILEXFER_ATTR_BITS:
+            attrs.attrib_bits = packet.get_uint32()
+            attrs.attrib_valid = packet.get_uint32()
+
+        if flags & FILEXFER_ATTR_TEXT_HINT:
+            attrs.text_hint = packet.get_byte()
+
+        if flags & FILEXFER_ATTR_MIME_TYPE:
+            try:
+                attrs.mime_type = packet.get_string().decode('utf-8')
+            except UnicodeDecodeError:
+                raise SFTPBadMessage('Invalid MIME type') from None
 
-        if flags & FILEXFER_ATTR_ACMODTIME:
-            attrs.atime = packet.get_uint32()
-            attrs.mtime = packet.get_uint32()
+        if flags & FILEXFER_ATTR_LINK_COUNT:
+            attrs.nlink = packet.get_uint32()
+
+        if flags & FILEXFER_ATTR_UNTRANSLATED_NAME:
+            attrs.untrans_name = packet.get_string()
 
         if flags & FILEXFER_ATTR_EXTENDED:
             count = packet.get_uint32()
             attrs.extended = []
 
             for _ in range(count):
                 attr = packet.get_string()
                 data = packet.get_string()
                 attrs.extended.append((attr, data))
 
         return attrs
 
     @classmethod
-    def from_local(cls, result):
+    def from_local(cls, result: os.stat_result) -> 'SFTPAttrs':
         """Convert from local stat attributes"""
 
-        return cls(result.st_size, result.st_uid, result.st_gid,
-                   result.st_mode, result.st_atime, result.st_mtime,
-                   result.st_nlink)
+        mode = result.st_mode
+        filetype = _stat_mode_to_filetype(mode)
+
+        if sys.platform == 'win32': # pragma: no cover
+            uid = 0
+            gid = 0
+            owner = ''
+            group = ''
+        else:
+            uid = result.st_uid
+            gid = result.st_gid
+            owner = _lookup_user(uid)
+            group = _lookup_group(gid)
+
+        atime, atime_ns = _nsec_to_tuple(result.st_atime_ns)
+        mtime, mtime_ns = _nsec_to_tuple(result.st_mtime_ns)
+        ctime, ctime_ns = _nsec_to_tuple(result.st_ctime_ns)
+
+        if sys.platform == 'win32': # pragma: no cover
+            crtime, crtime_ns = ctime, ctime_ns
+        elif hasattr(result, 'st_birthtime'): # pragma: no cover
+            crtime, crtime_ns = _float_sec_to_tuple(result.st_birthtime)
+        else: # pragma: no cover
+            crtime, crtime_ns = mtime, mtime_ns
+
+        return cls(filetype, result.st_size, None, uid, gid, owner, group,
+                   mode, atime, atime_ns, crtime, crtime_ns, mtime, mtime_ns,
+                   ctime, ctime_ns, None, None, None, None, None,
+                   result.st_nlink, None)
 
 
 class SFTPVFSAttrs(Record):
     """SFTP file system attributes
 
        SFTPVFSAttrs is a simple record class with the following fields:
 
@@ -924,28 +2019,32 @@
     files: int = 0
     ffree: int = 0
     favail: int = 0
     fsid: int = 0
     flags: int = 0
     namemax: int = 0
 
-    def encode(self):
+    def encode(self, sftp_version: int) -> bytes:
         """Encode SFTP statvfs attributes as bytes in an SSH packet"""
 
+        # pylint: disable=unused-argument
+
         return b''.join((UInt64(self.bsize), UInt64(self.frsize),
                          UInt64(self.blocks), UInt64(self.bfree),
                          UInt64(self.bavail), UInt64(self.files),
                          UInt64(self.ffree), UInt64(self.favail),
                          UInt64(self.fsid), UInt64(self.flags),
                          UInt64(self.namemax)))
 
     @classmethod
-    def decode(cls, packet):
+    def decode(cls, packet: SSHPacket, sftp_version: int) -> 'SFTPVFSAttrs':
         """Decode bytes in an SSH packet as SFTP statvfs attributes"""
 
+        # pylint: disable=unused-argument
+
         vfsattrs = cls()
 
         vfsattrs.bsize = packet.get_uint64()
         vfsattrs.frsize = packet.get_uint64()
         vfsattrs.blocks = packet.get_uint64()
         vfsattrs.bfree = packet.get_uint64()
         vfsattrs.bavail = packet.get_uint64()
@@ -955,15 +2054,15 @@
         vfsattrs.fsid = packet.get_uint64()
         vfsattrs.flags = packet.get_uint64()
         vfsattrs.namemax = packet.get_uint64()
 
         return vfsattrs
 
     @classmethod
-    def from_local(cls, result):
+    def from_local(cls, result: os.statvfs_result) -> 'SFTPVFSAttrs':
         """Convert from local statvfs attributes"""
 
         return cls(result.f_bsize, result.f_frsize, result.f_blocks,
                    result.f_bfree, result.f_bavail, result.f_files,
                    result.f_ffree, result.f_favail, 0, result.f_flag,
                    result.f_namemax)
 
@@ -986,48 +2085,51 @@
 
     """
 
     filename: BytesOrStr = ''
     longname: BytesOrStr = ''
     attrs: SFTPAttrs = SFTPAttrs()
 
-    def _format(self, k, v):
+    def _format(self, k: str, v: object) -> Optional[str]:
         """Convert name fields to more readable values"""
 
+        if k == 'longname' and not v:
+            return None
+
         if isinstance(v, bytes):
-            v = v.decode('utf-8', errors='replace')
+            v = v.decode('utf-8', 'backslashreplace')
 
         return str(v) or None
 
-    def encode(self):
+    def encode(self, sftp_version: int) -> bytes:
         """Encode an SFTP name as bytes in an SSH packet"""
 
+        longname = String(self.longname) if sftp_version == 3 else b''
 
-        # pylint: disable=no-member
-        return (String(self.filename) + String(self.longname) +
-                self.attrs.encode())
+        return (String(self.filename) + longname +
+                self.attrs.encode(sftp_version))
 
     @classmethod
-    def decode(cls, packet):
+    def decode(cls, packet: SSHPacket, sftp_version: int) -> 'SFTPName':
         """Decode bytes in an SSH packet as an SFTP name"""
 
-
         filename = packet.get_string()
-        longname = packet.get_string()
-        attrs = SFTPAttrs.decode(packet)
+        longname = packet.get_string() if sftp_version == 3 else None
+        attrs = SFTPAttrs.decode(packet, sftp_version)
 
         return cls(filename, longname, attrs)
 
 
 class SFTPHandler(SSHPacketLogger):
     """SFTP session handler"""
 
     _data_pkttypes = {FXP_WRITE, FXP_DATA}
 
-    _handler_names = get_symbol_names(globals(), 'FXP_')
+    _handler_names = get_symbol_names(_const_dict, 'FXP_')
+    _realpath_check_names = get_symbol_names(_const_dict, 'FXRP_', 5)
 
     # SFTP implementations with broken order for SYMLINK arguments
     _nonstandard_symlink_impls = ['OpenSSH', 'paramiko']
 
     # Return types by message -- unlisted entries always return FXP_STATUS,
     #                            those below return FXP_STATUS on error
     _return_types = {
@@ -1040,63 +2142,133 @@
         FXP_REALPATH:             FXP_NAME,
         FXP_STAT:                 FXP_ATTRS,
         FXP_READLINK:             FXP_NAME,
         b'statvfs@openssh.com':   FXP_EXTENDED_REPLY,
         b'fstatvfs@openssh.com':  FXP_EXTENDED_REPLY
     }
 
-    def __init__(self, reader, writer):
-        self._reader = reader
-        self._writer = writer
-
+    def __init__(self, reader: 'SSHReader[bytes]', writer: 'SSHWriter[bytes]'):
+        self._reader: Optional['SSHReader[bytes]'] = reader
+        self._writer: Optional['SSHWriter[bytes]'] = writer
         self._logger = reader.logger.get_child('sftp')
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this SFTP handler"""
 
         return self._logger
 
-    async def _cleanup(self, exc):
+    async def _cleanup(self, exc: Optional[Exception]) -> None:
         """Clean up this SFTP session"""
 
         # pylint: disable=unused-argument
 
         if self._writer: # pragma: no branch
             self._writer.close()
             self._reader = None
             self._writer = None
 
-    async def _process_packet(self, pkttype, pktid, packet):
+    def _log_extensions(self, extensions: Sequence[Tuple[bytes, bytes]]):
+        """Dump a formatted list of extensions to the debug log"""
+
+        for name, data in extensions:
+            if name == b'acl-supported':
+                capabilities = _parse_acl_supported(data)
+
+                self.logger.debug1('  acl-supported:')
+                self.logger.debug1('    capabilities: 0x%08x', capabilities)
+            elif name == b'supported':
+                attr_mask, attrib_mask, open_flags, access_mask, \
+                    max_read_size, ext_names = _parse_supported(data)
+
+                self.logger.debug1('  supported:')
+                self.logger.debug1('    attr_mask: 0x%08x', attr_mask)
+                self.logger.debug1('    attrib_mask: 0x%08x', attrib_mask)
+                self.logger.debug1('    open_flags: 0x%08x', open_flags)
+                self.logger.debug1('    access_mask: 0x%08x', access_mask)
+                self.logger.debug1('    max_read_size: %d', max_read_size)
+
+                if ext_names:
+                    self.logger.debug1('    extensions:')
+
+                    for ext_name in ext_names:
+                        self.logger.debug1('      %s', ext_name)
+            elif name == b'supported2':
+                attr_mask, attrib_mask, open_flags, access_mask, \
+                    max_read_size, open_block_vector, block_vector, \
+                    attrib_ext_names, ext_names = _parse_supported2(data)
+
+                self.logger.debug1('  supported2:')
+                self.logger.debug1('    attr_mask: 0x%08x', attr_mask)
+                self.logger.debug1('    attrib_mask: 0x%08x', attrib_mask)
+                self.logger.debug1('    open_flags: 0x%08x', open_flags)
+                self.logger.debug1('    access_mask: 0x%08x', access_mask)
+                self.logger.debug1('    max_read_size: %d', max_read_size)
+                self.logger.debug1('    open_block_vector: 0x%04x',
+                    open_block_vector)
+                self.logger.debug1('    block_vector: 0x%04x', block_vector)
+
+                if attrib_ext_names:
+                    self.logger.debug1('    attrib_extensions:')
+
+                    for attrib_ext_name in attrib_ext_names:
+                        self.logger.debug1('      %s', attrib_ext_name)
+
+                if ext_names:
+                    self.logger.debug1('    extensions:')
+
+                    for ext_name in ext_names:
+                        self.logger.debug1('      %s', ext_name)
+            elif name == b'vendor-id':
+                vendor_name, product_name, product_version, product_build = \
+                    _parse_vendor_id(data)
+
+                self.logger.debug1('  vendor-id:')
+                self.logger.debug1('    vendor_name: %s', vendor_name)
+                self.logger.debug1('    product_name: %s', product_name)
+                self.logger.debug1('    product_version: %s', product_version)
+                self.logger.debug1('    product_build: %d', product_build)
+            else:
+                self.logger.debug1('  %s%s%s', name,
+                                   ': ' if data else '', data)
+
+    async def _process_packet(self, pkttype: int, pktid: int,
+                              packet: SSHPacket) -> None:
         """Abstract method for processing SFTP packets"""
 
         raise NotImplementedError
 
-    def send_packet(self, pkttype, pktid, *args):
+    def send_packet(self, pkttype: int, pktid: Optional[int],
+                    *args: bytes) -> None:
         """Send an SFTP packet"""
 
+        if not self._writer:
+            raise SFTPNoConnection('Connection not open')
+
         payload = Byte(pkttype) + b''.join(args)
 
         try:
             self._writer.write(UInt32(len(payload)) + payload)
         except ConnectionError as exc:
             raise SFTPConnectionLost(str(exc)) from None
 
         self.log_sent_packet(pkttype, pktid, payload)
 
-    async def recv_packet(self):
+    async def recv_packet(self) -> SSHPacket:
         """Receive an SFTP packet"""
 
+        assert self._reader is not None
+
         pktlen = await self._reader.readexactly(4)
         pktlen = int.from_bytes(pktlen, 'big')
 
         packet = await self._reader.readexactly(pktlen)
         return SSHPacket(packet)
 
-    async def recv_packets(self):
+    async def recv_packets(self) -> None:
         """Receive and process SFTP packets"""
 
         try:
             while self._reader: # pragma: no branch
                 packet = await self.recv_packet()
 
                 pkttype = packet.get_byte()
@@ -1112,79 +2284,85 @@
         except (OSError, Error) as exc:
             await self._cleanup(exc)
 
 
 class SFTPClientHandler(SFTPHandler):
     """An SFTP client session handler"""
 
-    _extensions = []
-
-    def __init__(self, loop, reader, writer):
+    def __init__(self, loop: asyncio.AbstractEventLoop,
+                 reader: 'SSHReader[bytes]', writer: 'SSHWriter[bytes]',
+                 sftp_version: int):
         super().__init__(reader, writer)
 
         self._loop = loop
-        self._version = None
+        self._version = sftp_version
         self._next_pktid = 0
-        self._requests = {}
+        self._requests: Dict[int, _RequestWaiter] = {}
         self._nonstandard_symlink = False
         self._supports_posix_rename = False
         self._supports_statvfs = False
         self._supports_fstatvfs = False
         self._supports_hardlink = False
         self._supports_fsync = False
 
-    async def _cleanup(self, exc):
+    @property
+    def version(self) -> int:
+        """SFTP version associated with this SFTP session"""
+
+        return self._version
+
+    async def _cleanup(self, exc: Optional[Exception]) -> None:
         """Clean up this SFTP client session"""
 
         req_exc = exc or SFTPConnectionLost('Connection closed')
 
         for waiter in list(self._requests.values()):
             if not waiter.cancelled(): # pragma: no branch
                 waiter.set_exception(req_exc)
 
         self._requests = {}
 
         self.logger.info('SFTP client exited%s', ': ' + str(exc) if exc else '')
 
         await super()._cleanup(exc)
 
-    async def _process_packet(self, pkttype, pktid, packet):
+    async def _process_packet(self, pkttype: int, pktid: int,
+                              packet: SSHPacket) -> None:
         """Process incoming SFTP responses"""
 
         try:
             waiter = self._requests.pop(pktid)
         except KeyError:
             await self._cleanup(SFTPBadMessage('Invalid response id'))
         else:
             if not waiter.cancelled(): # pragma: no branch
                 waiter.set_result((pkttype, packet))
 
-    def _send_request(self, pkttype, args, waiter):
+    def _send_request(self, pkttype: Union[int, bytes], args: Sequence[bytes],
+                      waiter: _RequestWaiter) -> None:
         """Send an SFTP request"""
 
-        if not self._writer:
-            raise SFTPNoConnection('Connection not open')
-
         pktid = self._next_pktid
         self._next_pktid = (self._next_pktid + 1) & 0xffffffff
 
         self._requests[pktid] = waiter
 
         if isinstance(pkttype, bytes):
             hdr = UInt32(pktid) + String(pkttype)
             pkttype = FXP_EXTENDED
         else:
             hdr = UInt32(pktid)
 
         self.send_packet(pkttype, pktid, hdr, *args)
 
-    async def _make_request(self, pkttype, *args):
+    async def _make_request(self, pkttype: Union[int, bytes],
+                            *args: bytes) -> object:
         """Make an SFTP request and wait for a response"""
 
-        waiter = self._loop.create_future()
+        waiter: _RequestWaiter = self._loop.create_future()
         self._send_request(pkttype, args, waiter)
         resptype, resp = await waiter
 
         return_type = self._return_types.get(pkttype)
 
         if resptype not in (FXP_STATUS, return_type):
             raise SFTPBadMessage('Unexpected response type: %s' % resptype)
@@ -1192,86 +2370,86 @@
         result = self._packet_handlers[resptype](self, resp)
 
         if result is not None or return_type is None:
             return result
         else:
             raise SFTPBadMessage('Unexpected FX_OK response')
 
-    def _process_status(self, packet):
+    def _process_status(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP status response"""
 
-        code = packet.get_uint32()
-
-        if packet:
-            try:
-                reason = packet.get_string().decode('utf-8')
-                lang = packet.get_string().decode('ascii')
-            except UnicodeDecodeError:
-                raise SFTPBadMessage('Invalid status message') from None
-        else:
-            # Some servers may not always send reason and lang (usually
-            # when responding with FX_OK). Tolerate this, automatically
-            # filling in empty strings for them if they're not present.
-
-            reason = ''
-            lang = ''
+        exc = SFTPError.construct(packet)
 
-        packet.check_end()
+        if self._version < 6:
+            packet.check_end()
 
-        if code == FX_OK:
-            self.logger.debug1('Received OK')
-            return None
+        if exc:
+            raise exc
         else:
-            raise _construct_sftp_error(code, reason, lang)
+            self.logger.debug1('Received OK')
 
-    def _process_handle(self, packet):
+    def _process_handle(self, packet: SSHPacket) -> bytes:
         """Process an incoming SFTP handle response"""
 
         handle = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received handle %s', to_hex(handle))
+        if self._version < 6:
+            packet.check_end()
+
+        self.logger.debug1('Received handle %s', handle.hex())
 
         return handle
 
-    def _process_data(self, packet):
+    def _process_data(self, packet: SSHPacket) -> Tuple[bytes, bool]:
         """Process an incoming SFTP data response"""
 
         data = packet.get_string()
-        packet.check_end()
+        at_end = packet.get_boolean() if packet and self._version >= 6 \
+            else False
 
-        self.logger.debug1('Received %s', plural(len(data), 'data byte'))
+        if self._version < 6:
+            packet.check_end()
 
-        return data
+        self.logger.debug1('Received %s%s', plural(len(data), 'data byte'),
+                           ' (at end)' if at_end else '')
+
+        return data, at_end
 
-    def _process_name(self, packet):
+    def _process_name(self, packet: SSHPacket) -> _SFTPNames:
         """Process an incoming SFTP name response"""
 
         count = packet.get_uint32()
-        names = [SFTPName.decode(packet) for i in range(count)]
-        packet.check_end()
+        names = [SFTPName.decode(packet, self._version) for _ in range(count)]
+        at_end = packet.get_boolean() if packet and self._version >= 6 \
+            else False
+
+        if self._version < 6:
+            packet.check_end()
 
-        self.logger.debug1('Received %s', plural(len(names), 'name'))
+        self.logger.debug1('Received %s%s', plural(len(names), 'name'),
+                           ' (at end)' if at_end else '')
 
         for name in names:
             self.logger.debug1('  %s', name)
 
-        return names
+        return names, at_end
 
-    def _process_attrs(self, packet):
+    def _process_attrs(self, packet: SSHPacket) -> SFTPAttrs:
         """Process an incoming SFTP attributes response"""
 
-        attrs = SFTPAttrs().decode(packet)
-        packet.check_end()
+        attrs = SFTPAttrs().decode(packet, self._version)
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received %s', attrs)
 
         return attrs
 
-    def _process_extended_reply(self, packet):
+    def _process_extended_reply(self, packet: SSHPacket) -> SSHPacket:
         """Process an incoming SFTP extended reply response"""
 
         # pylint: disable=no-self-use
 
         # Let the caller do the decoding for extended replies
         return packet
 
@@ -1280,303 +2458,439 @@
         FXP_HANDLE:         _process_handle,
         FXP_DATA:           _process_data,
         FXP_NAME:           _process_name,
         FXP_ATTRS:          _process_attrs,
         FXP_EXTENDED_REPLY: _process_extended_reply
     }
 
-    async def start(self):
+    async def start(self) -> None:
         """Start an SFTP client"""
 
-        self.logger.debug1('Sending init, version=%d%s', _SFTP_VERSION,
-                           ', extensions:' if self._extensions else '')
-
-        for name, data in self._extensions: # pragma: no cover
-            self.logger.debug1('  %s: %s', name, data)
+        assert self._reader is not None
 
-        extensions = (String(name) + String(data)
-                      for name, data in self._extensions)
+        self.logger.debug1('Sending init, version=%d', self._version)
 
-        self.send_packet(FXP_INIT, None, UInt32(_SFTP_VERSION), *extensions)
+        self.send_packet(FXP_INIT, None, UInt32(self._version))
 
         try:
             resp = await self.recv_packet()
 
             resptype = resp.get_byte()
 
             self.log_received_packet(resptype, None, resp)
 
             if resptype != FXP_VERSION:
                 raise SFTPBadMessage('Expected version message')
 
             version = resp.get_uint32()
 
-            if version != _SFTP_VERSION:
+            if not MIN_SFTP_VERSION <= version <= MAX_SFTP_VERSION:
                 raise SFTPBadMessage('Unsupported version: %d' % version)
 
-            self._version = version
-
-            extensions = []
+            rcvd_extensions: List[Tuple[bytes, bytes]] = []
 
             while resp:
                 name = resp.get_string()
                 data = resp.get_string()
-                extensions.append((name, data))
+                rcvd_extensions.append((name, data))
         except PacketDecodeError as exc:
             raise SFTPBadMessage(str(exc)) from None
+        except SFTPError as exc:
+            raise
+        except ConnectionLost as exc:
+            raise SFTPConnectionLost(str(exc)) from None
         except (asyncio.IncompleteReadError, Error) as exc:
-            raise SFTPFailure(str(exc)) from None
+            raise SFTPConnectionLost(str(exc)) from None
 
         self.logger.debug1('Received version=%d%s', version,
-                           ', extensions:' if extensions else '')
+                           ', extensions:' if rcvd_extensions else '')
 
-        for name, data in extensions:
-            self.logger.debug1('  %s: %s', name, data)
+        self._log_extensions(rcvd_extensions)
 
+        self._version = version
+
+        for name, data in rcvd_extensions:
             if name == b'posix-rename@openssh.com' and data == b'1':
                 self._supports_posix_rename = True
             elif name == b'statvfs@openssh.com' and data == b'2':
                 self._supports_statvfs = True
             elif name == b'fstatvfs@openssh.com' and data == b'2':
                 self._supports_fstatvfs = True
             elif name == b'hardlink@openssh.com' and data == b'1':
                 self._supports_hardlink = True
             elif name == b'fsync@openssh.com' and data == b'1':
                 self._supports_fsync = True
 
         if version == 3:
             # Check if the server has a buggy SYMLINK implementation
 
-            server_version = self._reader.get_extra_info('server_version', '')
+            server_version = cast(str,
+                self._reader.get_extra_info('server_version', ''))
+
             if any(name in server_version
                    for name in self._nonstandard_symlink_impls):
                 self.logger.debug1('Adjusting for non-standard symlink '
                                    'implementation')
                 self._nonstandard_symlink = True
 
-    async def open(self, filename, pflags, attrs):
+    async def open(self, filename: bytes, pflags: int,
+                   attrs: SFTPAttrs) -> bytes:
         """Make an SFTP open request"""
 
-        self.logger.debug1('Sending open for %s, mode 0x%02x%s',
-                           filename, pflags, hide_empty(attrs))
+        if self._version >= 5:
+            desired_access, flags = _pflags_to_flags(pflags)
 
-        return await self._make_request(FXP_OPEN, String(filename),
-                                        UInt32(pflags), attrs.encode())
+            self.logger.debug1('Sending open for %s, desired_access=0x%08x, '
+                               'flags=0x%08x%s', filename, desired_access,
+                               flags, hide_empty(attrs))
+
+            return cast(bytes, await self._make_request(
+                FXP_OPEN, String(filename), UInt32(desired_access),
+                UInt32(flags), attrs.encode(self._version)))
+        else:
+            self.logger.debug1('Sending open for %s, mode 0x%02x%s',
+                               filename, pflags, hide_empty(attrs))
+
+            return cast(bytes, await self._make_request(
+                FXP_OPEN, String(filename), UInt32(pflags),
+                attrs.encode(self._version)))
+
+    async def open56(self, filename: bytes, desired_access: int,
+                     flags: int, attrs: SFTPAttrs) -> bytes:
+        """Make an SFTPv5/v6 open request"""
+
+        self.logger.debug1('Sending open for %s, desired_access=0x%08x, '
+                           'flags=0x%08x%s', filename, desired_access,
+                           flags, hide_empty(attrs))
+
+        if self._version >= 5:
+            return cast(bytes, await self._make_request(
+                FXP_OPEN, String(filename), UInt32(desired_access),
+                UInt32(flags), attrs.encode(self._version)))
+        else:
+            raise SFTPOpUnsupported('SFTPv5/v6 open not supported by server')
 
-    async def close(self, handle):
+    async def close(self, handle: bytes) -> None:
         """Make an SFTP close request"""
 
-        self.logger.debug1('Sending close for handle %s', to_hex(handle))
+        self.logger.debug1('Sending close for handle %s', handle.hex())
 
         if self._writer:
             await self._make_request(FXP_CLOSE, String(handle))
 
-    async def read(self, handle, offset, length):
+    async def read(self, handle: bytes, offset: int,
+                   length: int) -> Tuple[bytes, bool]:
         """Make an SFTP read request"""
 
         self.logger.debug1('Sending read for %s at offset %d in handle %s',
-                           plural(length, 'byte'), offset, to_hex(handle))
+                           plural(length, 'byte'), offset, handle.hex())
 
-        return await self._make_request(FXP_READ, String(handle),
-                                        UInt64(offset), UInt32(length))
+        return cast(Tuple[bytes, bool], await self._make_request(
+            FXP_READ, String(handle), UInt64(offset), UInt32(length)))
 
-    async def write(self, handle, offset, data):
+    async def write(self, handle: bytes, offset: int, data: bytes) -> int:
         """Make an SFTP write request"""
 
         self.logger.debug1('Sending write for %s at offset %d in handle %s',
-                           plural(len(data), 'byte'), offset, to_hex(handle))
+                           plural(len(data), 'byte'), offset, handle.hex())
 
-        return await self._make_request(FXP_WRITE, String(handle),
-                                        UInt64(offset), String(data))
+        return cast(int, await self._make_request(
+            FXP_WRITE, String(handle), UInt64(offset), String(data)))
 
-    async def stat(self, path):
+    async def stat(self, path: bytes, flags: int) -> SFTPAttrs:
         """Make an SFTP stat request"""
 
-        self.logger.debug1('Sending stat for %s', path)
+        if self._version >= 4:
+            flag_bytes = UInt32(flags)
+            flag_text = ', flags 0x%08x' % flags
+        else:
+            flag_bytes = b''
+            flag_text = ''
+
+        self.logger.debug1('Sending stat for %s%s', path, flag_text)
 
-        return await self._make_request(FXP_STAT, String(path))
+        return cast(SFTPAttrs,  await self._make_request(
+            FXP_STAT, String(path), flag_bytes))
 
-    async def lstat(self, path):
+    async def lstat(self, path: bytes, flags: int) -> SFTPAttrs:
         """Make an SFTP lstat request"""
 
-        self.logger.debug1('Sending lstat for %s', path)
+        if self._version >= 4:
+            flag_bytes = UInt32(flags)
+            flag_text = ', flags 0x%08x' % flags
+        else:
+            flag_bytes = b''
+            flag_text = ''
+
+        self.logger.debug1('Sending lstat for %s%s', path, flag_text)
 
-        return await self._make_request(FXP_LSTAT, String(path))
+        return cast(SFTPAttrs, await self._make_request(
+            FXP_LSTAT, String(path), flag_bytes))
 
-    async def fstat(self, handle):
+    async def fstat(self, handle: bytes, flags: int) -> SFTPAttrs:
         """Make an SFTP fstat request"""
 
-        self.logger.debug1('Sending fstat for handle %s', to_hex(handle))
+        if self._version >= 4:
+            flag_bytes = UInt32(flags)
+            flag_text = ', flags 0x%08x' % flags
+        else:
+            flag_bytes = b''
+            flag_text = ''
 
-        return await self._make_request(FXP_FSTAT, String(handle))
+        self.logger.debug1('Sending fstat for handle %s%s',
+                           handle.hex(), flag_text)
 
-    async def setstat(self, path, attrs):
+        return cast(SFTPAttrs, await self._make_request(
+            FXP_FSTAT, String(handle), flag_bytes))
+
+    async def setstat(self, path: bytes, attrs: SFTPAttrs) -> None:
         """Make an SFTP setstat request"""
 
         self.logger.debug1('Sending setstat for %s%s', path, hide_empty(attrs))
 
-        return await self._make_request(FXP_SETSTAT, String(path),
-                                        attrs.encode())
+        await self._make_request(FXP_SETSTAT, String(path),
+                                 attrs.encode(self._version))
 
-    async def fsetstat(self, handle, attrs):
+    async def fsetstat(self, handle: bytes, attrs: SFTPAttrs) -> None:
         """Make an SFTP fsetstat request"""
 
         self.logger.debug1('Sending fsetstat for handle %s%s',
-                           to_hex(handle), hide_empty(attrs))
+                           handle.hex(), hide_empty(attrs))
 
-        return await self._make_request(FXP_FSETSTAT, String(handle),
-                                        attrs.encode())
+        await self._make_request(FXP_FSETSTAT, String(handle),
+                                 attrs.encode(self._version))
 
-    async def statvfs(self, path):
+    async def statvfs(self, path: bytes) -> SFTPVFSAttrs:
         """Make an SFTP statvfs request"""
 
         if self._supports_statvfs:
             self.logger.debug1('Sending statvfs for %s', path)
 
-            packet = await self._make_request(b'statvfs@openssh.com',
-                                              String(path))
-            vfsattrs = SFTPVFSAttrs.decode(packet)
+            packet = cast(SSHPacket, await self._make_request(
+                b'statvfs@openssh.com', String(path)))
+
+            vfsattrs = SFTPVFSAttrs.decode(packet, self._version)
             packet.check_end()
 
             self.logger.debug1('Received %s', vfsattrs)
 
             return vfsattrs
         else:
             raise SFTPOpUnsupported('statvfs not supported')
 
-    async def fstatvfs(self, handle):
+    async def fstatvfs(self, handle: bytes) -> SFTPVFSAttrs:
         """Make an SFTP fstatvfs request"""
 
         if self._supports_fstatvfs:
-            self.logger.debug1('Sending fstatvfs for handle %s', to_hex(handle))
+            self.logger.debug1('Sending fstatvfs for handle %s', handle.hex())
 
-            packet = await self._make_request(b'fstatvfs@openssh.com',
-                                              String(handle))
-            vfsattrs = SFTPVFSAttrs.decode(packet)
+            packet = cast(SSHPacket, await self._make_request(
+                b'fstatvfs@openssh.com', String(handle)))
+
+            vfsattrs = SFTPVFSAttrs.decode(packet, self._version)
             packet.check_end()
 
             self.logger.debug1('Received %s', vfsattrs)
 
             return vfsattrs
         else:
             raise SFTPOpUnsupported('fstatvfs not supported')
 
-    async def remove(self, path):
+    async def remove(self, path: bytes) -> None:
         """Make an SFTP remove request"""
 
         self.logger.debug1('Sending remove for %s', path)
 
-        return await self._make_request(FXP_REMOVE, String(path))
+        await self._make_request(FXP_REMOVE, String(path))
 
-    async def rename(self, oldpath, newpath):
+    async def rename(self, oldpath: bytes, newpath: bytes, flags: int) -> None:
         """Make an SFTP rename request"""
 
-        self.logger.debug1('Sending rename request from %s to %s',
-                           oldpath, newpath)
+        if self._version >= 5:
+            self.logger.debug1('Sending rename request from %s to %s%s',
+                               oldpath, newpath, ', flags=0x%x' % flags
+                               if flags else '')
+
+            await self._make_request(FXP_RENAME, String(oldpath),
+                                     String(newpath), UInt32(flags))
+        elif flags and self._supports_posix_rename:
+            self.logger.debug1('Sending OpenSSH POSIX rename request '
+                               'from %s to %s', oldpath, newpath)
+
+            await self._make_request(b'posix-rename@openssh.com',
+                                     String(oldpath), String(newpath))
+        elif not flags:
+            self.logger.debug1('Sending rename request from %s to %s',
+                               oldpath, newpath)
 
-        return await self._make_request(FXP_RENAME, String(oldpath),
-                                        String(newpath))
+            await self._make_request(FXP_RENAME, String(oldpath),
+                                     String(newpath))
+        else:
+            raise SFTPOpUnsupported('Rename with overwrite not supported')
 
-    async def posix_rename(self, oldpath, newpath):
+    async def posix_rename(self, oldpath: bytes, newpath: bytes) -> None:
         """Make an SFTP POSIX rename request"""
 
         if self._supports_posix_rename:
-            self.logger.debug1('Sending POSIX rename request from %s to %s',
-                               oldpath, newpath)
+            self.logger.debug1('Sending OpenSSH POSIX rename request '
+                               'from %s to %s', oldpath, newpath)
+
+            await self._make_request(b'posix-rename@openssh.com',
+                                     String(oldpath), String(newpath))
+        elif self._version >= 5:
+            self.logger.debug1('Sending rename request from %s to %s '
+                               'with overwrite', oldpath, newpath)
 
-            return await self._make_request(b'posix-rename@openssh.com',
-                                            String(oldpath), String(newpath))
+            await self._make_request(FXP_RENAME, String(oldpath),
+                                     String(newpath), UInt32(FXR_OVERWRITE))
         else:
             raise SFTPOpUnsupported('POSIX rename not supported')
 
-    async def opendir(self, path):
+    async def opendir(self, path: bytes) -> bytes:
         """Make an SFTP opendir request"""
 
         self.logger.debug1('Sending opendir for %s', path)
 
-        return await self._make_request(FXP_OPENDIR, String(path))
+        return cast(bytes, await self._make_request(
+            FXP_OPENDIR, String(path)))
 
-    async def readdir(self, handle):
+    async def readdir(self, handle: bytes) -> _SFTPNames:
         """Make an SFTP readdir request"""
 
-        self.logger.debug1('Sending readdir for handle %s', to_hex(handle))
+        self.logger.debug1('Sending readdir for handle %s', handle.hex())
 
-        return await self._make_request(FXP_READDIR, String(handle))
+        return  cast(_SFTPNames, await self._make_request(
+            FXP_READDIR, String(handle)))
 
-    async def mkdir(self, path, attrs):
+    async def mkdir(self, path: bytes, attrs: SFTPAttrs) -> None:
         """Make an SFTP mkdir request"""
 
         self.logger.debug1('Sending mkdir for %s', path)
 
-        return await self._make_request(FXP_MKDIR, String(path), attrs.encode())
+        await self._make_request(FXP_MKDIR, String(path),
+                                 attrs.encode(self._version))
 
-    async def rmdir(self, path):
+    async def rmdir(self, path: bytes) -> None:
         """Make an SFTP rmdir request"""
 
         self.logger.debug1('Sending rmdir for %s', path)
 
-        return await self._make_request(FXP_RMDIR, String(path))
+        await self._make_request(FXP_RMDIR, String(path))
 
-    async def realpath(self, path):
+    async def realpath(self, path: bytes, *compose_paths: bytes,
+                       check: int = FXRP_NO_CHECK) -> _SFTPNames:
         """Make an SFTP realpath request"""
 
-        self.logger.debug1('Sending realpath for %s', path)
-
-        return await self._make_request(FXP_REALPATH, String(path))
+        if check == FXRP_NO_CHECK:
+            checkmsg = ''
+        else:
+            try:
+                checkmsg = ', check=%s' % self._realpath_check_names[check]
+            except KeyError:
+                checkmsg = ', check=%d' % check
+
+        self.logger.debug1('Sending realpath of %s%s%s', path,
+                           b', compose_path: %s' % b', '.join(compose_paths)
+                           if compose_paths else b'', checkmsg)
+
+        if self._version >= 6:
+            return cast(_SFTPNames, await self._make_request(
+                FXP_REALPATH, String(path), Byte(check),
+                *map(String, compose_paths)))
+        else:
+            return cast(_SFTPNames, await self._make_request(
+                FXP_REALPATH, String(path)))
 
-    async def readlink(self, path):
+    async def readlink(self, path: bytes) -> _SFTPNames:
         """Make an SFTP readlink request"""
 
         self.logger.debug1('Sending readlink for %s', path)
 
-        return await self._make_request(FXP_READLINK, String(path))
+        return cast(_SFTPNames, await self._make_request(
+            FXP_READLINK, String(path)))
 
-    async def symlink(self, oldpath, newpath):
+    async def symlink(self, oldpath: bytes, newpath: bytes) -> None:
         """Make an SFTP symlink request"""
 
         self.logger.debug1('Sending symlink request from %s to %s',
                            oldpath, newpath)
 
-        if self._nonstandard_symlink:
-            args = String(oldpath) + String(newpath)
+        if self._version >= 6:
+            await self._make_request(FXP_LINK, String(newpath),
+                                     String(oldpath), Boolean(True))
         else:
-            args = String(newpath) + String(oldpath)
+            if self._nonstandard_symlink:
+                args = String(oldpath) + String(newpath)
+            else:
+                args = String(newpath) + String(oldpath)
 
-        return await self._make_request(FXP_SYMLINK, args)
+            await self._make_request(FXP_SYMLINK, args)
 
-    async def link(self, oldpath, newpath):
-        """Make an SFTP link request"""
+    async def link(self, oldpath: bytes, newpath: bytes) -> None:
+        """Make an SFTP hard link request"""
 
-        if self._supports_hardlink:
+        if self._version >= 6 or self._supports_hardlink:
             self.logger.debug1('Sending hardlink request from %s to %s',
                                oldpath, newpath)
 
-            return await self._make_request(b'hardlink@openssh.com',
-                                            String(oldpath), String(newpath))
+            if self._version >= 6:
+                await self._make_request(FXP_LINK, String(newpath),
+                                         String(oldpath), Boolean(False))
+            else:
+                await self._make_request(b'hardlink@openssh.com',
+                                         String(oldpath), String(newpath))
         else:
             raise SFTPOpUnsupported('link not supported')
 
-    async def fsync(self, handle):
+    async def lock(self, handle: bytes, offset: int, length: int,
+                   flags: int) -> None:
+        """Make an SFTP byte range lock request"""
+
+        if self._version >= 6:
+            self.logger.debug1('Sending byte range lock request for '
+                               'handle %s, offset %d, length %d, '
+                               'flags 0x%04x', handle.hex(), offset,
+                               length, flags)
+
+            await self._make_request(FXP_BLOCK, String(handle),
+                                     UInt64(offset), UInt64(length),
+                                     UInt32(flags))
+        else:
+            raise SFTPOpUnsupported('Byte range locks not supported')
+
+    async def unlock(self, handle: bytes, offset: int, length: int) -> None:
+        """Make an SFTP byte range unlock request"""
+
+        if self._version >= 6:
+            self.logger.debug1('Sending byte range unlock request for '
+                               'handle %s, offset %d, length %d',
+                               handle.hex(), offset, length)
+
+            await self._make_request(FXP_UNBLOCK, String(handle),
+                                     UInt64(offset), UInt64(length))
+        else:
+            raise SFTPOpUnsupported('Byte range locks not supported')
+
+    async def fsync(self, handle: bytes) -> None:
         """Make an SFTP fsync request"""
 
         if self._supports_fsync:
-            self.logger.debug1('Sending fsync for handle %s', to_hex(handle))
+            self.logger.debug1('Sending fsync for handle %s', handle.hex())
 
-            return await self._make_request(b'fsync@openssh.com',
-                                            String(handle))
+            await self._make_request(b'fsync@openssh.com', String(handle))
         else:
             raise SFTPOpUnsupported('fsync not supported')
 
-    def exit(self):
+    def exit(self) -> None:
         """Handle a request to close the SFTP session"""
 
         if self._writer:
             self._writer.write_eof()
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this SFTP session to close"""
 
         if self._writer:
             await self._writer.channel.wait_closed()
 
 
 class SFTPClientFile:
@@ -1585,42 +2899,47 @@
        This class represents an open file on a remote SFTP server. It
        is opened with the :meth:`open() <SFTPClient.open>` method on the
        :class:`SFTPClient` class and provides methods to read and write
        data and get and set attributes on the open file.
 
     """
 
-    def __init__(self, handler, handle, appending, encoding, errors,
-                 block_size, max_requests):
+    def __init__(self, handler: SFTPClientHandler, handle: bytes,
+                 appending: bool, encoding: Optional[str], errors: str,
+                 block_size: int, max_requests: int):
         self._handler = handler
-        self._handle = handle
+        self._handle: Optional[bytes] = handle
         self._appending = appending
         self._encoding = encoding
         self._errors = errors
         self._block_size = block_size
         self._max_requests = max_requests
         self._offset = None if appending else 0
 
-    async def __aenter__(self):
+    async def __aenter__(self) -> 'SFTPClientFile':
         """Allow SFTPClientFile to be used as an async context manager"""
 
         return self
 
-    async def __aexit__(self, *exc_info):
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
         """Wait for file close when used as an async context manager"""
 
         await self.close()
+        return False
 
-    async def _end(self):
+    async def _end(self) -> int:
         """Return the offset of the end of the file"""
 
         attrs = await self.stat()
-        return attrs.size
+        return attrs.size or 0
 
-    async def read(self, size=-1, offset=None):
+    async def read(self, size: int = -1,
+                   offset: Optional[int] = None) -> AnyStr:
         """Read data from the remote file
 
            This method reads and returns up to `size` bytes of data
            from the remote file. If size is negative, all data up to
            the end of the file is returned.
 
            If offset is specified, the read will be performed starting
@@ -1668,25 +2987,27 @@
 
             try:
                 if self._block_size and size > self._block_size:
                     data = await _SFTPFileReader(
                         self._block_size, self._max_requests, self._handler,
                         self._handle, offset, size).run()
                 else:
-                    data = await self._handler.read(self._handle, offset, size)
+                    data, _ = await self._handler.read(self._handle,
+                                                       offset, size)
+
                 self._offset = offset + len(data)
             except SFTPEOFError:
                 pass
 
         if self._encoding:
-            data = data.decode(self._encoding, self._errors)
-
-        return data
+            return cast(AnyStr, data.decode(self._encoding, self._errors))
+        else:
+            return cast(AnyStr, data)
 
-    async def write(self, data, offset=None):
+    async def write(self, data: AnyStr, offset: Optional[int] = None) -> int:
         """Write data to the remote file
 
            This method writes the specified data at the current
            position in the remote file.
 
            :param data:
                The data to write to the file
@@ -1715,29 +3036,31 @@
 
         if offset is None:
             # Offset is ignored when appending, so fill in an offset of 0
             # if we don't have a current file position
             offset = self._offset or 0
 
         if self._encoding:
-            data = data.encode(self._encoding, self._errors)
+            data_bytes = cast(str, data).encode(self._encoding, self._errors)
+        else:
+            data_bytes = cast(bytes, data)
 
-        datalen = len(data)
+        datalen = len(data_bytes)
 
         if self._block_size and datalen > self._block_size:
             await _SFTPFileWriter(
                 self._block_size, self._max_requests, self._handler,
-                self._handle, offset, data).run()
+                self._handle, offset, data_bytes).run()
         else:
-            await self._handler.write(self._handle, offset, data)
+            await self._handler.write(self._handle, offset, data_bytes)
 
         self._offset = None if self._appending else offset + datalen
         return datalen
 
-    async def seek(self, offset, from_what=SEEK_SET):
+    async def seek(self, offset: int, from_what: int = SEEK_SET) -> int:
         """Seek to a new position in the remote file
 
            This method changes the position in the remote file. The
            `offset` passed in is treated as relative to the beginning
            of the file if `from_what` is set to `SEEK_SET` (the
            default), relative to the current file position if it is
            set to `SEEK_CUR`, or relative to the end of the file
@@ -1756,23 +3079,26 @@
 
         if self._handle is None:
             raise ValueError('I/O operation on closed file')
 
         if from_what == SEEK_SET:
             self._offset = offset
         elif from_what == SEEK_CUR:
-            self._offset += offset
+            if self._offset is None:
+                self._offset = (await self._end()) + offset
+            else:
+                self._offset += offset
         elif from_what == SEEK_END:
             self._offset = (await self._end()) + offset
         else:
             raise ValueError('Invalid reference point')
 
         return self._offset
 
-    async def tell(self):
+    async def tell(self) -> int:
         """Return the current position in the remote file
 
            This method returns the current position in the remote file.
 
            :returns: The current byte offset from the beginning of the file
 
         """
@@ -1781,31 +3107,35 @@
             raise ValueError('I/O operation on closed file')
 
         if self._offset is None:
             self._offset = await self._end()
 
         return self._offset
 
-    async def stat(self):
+    async def stat(self, flags = FILEXFER_ATTR_DEFINED_V4) -> SFTPAttrs:
         """Return file attributes of the remote file
 
            This method queries file attributes of the currently open file.
 
+           :param flags: (optional)
+               Flags indicating attributes of interest (SFTPv4 or later)
+           :type flags: `int`
+
            :returns: An :class:`SFTPAttrs` containing the file attributes
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         if self._handle is None:
             raise ValueError('I/O operation on closed file')
 
-        return await self._handler.fstat(self._handle)
+        return await self._handler.fstat(self._handle, flags)
 
-    async def setstat(self, attrs):
+    async def setstat(self, attrs: SFTPAttrs) -> None:
         """Set attributes of the remote file
 
            This method sets file attributes of the currently open file.
 
            :param attrs:
                File attributes to set on the file
            :type attrs: :class:`SFTPAttrs`
@@ -1815,15 +3145,15 @@
         """
 
         if self._handle is None:
             raise ValueError('I/O operation on closed file')
 
         await self._handler.fsetstat(self._handle, attrs)
 
-    async def statvfs(self):
+    async def statvfs(self) -> SFTPVFSAttrs:
         """Return file system attributes of the remote file
 
            This method queries attributes of the file system containing
            the currently open file.
 
            :returns: An :class:`SFTPVFSAttrs` containing the file system
                      attributes
@@ -1834,15 +3164,15 @@
         """
 
         if self._handle is None:
             raise ValueError('I/O operation on closed file')
 
         return await self._handler.fstatvfs(self._handle)
 
-    async def truncate(self, size=None):
+    async def truncate(self, size: Optional[int] = None) -> None:
         """Truncate the remote file to the specified size
 
            This method changes the remote file's size to the specified
            value. If a size is not provided, the current file position
            is used.
 
            :param size: (optional)
@@ -1854,34 +3184,58 @@
         """
 
         if size is None:
             size = self._offset
 
         await self.setstat(SFTPAttrs(size=size))
 
-    async def chown(self, uid, gid):
-        """Change the owner user and group id of the remote file
+    @overload
+    async def chown(self, uid: int, gid: int) -> None: ... # pragma: no cover
+
+    @overload
+    async def chown(self, owner: str,
+                    group: str) -> None: ... # pragma: no cover
+
+    async def chown(self, uid_or_owner = None, gid_or_group = None,
+                    uid = None, gid = None, owner = None, group = None):
+        """Change the owner user and group of the remote file
 
-           This method changes the user and group id of the
-           currently open file.
+           This method changes the user and group of the currently open file.
 
            :param uid:
                The new user id to assign to the file
            :param gid:
                The new group id to assign to the file
+           :param owner:
+               The new owner to assign to the file (SFTPv4 only)
+           :param group:
+               The new group to assign to the file (SFTPv4 only)
            :type uid: `int`
            :type gid: `int`
+           :type owner: `str`
+           :type group: `str`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        await self.setstat(SFTPAttrs(uid=uid, gid=gid))
+        if isinstance(uid_or_owner, int):
+            uid = uid_or_owner
+        elif isinstance(uid_or_owner, str):
+            owner = uid_or_owner
+
+        if isinstance(gid_or_group, int):
+            gid = gid_or_group
+        elif isinstance(gid_or_group, str):
+            group = gid_or_group
 
-    async def chmod(self, mode):
+        await self.setstat(SFTPAttrs(uid=uid, gid=gid,
+                                     owner=owner, group=group))
+
+    async def chmod(self, mode: int) -> None:
         """Change the file permissions of the remote file
 
            This method changes the permissions of the currently
            open file.
 
            :param mode:
                The new file permissions, expressed as an int
@@ -1889,46 +3243,62 @@
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         await self.setstat(SFTPAttrs(permissions=mode))
 
-    async def utime(self, times=None):
+    async def utime(self, times: Optional[Tuple[float, float]] = None,
+                    ns: Optional[Tuple[int, int]] = None) -> None:
         """Change the access and modify times of the remote file
 
            This method changes the access and modify times of the
            currently open file. If `times` is not provided,
            the times will be changed to the current time.
 
            :param times: (optional)
                The new access and modify times, as seconds relative to
                the UNIX epoch
+           :param ns: (optional)
+               The new access and modify times, as nanoseconds relative to
+               the UNIX epoch
            :type times: tuple of two `int` or `float` values
+           :type ns: tuple of two `int` values
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        if times is None:
-            atime = mtime = time.time()
-        else:
-            atime, mtime = times
+        await self.setstat(_utime_to_attrs(times, ns))
+
+    async def lock(self, offset: int, length: int, flags: int) -> None:
+        """Acquire a byte range lock on the remote file"""
+
+        if self._handle is None:
+            raise ValueError('I/O operation on closed file')
+
+        await self._handler.lock(self._handle, offset, length, flags)
 
-        await self.setstat(SFTPAttrs(atime=atime, mtime=mtime))
+    async def unlock(self, offset: int, length: int) -> None:
+        """Release a byte range lock on the remote file"""
+
+        if self._handle is None:
+            raise ValueError('I/O operation on closed file')
 
-    async def fsync(self):
+        await self._handler.unlock(self._handle, offset, length)
+
+    async def fsync(self) -> None:
         """Force the remote file data to be written to disk"""
 
         if self._handle is None:
             raise ValueError('I/O operation on closed file')
 
         await self._handler.fsync(self._handle)
 
-    async def close(self):
+    async def close(self) -> None:
         """Close the remote file"""
 
         if self._handle:
             await self._handler.close(self._handle)
             self._handle = None
 
 
@@ -1938,142 +3308,138 @@
        This class represents the client side of an SFTP session. It is
        started by calling the :meth:`start_sftp_client()
        <SSHClientConnection.start_sftp_client>` method on the
        :class:`SSHClientConnection` class.
 
     """
 
-    def __init__(self, handler, path_encoding, path_errors):
+    def __init__(self, handler: SFTPClientHandler,
+                 path_encoding: Optional[str], path_errors: str):
         self._handler = handler
         self._path_encoding = path_encoding
         self._path_errors = path_errors
-        self._cwd = None
+        self._cwd: Optional[bytes] = None
 
-    async def __aenter__(self):
+    async def __aenter__(self) -> 'SFTPClient':
         """Allow SFTPClient to be used as an async context manager"""
 
         return self
 
-    async def __aexit__(self, *exc_info):
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
         """Wait for client close when used as an async context manager"""
 
         self.exit()
         await self.wait_closed()
+        return False
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this SFTP client"""
 
         return self._handler.logger
 
-    def basename(self, path):
-        """Return the final component of a POSIX-style path"""
+    @property
+    def version(self) -> int:
+        """SFTP version associated with this SFTP session"""
 
-        # pylint: disable=no-self-use
+        return self._handler.version
+
+    @staticmethod
+    def basename(path: bytes) -> bytes:
+        """Return the final component of a POSIX-style path"""
 
         return posixpath.basename(path)
 
-    def encode(self, path):
+    def encode(self, path: _SFTPPath) -> bytes:
         """Encode path name using configured path encoding
 
            This method has no effect if the path is already bytes.
 
         """
 
-        if isinstance(path, PurePath): # pragma: no branch
+        if isinstance(path, PurePath):
             path = str(path)
 
         if isinstance(path, str):
             if self._path_encoding:
                 path = path.encode(self._path_encoding, self._path_errors)
             else:
                 raise SFTPBadMessage('Path must be bytes when '
                                      'encoding is not set')
 
         return path
 
-    def decode(self, path, want_string=True):
+    def decode(self, path: bytes, want_string: bool = True) -> BytesOrStr:
         """Decode path name using configured path encoding
 
            This method has no effect if want_string is set to `False`.
 
         """
 
         if want_string and self._path_encoding:
             try:
-                path = path.decode(self._path_encoding, self._path_errors)
+                return path.decode(self._path_encoding, self._path_errors)
             except UnicodeDecodeError:
                 raise SFTPBadMessage('Unable to decode name') from None
 
         return path
 
-    def compose_path(self, path, parent=...):
+    def compose_path(self, path: _SFTPPath,
+                     parent: Optional[bytes] = None) -> bytes:
         """Compose a path
 
            If parent is not specified, return a path relative to the
            current remote working directory.
 
         """
 
-        if parent is ...:
+        if parent is None:
             parent = self._cwd
 
         path = self.encode(path)
 
         return posixpath.join(parent, path) if parent else path
 
-    async def _mode(self, path, statfunc=None):
-        """Return the mode of a remote path, or 0 if it can't be accessed"""
+    async def _type(self, path: _SFTPPath,
+                    statfunc: Optional[_SFTPStatFunc] = None) -> int:
+        """Return the file type of a remote path, or FILEXFER_TYPE_UNKNOWN
+           if it can't be accessed"""
 
         if statfunc is None:
             statfunc = self.stat
 
         try:
-            return (await statfunc(path)).permissions
-        except (SFTPNoSuchFile, SFTPPermissionDenied):
-            return 0
-
-    async def _glob(self, fs, patterns, error_handler):
-        """Begin a new glob pattern match"""
-
-        # pylint: disable=no-self-use
-
-        if isinstance(patterns, (str, bytes, PurePath)):
-            patterns = [patterns]
-
-        result = []
-
-        for pattern in patterns:
-            if not pattern:
-                continue
-
-            names = await match_glob(fs, fs.encode(pattern), error_handler)
-
-            if isinstance(pattern, (str, PurePath)):
-                names = [fs.decode(name) for name in names]
-
-            result.extend(names)
-
-        return result
-
-    async def _copy(self, srcfs, dstfs, srcpath, dstpath, preserve,
-                    recurse, follow_symlinks, block_size, max_requests,
-                    progress_handler, error_handler):
+            return (await statfunc(path)).type
+        except (SFTPNoSuchFile, SFTPNoSuchPath, SFTPPermissionDenied):
+            return FILEXFER_TYPE_UNKNOWN
+
+    async def _copy(self, srcfs: _SFTPFSProtocol, dstfs: _SFTPFSProtocol,
+                    srcpath: bytes, dstpath: bytes, preserve: bool,
+                    recurse: bool, follow_symlinks: bool, block_size: int,
+                    max_requests: int, progress_handler: SFTPProgressHandler,
+                    error_handler: SFTPErrorHandler) -> None:
         """Copy a file, directory, or symbolic link"""
 
         try:
             if follow_symlinks:
                 srcattrs = await srcfs.stat(srcpath)
             else:
                 srcattrs = await srcfs.lstat(srcpath)
 
-            if stat.S_ISDIR(srcattrs.permissions):
+            filetype = srcattrs.type
+
+            if filetype == FILEXFER_TYPE_DIRECTORY:
                 if not recurse:
-                    raise SFTPFailure('%s is a directory' %
-                                      srcpath.decode('utf-8', errors='replace'))
+                    exc = SFTPFileIsADirectory if self.version >= 6 \
+                        else SFTPFailure
+
+                    raise exc('%s is a directory' %
+                              srcpath.decode('utf-8', 'backslashreplace'))
 
                 self.logger.info('  Starting copy of directory %s to %s',
                                  srcpath, dstpath)
 
                 if not await dstfs.isdir(dstpath):
                     await dstfs.mkdir(dstpath)
 
@@ -2090,92 +3456,116 @@
                                      preserve, recurse, follow_symlinks,
                                      block_size, max_requests,
                                      progress_handler, error_handler)
 
                 self.logger.info('  Finished copy of directory %s to %s',
                                  srcpath, dstpath)
 
-            elif stat.S_ISLNK(srcattrs.permissions):
+            elif filetype == FILEXFER_TYPE_SYMLINK:
                 targetpath = await srcfs.readlink(srcpath)
 
                 self.logger.info('  Copying symlink %s to %s', srcpath, dstpath)
                 self.logger.info('    Target path: %s', targetpath)
 
                 await dstfs.symlink(targetpath, dstpath)
             else:
                 self.logger.info('  Copying file %s to %s', srcpath, dstpath)
 
                 await _SFTPFileCopier(block_size, max_requests, 0,
-                                      srcattrs.size, srcfs, dstfs, srcpath,
-                                      dstpath, progress_handler).run()
+                                      srcattrs.size or 0, srcfs, dstfs,
+                                      srcpath, dstpath, progress_handler).run()
 
             if preserve:
                 attrs = await srcfs.stat(srcpath)
 
                 attrs = SFTPAttrs(permissions=attrs.permissions,
-                                  atime=attrs.atime, mtime=attrs.mtime)
+                                  atime=attrs.atime, atime_ns=attrs.atime_ns,
+                                  mtime=attrs.mtime, mtime_ns=attrs.mtime_ns)
 
                 self.logger.info('    Preserving attrs: %s', attrs)
 
                 await dstfs.setstat(dstpath, attrs)
         except (OSError, SFTPError) as exc:
-            # pylint: disable=attribute-defined-outside-init
-            exc.srcpath = srcpath
-            exc.dstpath = dstpath
+            setattr(exc, 'srcpath', srcpath)
+            setattr(exc, 'dstpath', dstpath)
 
             if error_handler:
                 error_handler(exc)
             else:
                 raise
 
-    async def _begin_copy(self, srcfs, dstfs, srcpaths, dstpath, copy_type,
-                          expand_glob, preserve, recurse, follow_symlinks,
-                          block_size, max_requests, progress_handler,
-                          error_handler):
+    async def _begin_copy(self, srcfs: _SFTPFSProtocol, dstfs: _SFTPFSProtocol,
+                          srcpaths: Sequence[_SFTPPath],
+                          dstpath: Optional[_SFTPPath],
+                          copy_type: str, expand_glob: bool, preserve: bool,
+                          recurse: bool, follow_symlinks: bool,
+                          block_size: int, max_requests: int,
+                          progress_handler: SFTPProgressHandler,
+                          error_handler: SFTPErrorHandler) -> None:
         """Begin a new file upload, download, or copy"""
 
         if isinstance(srcpaths, tuple):
             srcpaths = list(srcpaths)
 
         self.logger.info('Starting SFTP %s of %s to %s',
                          copy_type, srcpaths, dstpath)
 
+        if isinstance(srcpaths, (bytes, str, PurePath)):
+            srcpaths = [srcpaths]
+
+        exppaths: List[bytes]
+
         if expand_glob:
-            srcpaths = await self._glob(srcfs, srcpaths, error_handler)
+            exppaths = []
 
-        dst_isdir = dstpath is None or (await dstfs.isdir(dstpath))
+            for pattern in srcpaths:
+                if not pattern:
+                    continue
+
+                exppaths.extend(await match_glob(srcfs, srcfs.encode(pattern),
+                                                 error_handler, self.version))
+        else:
+            exppaths = [srcfs.encode(srcfile) for srcfile in srcpaths]
 
         if dstpath:
             dstpath = dstfs.encode(dstpath)
 
-        if isinstance(srcpaths, (str, bytes, PurePath)):
-            srcpaths = [srcpaths]
-        elif not dst_isdir:
-            raise SFTPFailure('%s must be a directory' %
-                              dstpath.decode('utf-8', errors='replace'))
+        dstpath: Optional[bytes]
 
-        for srcfile in srcpaths:
-            srcfile = srcfs.encode(srcfile)
+        dst_isdir = dstpath is None or (await dstfs.isdir(dstpath))
+
+        if len(exppaths) > 1 and not dst_isdir:
+            assert dstpath is not None
+            exc = SFTPNotADirectory if self.version >= 6 else SFTPFailure
+
+            raise exc('%s must be a directory' %
+                       dstpath.decode('utf-8', 'backslashreplace'))
+
+        for srcfile in exppaths:
             filename = srcfs.basename(srcfile)
 
             if dstpath is None:
                 dstfile = filename
             elif dst_isdir:
                 dstfile = dstfs.compose_path(filename, parent=dstpath)
             else:
                 dstfile = dstpath
 
             await self._copy(srcfs, dstfs, srcfile, dstfile, preserve,
                              recurse, follow_symlinks, block_size,
                              max_requests, progress_handler, error_handler)
 
-    async def get(self, remotepaths, localpath=None, *, preserve=False,
-                  recurse=False, follow_symlinks=False,
-                  block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS,
-                  progress_handler=None, error_handler=None):
+    async def get(self, remotepaths: Sequence[_SFTPPath],
+                  localpath: Optional[_SFTPPath] = None, *,
+                  preserve: bool = False, recurse: bool = False,
+                  follow_symlinks: bool = False,
+                  block_size: int = SFTP_BLOCK_SIZE,
+                  max_requests: int = _MAX_SFTP_REQUESTS,
+                  progress_handler: SFTPProgressHandler = None,
+                  error_handler: SFTPErrorHandler = None) -> None:
         """Download remote files
 
            This method downloads one or more files or directories from
            the remote system. Either a single remote path or a sequence
            of remote paths to download can be provided.
 
            When downloading a single file or directory, the local path can
@@ -2260,23 +3650,27 @@
            :type error_handler: `callable`
 
            :raises: | :exc:`OSError` if a local file I/O error occurs
                     | :exc:`SFTPError` if the server returns an error
 
         """
 
-        await self._begin_copy(self, LocalFile, remotepaths, localpath, 'get',
+        await self._begin_copy(self, local_fs, remotepaths, localpath, 'get',
                                False, preserve, recurse, follow_symlinks,
                                block_size, max_requests, progress_handler,
                                error_handler)
 
-    async def put(self, localpaths, remotepath=None, *, preserve=False,
-                  recurse=False, follow_symlinks=False,
-                  block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS,
-                  progress_handler=None, error_handler=None):
+    async def put(self, localpaths: Sequence[_SFTPPath],
+                  remotepath: Optional[_SFTPPath] = None, *,
+                  preserve: bool = False, recurse: bool = False,
+                  follow_symlinks: bool = False,
+                  block_size: int = SFTP_BLOCK_SIZE,
+                  max_requests: int = _MAX_SFTP_REQUESTS,
+                  progress_handler: SFTPProgressHandler = None,
+                  error_handler: SFTPErrorHandler = None) -> None:
         """Upload local files
 
            This method uploads one or more files or directories to the
            remote system. Either a single local path or a sequence of
            local paths to upload can be provided.
 
            When uploading a single file or directory, the remote path can
@@ -2361,23 +3755,27 @@
            :type error_handler: `callable`
 
            :raises: | :exc:`OSError` if a local file I/O error occurs
                     | :exc:`SFTPError` if the server returns an error
 
         """
 
-        await self._begin_copy(LocalFile, self, localpaths, remotepath, 'put',
+        await self._begin_copy(local_fs, self, localpaths, remotepath, 'put',
                                False, preserve, recurse, follow_symlinks,
                                block_size, max_requests, progress_handler,
                                error_handler)
 
-    async def copy(self, srcpaths, dstpath=None, *, preserve=False,
-                   recurse=False, follow_symlinks=False,
-                   block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS,
-                   progress_handler=None, error_handler=None):
+    async def copy(self, srcpaths: Sequence[_SFTPPath],
+                   dstpath: Optional[_SFTPPath] = None, *,
+                   preserve: bool = False, recurse: bool = False,
+                   follow_symlinks: bool = False,
+                   block_size: int =SFTP_BLOCK_SIZE,
+                   max_requests: int = _MAX_SFTP_REQUESTS,
+                   progress_handler: SFTPProgressHandler = None,
+                   error_handler: SFTPErrorHandler = None) -> None:
         """Copy remote files to a new location
 
            This method copies one or more files or directories on the
            remote system to a new location. Either a single source path
            or a sequence of source paths to copy can be provided.
 
            When copying a single file or directory, the destination path
@@ -2467,58 +3865,70 @@
         """
 
         await self._begin_copy(self, self, srcpaths, dstpath, 'remote copy',
                                False, preserve, recurse, follow_symlinks,
                                block_size, max_requests, progress_handler,
                                error_handler)
 
-    async def mget(self, remotepaths, localpath=None, *, preserve=False,
-                   recurse=False, follow_symlinks=False,
-                   block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS,
-                   progress_handler=None, error_handler=None):
+    async def mget(self, remotepaths: Sequence[_SFTPPath],
+                   localpath: Optional[_SFTPPath] = None, *,
+                   preserve: bool = False, recurse: bool = False,
+                   follow_symlinks: bool = False,
+                   block_size: int = SFTP_BLOCK_SIZE,
+                   max_requests: int = _MAX_SFTP_REQUESTS,
+                   progress_handler: SFTPProgressHandler = None,
+                   error_handler: SFTPErrorHandler = None) -> None:
         """Download remote files with glob pattern match
 
            This method downloads files and directories from the remote
            system matching one or more glob patterns.
 
            The arguments to this method are identical to the :meth:`get`
            method, except that the remote paths specified can contain
            wildcard patterns.
 
         """
 
-        await self._begin_copy(self, LocalFile, remotepaths, localpath, 'mget',
+        await self._begin_copy(self, local_fs, remotepaths, localpath, 'mget',
                                True, preserve, recurse, follow_symlinks,
                                block_size, max_requests, progress_handler,
                                error_handler)
 
-    async def mput(self, localpaths, remotepath=None, *, preserve=False,
-                   recurse=False, follow_symlinks=False,
-                   block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS,
-                   progress_handler=None, error_handler=None):
+    async def mput(self, localpaths: Sequence[_SFTPPath],
+                   remotepath: Optional[_SFTPPath] = None, *,
+                   preserve: bool = False, recurse: bool = False,
+                   follow_symlinks: bool = False,
+                   block_size: int = SFTP_BLOCK_SIZE,
+                   max_requests: int = _MAX_SFTP_REQUESTS,
+                   progress_handler: SFTPProgressHandler = None,
+                   error_handler: SFTPErrorHandler = None) -> None:
         """Upload local files with glob pattern match
 
            This method uploads files and directories to the remote
            system matching one or more glob patterns.
 
            The arguments to this method are identical to the :meth:`put`
            method, except that the local paths specified can contain
            wildcard patterns.
 
         """
 
-        await self._begin_copy(LocalFile, self, localpaths, remotepath, 'mput',
+        await self._begin_copy(local_fs, self, localpaths, remotepath, 'mput',
                                True, preserve, recurse, follow_symlinks,
                                block_size, max_requests, progress_handler,
                                error_handler)
 
-    async def mcopy(self, srcpaths, dstpath=None, *, preserve=False,
-                    recurse=False, follow_symlinks=False,
-                    block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS,
-                    progress_handler=None, error_handler=None):
+    async def mcopy(self, srcpaths: Sequence[_SFTPPath],
+                    dstpath: Optional[_SFTPPath] = None, *,
+                    preserve: bool = False, recurse: bool = False,
+                    follow_symlinks: bool = False,
+                    block_size: int =SFTP_BLOCK_SIZE,
+                    max_requests: int = _MAX_SFTP_REQUESTS,
+                    progress_handler: SFTPProgressHandler = None,
+                    error_handler: SFTPErrorHandler = None) -> None:
         """Download remote files with glob pattern match
 
            This method copies files and directories on the remote
            system matching one or more glob patterns.
 
            The arguments to this method are identical to the :meth:`copy`
            method, except that the source paths specified can contain
@@ -2527,15 +3937,17 @@
         """
 
         await self._begin_copy(self, self, srcpaths, dstpath, 'remote mcopy',
                                True, preserve, recurse, follow_symlinks,
                                block_size, max_requests, progress_handler,
                                error_handler)
 
-    async def glob(self, patterns, error_handler=None):
+    async def glob(self, patterns: Union[_SFTPPath, Sequence[_SFTPPath]],
+                   error_handler: SFTPErrorHandler = None) -> \
+            Sequence[BytesOrStr]:
         """Match remote files against glob patterns
 
            This method matches remote files against one or more glob
            patterns. Either a single pattern or a sequence of patterns
            can be provided to match against.
 
            Supported wildcard characters include '*', '?', and
@@ -2569,17 +3981,38 @@
            :type error_handler: `callable`
 
            :raises: :exc:`SFTPError` if the server returns an error
                     or no match is found
 
         """
 
-        return await self._glob(self, patterns, error_handler)
+        if isinstance(patterns, (bytes, str, PurePath)):
+            patterns = [patterns]
+
+        result: List[BytesOrStr] = []
+
+        for pattern in patterns:
+            if not pattern:
+                continue
+
+            enc_names = await match_glob(self, self.encode(pattern),
+                                         error_handler, self.version)
+
+            if isinstance(pattern, (str, PurePath)):
+                names = [self.decode(name) for name in enc_names]
+            else:
+                names = cast(List[BytesOrStr], enc_names)
+
+            result.extend(names)
+
+        return result
 
-    async def makedirs(self, path, attrs=SFTPAttrs(), exist_ok=False):
+
+    async def makedirs(self, path: _SFTPPath, attrs: SFTPAttrs = SFTPAttrs(),
+                       exist_ok: bool = False) -> None:
         """Create a remote directory with the specified attributes
 
            This method creates a remote directory at the specified path
            similar to :meth:`mkdir`, but it will also create any
            intermediate directories which don't yet exist.
 
            If the target directory already exists and exist_ok is set
@@ -2607,26 +4040,33 @@
 
         for part in path.split(b'/'):
             curpath = posixpath.join(curpath, part)
 
             try:
                 await self.mkdir(curpath, attrs)
                 exists = False
-            except SFTPFailure:
-                mode = await self._mode(curpath)
+            except (SFTPFailure, SFTPFileAlreadyExists):
+                filetype = await self._type(curpath)
+
+                if filetype != FILEXFER_TYPE_DIRECTORY:
+                    curpath_str = curpath.decode('utf-8', 'backslashreplace')
+
+                    exc = SFTPNotADirectory if self.version >= 6 \
+                        else SFTPFailure
 
-                if not stat.S_ISDIR(mode):
-                    path = curpath.decode('utf-8', errors='replace')
-                    raise SFTPFailure('%s is not a directory' % path) from None
+                    raise exc('%s is not a directory' % curpath_str) from None
 
         if exists and not exist_ok:
-            raise SFTPFailure('%s already exists' %
-                              curpath.decode('utf-8', errors='replace'))
+            exc = SFTPFileAlreadyExists if self.version >= 6 else SFTPFailure
 
-    async def rmtree(self, path, ignore_errors=False, onerror=None):
+            raise exc('%s already exists' %
+                      curpath.decode('utf-8', 'backslashreplace'))
+
+    async def rmtree(self, path: _SFTPPath, ignore_errors: bool = False,
+                     onerror: _SFTPOnErrorHandler = None) -> None:
         """Recursively delete a directory tree
 
            This method removes all the files in a directory tree.
 
            If ignore_errors is set, errors are ignored. Otherwise,
            if onerror is set, it will be called with arguments of
            the function which failed, the path it failed on, and
@@ -2646,40 +4086,45 @@
            :type ignore_errors: `bool`
            :type onerror: `callable`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        async def _unlink(path):
+        async def _unlink(path: bytes) -> None:
             """Internal helper for unlinking non-directories"""
 
+            assert onerror is not None
+
             try:
                 await self.unlink(path)
             except SFTPError:
                 onerror(self.unlink, path, sys.exc_info())
 
-        async def _rmtree(path):
+        async def _rmtree(path: bytes) -> None:
             """Internal helper for rmtree recursion"""
 
+            assert onerror is not None
+
             tasks = []
 
             try:
                 async with sem:
                     async for entry in self.scandir(path):
-                        if entry.filename in (b'.', b'..'):
+                        filename = cast(bytes, entry.filename)
+
+                        if filename in (b'.', b'..'):
                             continue
 
-                        mode = entry.attrs.permissions
-                        entry = posixpath.join(path, entry.filename)
+                        filename = posixpath.join(path, filename)
 
-                        if stat.S_ISDIR(mode):
-                            task = _rmtree(entry)
+                        if entry.attrs.type == FILEXFER_TYPE_DIRECTORY:
+                            task = _rmtree(filename)
                         else:
-                            task = _unlink(entry)
+                            task = _unlink(filename)
 
                         tasks.append(asyncio.ensure_future(task))
             except SFTPError:
                 onerror(self.scandir, path, sys.exc_info())
 
             results = await asyncio.gather(*tasks, return_exceptions=True)
             exc = next((result for result in results
@@ -2691,38 +4136,43 @@
             try:
                 await self.rmdir(path)
             except SFTPError:
                 onerror(self.rmdir, path, sys.exc_info())
 
         # pylint: disable=function-redefined
         if ignore_errors:
-            def onerror(*_args):
+            def onerror(*_args: object) -> None:
                 pass
         elif onerror is None:
-            def onerror(*_args):
+            def onerror(*_args: object) -> None:
                 raise # pylint: disable=misplaced-bare-raise
         # pylint: enable=function-redefined
 
+        assert onerror is not None
+
         path = self.encode(path)
         sem = asyncio.Semaphore(_MAX_SFTP_REQUESTS)
 
         try:
             if await self.islink(path):
                 raise SFTPNoSuchFile('%s must not be a symlink' %
-                                     path.decode('utf-8', errors='replace'))
+                                     path.decode('utf-8', 'backslashreplace'))
         except SFTPError:
             onerror(self.islink, path, sys.exc_info())
             return
 
         await _rmtree(path)
 
     @async_context_manager
-    async def open(self, path, pflags_or_mode=FXF_READ, attrs=SFTPAttrs(),
-                   encoding='utf-8', errors='strict',
-                   block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS):
+    async def open(self, path: _SFTPPath,
+                   pflags_or_mode: Union[int, str] = FXF_READ,
+                   attrs: SFTPAttrs = SFTPAttrs(),
+                   encoding: Optional[str] = 'utf-8', errors: str = 'strict',
+                   block_size: int = SFTP_BLOCK_SIZE,
+                   max_requests: int = _MAX_SFTP_REQUESTS) -> SFTPFileProtocol:
         """Open a remote file
 
            This method opens a remote file and returns an
            :class:`SFTPClientFile` object which can be used to read and
            write data and get and set file attributes.
 
            The path can be either a `str` or `bytes` value. If it is a
@@ -2742,20 +4192,14 @@
              FXF_CREAT  Create the file if it doesn't exist. Without this,
                         attempts to open a non-existent file will fail.
              FXF_TRUNC  Truncate the file to zero length if it already exists.
              FXF_EXCL   Return an error when trying to open a file which
                         already exists.
              ========== ======================================================
 
-           By default, file data is read and written as strings in UTF-8
-           format with strict error checking, but this can be changed
-           using the `encoding` and `errors` parameters. To read and
-           write data as bytes in binary format, an `encoding` value of
-           `None` can be used.
-
            Instead of these flags, a Python open mode string can also be
            provided. Python open modes map to the above flags as follows:
 
              ==== =============================================
              Mode Flags
              ==== =============================================
              r    FXF_READ
@@ -2769,14 +4213,22 @@
              x+   FXF_READ | FXF_WRITE | FXF_CREAT | FXF_EXCL
              ==== =============================================
 
            Including a 'b' in the mode causes the `encoding` to be set
            to `None`, forcing all data to be read and written as bytes
            in binary format.
 
+           Most applications should be able to use this method regardless
+           of the version of the SFTP protocol negotiated with the SFTP
+           server. A conversion from the pflags_or_mode values to the
+           SFTPv5/v6 flag values will happen automaitcally. However, if
+           an application wishes to set flags only available in SFTPv5/v6,
+           the :meth:`open56` method may be used to specify these flags
+           explicitly.
+
            The attrs argument is used to set initial attributes of the
            file if it needs to be created. Otherwise, this argument is
            ignored.
 
            The block_size argument specifies the size of parallel read and
            write requests issued on the file. If set to `None`, each read
            or write call will become a single request to the SFTP server.
@@ -2833,61 +4285,166 @@
                 encoding = None
         else:
             pflags = pflags_or_mode
 
         path = self.compose_path(path)
         handle = await self._handler.open(path, pflags, attrs)
 
-        return SFTPClientFile(self._handler, handle, pflags & FXF_APPEND,
+        return SFTPClientFile(self._handler, handle, bool(pflags & FXF_APPEND),
                               encoding, errors, block_size, max_requests)
 
-    async def stat(self, path):
+    @async_context_manager
+    async def open56(self, path: _SFTPPath,
+                     desired_access: int = ACE4_READ_DATA |
+                                           ACE4_READ_ATTRIBUTES,
+                     flags: int = FXF_OPEN_EXISTING,
+                     attrs: SFTPAttrs = SFTPAttrs(),
+                     encoding: Optional[str] = 'utf-8', errors: str = 'strict',
+                     block_size: int = SFTP_BLOCK_SIZE,
+                     max_requests: int = _MAX_SFTP_REQUESTS) -> \
+            SFTPFileProtocol:
+        """Open a remote file using SFTP v5/v6 flags
+
+           This method is very similar to :meth:`open`, but the pflags_or_mode
+           argument is replaced with SFTPv5/v6 desired_access and flags
+           arguments. Most applications can continue to use :meth:`open`
+           even when talking to an SFTPv5/v6 server and the translation of
+           the flags will happen automatically. However, if an application
+           wishes to set flags only available in SFTPv5/v6, this method
+           provides that capability.
+
+           The following desired_access flags can be specified:
+
+               | ACE4_READ_DATA
+               | ACE4_WRITE_DATA
+               | ACE4_APPEND_DATA
+               | ACE4_READ_ATTRIBUTES
+               | ACE4_WRITE_ATTRIBUTES
+
+           The following flags can be specified:
+
+               | FXF_CREATE_NEW
+               | FXF_CREATE_TRUNCATE
+               | FXF_OPEN_EXISTING
+               | FXF_OPEN_OR_CREATE
+               | FXF_TRUNCATE_EXISTING
+               | FXF_APPEND_DATA
+               | FXF_APPEND_DATA_ATOMIC
+               | FXF_BLOCK_READ
+               | FXF_BLOCK_WRITE
+               | FXF_BLOCK_DELETE
+               | FXF_BLOCK_ADVISORY (SFTPv6)
+               | FXF_NOFOLLOW (SFTPv6)
+               | FXF_DELETE_ON_CLOSE (SFTPv6)
+               | FXF_ACCESS_AUDIT_ALARM_INFO (SFTPv6)
+               | FXF_ACCESS_BACKUP (SFTPv6)
+               | FXF_BACKUP_STREAM (SFTPv6)
+               | FXF_OVERRIDE_OWNER (SFTPv6)
+
+           At this time, FXF_TEXT_MODE is not supported. Also, servers
+           may support only a subset of these flags. For example,
+           the AsyncSSH SFTP server doesn't currently support ACLs,
+           file locking, or most of the SFTPv6 open flags, but
+           support for some of these may be added over time.
+
+           :param path:
+               The name of the remote file to open
+           :param desired_access: (optional)
+               The access mode to use for the remote file (see above)
+           :param flags: (optional)
+               The access flags to use for the remote file (see above)
+           :param attrs: (optional)
+               File attributes to use if the file needs to be created
+           :param encoding: (optional)
+               The Unicode encoding to use for data read and written
+               to the remote file
+           :param errors: (optional)
+               The error-handling mode if an invalid Unicode byte
+               sequence is detected, defaulting to 'strict' which
+               raises an exception
+           :param block_size: (optional)
+               The block size to use for read and write requests
+           :param max_requests: (optional)
+               The maximum number of parallel read or write requests
+           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :type desired_access: int
+           :type flags: int
+           :type attrs: :class:`SFTPAttrs`
+           :type encoding: `str`
+           :type errors: `str`
+           :type block_size: `int` or `None`
+           :type max_requests: `int`
+
+           :returns: An :class:`SFTPClientFile` to use to access the file
+
+           :raises: | :exc:`ValueError` if the mode is not valid
+                    | :exc:`SFTPError` if the server returns an error
+
+        """
+
+        path = self.compose_path(path)
+        handle = await self._handler.open56(path, desired_access, flags, attrs)
+
+        return SFTPClientFile(self._handler, handle,
+                              bool(desired_access & ACE4_APPEND_DATA or
+                                   flags & FXF_APPEND_DATA),
+                              encoding, errors, block_size, max_requests)
+
+    async def stat(self, path: _SFTPPath,
+                   flags = FILEXFER_ATTR_DEFINED_V4) -> SFTPAttrs:
         """Get attributes of a remote file or directory, following symlinks
 
            This method queries the attributes of a remote file or
            directory. If the path provided is a symbolic link, the
            returned attributes will correspond to the target of the
            link.
 
            :param path:
                The path of the remote file or directory to get attributes for
+           :param flags: (optional)
+               Flags indicating attributes of interest (SFTPv4 only)
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :type flags: `int`
 
            :returns: An :class:`SFTPAttrs` containing the file attributes
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         path = self.compose_path(path)
-        return await self._handler.stat(path)
+        return await self._handler.stat(path, flags)
 
-    async def lstat(self, path):
+    async def lstat(self, path: _SFTPPath,
+                    flags = FILEXFER_ATTR_DEFINED_V4) -> SFTPAttrs:
         """Get attributes of a remote file, directory, or symlink
 
            This method queries the attributes of a remote file,
            directory, or symlink. Unlike :meth:`stat`, this method
            returns the attributes of a symlink itself rather than
            the target of that link.
 
            :param path:
                The path of the remote file, directory, or link to get
                attributes for
+           :param flags: (optional)
+               Flags indicating attributes of interest (SFTPv4 only)
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :type flags: `int`
 
            :returns: An :class:`SFTPAttrs` containing the file attributes
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         path = self.compose_path(path)
-        return await self._handler.lstat(path)
+        return await self._handler.lstat(path, flags)
 
-    async def setstat(self, path, attrs):
+    async def setstat(self, path: _SFTPPath, attrs: SFTPAttrs) -> None:
         """Set attributes of a remote file or directory
 
            This method sets attributes of a remote file or directory.
            If the path provided is a symbolic link, the attributes
            will be set on the target of the link. A subset of the
            fields in `attrs` can be initialized and only those
            attributes will be changed.
@@ -2902,15 +4459,15 @@
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         path = self.compose_path(path)
         await self._handler.setstat(path, attrs)
 
-    async def statvfs(self, path):
+    async def statvfs(self, path: _SFTPPath) -> SFTPVFSAttrs:
         """Get attributes of a remote file system
 
            This method queries the attributes of the file system containing
            the specified path.
 
            :param path:
                The path of the remote file system to get attributes for
@@ -2923,15 +4480,15 @@
                     extension or returns an error
 
         """
 
         path = self.compose_path(path)
         return await self._handler.statvfs(path)
 
-    async def truncate(self, path, size):
+    async def truncate(self, path: _SFTPPath, size: int) -> None:
         """Truncate a remote file to the specified size
 
            This method truncates a remote file to the specified size.
            If the path provided is a symbolic link, the target of
            the link will be truncated.
 
            :param path:
@@ -2943,38 +4500,64 @@
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         await self.setstat(path, SFTPAttrs(size=size))
 
-    async def chown(self, path, uid, gid):
+    @overload
+    async def chown(self, path: _SFTPPath,
+                    uid: int, gid: int) -> None: ... # pragma: no cover
+
+    @overload
+    async def chown(self, path: _SFTPPath,
+                    owner: str, group: str) -> None: ... # pragma: no cover
+
+    async def chown(self, path, uid_or_owner = None, gid_or_group = None,
+                    uid = None, gid = None, owner = None, group = None):
         """Change the owner user and group id of a remote file or directory
 
            This method changes the user and group id of a remote
            file or directory. If the path provided is a symbolic
            link, the target of the link will be changed.
 
            :param path:
                The path of the remote file to change
            :param uid:
                The new user id to assign to the file
            :param gid:
                The new group id to assign to the file
+           :param owner:
+               The new owner to assign to the file (SFTPv4 only)
+           :param group:
+               The new group to assign to the file (SFTPv4 only)
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
            :type uid: `int`
            :type gid: `int`
+           :type owner: `str`
+           :type group: `str`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        await self.setstat(path, SFTPAttrs(uid=uid, gid=gid))
+        if isinstance(uid_or_owner, int):
+            uid = uid_or_owner
+        elif isinstance(uid_or_owner, str):
+            owner = uid_or_owner
+
+        if isinstance(gid_or_group, int):
+            gid = gid_or_group
+        elif isinstance(gid_or_group, str):
+            group = gid_or_group
 
-    async def chmod(self, path, mode):
+        await self.setstat(path, SFTPAttrs(uid=uid, gid=gid,
+                                           owner=owner, group=group))
+
+    async def chmod(self, path: _SFTPPath, mode: int) -> None:
         """Change the file permissions of a remote file or directory
 
            This method changes the permissions of a remote file or
            directory. If the path provided is a symbolic link, the
            target of the link will be changed.
 
            :param path:
@@ -2986,147 +4569,227 @@
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         await self.setstat(path, SFTPAttrs(permissions=mode))
 
-    async def utime(self, path, times=None):
+    async def utime(self, path: _SFTPPath,
+                    times: Optional[Tuple[float, float]] = None,
+                    ns: Optional[Tuple[int, int]] = None) -> None:
         """Change the access and modify times of a remote file or directory
 
            This method changes the access and modify times of a
-           remote file or directory. If `times` is not provided,
-           the times will be changed to the current time. If the
-           path provided is a symbolic link, the target of the link
-           will be changed.
+           remote file or directory. If neither `times` nor '`ns` is
+           provided, the times will be changed to the current time.
+
+           If the path provided is a symbolic link, the target of the
+           link will be changed.
 
            :param path:
                The path of the remote file to change
            :param times: (optional)
                The new access and modify times, as seconds relative to
                the UNIX epoch
+           :param ns: (optional)
+               The new access and modify times, as nanoseconds relative to
+               the UNIX epoch
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
            :type times: tuple of two `int` or `float` values
+           :type ns: tuple of two `int` values
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        if times is None:
-            atime = mtime = time.time()
-        else:
-            atime, mtime = times
-
-        await self.setstat(path, SFTPAttrs(atime=atime, mtime=mtime))
+        await self.setstat(path, _utime_to_attrs(times, ns))
 
-    async def exists(self, path):
+    async def exists(self, path: _SFTPPath) -> bool:
         """Return if the remote path exists and isn't a broken symbolic link
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return bool((await self._mode(path)))
+        return (await self._type(path)) != FILEXFER_TYPE_UNKNOWN
 
-    async def lexists(self, path):
+    async def lexists(self, path: _SFTPPath) -> bool:
         """Return if the remote path exists, without following symbolic links
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return bool((await self._mode(path, statfunc=self.lstat)))
+        return (await self._type(path, statfunc=self.lstat)) != \
+            FILEXFER_TYPE_UNKNOWN
 
-    async def getatime(self, path):
+    async def getatime(self, path: _SFTPPath) -> Optional[float]:
         """Return the last access time of a remote file or directory
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return (await self.stat(path)).atime
+        attrs = await self.stat(path)
 
-    async def getmtime(self, path):
+        return _tuple_to_float_sec(attrs.atime, attrs.atime_ns) \
+            if attrs.atime is not None else None
+
+    async def getatime_ns(self, path: _SFTPPath) -> Optional[int]:
+        """Return the last access time of a remote file or directory
+
+           The time returned is nanoseconds since the epoch.
+
+           :param path:
+               The remote path to check
+           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+
+           :raises: :exc:`SFTPError` if the server returns an error
+
+        """
+
+        attrs = await self.stat(path)
+
+        return _tuple_to_nsec(attrs.atime, attrs.atime_ns) \
+            if attrs.atime is not None else None
+
+    async def getcrtime(self, path: _SFTPPath) -> Optional[float]:
+        """Return the creation time of a remote file or directory (SFTPv4 only)
+
+           :param path:
+               The remote path to check
+           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+
+           :raises: :exc:`SFTPError` if the server returns an error
+
+        """
+
+        attrs = await self.stat(path)
+
+        return _tuple_to_float_sec(attrs.crtime, attrs.crtime_ns) \
+            if attrs.crtime is not None else None
+
+    async def getcrtime_ns(self, path: _SFTPPath) -> Optional[int]:
+        """Return the creation time of a remote file or directory
+
+           The time returned is nanoseconds since the epoch.
+
+           :param path:
+               The remote path to check
+           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+
+           :raises: :exc:`SFTPError` if the server returns an error
+
+        """
+
+        attrs = await self.stat(path)
+
+        return _tuple_to_nsec(attrs.crtime, attrs.crtime_ns) \
+            if attrs.crtime is not None else None
+
+    async def getmtime(self, path: _SFTPPath) -> Optional[float]:
+        """Return the last modification time of a remote file or directory
+
+           :param path:
+               The remote path to check
+           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+
+           :raises: :exc:`SFTPError` if the server returns an error
+
+        """
+
+        attrs = await self.stat(path)
+
+        return _tuple_to_float_sec(attrs.mtime, attrs.mtime_ns) \
+            if attrs.mtime is not None else None
+
+    async def getmtime_ns(self, path: _SFTPPath) -> Optional[int]:
         """Return the last modification time of a remote file or directory
 
+           The time returned is nanoseconds since the epoch.
+
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return (await self.stat(path)).mtime
+        attrs = await self.stat(path)
+
+        return _tuple_to_nsec(attrs.mtime, attrs.mtime_ns) \
+            if attrs.mtime is not None else None
 
-    async def getsize(self, path):
+    async def getsize(self, path: _SFTPPath) -> Optional[int]:
         """Return the size of a remote file or directory
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         return (await self.stat(path)).size
 
-    async def isdir(self, path):
+    async def isdir(self, path: _SFTPPath) -> bool:
         """Return if the remote path refers to a directory
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return stat.S_ISDIR((await self._mode(path)))
+        return (await self._type(path)) == FILEXFER_TYPE_DIRECTORY
 
-    async def isfile(self, path):
+    async def isfile(self, path: _SFTPPath) -> bool:
         """Return if the remote path refers to a regular file
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return stat.S_ISREG((await self._mode(path)))
+        return (await self._type(path)) == FILEXFER_TYPE_REGULAR
 
-    async def islink(self, path):
+    async def islink(self, path: _SFTPPath) -> bool:
         """Return if the remote path refers to a symbolic link
 
            :param path:
                The remote path to check
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        return stat.S_ISLNK((await self._mode(path, statfunc=self.lstat)))
+        return (await self._type(path, statfunc=self.lstat)) == \
+            FILEXFER_TYPE_SYMLINK
 
-    async def remove(self, path):
+    async def remove(self, path: _SFTPPath) -> None:
         """Remove a remote file
 
            This method removes a remote file or symbolic link.
 
            :param path:
                The path of the remote file or link to remove
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
@@ -3134,55 +4797,70 @@
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         path = self.compose_path(path)
         await self._handler.remove(path)
 
-    async def unlink(self, path):
+    async def unlink(self, path: _SFTPPath) -> None:
         """Remove a remote file (see :meth:`remove`)"""
 
         await self.remove(path)
 
-    async def rename(self, oldpath, newpath):
+    async def rename(self, oldpath: _SFTPPath, newpath: _SFTPPath,
+                     flags: int = 0) -> None:
         """Rename a remote file, directory, or link
 
            This method renames a remote file, directory, or link.
 
-           .. note:: This requests the standard SFTP version of rename
-                     which will not overwrite the new path if it already
-                     exists. To request POSIX behavior where the new
-                     path is removed before the rename, use
-                     :meth:`posix_rename`.
+           .. note:: By default, this version of rename will not overwrite
+                     the new path if it already exists. However, this
+                     can be controlled using the `flags` argument,
+                     available in SFTPv5 and later. Whan a connection
+                     is negotiated to use an earliler version of SFTP
+                     and `flags` is set, this method will attempt to
+                     fall back to the OpenSSH "posix-rename" extension
+                     if it is available. That can also be invoked
+                     directly by calling :meth:`posix_rename`.
 
            :param oldpath:
                The path of the remote file, directory, or link to rename
            :param newpath:
                The new name for this file, directory, or link
+           :param flags: (optional)
+               A combination of the `FXR_OVERWRITE`, `FXR_ATOMIC`, and
+               `FXR_NATIVE` flags to specify what happens when `newpath`
+               already exists, defaulting to not allowing the overwrite
+               (SFTPv5 and later)
            :type oldpath:
                :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
            :type newpath:
                :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :type flags: `int`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         oldpath = self.compose_path(oldpath)
         newpath = self.compose_path(newpath)
-        await self._handler.rename(oldpath, newpath)
+        await self._handler.rename(oldpath, newpath, flags)
 
-    async def posix_rename(self, oldpath, newpath):
+    async def posix_rename(self, oldpath: _SFTPPath,
+                           newpath: _SFTPPath) -> None:
         """Rename a remote file, directory, or link with POSIX semantics
 
            This method renames a remote file, directory, or link,
            removing the prior instance of new path if it previously
            existed.
 
-           This method may not be supported by all SFTP servers.
+           This method may not be supported by all SFTP servers. If it
+           is not available but the server supports SFTPv5 or later,
+           this method will attempt to send the standard SFTP rename
+           request with the `FXR_OVERWRITE` flag set.
 
            :param oldpath:
                The path of the remote file, directory, or link to rename
            :param newpath:
                The new name for this file, directory, or link
            :type oldpath:
                :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
@@ -3194,15 +4872,15 @@
 
         """
 
         oldpath = self.compose_path(oldpath)
         newpath = self.compose_path(newpath)
         await self._handler.posix_rename(oldpath, newpath)
 
-    async def scandir(self, path='.'):
+    async def scandir(self, path: _SFTPPath = '.') -> AsyncIterator[SFTPName]:
         """Return an async iterator of the contents of a remote directory
 
            This method reads the contents of a directory, returning
            the names and attributes of what is contained there as an
            async iterator. If no path is provided, it defaults to the
            current remote working directory.
 
@@ -3215,29 +4893,36 @@
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         dirpath = self.compose_path(path)
         handle = await self._handler.opendir(dirpath)
+        at_end = False
 
         try:
-            while True:
-                for entry in await self._handler.readdir(handle):
+            while not at_end:
+                names, at_end = await self._handler.readdir(handle)
+
+                for entry in names:
                     if isinstance(path, (str, PurePath)):
-                        entry.filename = self.decode(entry.filename)
-                        entry.longname = self.decode(entry.longname)
+                        entry.filename = \
+                            self.decode(cast(bytes, entry.filename))
+
+                        if entry.longname is not None:
+                            entry.longname = \
+                                self.decode(cast(bytes, entry.longname))
 
                     yield entry
         except SFTPEOFError:
             pass
         finally:
             await self._handler.close(handle)
 
-    async def readdir(self, path='.'):
+    async def readdir(self, path: _SFTPPath = '.') -> Sequence[SFTPName]:
         """Read the contents of a remote directory
 
            This method reads the contents of a directory, returning
            the names and attributes of what is contained there. If no
            path is provided, it defaults to the current remote working
            directory.
 
@@ -3250,36 +4935,45 @@
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         return [entry async for entry in self.scandir(path)]
 
-    async def listdir(self, path='.'):
+    @overload
+    async def listdir(self, path: bytes) -> \
+        Sequence[bytes]: ... # pragma: no cover
+
+    @overload
+    async def listdir(self, path: FilePath) -> \
+        Sequence[str]: ... # pragma: no cover
+
+    async def listdir(self, path: _SFTPPath = '.') -> Sequence[BytesOrStr]:
         """Read the names of the files in a remote directory
 
            This method reads the names of files and subdirectories
            in a remote directory. If no path is provided, it defaults
            to the current remote working directory.
 
            :param path: (optional)
                The path of the remote directory to read
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
-           :returns: A list of file/subdirectory names, matching the
-                     type used to pass in the path
+           :returns: A list of file/subdirectory names, as a `str` or `bytes`
+                     matching the type used to pass in the path
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         names = await self.readdir(path)
         return [name.filename for name in names]
 
-    async def mkdir(self, path, attrs=SFTPAttrs()):
+    async def mkdir(self, path: _SFTPPath,
+                    attrs: SFTPAttrs = SFTPAttrs()) -> None:
         """Create a remote directory with the specified attributes
 
            This method creates a new remote directory at the
            specified path with the requested attributes.
 
            :param path:
                The path of where the new remote directory should be created
@@ -3291,15 +4985,15 @@
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         path = self.compose_path(path)
         await self._handler.mkdir(path, attrs)
 
-    async def rmdir(self, path):
+    async def rmdir(self, path: _SFTPPath) -> None:
         """Remove a remote directory
 
            This method removes a remote directory. The directory
            must be empty for the removal to succeed.
 
            :param path:
                The path of the remote directory to remove
@@ -3308,67 +5002,133 @@
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         path = self.compose_path(path)
         await self._handler.rmdir(path)
 
-    async def realpath(self, path):
+    @overload
+    async def realpath(self, path: bytes, # pragma: no cover
+                       *compose_paths: bytes) -> bytes: ...
+
+    @overload
+    async def realpath(self, path: FilePath, # pragma: no cover
+                       *compose_paths: FilePath) -> str: ...
+
+    @overload
+    async def realpath(self, path: bytes, # pragma: no cover
+                       *compose_paths: bytes, check: int) -> SFTPName: ...
+
+    @overload
+    async def realpath(self, path: FilePath, # pragma: no cover
+                       *compose_paths: FilePath, check: int) -> SFTPName: ...
+
+    async def realpath(self, path: _SFTPPath, *compose_paths: _SFTPPath,
+                       check: int = FXRP_NO_CHECK) -> \
+            Union[BytesOrStr, SFTPName]:
         """Return the canonical version of a remote path
 
            This method returns a canonical version of the requested path.
 
            :param path: (optional)
                The path of the remote directory to canonicalize
-           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :param compose_paths: (optional)
+               A list of additional paths that the server should compose
+               with `path` before canonicalizing it
+           :param check: (optional)
+               One of `FXRP_NO_CHECK`, `FXRP_STAT_IF_EXISTS`, and
+               `FXRP_STAT_ALWAYS`, specifying when to perform a
+               stat operation on the resulting path, defaulting to
+               `FXRP_NO_CHECK`
+           :type path:
+               :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :type compose_paths:
+               :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
+           :type check: int
 
            :returns: The canonical path as a `str` or `bytes`, matching
-                     the type used to pass in the path
+                     the type used to pass in the path if `check` is set
+                     to `FXRP_NO_CHECK`, or an :class:`SFTPName`
+                     containing the canonical path name and attributes
+                     otherwise
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
-        fullpath = self.compose_path(path)
-        names = await self._handler.realpath(fullpath)
+        if compose_paths and isinstance(compose_paths[-1], int):
+            check = compose_paths[-1]
+            compose_paths = compose_paths[:-1]
+
+        path_bytes = self.compose_path(path)
+
+        if self.version >= 6:
+            names, _ = await self._handler.realpath(
+                path_bytes, *map(self.encode, compose_paths), check=check)
+        else:
+            for cpath in compose_paths:
+                path_bytes = self.compose_path(cpath, path_bytes)
+
+            names, _ = await self._handler.realpath(path_bytes)
 
         if len(names) > 1:
             raise SFTPBadMessage('Too many names returned')
 
-        return self.decode(names[0].filename, isinstance(path, (str, PurePath)))
+        if check != FXRP_NO_CHECK:
+            if self.version < 6:
+                try:
+                    names[0].attrs = await self._handler.stat(
+                        self.encode(names[0].filename),
+                        _valid_attr_flags[self.version])
+                except SFTPError:
+                    if check == FXRP_STAT_IF_EXISTS:
+                        names[0].attrs = SFTPAttrs(type=FILEXFER_TYPE_UNKNOWN)
+                    else:
+                        raise
 
-    async def getcwd(self):
+            return names[0]
+        else:
+            return self.decode(cast(bytes, names[0].filename),
+                               isinstance(path, (str, PurePath)))
+
+    async def getcwd(self) -> BytesOrStr:
         """Return the current remote working directory
 
            :returns: The current remote working directory, decoded using
                      the specified path encoding
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         if self._cwd is None:
             self._cwd = await self.realpath(b'.')
 
         return self.decode(self._cwd)
 
-    async def chdir(self, path):
+    async def chdir(self, path: _SFTPPath) -> None:
         """Change the current remote working directory
 
            :param path:
                The path to set as the new remote working directory
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         self._cwd = await self.realpath(self.encode(path))
 
-    async def readlink(self, path):
+    @overload
+    async def readlink(self, path: bytes) -> bytes: ... # pragma: no cover
+
+    @overload
+    async def readlink(self, path: FilePath) -> str: ... # pragma: no cover
+
+    async def readlink(self, path: _SFTPPath) -> BytesOrStr:
         """Return the target of a remote symbolic link
 
            This method returns the target of a symbolic link.
 
            :param path:
                The path of the remote symbolic link to follow
            :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`
@@ -3376,22 +5136,23 @@
            :returns: The target path of the link as a `str` or `bytes`
 
            :raises: :exc:`SFTPError` if the server returns an error
 
         """
 
         linkpath = self.compose_path(path)
-        names = await self._handler.readlink(linkpath)
+        names, _ = await self._handler.readlink(linkpath)
 
         if len(names) > 1:
             raise SFTPBadMessage('Too many names returned')
 
-        return self.decode(names[0].filename, isinstance(path, (str, PurePath)))
+        return self.decode(cast(bytes, names[0].filename),
+                           isinstance(path, (str, PurePath)))
 
-    async def symlink(self, oldpath, newpath):
+    async def symlink(self, oldpath: _SFTPPath, newpath: _SFTPPath) -> None:
         """Create a remote symbolic link
 
            This method creates a symbolic link. The argument order here
            matches the standard Python :meth:`os.symlink` call. The
            argument order sent on the wire is automatically adapted
            depending on the version information sent by the server, as
            a number of servers (OpenSSH in particular) did not follow
@@ -3410,15 +5171,15 @@
 
         """
 
         oldpath = self.compose_path(oldpath)
         newpath = self.encode(newpath)
         await self._handler.symlink(oldpath, newpath)
 
-    async def link(self, oldpath, newpath):
+    async def link(self, oldpath: _SFTPPath, newpath: _SFTPPath) -> None:
         """Create a remote hard link
 
            This method creates a hard link to the remote file specified
            by oldpath at the location specified by newpath.
 
            This method may not be supported by all SFTP servers.
 
@@ -3436,514 +5197,745 @@
 
         """
 
         oldpath = self.compose_path(oldpath)
         newpath = self.compose_path(newpath)
         await self._handler.link(oldpath, newpath)
 
-    def exit(self):
+    def exit(self) -> None:
         """Exit the SFTP client session
 
            This method exits the SFTP client session, closing the
            corresponding channel opened on the server.
 
         """
 
         self._handler.exit()
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this SFTP client session to close"""
 
         await self._handler.wait_closed()
 
 
 class SFTPServerHandler(SFTPHandler):
     """An SFTP server session handler"""
 
-    _extensions = [(b'posix-rename@openssh.com', b'1'),
-                   (b'hardlink@openssh.com', b'1'),
-                   (b'fsync@openssh.com', b'1')]
+    # Supported attribute flags in setstat/fsetstat
+    _supported_attr_mask = FILEXFER_ATTR_SIZE | \
+                           FILEXFER_ATTR_PERMISSIONS | \
+                           FILEXFER_ATTR_ACCESSTIME | \
+                           FILEXFER_ATTR_MODIFYTIME | \
+                           FILEXFER_ATTR_OWNERGROUP | \
+                           FILEXFER_ATTR_SUBSECOND_TIMES
+
+    # No attrib bits currently supported
+    _supported_attrib_mask = 0
+
+    # Supported SFTPv5/v6 open flags
+    _supported_open_flags = FXF_ACCESS_DISPOSITION | FXF_APPEND_DATA
+
+    # Supported SFTPv5/v6 desired accesss flags
+    _supported_access_mask = ACE4_READ_DATA | ACE4_WRITE_DATA | \
+                             ACE4_APPEND_DATA | ACE4_READ_ATTRIBUTES | \
+                             ACE4_WRITE_ATTRIBUTES
+
+    # Locking not currently supported
+    _supported_open_block_vector = _supported_block_vector = 0x0001
+
+    _vendor_id = String(__author__) + String('AsyncSSH') + \
+        String(__version__) + UInt64(0)
+
+    _extensions: List[Tuple[bytes, bytes]] = [
+        (b'newline', os.linesep.encode('utf-8')),
+        (b'vendor-id', _vendor_id),
+        (b'posix-rename@openssh.com', b'1'),
+        (b'hardlink@openssh.com', b'1'),
+        (b'fsync@openssh.com', b'1')]
+
+    _attrib_extensions: List[bytes] = []
 
     if hasattr(os, 'statvfs'): # pragma: no branch
         _extensions += [(b'statvfs@openssh.com', b'2'),
                         (b'fstatvfs@openssh.com', b'2')]
 
-    def __init__(self, server, reader, writer):
+    def __init__(self, server: 'SFTPServer', reader: 'SSHReader[bytes]',
+                 writer: 'SSHWriter[bytes]', sftp_version: int):
         super().__init__(reader, writer)
 
         self._server = server
-        self._version = None
+        self._version = sftp_version
         self._nonstandard_symlink = False
         self._next_handle = 0
-        self._file_handles = {}
-        self._dir_handles = {}
+        self._file_handles: Dict[bytes, object] = {}
+        self._dir_handles: Dict[bytes, List[SFTPName]] = {}
 
-    async def _cleanup(self, exc):
+    async def _cleanup(self, exc: Optional[Exception]) -> None:
         """Clean up this SFTP server session"""
 
         if self._server: # pragma: no branch
             for file_obj in list(self._file_handles.values()):
                 result = self._server.close(file_obj)
 
                 if inspect.isawaitable(result):
+                    assert result is not None
                     await result
 
             self._server.exit()
 
-            self._server = None
-            self._file_handles = []
-            self._dir_handles = []
+            self._file_handles = {}
+            self._dir_handles = {}
 
         self.logger.info('SFTP server exited%s', ': ' + str(exc) if exc else '')
 
         await super()._cleanup(exc)
 
-    def _get_next_handle(self):
+    def _get_next_handle(self) -> bytes:
         """Get the next available unique file handle number"""
 
         while True:
             handle = self._next_handle.to_bytes(4, 'big')
             self._next_handle = (self._next_handle + 1) & 0xffffffff
 
             if (handle not in self._file_handles and
                     handle not in self._dir_handles):
                 return handle
 
-    async def _process_packet(self, pkttype, pktid, packet):
+    async def _process_packet(self, pkttype: int, pktid: int,
+                              packet: SSHPacket) -> None:
         """Process incoming SFTP requests"""
 
         # pylint: disable=broad-except
         try:
             if pkttype == FXP_EXTENDED:
-                pkttype = packet.get_string()
+                handler_type: Union[int, bytes] = packet.get_string()
+            else:
+                handler_type = pkttype
 
-            handler = self._packet_handlers.get(pkttype)
+            handler = self._packet_handlers.get(handler_type)
             if not handler:
                 raise SFTPOpUnsupported('Unsupported request type: %s' %
                                         pkttype)
 
-            return_type = self._return_types.get(pkttype, FXP_STATUS)
+            return_type = self._return_types.get(handler_type, FXP_STATUS)
             result = await handler(self, packet)
 
             if return_type == FXP_STATUS:
                 self.logger.debug1('Sending OK')
 
-                result = UInt32(FX_OK) + String('') + String('')
+                response = UInt32(FX_OK) + String('') + String('')
             elif return_type == FXP_HANDLE:
-                self.logger.debug1('Sending handle %s', to_hex(result))
+                handle = cast(bytes, result)
+
+                self.logger.debug1('Sending handle %s', handle.hex())
 
-                result = String(result)
+                response = String(handle)
             elif return_type == FXP_DATA:
-                self.logger.debug1('Sending %s', plural(len(result),
-                                                        'data byte'))
+                data, at_end = cast(Tuple[bytes, bool], result)
+
+                self.logger.debug1('Sending %s%s',
+                                   plural(len(data), 'data byte'),
+                                   ' (at end)' if at_end else '')
 
-                result = String(result)
+                end = Boolean(at_end) if at_end and self._version >= 6 else b''
+
+                response = String(data) + end
             elif return_type == FXP_NAME:
-                self.logger.debug1('Sending %s', plural(len(result), 'name'))
+                names, at_end = cast(_SFTPNames, result)
+
+                self.logger.debug1('Sending %s%s', plural(len(names), 'name'),
+                                   ' (at end)' if at_end else '')
 
-                for name in result:
+                for name in names:
                     self.logger.debug1('  %s', name)
 
-                result = (UInt32(len(result)) +
-                          b''.join(name.encode() for name in result))
+                end = Boolean(at_end) if at_end and self._version >= 6 else b''
+
+                response = (UInt32(len(names)) +
+                            b''.join(name.encode(self._version)
+                                     for name in names) + end)
             else:
+                attrs: _SupportsEncode
+
                 if isinstance(result, os.stat_result):
-                    result = SFTPAttrs.from_local(result)
+                    attrs = SFTPAttrs.from_local(cast(os.stat_result, result))
                 elif isinstance(result, os.statvfs_result):
-                    result = SFTPVFSAttrs.from_local(result)
-
-                if isinstance(result, SFTPAttrs):
-                    self.logger.debug1('Sending %s', result)
-                elif isinstance(result, SFTPVFSAttrs): # pragma: no branch
-                    self.logger.debug1('Sending %s', result)
+                    attrs = SFTPVFSAttrs.from_local(cast(os.statvfs_result,
+                                                         result))
+                else:
+                    attrs = cast(_SupportsEncode, result)
 
-                result = result.encode()
+                self.logger.debug1('Sending %s', attrs)
+                response = attrs.encode(self._version)
         except PacketDecodeError as exc:
             return_type = FXP_STATUS
 
             self.logger.debug1('Sending bad message error: %s', str(exc))
 
-            result = (UInt32(FX_BAD_MESSAGE) + String(str(exc)) +
-                      String(DEFAULT_LANG))
+            response = (UInt32(FX_BAD_MESSAGE) + String(str(exc)) +
+                        String(DEFAULT_LANG))
         except SFTPError as exc:
             return_type = FXP_STATUS
 
             if exc.code == FX_EOF:
                 self.logger.debug1('Sending EOF')
             else:
-                self.logger.debug1('Sending error: %s', str(exc.reason))
+                self.logger.debug1('Sending %s: %s', exc.__class__.__name__,
+                                   str(exc.reason))
 
-            result = UInt32(exc.code) + String(exc.reason) + String(exc.lang)
+            response = exc.encode(self._version)
         except NotImplementedError as exc:
+            assert handler is not None
+
             return_type = FXP_STATUS
-            name = handler.__name__[9:]
+            op_name = handler.__name__[9:]
 
-            self.logger.debug1('Sending operation not supported: %s', name)
+            self.logger.debug1('Sending operation not supported: %s', op_name)
 
-            result = (UInt32(FX_OP_UNSUPPORTED) +
-                      String('Operation not supported: %s' % name) +
-                      String(DEFAULT_LANG))
+            response = (UInt32(FX_OP_UNSUPPORTED) +
+                        String('Operation not supported: %s' % op_name) +
+                        String(DEFAULT_LANG))
         except OSError as exc:
             return_type = FXP_STATUS
             reason = exc.strerror or str(exc)
 
-            if exc.errno in (errno.ENOENT, errno.ENOTDIR):
-                self.logger.debug1('Sending no such file error: %s', reason)
-
+            if exc.errno == errno.ENOENT:
+                self.logger.debug1('Sending no such file: %s', reason)
                 code = FX_NO_SUCH_FILE
             elif exc.errno == errno.EACCES:
                 self.logger.debug1('Sending permission denied: %s', reason)
-
                 code = FX_PERMISSION_DENIED
+            elif exc.errno == errno.EEXIST:
+                self.logger.debug1('Sending file already exists: %s', reason)
+                code = FX_FILE_ALREADY_EXISTS
+            elif exc.errno == errno.EROFS:
+                self.logger.debug1('Sending write protect: %s', reason)
+                code = FX_WRITE_PROTECT
+            elif exc.errno == errno.ENOSPC:
+                self.logger.debug1('Sending no space on '
+                                   'filesystem: %s', reason)
+                code = FX_NO_SPACE_ON_FILESYSTEM
+            elif exc.errno == errno.EDQUOT:
+                self.logger.debug1('Sending disk quota exceeded: %s', reason)
+                code = FX_QUOTA_EXCEEDED
+            elif exc.errno == errno.ENOTEMPTY:
+                self.logger.debug1('Sending directory not empty: %s', reason)
+                code = FX_DIR_NOT_EMPTY
+            elif exc.errno == errno.ENOTDIR:
+                self.logger.debug1('Sending not a directory: %s', reason)
+                code = FX_NOT_A_DIRECTORY
+            elif exc.errno in (errno.ENAMETOOLONG, errno.EILSEQ):
+                self.logger.debug1('Sending invalid filename: %s', reason)
+                code = FX_INVALID_FILENAME
+            elif exc.errno == errno.ELOOP:
+                self.logger.debug1('Sending link loop: %s', reason)
+                code = FX_LINK_LOOP
+            elif exc.errno == errno.EINVAL:
+                self.logger.debug1('Sending invalid parameter: %s', reason)
+                code = FX_INVALID_PARAMETER
+            elif exc.errno == errno.EISDIR:
+                self.logger.debug1('Sending file is a directory: %s', reason)
+                code = FX_FILE_IS_A_DIRECTORY
             else:
                 self.logger.debug1('Sending failure: %s', reason)
-
                 code = FX_FAILURE
 
-            result = UInt32(code) + String(reason) + String(DEFAULT_LANG)
+            response = SFTPError(code, reason).encode(self._version)
         except Exception as exc: # pragma: no cover
             return_type = FXP_STATUS
             reason = 'Uncaught exception: %s' % str(exc)
 
-            self.logger.debug1('Sending failure: %s', reason)
+            self.logger.debug1('Sending failure: %s', reason,
+                               exc_info=sys.exc_info)
 
-            result = UInt32(FX_FAILURE) + String(reason) + String(DEFAULT_LANG)
+            response = (UInt32(FX_FAILURE) + String(reason) +
+                        String(DEFAULT_LANG))
 
-        self.send_packet(return_type, pktid, UInt32(pktid), result)
+        self.send_packet(return_type, pktid, UInt32(pktid), response)
 
-    async def _process_open(self, packet):
+    async def _process_open(self, packet: SSHPacket) -> bytes:
         """Process an incoming SFTP open request"""
 
         path = packet.get_string()
-        pflags = packet.get_uint32()
-        attrs = SFTPAttrs.decode(packet)
-        packet.check_end()
 
-        self.logger.debug1('Received open request for %s, mode 0x%02x%s',
-                           path, pflags, hide_empty(attrs))
+        if self._version >= 5:
+            desired_access = packet.get_uint32()
+            flags = packet.get_uint32()
+            flagmsg = 'access=0x%04x, flags=0x%04x' % (desired_access, flags)
+        else:
+            pflags = packet.get_uint32()
+            flagmsg = 'pflags=0x%02x' % pflags
+
+        attrs = SFTPAttrs.decode(packet, self._version)
+
+        if self._version < 6:
+            packet.check_end()
+
+        self.logger.debug1('Received open request for %s, %s%s',
+                           path, flagmsg, hide_empty(attrs))
+
+        if self._version >= 5:
+            unsupported_access = desired_access & ~self._supported_access_mask
+
+            if unsupported_access:
+                raise SFTPInvalidParameter('Unsupported access flags: 0x%08x' %
+                                           unsupported_access)
 
-        result = self._server.open(path, pflags, attrs)
+            unsupported_flags = flags & ~self._supported_open_flags
+
+            if unsupported_flags:
+                raise SFTPInvalidParameter('Unsupported open flags: 0x%08x' %
+                                           unsupported_flags)
+
+            result = self._server.open56(path, desired_access, flags, attrs)
+        else:
+            result = self._server.open(path, pflags, attrs)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[object], result)
 
         handle = self._get_next_handle()
         self._file_handles[handle] = result
         return handle
 
-    async def _process_close(self, packet):
+    async def _process_close(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP close request"""
 
         handle = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received close for handle %s', to_hex(handle))
+        if self._version < 6:
+            packet.check_end()
+
+        self.logger.debug1('Received close for handle %s', handle.hex())
 
         file_obj = self._file_handles.pop(handle, None)
         if file_obj:
             result = self._server.close(file_obj)
 
             if inspect.isawaitable(result):
+                assert result is not None
                 await result
 
             return
 
         if self._dir_handles.pop(handle, None) is not None:
             return
 
-        raise SFTPFailure('Invalid file handle')
+        raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_read(self, packet):
+    async def _process_read(self, packet: SSHPacket) -> Tuple[bytes, bool]:
         """Process an incoming SFTP read request"""
 
         handle = packet.get_string()
         offset = packet.get_uint64()
         length = packet.get_uint32()
-        packet.check_end()
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received read for %s at offset %d in handle %s',
-                           plural(length, 'byte'), offset, to_hex(handle))
+                           plural(length, 'byte'), offset, handle.hex())
 
         file_obj = self._file_handles.get(handle)
 
         if file_obj:
             result = self._server.read(file_obj, offset, length)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[bytes], result)
+
+            result: bytes
+
+            if self._version >= 6:
+                attr_result = self._server.fstat(file_obj)
+
+                if inspect.isawaitable(attr_result):
+                    attr_result = await cast(Awaitable[_SFTPOSAttrs],
+                                             attr_result)
+
+                if isinstance(attr_result, os.stat_result):
+                    attrs = SFTPAttrs.from_local(attr_result)
+                else:
+                    attrs = cast(SFTPAttrs, attr_result)
+
+                at_end = offset + len(result) == attrs.size
+            else:
+                at_end = False
 
             if result:
-                return result
+                return cast(bytes, result), at_end
             else:
                 raise SFTPEOFError
         else:
-            raise SFTPFailure('Invalid file handle')
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_write(self, packet):
+    async def _process_write(self, packet: SSHPacket) -> int:
         """Process an incoming SFTP write request"""
 
         handle = packet.get_string()
         offset = packet.get_uint64()
         data = packet.get_string()
-        packet.check_end()
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received write for %s at offset %d in handle %s',
-                           plural(len(data), 'byte'), offset, to_hex(handle))
+                           plural(len(data), 'byte'), offset, handle.hex())
 
         file_obj = self._file_handles.get(handle)
 
         if file_obj:
             result = self._server.write(file_obj, offset, data)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[int], result)
 
-            return result
+            return cast(int, result)
         else:
-            raise SFTPFailure('Invalid file handle')
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_lstat(self, packet):
+    async def _process_lstat(self, packet: SSHPacket) -> _SFTPOSAttrs:
         """Process an incoming SFTP lstat request"""
 
         path = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received lstat for %s', path)
+        flags = packet.get_uint32()if self._version >= 4 else 0
+
+        if self._version < 6:
+            packet.check_end()
+
+        self.logger.debug1('Received lstat for %s%s', path,
+                           ', flags=0x%08x' % flags if flags else '')
+
+        # Ignore flags for now, returning all available fields
 
         result = self._server.lstat(path)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[_SFTPOSAttrs], result)
+
+        result: _SFTPOSAttrs
 
         return result
 
-    async def _process_fstat(self, packet):
+    async def _process_fstat(self, packet: SSHPacket) -> _SFTPOSAttrs:
         """Process an incoming SFTP fstat request"""
 
         handle = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received fstat for handle %s', to_hex(handle))
+        flags = packet.get_uint32() if self._version >= 4 else 0
+
+        if self._version < 6:
+            packet.check_end()
+
+        self.logger.debug1('Received fstat for handle %s%s', handle.hex(),
+                           ', flags=0x%08x' % flags if flags else '')
 
         file_obj = self._file_handles.get(handle)
 
         if file_obj:
+            # Ignore flags for now, returning all available fields
             result = self._server.fstat(file_obj)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[_SFTPOSAttrs], result)
+
+            result: _SFTPOSAttrs
 
             return result
         else:
-            raise SFTPFailure('Invalid file handle')
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_setstat(self, packet):
+    async def _process_setstat(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP setstat request"""
 
         path = packet.get_string()
-        attrs = SFTPAttrs.decode(packet)
-        packet.check_end()
+        attrs = SFTPAttrs.decode(packet, self._version)
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received setstat for %s%s', path, hide_empty(attrs))
 
         result = self._server.setstat(path, attrs)
 
         if inspect.isawaitable(result):
-            result = await result
-
-        return result
+            assert result is not None
+            await result
 
-    async def _process_fsetstat(self, packet):
+    async def _process_fsetstat(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP fsetstat request"""
 
         handle = packet.get_string()
-        attrs = SFTPAttrs.decode(packet)
-        packet.check_end()
+        attrs = SFTPAttrs.decode(packet, self._version)
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received fsetstat for handle %s%s',
-                           to_hex(handle), hide_empty(attrs))
+                           handle.hex(), hide_empty(attrs))
 
         file_obj = self._file_handles.get(handle)
 
         if file_obj:
             result = self._server.fsetstat(file_obj, attrs)
 
             if inspect.isawaitable(result):
-                result = await result
-
-            return result
+                assert result is not None
+                await result
         else:
-            raise SFTPFailure('Invalid file handle')
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_opendir(self, packet):
+    async def _process_opendir(self, packet: SSHPacket) -> bytes:
         """Process an incoming SFTP opendir request"""
 
         path = packet.get_string()
-        packet.check_end()
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received opendir for %s', path)
 
         listdir_result = self._server.listdir(path)
 
         if inspect.isawaitable(listdir_result):
-            listdir_result = await listdir_result
+            listdir_result = await cast(Awaitable[Sequence[bytes]],
+                                        listdir_result)
+
+        listdir_result: Sequence[Union[bytes, SFTPName]]
+        entries = list(listdir_result)
 
-        for i, name in enumerate(listdir_result):
-            if isinstance(name, bytes):
-                name = SFTPName(name)
-                listdir_result[i] = name
+        for i, entry in enumerate(entries):
+            if isinstance(entry, bytes):
+                entries[i] = entry = SFTPName(entry)
 
-                # pylint: disable=no-member
-                filename = os.path.join(path, name.filename)
+                filename = os.path.join(path, cast(bytes, entry.filename))
                 attr_result = self._server.lstat(filename)
 
                 if inspect.isawaitable(attr_result):
-                    attr_result = await attr_result
+                    attr_result = await cast(Awaitable[_SFTPOSAttrs],
+                                             attr_result)
+
+                attr_result: _SFTPOSAttrs
 
                 if isinstance(attr_result, os.stat_result):
                     attr_result = SFTPAttrs.from_local(attr_result)
 
-                # pylint: disable=attribute-defined-outside-init
-                name.attrs = attr_result
+                attr_result: SFTPAttrs
+
+                entry.attrs = attr_result
 
-            if not name.longname:
-                longname_result = self._server.format_longname(name)
+            if not entry.longname and self._version == 3:
+                longname_result = self._server.format_longname(entry)
 
                 if inspect.isawaitable(longname_result):
+                    assert longname_result is not None
                     await longname_result
 
+        entries: List[SFTPName]
+
         handle = self._get_next_handle()
-        self._dir_handles[handle] = listdir_result
+        self._dir_handles[handle] = entries
         return handle
 
-    async def _process_readdir(self, packet):
+    async def _process_readdir(self, packet: SSHPacket) -> _SFTPNames:
         """Process an incoming SFTP readdir request"""
 
         handle = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received readdir for handle %s', to_hex(handle))
+        if self._version < 6:
+            packet.check_end()
+
+        self.logger.debug1('Received readdir for handle %s', handle.hex())
 
         names = self._dir_handles.get(handle)
         if names:
             result = names[:_MAX_READDIR_NAMES]
             del names[:_MAX_READDIR_NAMES]
-            return result
-        else:
+            return result, not names
+        elif names is not None:
             raise SFTPEOFError
+        else:
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_remove(self, packet):
+    async def _process_remove(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP remove request"""
 
         path = packet.get_string()
-        packet.check_end()
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received remove for %s', path)
 
         result = self._server.remove(path)
 
         if inspect.isawaitable(result):
-            result = await result
-
-        return result
+            assert result is not None
+            await result
 
-    async def _process_mkdir(self, packet):
+    async def _process_mkdir(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP mkdir request"""
 
         path = packet.get_string()
-        attrs = SFTPAttrs.decode(packet)
-        packet.check_end()
+        attrs = SFTPAttrs.decode(packet, self._version)
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received mkdir for %s', path)
 
         result = self._server.mkdir(path, attrs)
 
         if inspect.isawaitable(result):
-            result = await result
-
-        return result
+            assert result is not None
+            await result
 
-    async def _process_rmdir(self, packet):
+    async def _process_rmdir(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP rmdir request"""
 
         path = packet.get_string()
-        packet.check_end()
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received rmdir for %s', path)
 
         result = self._server.rmdir(path)
 
         if inspect.isawaitable(result):
-            result = await result
-
-        return result
+            assert result is not None
+            await result
 
-    async def _process_realpath(self, packet):
+    async def _process_realpath(self, packet: SSHPacket) -> _SFTPNames:
         """Process an incoming SFTP realpath request"""
 
         path = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received realpath for %s', path)
+        checkmsg = ''
+        compose_paths: List[bytes] = []
+
+        if self._version >= 6:
+            check = packet.get_byte()
+
+            while packet:
+                compose_paths.append(packet.get_string())
+
+            try:
+                checkmsg = ', check=%s' % self._realpath_check_names[check]
+            except KeyError:
+                raise SFTPInvalidParameter('Invalid check value') from None
+        else:
+            check = FXRP_NO_CHECK
+
+        self.logger.debug1('Received realpath for %s%s%s', path,
+                           b', compose_path: %s' % b', '.join(compose_paths)
+                           if compose_paths else b'', checkmsg)
+
+        for cpath in compose_paths:
+            path = posixpath.join(path, cpath)
 
         result = self._server.realpath(path)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[bytes], result)
+
+        result: bytes
 
-        return [SFTPName(result)]
+        attrs = SFTPAttrs()
 
-    async def _process_stat(self, packet):
+        if check != FXRP_NO_CHECK:
+            try:
+                attr_result = self._server.stat(result)
+
+                if inspect.isawaitable(attr_result):
+                    attr_result = await cast(Awaitable[_SFTPOSAttrs],
+                                             attr_result)
+
+                if isinstance(attr_result, os.stat_result):
+                    attrs = SFTPAttrs.from_local(attr_result)
+                else:
+                    attrs = cast(SFTPAttrs, attr_result)
+            except (OSError, SFTPError):
+                if check == FXRP_STAT_ALWAYS:
+                    raise
+
+        return [SFTPName(result, attrs=attrs)], False
+
+    async def _process_stat(self, packet: SSHPacket) -> _SFTPOSAttrs:
         """Process an incoming SFTP stat request"""
 
         path = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received stat for %s', path)
+        flags = packet.get_uint32() if self._version >= 4 else 0
+
+        if self._version < 6:
+            packet.check_end()
 
+        self.logger.debug1('Received stat for %s%s', path,
+                           ', flags=0x%08x' % flags if flags else '')
+
+        # Ignore flags for now, returning all available fields
         result = self._server.stat(path)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[_SFTPOSAttrs], result)
+
+        result: _SFTPOSAttrs
 
         return result
 
-    async def _process_rename(self, packet):
+    async def _process_rename(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP rename request"""
 
         oldpath = packet.get_string()
         newpath = packet.get_string()
-        packet.check_end()
 
-        self.logger.debug1('Received rename request from %s to %s',
-                           oldpath, newpath)
+        if self._version >= 5:
+            flags = packet.get_uint32()
+            flag_text = ', flags=0x%08x' % flags
+        else:
+            flags = 0
+            flag_text = ''
 
-        result = self._server.rename(oldpath, newpath)
+        if self._version < 6:
+            packet.check_end()
 
-        if inspect.isawaitable(result):
-            result = await result
+        self.logger.debug1('Received rename request from %s to %s%s',
+                           oldpath, newpath, flag_text)
 
-        return result
+        if flags:
+            result = self._server.posix_rename(oldpath, newpath)
+        else:
+            result = self._server.rename(oldpath, newpath)
 
-    async def _process_readlink(self, packet):
+        if inspect.isawaitable(result):
+            assert result is not None
+            await result
+
+    async def _process_readlink(self, packet: SSHPacket) -> _SFTPNames:
         """Process an incoming SFTP readlink request"""
 
         path = packet.get_string()
-        packet.check_end()
+
+        if self._version < 6:
+            packet.check_end()
 
         self.logger.debug1('Received readlink for %s', path)
 
         result = self._server.readlink(path)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[bytes], result)
+
+        result: bytes
 
-        return [SFTPName(result)]
+        return [SFTPName(result)], False
 
-    async def _process_symlink(self, packet):
+    async def _process_symlink(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP symlink request"""
 
         if self._nonstandard_symlink:
             oldpath = packet.get_string()
             newpath = packet.get_string()
         else:
             newpath = packet.get_string()
@@ -3953,108 +5945,176 @@
 
         self.logger.debug1('Received symlink request from %s to %s',
                            oldpath, newpath)
 
         result = self._server.symlink(oldpath, newpath)
 
         if inspect.isawaitable(result):
-            result = await result
+            assert result is not None
+            await result
 
-        return result
+    async def _process_link(self, packet: SSHPacket) -> None:
+        """Process an incoming SFTP hard link request"""
+
+        newpath = packet.get_string()
+        oldpath = packet.get_string()
+        symlink = packet.get_boolean()
+
+        if symlink:
+            self.logger.debug1('Received symlink request from %s to %s',
+                               oldpath, newpath)
+
+            result = self._server.symlink(oldpath, newpath)
+        else:
+            self.logger.debug1('Received hardlink request from %s to %s',
+                               oldpath, newpath)
+
+            result = self._server.link(oldpath, newpath)
+
+        if inspect.isawaitable(result):
+            assert result is not None
+            await result
+
+    async def _process_lock(self, packet: SSHPacket) -> None:
+        """Process an incoming SFTP byte range lock request"""
+
+        handle = packet.get_string()
+        offset = packet.get_uint64()
+        length = packet.get_uint64()
+        flags = packet.get_uint32()
+
+        self.logger.debug1('Received byte range lock request for '
+                           'handle %s, offset %d, length %d, '
+                           'flags 0x%04x', handle.hex(), offset,
+                           length, flags)
+
+        file_obj = self._file_handles.get(handle)
+
+        if file_obj:
+            result = self._server.lock(file_obj, offset, length, flags)
+
+            if inspect.isawaitable(result): # pragma: no branch
+                assert result is not None
+                await result
+        else:
+            raise SFTPInvalidHandle('Invalid file handle')
+
+    async def _process_unlock(self, packet: SSHPacket) -> None:
+        """Process an incoming SFTP byte range unlock request"""
+
+        handle = packet.get_string()
+        offset = packet.get_uint64()
+        length = packet.get_uint64()
+
+        self.logger.debug1('Received byte range lock request for '
+                           'handle %s, offset %d, length %d',
+                           handle.hex(), offset, length)
+
+        file_obj = self._file_handles.get(handle)
+
+        if file_obj:
+            result = self._server.unlock(file_obj, offset, length)
+
+            if inspect.isawaitable(result): # pragma: no branch
+                assert result is not None
+                await result
+        else:
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_posix_rename(self, packet):
+    async def _process_posix_rename(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP POSIX rename request"""
 
         oldpath = packet.get_string()
         newpath = packet.get_string()
         packet.check_end()
 
         self.logger.debug1('Received POSIX rename request from %s to %s',
                            oldpath, newpath)
 
         result = self._server.posix_rename(oldpath, newpath)
 
         if inspect.isawaitable(result):
-            result = await result
-
-        return result
+            assert result is not None
+            await result
 
-    async def _process_statvfs(self, packet):
+    async def _process_statvfs(self, packet: SSHPacket) -> _SFTPOSVFSAttrs:
         """Process an incoming SFTP statvfs request"""
 
         path = packet.get_string()
         packet.check_end()
 
         self.logger.debug1('Received statvfs for %s', path)
 
         result = self._server.statvfs(path)
 
         if inspect.isawaitable(result):
-            result = await result
+            result = await cast(Awaitable[_SFTPOSVFSAttrs], result)
+
+        result: _SFTPOSVFSAttrs
 
         return result
 
-    async def _process_fstatvfs(self, packet):
+    async def _process_fstatvfs(self, packet: SSHPacket) -> _SFTPOSVFSAttrs:
         """Process an incoming SFTP fstatvfs request"""
 
         handle = packet.get_string()
         packet.check_end()
 
-        self.logger.debug1('Received fstatvfs for handle %s', to_hex(handle))
+        self.logger.debug1('Received fstatvfs for handle %s', handle.hex())
 
         file_obj = self._file_handles.get(handle)
 
         if file_obj:
             result = self._server.fstatvfs(file_obj)
 
             if inspect.isawaitable(result):
-                result = await result
+                result = await cast(Awaitable[_SFTPOSVFSAttrs], result)
+
+            result: _SFTPOSVFSAttrs
 
             return result
         else:
-            raise SFTPFailure('Invalid file handle')
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    async def _process_link(self, packet):
+    async def _process_openssh_link(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP hard link request"""
 
         oldpath = packet.get_string()
         newpath = packet.get_string()
         packet.check_end()
 
         self.logger.debug1('Received hardlink request from %s to %s',
                            oldpath, newpath)
 
         result = self._server.link(oldpath, newpath)
 
         if inspect.isawaitable(result):
-            result = await result
-
-        return result
+            assert result is not None
+            await result
 
-    async def _process_fsync(self, packet):
+    async def _process_fsync(self, packet: SSHPacket) -> None:
         """Process an incoming SFTP fsync request"""
 
         handle = packet.get_string()
         packet.check_end()
 
-        self.logger.debug1('Received fsync for handle %s', to_hex(handle))
+        self.logger.debug1('Received fsync for handle %s', handle.hex())
 
         file_obj = self._file_handles.get(handle)
 
         if file_obj:
             result = self._server.fsync(file_obj)
 
             if inspect.isawaitable(result):
-                result = await result
-
-            return result
+                assert result is not None
+                await result
         else:
-            raise SFTPFailure('Invalid file handle')
+            raise SFTPInvalidHandle('Invalid file handle')
 
-    _packet_handlers = {
+    _packet_handlers: Dict[Union[int, bytes], _SFTPPacketHandler] = {
         FXP_OPEN:                     _process_open,
         FXP_CLOSE:                    _process_close,
         FXP_READ:                     _process_read,
         FXP_WRITE:                    _process_write,
         FXP_LSTAT:                    _process_lstat,
         FXP_FSTAT:                    _process_fstat,
         FXP_SETSTAT:                  _process_setstat,
@@ -4065,78 +6125,119 @@
         FXP_MKDIR:                    _process_mkdir,
         FXP_RMDIR:                    _process_rmdir,
         FXP_REALPATH:                 _process_realpath,
         FXP_STAT:                     _process_stat,
         FXP_RENAME:                   _process_rename,
         FXP_READLINK:                 _process_readlink,
         FXP_SYMLINK:                  _process_symlink,
+        FXP_LINK:                     _process_link,
+        FXP_BLOCK:                    _process_lock,
+        FXP_UNBLOCK:                  _process_unlock,
         b'posix-rename@openssh.com':  _process_posix_rename,
         b'statvfs@openssh.com':       _process_statvfs,
         b'fstatvfs@openssh.com':      _process_fstatvfs,
-        b'hardlink@openssh.com':      _process_link,
+        b'hardlink@openssh.com':      _process_openssh_link,
         b'fsync@openssh.com':         _process_fsync
     }
 
-    async def run(self):
+    async def run(self) -> None:
         """Run an SFTP server"""
 
+        assert self._reader is not None
+
         try:
             packet = await self.recv_packet()
-
             pkttype = packet.get_byte()
-
             self.log_received_packet(pkttype, None, packet)
 
-            version = packet.get_uint32()
+            if pkttype != FXP_INIT:
+                await self._cleanup(SFTPBadMessage('Expected init message'))
+                return
 
-            extensions = []
+            version = packet.get_uint32()
+            rcvd_extensions: List[Tuple[bytes, bytes]] = []
 
-            while packet:
-                name = packet.get_string()
-                data = packet.get_string()
-                extensions.append((name, data))
+            if version == 3:
+                while packet:
+                    name = packet.get_string()
+                    data = packet.get_string()
+                    rcvd_extensions.append((name, data))
+            else:
+                packet.check_end()
         except PacketDecodeError as exc:
             await self._cleanup(SFTPBadMessage(str(exc)))
             return
         except Error as exc:
             await self._cleanup(exc)
             return
 
-        if pkttype != FXP_INIT:
-            await self._cleanup(SFTPBadMessage('Expected init message'))
-            return
-
         self.logger.debug1('Received init, version=%d%s', version,
-                           ', extensions:' if extensions else '')
+                           ', extensions:' if rcvd_extensions else '')
 
-        for name, data in extensions:
-            self.logger.debug1('  %s: %s', name, data)
+        self._log_extensions(rcvd_extensions)
+
+        self._version = min(version, self._version)
+
+        extensions: List[Tuple[bytes, bytes]] = []
 
-        reply_version = min(version, _SFTP_VERSION)
+        ext_names = b''.join(String(name) for (name, _) in self._extensions)
 
-        self.logger.debug1('Sending version=%d%s', reply_version,
-                           ', extensions:' if self._extensions else '')
+        attrib_ext_names = b''.join(String(name) for name in
+                                    self._attrib_extensions)
 
-        for name, data in self._extensions:
-            self.logger.debug1('  %s: %s', name, data)
+        if self._version == 5:
+            supported = UInt32(self._supported_attr_mask) + \
+                        UInt32(self._supported_attrib_mask) + \
+                        UInt32(self._supported_open_flags) + \
+                        UInt32(self._supported_access_mask) + \
+                        UInt32(_MAX_SFTP_READ_SIZE) + ext_names + \
+                        attrib_ext_names
 
-        extensions = (String(name) + String(data)
-                      for name, data in self._extensions)
+            extensions.append((b'supported', supported))
+        elif self._version == 6:
+            acl_supported = UInt32(0) # No ACL support yet
+
+            supported2 = UInt32(self._supported_attr_mask) + \
+                         UInt32(self._supported_attrib_mask) + \
+                         UInt32(self._supported_open_flags) + \
+                         UInt32(self._supported_access_mask) + \
+                         UInt32(_MAX_SFTP_READ_SIZE) + \
+                         UInt16(self._supported_open_block_vector) + \
+                         UInt16(self._supported_block_vector) + \
+                         UInt32(len(self._attrib_extensions)) + \
+                         attrib_ext_names + \
+                         UInt32(len(self._extensions)) + \
+                         ext_names
+
+            extensions.append((b'acl-supported', acl_supported))
+            extensions.append((b'supported2', supported2))
+
+        extensions.extend(self._extensions)
+
+        self.logger.debug1('Sending version=%d%s', self._version,
+                           ', extensions:' if extensions else '')
+
+        self._log_extensions(extensions)
+
+        sent_extensions: Iterable[bytes] = \
+            (String(name) + String(data) for name, data in extensions)
 
         try:
-            self.send_packet(FXP_VERSION, None, UInt32(reply_version),
-                             *extensions)
+            self.send_packet(FXP_VERSION, None, UInt32(self._version),
+                             *sent_extensions)
         except SFTPError as exc:
             await self._cleanup(exc)
             return
 
-        if reply_version == 3:
-            # Check if the server has a buggy SYMLINK implementation
+        if self._version == 3:
+            # Check if the client has a buggy SYMLINK implementation
+
+            client_version = cast(str,
+                self._reader.get_extra_info('client_version', ''))
 
-            client_version = self._reader.get_extra_info('client_version', '')
             if any(name in client_version
                    for name in self._nonstandard_symlink_impls):
                 self.logger.debug1('Adjusting for non-standard symlink '
                                    'implementation')
                 self._nonstandard_symlink = True
 
         await self.recv_packets()
@@ -4175,58 +6276,58 @@
        :meth:`realpath` and :meth:`readlink` methods.
 
     """
 
     # The default implementation of a number of these methods don't need self
     # pylint: disable=no-self-use
 
-    def __init__(self, chan, chroot=None):
-        # pylint: disable=unused-argument
-
+    def __init__(self, chan: 'SSHServerChannel',
+                 chroot: Optional[bytes] = None):
         self._chan = chan
 
+        self._chroot: Optional[bytes]
+
         if chroot:
             self._chroot = _from_local_path(os.path.realpath(chroot))
         else:
             self._chroot = None
 
     @property
-    def channel(self):
+    def channel(self) -> 'SSHServerChannel':
         """The channel associated with this SFTP server session"""
 
         return self._chan
 
     @property
-    def connection(self):
+    def connection(self) -> 'SSHServerConnection':
         """The channel associated with this SFTP server session"""
 
-        return self._chan.get_connection()
+        return cast('SSHServerConnection', self._chan.get_connection())
 
     @property
-    def env(self):
+    def env(self) -> Mapping[str, str]:
         """The environment associated with this SFTP server session
 
            This method returns the environment set by the client
            when this SFTP session was opened.
 
            :returns: A dictionary containing the environment variables
                      set by the client
 
         """
 
-
         return self._chan.get_environment()
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this SFTP server"""
 
         return self._chan.logger
 
-    def format_user(self, uid):
+    def format_user(self, uid: Optional[int]) -> str:
         """Return the user name associated with a uid
 
            This method returns a user name string to insert into
            the `longname` field of an :class:`SFTPName` object.
 
            By default, it calls the Python :func:`pwd.getpwuid`
            function if it is available, or returns the numeric
@@ -4237,28 +6338,17 @@
                The uid value to look up
            :type uid: `int` or `None`
 
            :returns: The formatted user name string
 
         """
 
-        if uid is not None:
-            try:
-                # pylint: disable=import-outside-toplevel
-                import pwd
-                user = pwd.getpwuid(uid).pw_name
-            except (ImportError, KeyError):
-                user = str(uid)
-        else:
-            user = ''
-
-        return user
+        return _lookup_user(uid)
 
-
-    def format_group(self, gid):
+    def format_group(self, gid: Optional[int]) -> str:
         """Return the group name associated with a gid
 
            This method returns a group name string to insert into
            the `longname` field of an :class:`SFTPName` object.
 
            By default, it calls the Python :func:`grp.getgrgid`
            function if it is available, or returns the numeric
@@ -4269,28 +6359,17 @@
                The gid value to look up
            :type gid: `int` or `None`
 
            :returns: The formatted group name string
 
         """
 
-        if gid is not None:
-            try:
-                # pylint: disable=import-outside-toplevel
-                import grp
-                group = grp.getgrgid(gid).gr_name
-            except (ImportError, KeyError):
-                group = str(gid)
-        else:
-            group = ''
-
-        return group
+        return _lookup_group(gid)
 
-
-    def format_longname(self, name):
+    def format_longname(self, name: SFTPName) -> MaybeAwait[None]:
         """Format the long name associated with an SFTP name
 
            This method fills in the `longname` field of a
            :class:`SFTPName` object. By default, it generates
            something similar to UNIX "ls -l" output. The `filename`
            and `attrs` fields of the :class:`SFTPName` should
            already be filled in before this method is called.
@@ -4329,17 +6408,19 @@
                 modtime += time.strftime('  %Y', mtime)
         else:
             modtime = ''
 
         detail = '{:10s} {:>4s} {:8s} {:8s} {:>8s} {:12s} '.format(
             mode, nlink, user, group, size, modtime)
 
-        name.longname = detail.encode('utf-8') + name.filename
+        name.longname = detail.encode('utf-8') + cast(bytes, name.filename)
+
+        return None
 
-    def map_path(self, path):
+    def map_path(self, path: bytes) -> bytes:
         """Map the path requested by the client to a local path
 
            This method can be overridden to provide a custom mapping
            from path names requested by the client to paths in the local
            filesystem. By default, it will enforce a virtual "chroot"
            if one was specified when this server was created. Otherwise,
            path names are left unchanged, with relative paths being
@@ -4356,15 +6437,15 @@
 
         if self._chroot:
             normpath = posixpath.normpath(posixpath.join(b'/', path))
             return posixpath.join(self._chroot, normpath[1:])
         else:
             return path
 
-    def reverse_map_path(self, path):
+    def reverse_map_path(self, path: bytes) -> bytes:
         """Reverse map a local path into the path reported to the client
 
            This method can be overridden to provide a custom reverse
            mapping for the mapping provided by :meth:`map_path`. By
            default, it hides the portion of the local path associated
            with the virtual "chroot" if one was specified.
 
@@ -4382,15 +6463,16 @@
             elif path.startswith(self._chroot + b'/'):
                 return path[len(self._chroot):]
             else:
                 raise SFTPNoSuchFile('File not found')
         else:
             return path
 
-    def open(self, path, pflags, attrs):
+    def open(self, path: bytes, pflags: int, attrs: SFTPAttrs) -> \
+            MaybeAwait[object]:
         """Open a file to serve to a remote client
 
            This method returns a file object which can be used to read
            and write data and get and set file attributes.
 
            The possible open mode flags and their meanings are:
 
@@ -4455,34 +6537,137 @@
 
         if pflags & FXF_TRUNC:
             flags |= os.O_TRUNC
 
         if pflags & FXF_EXCL:
             flags |= os.O_EXCL
 
-        flags |= getattr(os, 'O_BINARY', 0)
+        try:
+            flags |= os.O_BINARY
+        except AttributeError: # pragma: no cover
+            pass
 
         perms = 0o666 if attrs.permissions is None else attrs.permissions
         return open(_to_local_path(self.map_path(path)), mode, buffering=0,
                     opener=lambda path, _: os.open(path, flags, perms))
 
-    def close(self, file_obj):
+    def open56(self, path: bytes, desired_access: int, flags: int,
+               attrs: SFTPAttrs) -> MaybeAwait[object]:
+        """Open a file to serve to a remote client (SFTPv5 and later)
+
+           This method returns a file object which can be used to read
+           and write data and get and set file attributes.
+
+           Supported desired_access bits include `ACE4_READ_DATA`,
+           `ACE4_WRITE_DATA`, `ACE4_APPEND_DATA`, `ACE4_READ_ATTRIBUTES`,
+           and `ACE4_WRITE_ATTRIBUTES`.
+
+           Supported disposition bits in flags and their meanings are:
+
+             ===================== ============================================
+             Disposition           Description
+             ===================== ============================================
+             FXF_OPEN_EXISTING     Open an existing file
+             FXF_OPEN_OR_CREATE    Open an existing file or create a new one
+             FXF_CREATE_NEW        Create a new file
+             FXF_CREATE_TRUNCATE   Create a new file or truncate an existing
+                                   one
+             FXF_TRUNCATE_EXISTING Truncate an existing file
+             ===================== ============================================
+
+           Other supported flag bits are:
+
+             ===================== ============================================
+             Flag                  Description
+             ===================== ============================================
+             FXF_APPEND_DATA       Append data writes to the end of the file
+             ===================== ============================================
+
+           The attrs argument is used to set initial attributes of the
+           file if it needs to be created. Otherwise, this argument is
+           ignored.
+
+           :param path:
+               The name of the file to open
+           :param desired_access:
+               The access mode to use for the file (see above)
+           :param flags:
+               The access flags to use for the file (see above)
+           :param attrs:
+               File attributes to use if the file needs to be created
+           :type path: `bytes`
+           :type desired_access: `int`
+           :type flags: `int`
+           :type attrs: :class:`SFTPAttrs`
+
+           :returns: A file object to use to access the file
+
+           :raises: :exc:`SFTPError` to return an error to the client
+
+        """
+
+        if desired_access & ACE4_READ_DATA and \
+                desired_access &  ACE4_WRITE_DATA:
+            open_flags = os.O_RDWR
+        elif desired_access & ACE4_WRITE_DATA:
+            open_flags = os.O_WRONLY
+        else:
+            open_flags = os.O_RDONLY
+
+        disp = flags & FXF_ACCESS_DISPOSITION
+
+        if disp == FXF_CREATE_NEW:
+            mode = 'xb'
+            open_flags |= os.O_CREAT | os.O_EXCL
+        elif disp == FXF_CREATE_TRUNCATE:
+            mode = 'wb'
+            open_flags |= os.O_CREAT | os.O_TRUNC
+        elif disp == FXF_OPEN_OR_CREATE:
+            mode = 'wb'
+            open_flags |= os.O_CREAT
+        elif disp == FXF_TRUNCATE_EXISTING:
+            mode = 'wb'
+            open_flags |= os.O_TRUNC
+        else:
+            mode = 'wb' if desired_access & ACE4_WRITE_DATA else 'rb'
+
+        if desired_access & ACE4_APPEND_DATA or flags & FXF_APPEND_DATA:
+            mode = 'ab'
+            open_flags |= os.O_APPEND
+
+        if desired_access & ACE4_READ_DATA and \
+                desired_access & ACE4_WRITE_DATA:
+            mode += '+'
+
+        try:
+            open_flags |= os.O_BINARY
+        except AttributeError: # pragma: no cover
+            pass
+
+        perms = 0o666 if attrs.permissions is None else attrs.permissions
+        return open(_to_local_path(self.map_path(path)), mode, buffering=0,
+                    opener=lambda path, _: os.open(path, open_flags, perms))
+
+    def close(self, file_obj: object) -> MaybeAwait[None]:
         """Close an open file or directory
 
            :param file_obj:
                The file or directory object to close
            :type file_obj: file
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
         file_obj.close()
+        return None
 
-    def read(self, file_obj, offset, size):
+    def read(self, file_obj: object, offset: int, size: int) -> \
+            MaybeAwait[bytes]:
         """Read data from an open file
 
            :param file_obj:
                The file to read from
            :param offset:
                The offset from the beginning of the file to begin reading
            :param size:
@@ -4493,18 +6678,20 @@
 
            :returns: bytes read from the file
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
         file_obj.seek(offset)
         return file_obj.read(size)
 
-    def write(self, file_obj, offset, data):
+    def write(self, file_obj: object, offset: int, data: bytes) -> \
+            MaybeAwait[int]:
         """Write data to an open file
 
            :param file_obj:
                The file to write to
            :param offset:
                The offset from the beginning of the file to begin writing
            :param data:
@@ -4515,18 +6702,19 @@
 
            :returns: number of bytes written
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
         file_obj.seek(offset)
         return file_obj.write(data)
 
-    def lstat(self, path):
+    def lstat(self, path: bytes) -> MaybeAwait[_SFTPOSAttrs]:
         """Get attributes of a file, directory, or symlink
 
            This method queries the attributes of a file, directory,
            or symlink. Unlike :meth:`stat`, this method should
            return the attributes of a symlink itself rather than
            the target of that link.
 
@@ -4539,32 +6727,33 @@
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         return os.lstat(_to_local_path(self.map_path(path)))
 
-    def fstat(self, file_obj):
+    def fstat(self, file_obj: object) -> MaybeAwait[_SFTPOSAttrs]:
         """Get attributes of an open file
 
            :param file_obj:
                The file to get attributes for
            :type file_obj: file
 
            :returns: An :class:`SFTPAttrs` or an os.stat_result containing
                      the file attributes
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
         file_obj.flush()
         return os.fstat(file_obj.fileno())
 
-    def setstat(self, path, attrs):
+    def setstat(self, path: bytes, attrs: SFTPAttrs) -> MaybeAwait[None]:
         """Set attributes of a file or directory
 
            This method sets attributes of a file or directory. If
            the path provided is a symbolic link, the attributes
            should be set on the target of the link. A subset of the
            fields in `attrs` can be initialized and only those
            attributes should be changed.
@@ -4577,70 +6766,80 @@
            :type attrs: :class:`SFTPAttrs`
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         _setstat(_to_local_path(self.map_path(path)), attrs)
+        return None
 
-    def fsetstat(self, file_obj, attrs):
+    def fsetstat(self, file_obj: object, attrs: SFTPAttrs) -> MaybeAwait[None]:
         """Set attributes of an open file
 
            :param file_obj:
                The file to set attributes for
            :param attrs:
                File attributes to set on the file
            :type file_obj: file
            :type attrs: :class:`SFTPAttrs`
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
         file_obj.flush()
 
         if sys.platform == 'win32': # pragma: no cover
             _setstat(file_obj.name, attrs)
         else:
             _setstat(file_obj.fileno(), attrs)
 
-    def listdir(self, path):
+        return None
+
+    def listdir(self, path: bytes) -> \
+            MaybeAwait[Sequence[Union[bytes, SFTPName]]]:
         """List the contents of a directory
 
            :param path:
                The path of the directory to open
            :type path: `bytes`
 
-           :returns: A list of names of files in the directory
+           :returns: A list of names of files in the directory or
+                     :class:`SFTPName` objects containing file names
+                     and attributes
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         files = os.listdir(_to_local_path(self.map_path(path)))
 
         if sys.platform == 'win32': # pragma: no cover
             files = [os.fsencode(f) for f in files]
 
+        files: List[bytes]
+
         return [b'.', b'..'] + files
 
-    def remove(self, path):
+    def remove(self, path: bytes) -> MaybeAwait[None]:
         """Remove a file or symbolic link
 
            :param path:
                The path of the file or link to remove
            :type path: `bytes`
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         os.remove(_to_local_path(self.map_path(path)))
+        return None
 
-    def mkdir(self, path, attrs):
+    def mkdir(self, path: bytes, attrs: SFTPAttrs) -> MaybeAwait[None]:
         """Create a directory with the specified attributes
 
            :param path:
                The path of where the new directory should be created
            :param attrs:
                The file attributes to use when creating the directory
            :type path: `bytes`
@@ -4648,29 +6847,31 @@
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         mode = 0o777 if attrs.permissions is None else attrs.permissions
         os.mkdir(_to_local_path(self.map_path(path)), mode)
+        return None
 
-    def rmdir(self, path):
+    def rmdir(self, path: bytes) -> MaybeAwait[None]:
         """Remove a directory
 
            :param path:
                The path of the directory to remove
            :type path: `bytes`
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         os.rmdir(_to_local_path(self.map_path(path)))
+        return None
 
-    def realpath(self, path):
+    def realpath(self, path: bytes) -> MaybeAwait[bytes]:
         """Return the canonical version of a path
 
            :param path:
                The path of the directory to canonicalize
            :type path: `bytes`
 
            :returns: bytes containing the canonical path
@@ -4678,15 +6879,15 @@
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         path = os.path.realpath(_to_local_path(self.map_path(path)))
         return self.reverse_map_path(_from_local_path(path))
 
-    def stat(self, path):
+    def stat(self, path: bytes) -> MaybeAwait[_SFTPOSAttrs]:
         """Get attributes of a file or directory, following symlinks
 
            This method queries the attributes of a file or directory.
            If the path provided is a symbolic link, the returned
            attributes should correspond to the target of the link.
 
            :param path:
@@ -4698,15 +6899,15 @@
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         return os.stat(_to_local_path(self.map_path(path)))
 
-    def rename(self, oldpath, newpath):
+    def rename(self, oldpath: bytes, newpath: bytes) -> MaybeAwait[None]:
         """Rename a file, directory, or link
 
            This method renames a file, directory, or link.
 
            .. note:: This is a request for the standard SFTP version
                      of rename which will not overwrite the new path
                      if it already exists. The :meth:`posix_rename`
@@ -4725,19 +6926,20 @@
 
         """
 
         oldpath = _to_local_path(self.map_path(oldpath))
         newpath = _to_local_path(self.map_path(newpath))
 
         if os.path.exists(newpath):
-            raise SFTPFailure('File already exists')
+            raise SFTPFileAlreadyExists('File already exists')
 
         os.rename(oldpath, newpath)
+        return None
 
-    def readlink(self, path):
+    def readlink(self, path: bytes) -> MaybeAwait[bytes]:
         """Return the target of a symbolic link
 
            :param path:
                The path of the symbolic link to follow
            :type path: `bytes`
 
            :returns: bytes containing the target path of the link
@@ -4745,15 +6947,15 @@
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
         path = os.readlink(_to_local_path(self.map_path(path)))
         return self.reverse_map_path(_from_local_path(path))
 
-    def symlink(self, oldpath, newpath):
+    def symlink(self, oldpath: bytes, newpath: bytes) -> MaybeAwait[None]:
         """Create a symbolic link
 
            :param oldpath:
                The path the link should point to
            :param newpath:
                The path of where to create the symbolic link
            :type oldpath: `bytes`
@@ -4775,16 +6977,49 @@
             # Make sure the symlink doesn't point outside the chroot
             if os.path.realpath(abspath1) != os.path.realpath(abspath2):
                 oldpath = os.path.relpath(abspath1, start=mapped_newdir)
 
         newpath = self.map_path(newpath)
 
         os.symlink(_to_local_path(oldpath), _to_local_path(newpath))
+        return None
+
+    def link(self, oldpath: bytes, newpath: bytes) -> MaybeAwait[None]:
+        """Create a hard link
+
+           :param oldpath:
+               The path of the file the hard link should point to
+           :param newpath:
+               The path of where to create the hard link
+           :type oldpath: `bytes`
+           :type newpath: `bytes`
+
+           :raises: :exc:`SFTPError` to return an error to the client
+
+        """
+
+        oldpath = _to_local_path(self.map_path(oldpath))
+        newpath = _to_local_path(self.map_path(newpath))
+
+        os.link(oldpath, newpath)
+        return None
+
+    def lock(self, file_obj: object, offset: int, length: int,
+             flags: int) -> MaybeAwait[None]:
+        """Acquire a byte range lock on an open file"""
+
+        raise SFTPOpUnsupported('Byte range locks not supported')
+
+    def unlock(self, file_obj: object, offset: int,
+               length: int) -> MaybeAwait[None]:
+        """Release a byte range lock on an open file"""
 
-    def posix_rename(self, oldpath, newpath):
+        raise SFTPOpUnsupported('Byte range locks not supported')
+
+    def posix_rename(self, oldpath: bytes, newpath: bytes) -> MaybeAwait[None]:
         """Rename a file, directory, or link with POSIX semantics
 
            This method renames a file, directory, or link, removing
            the prior instance of new path if it previously existed.
 
            :param oldpath:
                The path of the file, directory, or link to rename
@@ -4797,16 +7032,17 @@
 
         """
 
         oldpath = _to_local_path(self.map_path(oldpath))
         newpath = _to_local_path(self.map_path(newpath))
 
         os.replace(oldpath, newpath)
+        return None
 
-    def statvfs(self, path):
+    def statvfs(self, path: bytes) -> MaybeAwait[_SFTPOSVFSAttrs]:
         """Get attributes of the file system containing a file
 
            :param path:
                The path of the file system to get attributes for
            :type path: `bytes`
 
            :returns: An :class:`SFTPVFSAttrs` or an os.statvfs_result
@@ -4817,201 +7053,349 @@
         """
 
         try:
             return os.statvfs(_to_local_path(self.map_path(path)))
         except AttributeError: # pragma: no cover
             raise SFTPOpUnsupported('statvfs not supported') from None
 
-    def fstatvfs(self, file_obj):
+    def fstatvfs(self, file_obj: object) -> MaybeAwait[_SFTPOSVFSAttrs]:
         """Return attributes of the file system containing an open file
 
            :param file_obj:
                The open file to get file system attributes for
            :type file_obj: file
 
            :returns: An :class:`SFTPVFSAttrs` or an os.statvfs_result
                      containing the file system attributes
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
+
         try:
             return os.statvfs(file_obj.fileno())
         except AttributeError: # pragma: no cover
             raise SFTPOpUnsupported('fstatvfs not supported') from None
 
-    def link(self, oldpath, newpath):
-        """Create a hard link
-
-           :param oldpath:
-               The path of the file the hard link should point to
-           :param newpath:
-               The path of where to create the hard link
-           :type oldpath: `bytes`
-           :type newpath: `bytes`
-
-           :raises: :exc:`SFTPError` to return an error to the client
-
-        """
-
-        oldpath = _to_local_path(self.map_path(oldpath))
-        newpath = _to_local_path(self.map_path(newpath))
-
-        os.link(oldpath, newpath)
-
-    def fsync(self, file_obj):
+    def fsync(self, file_obj: object) -> MaybeAwait[None]:
         """Force file data to be written to disk
 
            :param file_obj:
                The open file containing the data to flush to disk
            :type file_obj: file
 
            :raises: :exc:`SFTPError` to return an error to the client
 
         """
 
+        file_obj = cast(_SFTPFileObj, file_obj)
         os.fsync(file_obj.fileno())
+        return None
 
-    def exit(self):
+    def exit(self) -> MaybeAwait[None]:
         """Shut down this SFTP server"""
 
+        return None
 
-class SFTPServerFile:
-    """A wrapper around SFTPServer used to access files it manages"""
+class LocalFile:
+    """An async wrapper around local file I/O"""
 
-    def __init__(self, server):
-        self._server = server
-        self._file_obj = None
+    def __init__(self, file: _SFTPFileObj):
+        self._file = file
 
-    @classmethod
-    def basename(cls, path):
-        """Return the final component of a POSIX-style path"""
+    async def __aenter__(self) -> 'SFTPFileProtocol':
+        """Allow LocalFile to be used as an async context manager"""
 
-        return posixpath.basename(path)
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
+        """Wait for file close when used as an async context manager"""
 
-    async def stat(self, path):
-        """Get attributes of a file"""
+    async def read(self, size: int, offset: int) -> bytes:
+        """Read data from the local file"""
 
-        attrs = self._server.stat(path)
+        self._file.seek(offset)
+        return self._file.read(size)
 
-        if inspect.isawaitable(attrs):
-            attrs = await attrs
+    async def write(self, data: bytes, offset: int) -> int:
+        """Write data to the local file"""
 
-        if isinstance(attrs, os.stat_result):
-            attrs = SFTPAttrs.from_local(attrs)
+        self._file.seek(offset)
+        return self._file.write(data)
 
-        return attrs
+    async def close(self) -> None:
+        """Close the local file"""
 
-    async def setstat(self, path, attrs):
-        """Set attributes of a file or directory"""
+        self._file.close()
 
-        result = self._server.setstat(path, attrs)
 
-        if inspect.isawaitable(result):
-            attrs = await result
+class LocalFS:
+    """An async wrapper around local filesystem access"""
 
-    async def _mode(self, path):
-        """Return the file mode of a path, or 0 if it can't be accessed"""
+    @staticmethod
+    def basename(path: bytes) -> bytes:
+        """Return the final component of a local file path"""
 
-        try:
-            return (await self.stat(path)).permissions
-        except OSError as exc:
-            if exc.errno in (errno.ENOENT, errno.EACCES):
-                return 0
-            else:
-                raise
-        except (SFTPNoSuchFile, SFTPPermissionDenied):
-            return 0
+        return os.path.basename(path)
 
-    async def exists(self, path):
-        """Return if a path exists"""
+    def encode(self, path: _SFTPPath) -> bytes:
+        """Encode path name using filesystem native encoding
 
-        return (await self._mode(path)) != 0
+           This method has no effect if the path is already bytes.
 
-    async def isdir(self, path):
-        """Return if the path refers to a directory"""
+        """
 
-        return stat.S_ISDIR((await self._mode(path)))
+        # pylint: disable=no-self-use
 
-    async def mkdir(self, path):
-        """Create a directory"""
+        return os.fsencode(path)
 
-        result = self._server.mkdir(path, SFTPAttrs())
+    def compose_path(self, path: bytes,
+                     parent: Optional[bytes] = None) -> bytes:
+        """Compose a path
 
-        if inspect.isawaitable(result):
-            await result
+           If parent is not specified, just encode the path.
 
-    async def listdir(self, path):
-        """List the contents of a directory"""
+        """
 
-        files = self._server.listdir(path)
+        path = self.encode(path)
 
-        if inspect.isawaitable(files):
-            files = await files
+        return posixpath.join(parent, path) if parent else path
+
+    async def stat(self, path: bytes) -> 'SFTPAttrs':
+        """Get attributes of a local file or directory, following symlinks"""
+
+        return SFTPAttrs.from_local(os.stat(_to_local_path(path)))
+
+    async def lstat(self, path: bytes) -> 'SFTPAttrs':
+        """Get attributes of a local file, directory, or symlink"""
+
+        return SFTPAttrs.from_local(os.lstat(_to_local_path(path)))
+
+    async def setstat(self, path: bytes, attrs: 'SFTPAttrs') -> None:
+        """Set attributes of a local file or directory"""
+
+        _setstat(_to_local_path(path), attrs)
+
+    async def exists(self, path: bytes) -> bool:
+        """Return if the local path exists and isn't a broken symbolic link"""
+
+        return os.path.exists(_to_local_path(path))
+
+    async def isdir(self, path: bytes) -> bool:
+        """Return if the local path refers to a directory"""
+
+        return os.path.isdir(_to_local_path(path))
+
+    async def listdir(self, path: bytes) -> Sequence[bytes]:
+        """Read the names of the files in a local directory"""
+
+        files = os.listdir(_to_local_path(path))
+
+        if sys.platform == 'win32': # pragma: no cover
+            files = [os.fsencode(f) for f in files]
 
         return files
 
-    async def open(self, path, mode='rb'):
-        """Open a file"""
+    async def mkdir(self, path: bytes) -> None:
+        """Create a local directory with the specified attributes"""
 
-        pflags, _ = _mode_to_pflags(mode)
-        file_obj = self._server.open(path, pflags, SFTPAttrs())
+        os.mkdir(_to_local_path(path))
 
-        if inspect.isawaitable(file_obj):
-            file_obj = await file_obj
+    async def readlink(self, path: bytes) -> bytes:
+        """Return the target of a local symbolic link"""
 
+        return _from_local_path(os.readlink(_to_local_path(path)))
+
+    async def symlink(self, oldpath: bytes, newpath: bytes) -> None:
+        """Create a local symbolic link"""
+
+        os.symlink(_to_local_path(oldpath), _to_local_path(newpath))
+
+    @async_context_manager
+    async def open(self, path: bytes, mode: str) -> SFTPFileProtocol:
+        """Open a local file"""
+
+        # pylint: disable=unused-argument
+
+        return LocalFile(open(_to_local_path(path), mode))
+
+local_fs = LocalFS()
+
+
+class SFTPServerFile:
+    """A wrapper around SFTPServer used to access files it manages"""
+
+    def __init__(self, server: SFTPServer, file_obj: object):
+        self._server = server
         self._file_obj = file_obj
+
+    async def __aenter__(self) -> 'SFTPServerFile': # pragma: no cover
+        """Allow SFTPServerFile to be used as an async context manager"""
+
         return self
 
-    async def read(self, size, offset):
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> \
+            bool: # pragma: no cover
+        """Wait for client close when used as an async context manager"""
+
+        return False
+
+    async def read(self, size: int, offset: int) -> bytes:
         """Read bytes from the file"""
 
         data = self._server.read(self._file_obj, offset, size)
 
         if inspect.isawaitable(data):
-            data = await data
+            data = await cast(Awaitable[bytes], data)
+
+        data: bytes
 
         return data
 
-    async def write(self, data, offset):
+    async def write(self, data: bytes, offset: int) -> int:
         """Write bytes to the file"""
 
         size = self._server.write(self._file_obj, offset, data)
 
         if inspect.isawaitable(size):
-            size = await size
+            size = await cast(Awaitable[int], size)
+
+        size: int
 
         return size
 
-    async def close(self):
+    async def close(self) -> None:
         """Close a file managed by the associated SFTPServer"""
 
         result = self._server.close(self._file_obj)
 
         if inspect.isawaitable(result):
+            assert result is not None
+            await result
+
+
+class SFTPServerFS:
+    """A wrapper around SFTPServer used to access its filesystem"""
+
+    def __init__(self, server: SFTPServer):
+        self._server = server
+
+    @staticmethod
+    def basename(path: bytes) -> bytes:
+        """Return the final component of a POSIX-style path"""
+
+        return posixpath.basename(path)
+
+    async def stat(self, path: bytes) -> SFTPAttrs:
+        """Get attributes of a file or directory, following symlinks"""
+
+        attrs = self._server.stat(path)
+
+        if inspect.isawaitable(attrs):
+            attrs = await cast(Awaitable[_SFTPOSAttrs], attrs)
+
+        attrs: _SFTPOSAttrs
+
+        if isinstance(attrs, os.stat_result):
+            attrs = SFTPAttrs.from_local(attrs)
+
+        return attrs
+
+    async def setstat(self, path: bytes, attrs: SFTPAttrs) -> None:
+        """Set attributes of a file or directory"""
+
+        result = self._server.setstat(path, attrs)
+
+        if inspect.isawaitable(result):
+            assert result is not None
             await result
 
+    async def _type(self, path: bytes) -> int:
+        """Return the file type of a path, or 0 if it can't be accessed"""
+
+        try:
+            return (await self.stat(path)).type
+        except OSError as exc:
+            if exc.errno in (errno.ENOENT, errno.EACCES):
+                return FILEXFER_TYPE_UNKNOWN
+            else:
+                raise
+        except (SFTPNoSuchFile, SFTPNoSuchPath, SFTPPermissionDenied):
+            return FILEXFER_TYPE_UNKNOWN
+
+    async def exists(self, path: bytes) -> bool:
+        """Return if a path exists"""
+
+        return (await self._type(path)) != FILEXFER_TYPE_UNKNOWN
+
+    async def isdir(self, path: bytes) -> bool:
+        """Return if the path refers to a directory"""
+
+        return (await self._type(path)) == FILEXFER_TYPE_DIRECTORY
+
+    async def listdir(self, path: bytes) -> Sequence[bytes]:
+        """List the contents of a directory"""
+
+        files = self._server.listdir(path)
+
+        if inspect.isawaitable(files):
+            files = await cast(Awaitable[Sequence[bytes]], files)
+
+        files: Sequence[bytes]
+
+        return files
+
+    async def mkdir(self, path: bytes) -> None:
+        """Create a directory"""
+
+        result = self._server.mkdir(path, SFTPAttrs())
+
+        if inspect.isawaitable(result):
+            assert result is not None
+            await result
+
+    @async_context_manager
+    async def open(self, path: bytes, mode: str) -> SFTPFileProtocol:
+        """Open a file"""
+
+        pflags, _ = _mode_to_pflags(mode)
+        file_obj = self._server.open(path, pflags, SFTPAttrs())
+
+        if inspect.isawaitable(file_obj):
+            file_obj = await cast(Awaitable[object], file_obj)
+
+        return SFTPServerFile(self._server, file_obj)
+
 
-async def start_sftp_client(conn, loop, reader, writer,
-                            path_encoding, path_errors):
+async def start_sftp_client(conn: 'SSHClientConnection',
+                            loop: asyncio.AbstractEventLoop,
+                            reader: 'SSHReader[bytes]',
+                            writer: 'SSHWriter[bytes]',
+                            path_encoding: Optional[str],
+                            path_errors: str, sftp_version: int) -> SFTPClient:
     """Start an SFTP client"""
 
-    handler = SFTPClientHandler(loop, reader, writer)
+    handler = SFTPClientHandler(loop, reader, writer, sftp_version)
 
     handler.logger.info('Starting SFTP client')
 
     await handler.start()
 
     conn.create_task(handler.recv_packets(), handler.logger)
 
     return SFTPClient(handler, path_encoding, path_errors)
 
 
-def run_sftp_server(sftp_server, reader, writer):
+def run_sftp_server(sftp_server: SFTPServer, reader: 'SSHReader[bytes]',
+                    writer: 'SSHWriter[bytes]',
+                    sftp_version: int) -> Awaitable[None]:
     """Return a handler for an SFTP server session"""
 
-    handler = SFTPServerHandler(sftp_server, reader, writer)
+    handler = SFTPServerHandler(sftp_server, reader, writer, sftp_version)
 
     handler.logger.info('Starting SFTP server')
 
     return handler.run()
```

### Comparing `asyncssh-2.8.1/asyncssh/editor.py` & `asyncssh-2.9.0/asyncssh/editor.py`

 * *Files 6% similar despite different names*

```diff
@@ -19,36 +19,52 @@
 #     Ron Frederick - initial implementation, API, and documentation
 
 """Input line editor"""
 
 import re
 
 from functools import partial
+from typing import TYPE_CHECKING, Callable, Dict, List
+from typing import Optional, Set, Tuple, Union, cast
 from unicodedata import east_asian_width
 
+from .session import DataType
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHServerChannel
+    from .session import SSHServerSession
+
+
+_CharDict = Dict[str, object]
+_CharHandler = Callable[['SSHLineEditor'], None]
+_KeyHandler = Callable[[str, int], Union[bool, Tuple[str, int]]]
+
 
 _DEFAULT_WIDTH = 80
 
 _ansi_terminals = ('ansi', 'cygwin', 'linux', 'putty', 'screen', 'teraterm',
                    'cit80', 'vt100', 'vt102', 'vt220', 'vt320', 'xterm',
                    'xterm-color', 'xterm-16color', 'xterm-256color', 'rxvt',
                    'rxvt-color')
 
 
-def _is_wide(ch):
+def _is_wide(ch: str) -> bool:
     """Return display width of character"""
 
     return east_asian_width(ch) in 'WF'
 
 
 class SSHLineEditor:
     """Input line editor"""
 
-    def __init__(self, chan, session, history_size, max_line_length,
-                 term_type, width):
+    def __init__(self, chan: 'SSHServerChannel[str]',
+                 session: 'SSHServerSession[str]', history_size: int,
+                 max_line_length: int, term_type: str, width: int):
         self._chan = chan
         self._session = session
         self._history_size = history_size if history_size > 0 else 0
         self._max_line_length = max_line_length
         self._wrap = term_type in _ansi_terminals
         self._width = width or _DEFAULT_WIDTH
         self._line_mode = True
@@ -57,69 +73,69 @@
         self._end_column = 0
         self._cursor = 0
         self._left_pos = 0
         self._right_pos = 0
         self._pos = 0
         self._line = ''
         self._bell_rung = False
-        self._early_wrap = set()
-        self._outbuf = []
-        self._keymap = {}
+        self._early_wrap: Set[int] = set()
+        self._outbuf: List[str] = []
+        self._keymap: _CharDict = {}
         self._key_state = self._keymap
         self._erased = ''
-        self._history = []
+        self._history: List[str] = []
         self._history_index = 0
 
         for func, keys in self._keylist:
             for key in keys:
                 self._add_key(key, func)
 
         self._build_printable()
 
-    def _add_key(self, key, func):
+    def _add_key(self, key: str, func: _CharHandler) -> None:
         """Add a key to the keymap"""
 
         keymap = self._keymap
 
         for ch in key[:-1]:
             if ch not in keymap:
                 keymap[ch] = {}
 
-            keymap = keymap[ch]
+            keymap = cast(_CharDict, keymap[ch])
 
         keymap[key[-1]] = func
 
-    def _del_key(self, key):
+    def _del_key(self, key: str) -> None:
         """Delete a key from the keymap"""
 
         keymap = self._keymap
 
         for ch in key[:-1]:
             if ch not in keymap:
                 return
 
-            keymap = keymap[ch]
+            keymap = cast(_CharDict, keymap[ch])
 
         keymap.pop(key[-1], None)
 
-    def _build_printable(self):
+    def _build_printable(self) -> None:
         """Build a regex of printable ASCII non-registered keys"""
 
-        def _escape(c):
+        def _escape(c: int) -> str:
             """Backslash escape special characters in regex character range"""
 
             ch = chr(c)
             return ('\\' if (ch in '-&|[]\\^~') else '') + ch
 
-        def _is_printable(ch):
+        def _is_printable(ch: str) -> bool:
             """Return if character is printable and has no handler"""
 
             return ch.isprintable() and ch not in keys
 
-        pat = []
+        pat: List[str] = []
         keys = self._keymap.keys()
         start = ord(' ')
         limit = 0x10000
 
         while start < limit:
             while start < limit and not _is_printable(chr(start)):
                 start += 1
@@ -134,34 +150,38 @@
             if start != end - 1:
                 pat.append('-' + _escape(end - 1))
 
             start = end + 1
 
         self._printable = re.compile('[' + ''.join(pat) + ']*')
 
-    def _char_width(self, pos):
+    def _char_width(self, pos: int) -> int:
         """Return width of character at specified position"""
 
         return 1 + _is_wide(self._line[pos]) + ((pos + 1) in self._early_wrap)
 
-    def _determine_column(self, data, column, pos=None):
+    def _determine_column(self, data: str, column: int,
+                          pos: Optional[int] = None) -> Tuple[str, int]:
         """Determine new output column after output occurs"""
 
         offset = pos
         last_wrap_pos = pos
         wrapped_data = []
 
         for ch in data:
             if ch == '\b':
                 column -= 1
             else:
                 if _is_wide(ch) and (column % self._width) == self._width - 1:
                     column += 1
 
                     if pos is not None:
+                        assert last_wrap_pos is not None
+                        assert offset is not None
+
                         wrapped_data.append(data[last_wrap_pos - offset:
                                                  pos - offset])
                         last_wrap_pos = pos
 
                         self._early_wrap.add(pos)
                 else:
                     if pos is not None:
@@ -169,20 +189,23 @@
 
                 column += 1 + _is_wide(ch)
 
             if pos is not None:
                 pos += 1
 
         if pos is not None:
-            wrapped_data.append(data[last_wrap_pos-offset:])
+            assert last_wrap_pos is not None
+            assert offset is not None
+
+            wrapped_data.append(data[last_wrap_pos - offset:])
             return ' '.join(wrapped_data), column
         else:
             return data, column
 
-    def _output(self, data, pos=None):
+    def _output(self, data: str, pos: Optional[int] = None) -> None:
         """Generate output and calculate new output column"""
 
         idx = data.rfind('\n')
 
         if idx >= 0:
             self._outbuf.append(data[:idx+1])
             tail = data[idx+1:]
@@ -193,22 +216,22 @@
         data, self._cursor = self._determine_column(tail, self._cursor, pos)
 
         self._outbuf.append(data)
 
         if self._cursor and self._cursor % self._width == 0:
             self._outbuf.append(' \b')
 
-    def _ring_bell(self):
+    def _ring_bell(self) -> None:
         """Ring the terminal bell"""
 
         if not self._bell_rung:
             self._outbuf.append('\a')
             self._bell_rung = True
 
-    def _update_input_window(self, new_pos):
+    def _update_input_window(self, new_pos: int) -> int:
         """Update visible input window when not wrapping onto multiple lines"""
 
         line_len = len(self._line)
 
         if new_pos < self._left_pos:
             self._left_pos = new_pos
         else:
@@ -245,15 +268,15 @@
                 self._right_pos += 1
                 column += ch_width
             else:
                 break
 
         return column
 
-    def _move_cursor(self, column):
+    def _move_cursor(self, column: int) -> None:
         """Move the cursor to selected position in input line"""
 
         start_row = self._cursor // self._width
         start_col = self._cursor % self._width
 
         end_row = column // self._width
         end_col = column % self._width
@@ -266,24 +289,24 @@
         if end_col > start_col:
             self._outbuf.append('\x1b[' + str(end_col-start_col) + 'C')
         elif end_col < start_col:
             self._outbuf.append('\x1b[' + str(start_col-end_col) + 'D')
 
         self._cursor = column
 
-    def _move_back(self, column):
+    def _move_back(self, column: int) -> None:
         """Move the cursor backward to selected position in input line"""
 
         if self._wrap:
             self._move_cursor(column)
         else:
             self._outbuf.append('\b' * (self._cursor - column))
             self._cursor = column
 
-    def _clear_to_end(self):
+    def _clear_to_end(self) -> None:
         """Clear any remaining characters from previous input line"""
 
         column = self._cursor
         remaining = self._end_column - column
 
         if remaining > 0:
             self._outbuf.append(' ' * remaining)
@@ -291,22 +314,22 @@
 
             if self._cursor % self._width == 0:
                 self._outbuf.append(' \b')
 
         self._move_back(column)
         self._end_column = column
 
-    def _erase_input(self):
+    def _erase_input(self) -> None:
         """Erase current input line"""
 
         self._move_cursor(self._start_column)
         self._clear_to_end()
         self._early_wrap.clear()
 
-    def _draw_input(self):
+    def _draw_input(self) -> None:
         """Draw current input line"""
 
         if self._line and self._echo:
             if self._wrap:
                 self._output(self._line[:self._pos], 0)
                 column = self._cursor
                 self._output(self._line[self._pos:], self._pos)
@@ -315,26 +338,26 @@
                 self._output(self._line[self._left_pos:self._pos])
                 column = self._cursor
                 self._output(self._line[self._pos:self._right_pos])
 
             self._end_column = self._cursor
             self._move_back(column)
 
-    def _reposition(self, new_pos, new_column):
+    def _reposition(self, new_pos: int, new_column: int) -> None:
         """Reposition the cursor to selected position in input"""
 
         if self._echo:
             if self._wrap:
                 self._move_cursor(new_column)
             else:
                 self._update_input(self._pos, self._cursor, new_pos)
 
         self._pos = new_pos
 
-    def _update_input(self, pos, column, new_pos):
+    def _update_input(self, pos: int, column: int, new_pos: int) -> None:
         """Update selected portion of current input line"""
 
         if self._echo:
             if self._wrap:
                 if pos in self._early_wrap:
                     column -= 1
 
@@ -352,15 +375,15 @@
                 self._output(self._line[new_pos:self._right_pos])
 
             self._clear_to_end()
             self._move_back(column)
 
         self._pos = new_pos
 
-    def _insert_printable(self, data):
+    def _insert_printable(self, data: str) -> None:
         """Insert data into the input line"""
 
         line_len = len(self._line)
         data_len = len(data)
 
         if self._max_line_length:
             if line_len + data_len > self._max_line_length:
@@ -371,15 +394,15 @@
         if data:
             pos = self._pos
             new_pos = pos + data_len
             self._line = self._line[:pos] + data + self._line[pos:]
 
             self._update_input(pos, self._cursor, new_pos)
 
-    def _end_line(self):
+    def _end_line(self) -> None:
         """End the current input line and send it to the session"""
 
         if (self._echo and not self._wrap and
                 (self._left_pos > 0 or self._right_pos < len(self._line))):
             self._output('\b' * (self._cursor - self._start_column) +
                          self._line)
         else:
@@ -401,146 +424,146 @@
         self._history_index = len(self._history)
 
         data = self._line + '\n'
         self._line = ''
 
         self._session.data_received(data, None)
 
-    def _eof_or_delete(self):
+    def _eof_or_delete(self) -> None:
         """Erase character to the right, or send EOF if input line is empty"""
 
         if not self._line:
             self._session.soft_eof_received()
         else:
             self._erase_right()
 
-    def _erase_left(self):
+    def _erase_left(self) -> None:
         """Erase character to the left"""
 
         if self._pos > 0:
             pos = self._pos - 1
             column = self._cursor - self._char_width(pos)
             self._line = self._line[:pos] + self._line[pos+1:]
             self._update_input(pos, column, pos)
         else:
             self._ring_bell()
 
-    def _erase_right(self):
+    def _erase_right(self) -> None:
         """Erase character to the right"""
 
         if self._pos < len(self._line):
             pos = self._pos
             self._line = self._line[:pos] + self._line[pos+1:]
             self._update_input(pos, self._cursor, pos)
         else:
             self._ring_bell()
 
-    def _erase_line(self):
+    def _erase_line(self) -> None:
         """Erase entire input line"""
 
         self._erased = self._line
         self._line = ''
         self._update_input(0, self._start_column, 0)
 
-    def _erase_to_end(self):
+    def _erase_to_end(self) -> None:
         """Erase to end of input line"""
 
         pos = self._pos
         self._erased = self._line[pos:]
         self._line = self._line[:pos]
         self._update_input(pos, self._cursor, pos)
 
-    def _handle_key(self, key, handler):
+    def _handle_key(self, key: str, handler: _KeyHandler) -> None:
         """Call an external key handler"""
 
         result = handler(self._line, self._pos)
 
         if result is True:
             if key.isprintable():
                 self._insert_printable(key)
             else:
                 self._ring_bell()
         elif result is False:
             self._ring_bell()
         else:
-            line, new_pos = result
+            line, new_pos = cast(Tuple[str, int], result)
 
             if new_pos < 0:
                 self._session.signal_received(line)
             else:
                 self._line = line
                 self._update_input(0, self._start_column, new_pos)
 
-    def _history_prev(self):
+    def _history_prev(self) -> None:
         """Replace input with previous line in history"""
 
         if self._history_index > 0:
             self._history_index -= 1
             self._line = self._history[self._history_index]
             self._update_input(0, self._start_column, len(self._line))
         else:
             self._ring_bell()
 
-    def _history_next(self):
+    def _history_next(self) -> None:
         """Replace input with next line in history"""
 
         if self._history_index < len(self._history):
             self._history_index += 1
 
             if self._history_index < len(self._history):
                 self._line = self._history[self._history_index]
             else:
                 self._line = ''
 
             self._update_input(0, self._start_column, len(self._line))
         else:
             self._ring_bell()
 
-    def _move_left(self):
+    def _move_left(self) -> None:
         """Move left in input line"""
 
         if self._pos > 0:
             pos = self._pos - 1
             column = self._cursor - self._char_width(pos)
             self._reposition(pos, column)
         else:
             self._ring_bell()
 
-    def _move_right(self):
+    def _move_right(self) -> None:
         """Move right in input line"""
 
         if self._pos < len(self._line):
             pos = self._pos
             column = self._cursor + self._char_width(pos)
             self._reposition(pos + 1, column)
         else:
             self._ring_bell()
 
-    def _move_to_start(self):
+    def _move_to_start(self) -> None:
         """Move to start of input line"""
 
         self._reposition(0, self._start_column)
 
-    def _move_to_end(self):
+    def _move_to_end(self) -> None:
         """Move to end of input line"""
 
         self._reposition(len(self._line), self._end_column)
 
-    def _redraw(self):
+    def _redraw(self) -> None:
         """Redraw input line"""
 
         self._erase_input()
         self._draw_input()
 
-    def _insert_erased(self):
+    def _insert_erased(self) -> None:
         """Insert previously erased input"""
 
         self._insert_printable(self._erased)
 
-    def _send_break(self):
+    def _send_break(self) -> None:
         """Send break to session"""
 
         self._session.break_received(0)
 
     _keylist = ((_end_line,      ('\n', '\r', '\x1bOM')),
                 (_eof_or_delete, ('\x04',)),
                 (_erase_left,    ('\x08', '\x7f')),
@@ -553,86 +576,92 @@
                 (_move_right,    ('\x06', '\x1b[C', '\x1bOC')),
                 (_move_to_start, ('\x01', '\x1b[H', '\x1b[1~')),
                 (_move_to_end,   ('\x05', '\x1b[F', '\x1b[4~')),
                 (_redraw,        ('\x12',)),
                 (_insert_erased, ('\x19',)),
                 (_send_break,    ('\x03', '\x1b[33~')))
 
-    def register_key(self, key, handler):
+    def register_key(self, key: str, handler: _KeyHandler) -> None:
         """Register a handler to be called when a key is pressed"""
 
         self._add_key(key, partial(SSHLineEditor._handle_key,
                                    key=key, handler=handler))
         self._build_printable()
 
-    def unregister_key(self, key):
+    def unregister_key(self, key: str) -> None:
         """Remove the handler associated with a key"""
 
         self._del_key(key)
         self._build_printable()
 
-    def set_input(self, line, pos):
+    def set_input(self, line: str, pos: int) -> None:
         """Set input line and cursor position"""
 
         self._line = line
         self._update_input(0, self._start_column, pos)
 
-    def set_line_mode(self, line_mode):
+    def set_line_mode(self, line_mode: bool) -> None:
         """Enable/disable input line editing"""
 
         if self._line and not line_mode:
             data = self._line
             self._erase_input()
             self._line = ''
 
             self._session.data_received(data, None)
 
         self._line_mode = line_mode
 
-    def set_echo(self, echo):
+    def set_echo(self, echo: bool) -> None:
         """Enable/disable echoing of input in line mode"""
 
         if self._echo and not echo:
             self._erase_input()
             self._echo = False
         elif echo and not self._echo:
             self._echo = True
             self._draw_input()
 
-    def set_width(self, width):
+    def set_width(self, width: int) -> None:
         """Set terminal line width"""
 
         self._width = width or _DEFAULT_WIDTH
 
         if self._wrap:
             _, self._cursor = self._determine_column(self._line,
                                                      self._start_column, 0)
 
         self._redraw()
 
-    def process_input(self, data, datatype):
+    def process_input(self, data: str, datatype: DataType) -> None:
         """Process input from channel"""
 
         if self._line_mode:
             data_len = len(data)
             idx = 0
 
             while idx < data_len:
                 ch = data[idx]
                 idx += 1
 
                 if ch in self._key_state:
-                    self._key_state = self._key_state[ch]
-                    if callable(self._key_state):
+                    key_state = self._key_state[ch]
+
+                    if callable(key_state):
                         try:
-                            self._key_state(self)
+                            cast(_CharHandler, key_state)(self)
                         finally:
                             self._key_state = self._keymap
+                    else:
+                        self._key_state = cast(_CharDict, key_state)
                 elif self._key_state == self._keymap and ch.isprintable():
-                    match = self._printable.match(data, idx - 1)[0]
+                    match = self._printable.match(data, idx - 1)
+
+                    assert match is not None
+                    match = match[0]
 
                     if match:
                         self._insert_printable(match)
                         idx += len(match) - 1
                     else:
                         self._insert_printable(ch)
                 else:
@@ -641,15 +670,15 @@
 
             self._bell_rung = False
             self._chan.write(''.join(self._outbuf))
             self._outbuf.clear()
         else:
             self._session.data_received(data, datatype)
 
-    def process_output(self, data):
+    def process_output(self, data: str) -> None:
         """Process output to channel"""
 
         data = data.replace('\n', '\r\n')
 
         self._erase_input()
         self._output(data)
 
@@ -673,37 +702,43 @@
 
        .. note:: Line editing is only available when a psuedo-terminal
                  is requested on the server channel and the character
                  encoding on the channel is not set to `None`.
 
     """
 
-    def __init__(self, orig_chan, orig_session, history_size, max_line_length):
+    def __init__(self, orig_chan: 'SSHServerChannel[str]',
+                 orig_session: 'SSHServerSession[str]',
+                 history_size: int, max_line_length: int):
         self._orig_chan = orig_chan
         self._orig_session = orig_session
         self._history_size = history_size
         self._max_line_length = max_line_length
-        self._editor = None
+        self._editor: Optional[SSHLineEditor] = None
 
-    def __getattr__(self, attr):
+    def __getattr__(self, attr: str):
         """Delegate most channel functions to original channel"""
 
         return getattr(self._orig_chan, attr)
 
-    def create_editor(self):
+    def create_editor(self) -> Optional[SSHLineEditor]:
         """Create input line editor if encoding and terminal type are set"""
 
-        if self._encoding and self._term_type:
+        encoding, _ = self._orig_chan.get_encoding()
+        term_type = self._orig_chan.get_terminal_type()
+        width = self._orig_chan.get_terminal_size()[0]
+
+        if encoding and term_type:
             self._editor = SSHLineEditor(
                 self._orig_chan, self._orig_session, self._history_size,
-                self._max_line_length, self._term_type, self._term_size[0])
+                self._max_line_length, term_type, width)
 
         return self._editor
 
-    def register_key(self, key, handler):
+    def register_key(self, key: str, handler: _KeyHandler) -> None:
         """Register a handler to be called when a key is pressed
 
            This method registers a handler function which will be called
            when a user presses the specified key while inputting a line.
 
            The handler will be called with arguments of the current
            input line and cursor position, and updated versions of these
@@ -731,59 +766,63 @@
            :param handler:
                The handler function to call when the key is pressed
            :type key: `str`
            :type handler: `callable`
 
         """
 
+        assert self._editor is not None
         self._editor.register_key(key, handler)
 
-    def unregister_key(self, key):
+    def unregister_key(self, key: str) -> None:
         """Remove the handler associated with a key
 
            This method removes a handler function associated with
            the specified key. If the key sequence is printable,
            this will cause it to return to being inserted at the
            current position when pressed. Otherwise, it will cause
            the bell to ring to signal the key is not understood.
 
            :param key:
                The key sequence to look for
            :type key: `str`
 
         """
 
+        assert self._editor is not None
         self._editor.unregister_key(key)
 
-    def clear_input(self):
+    def clear_input(self) -> None:
         """Clear input line
 
            This method clears the current input line.
 
         """
 
+        assert self._editor is not None
         self._editor.set_input('', 0)
 
-    def set_input(self, line, pos):
+    def set_input(self, line: str, pos: int) -> None:
         """Clear input line
 
            This method sets the current input line and cursor position.
 
            :param line:
                The new input line
            :param pos:
                The new cursor position within the input line
            :type line: `str`
            :type pos: `int`
 
         """
 
+        assert self._editor is not None
         self._editor.set_input(line, pos)
 
-    def set_line_mode(self, line_mode):
+    def set_line_mode(self, line_mode: bool) -> None:
         """Enable/disable input line editing
 
            This method enabled or disables input line editing. When set,
            only full lines of input are sent to the session, and each
            line of input can be edited before it is sent.
 
            :param line_mode:
@@ -791,78 +830,82 @@
            :type line_mode: `bool`
 
         """
 
         self._orig_chan.logger.info('%s line editor',
                                     'Enabling' if line_mode else 'Disabling')
 
+        assert self._editor is not None
         self._editor.set_line_mode(line_mode)
 
-    def set_echo(self, echo):
+    def set_echo(self, echo: bool) -> None:
         """Enable/disable echoing of input in line mode
 
            This method enables or disables echoing of input data when
            input line editing is enabled.
 
            :param echo:
                Whether or not input to echo input as it is entered
            :type echo: `bool`
 
         """
 
         self._orig_chan.logger.info('%s echo',
                                     'Enabling' if echo else 'Disabling')
 
+        assert self._editor is not None
         self._editor.set_echo(echo)
 
-    def write(self, data, datatype=None):
+    def write(self, data: str, datatype: DataType = None) -> None:
         """Process data written to the channel"""
 
         if self._editor and datatype is None:
             self._editor.process_output(data)
         else:
             self._orig_chan.write(data, datatype)
 
 
 class SSHLineEditorSession:
     """Input line editor session wrapper"""
 
-    def __init__(self, chan, orig_session):
+    def __init__(self, chan: SSHLineEditorChannel,
+                 orig_session: 'SSHServerSession[str]'):
         self._chan = chan
         self._orig_session = orig_session
-        self._editor = None
+        self._editor: Optional[SSHLineEditor] = None
 
-    def __getattr__(self, attr):
+    def __getattr__(self, attr: str):
         """Delegate most channel functions to original session"""
 
         return getattr(self._orig_session, attr)
 
-    def session_started(self):
+    def session_started(self) -> None:
         """Start a session for this newly opened server channel"""
 
         self._editor = self._chan.create_editor()
         self._orig_session.session_started()
 
-    def terminal_size_changed(self, width, height, pixwidth, pixheight):
+    def terminal_size_changed(self, width: int, height: int,
+                              pixwidth: int, pixheight: int) -> None:
         """The terminal size has changed"""
 
         if self._editor:
             self._editor.set_width(width)
 
         self._orig_session.terminal_size_changed(width, height,
                                                  pixwidth, pixheight)
 
-    def data_received(self, data, datatype):
+    def data_received(self, data: str, datatype: DataType) -> None:
         """Process data received from the channel"""
 
         if self._editor:
             self._editor.process_input(data, datatype)
         else:
             self._orig_session.data_received(data, datatype)
 
-    def eof_received(self):
+    def eof_received(self) -> Optional[bool]:
         """Process EOF received from the channel"""
 
         if self._editor:
             self._editor.set_line_mode(False)
 
         return self._orig_session.eof_received()
```

### Comparing `asyncssh-2.8.1/asyncssh/public_key.py` & `asyncssh-2.9.0/asyncssh/public_key.py`

 * *Files 11% similar despite different names*

```diff
@@ -24,39 +24,81 @@
 import os
 import re
 import time
 
 from datetime import datetime
 from hashlib import md5, sha1, sha256, sha384, sha512
 from pathlib import Path, PurePath
+from typing import Callable, Dict, List, Mapping, Optional, Sequence, Set
+from typing import Tuple, Type, Union, cast
+from typing_extensions import Protocol
 
 from .crypto import ed25519_available, ed448_available
+from .encryption import Encryption
 from .sk import sk_available
 
 try:
+    # pylint: disable=unused-import
+    from .crypto import X509Certificate
     from .crypto import generate_x509_certificate, import_x509_certificate
     _x509_available = True
 except ImportError: # pragma: no cover
     _x509_available = False
 
 try:
     import bcrypt
     _bcrypt_available = hasattr(bcrypt, 'kdf')
 except ImportError: # pragma: no cover
     _bcrypt_available = False
 
-from .asn1 import ASN1DecodeError, BitString, der_encode, der_decode
+from .asn1 import ASN1DecodeError, BitString, ObjectIdentifier
+from .asn1 import der_encode, der_decode, der_decode_partial
+from .crypto import CryptoKey, PyCAKey
 from .encryption import get_encryption_params, get_encryption
+from .misc import BytesOrStr, DefTuple, FilePath, IPNetwork
 from .misc import ip_network, read_file, write_file, parse_time_interval
 from .packet import NameList, String, UInt32, UInt64
 from .packet import PacketDecodeError, SSHPacket
 from .pbe import KeyEncryptionError, pkcs1_encrypt, pkcs8_encrypt
 from .pbe import pkcs1_decrypt, pkcs8_decrypt
 from .sk import SSH_SK_USER_PRESENCE_REQD, sk_get_resident
 
+
+_Comment = Optional[BytesOrStr]
+_CertPrincipals = Union[str, Sequence[str]]
+_Time = Union[int, float, datetime, str]
+
+_PubKeyAlgMap = Dict[bytes, Type['SSHKey']]
+_CertAlgMap = Dict[bytes, Tuple[Optional[Type['SSHKey']],
+                                Type['SSHCertificate']]]
+_CertVersionMap = Dict[Tuple[bytes, int],
+                       Tuple[bytes, Type['SSHOpenSSHCertificate']]]
+
+_PEMMap = Dict[bytes, Type['SSHKey']]
+_PKCS8OIDMap = Dict[ObjectIdentifier, Type['SSHKey']]
+_SKAlgMap = Dict[int, Tuple[Type['SSHKey'], Tuple[object, ...]]]
+
+_OpenSSHCertOptions = Dict[str, object]
+_OpenSSHCertParams = Tuple[object, int, int, bytes, bytes,
+                           int, int, bytes, bytes]
+_OpenSSHCertEncoders = Sequence[Tuple[str, Callable[[object], bytes]]]
+_OpenSSHCertDecoders = Dict[bytes, Callable[[SSHPacket], object]]
+
+X509CertPurposes = Union[None, str, Sequence[str]]
+
+_IdentityArg = Union[bytes, FilePath, 'SSHKey', 'SSHCertificate']
+IdentityListArg = Union[_IdentityArg, Sequence[_IdentityArg]]
+_KeyArg = Union[bytes, FilePath, 'SSHKey']
+KeyListArg = Union[FilePath, Sequence[_KeyArg]]
+_CertArg = Union[bytes, FilePath, 'SSHCertificate']
+CertListArg = Union[_CertArg, Sequence[_CertArg]]
+_KeyPairArg = Union['SSHKeyPair', _KeyArg, Tuple[_KeyArg, _CertArg]]
+KeyPairListArg = Union[_KeyPairArg, Sequence[_KeyPairArg]]
+
+
 # Default file names in .ssh directory to read private keys from
 _DEFAULT_KEY_FILES = (
     ('id_ed25519_sk', ed25519_available and sk_available),
     ('id_ecdsa_sk', sk_available),
     ('id_ed448', ed448_available),
     ('id_ed25519', ed25519_available),
     ('id_ecdsa', True),
@@ -71,29 +113,29 @@
 _DEFAULT_HOST_KEY_FILES = ('ssh_host_ed448_key', 'ssh_host_ed25519_key',
                            'ssh_host_ecdsa_key', 'ssh_host_rsa_key',
                            'ssh_host_dsa_key')
 
 _hashes = {'md5': md5, 'sha1': sha1, 'sha256': sha256,
            'sha384': sha384, 'sha512': sha512}
 
-_public_key_algs = []
-_default_public_key_algs = []
+_public_key_algs: List[bytes] = []
+_default_public_key_algs: List[bytes] = []
 
-_certificate_algs = []
-_default_certificate_algs = []
+_certificate_algs: List[bytes] = []
+_default_certificate_algs: List[bytes] = []
 
-_x509_certificate_algs = []
-_default_x509_certificate_algs = []
+_x509_certificate_algs: List[bytes] = []
+_default_x509_certificate_algs: List[bytes] = []
 
-_sk_alg_map = {}
-_public_key_alg_map = {}
-_certificate_alg_map = {}
-_certificate_version_map = {}
-_pem_map = {}
-_pkcs8_oid_map = {}
+_public_key_alg_map: _PubKeyAlgMap = {}
+_certificate_alg_map: _CertAlgMap = {}
+_certificate_version_map: _CertVersionMap = {}
+_pem_map: _PEMMap = {}
+_pkcs8_oid_map: _PKCS8OIDMap = {}
+_sk_alg_map: _SKAlgMap = {}
 
 _abs_date_pattern = re.compile(r'\d{8}')
 _abs_time_pattern = re.compile(r'\d{14}')
 
 _subject_pattern = re.compile(r'(?:Distinguished[ -_]?Name|Subject|DN)[=:]?\s?',
                               re.IGNORECASE)
 
@@ -105,15 +147,15 @@
 OMIT = object()
 
 _OPENSSH_KEY_V1 = b'openssh-key-v1\0'
 _OPENSSH_SALT_LEN = 16
 _OPENSSH_WRAP_LEN = 70
 
 
-def _parse_time(t):
+def _parse_time(t: _Time) -> int:
     """Parse a time value"""
 
     if isinstance(t, int):
         return t
     elif isinstance(t, float):
         return int(t)
     elif isinstance(t, datetime):
@@ -134,15 +176,15 @@
             return int(time.time() + parse_time_interval(t))
         except ValueError:
             pass
 
     raise ValueError('Unrecognized time value')
 
 
-def _wrap_base64(data, wrap=64):
+def _wrap_base64(data: bytes, wrap: int = 64) -> bytes:
     """Break a Base64 value into multiple lines."""
 
     data = binascii.b2a_base64(data)[:-1]
     return b'\n'.join(data[i:i+wrap]
                       for i in range(0, len(data), wrap)) + b'\n'
 
 
@@ -173,76 +215,154 @@
        This exception is raised by key export functions when the
        requested format is unknown or encryption is requested for a
        format which doesn't support it.
 
     """
 
 
+class SigningKey(Protocol):
+    """Protocol for signing a block of data"""
+
+    def sign(self, data: bytes) -> bytes:
+        """Sign a block of data with a private key"""
+
+
+class VerifyingKey(Protocol):
+    """Protocol for verifying a signature on a block of data"""
+
+    def verify(self, data: bytes, sig: bytes) -> bool:
+        """Verify a signature on a block of data with a public key"""
+
+
 class SSHKey:
     """Parent class which holds an asymmetric encryption key"""
 
-    algorithm = None
-    sig_algorithms = None
-    x509_algorithms = None
-    all_sig_algorithms = None
-    default_hash_alg = None
-    pem_name = None
-    pkcs8_oid = None
-    use_executor = False
+    algorithm: bytes = b''
+    sig_algorithms: Sequence[bytes] = ()
+    x509_algorithms: Sequence[bytes] = ()
+    all_sig_algorithms: Set[bytes] = set()
+    default_hash_name: str = ''
+    pem_name: bytes = b''
+    pkcs8_oid: Optional[ObjectIdentifier] = None
+    use_executor: bool = False
 
-    def __init__(self, key=None):
+    def __init__(self, key: Optional[CryptoKey] = None):
         self._key = key
-        self._comment = None
-        self._filename = None
+        self._comment: Optional[bytes] = None
+        self._filename: Optional[bytes] = None
         self._touch_required = False
 
+    @classmethod
+    def generate(cls, algorithm: bytes, **kwargs) -> 'SSHKey':
+        """Generate a new SSH private key"""
+
+        raise NotImplementedError
+
+    @classmethod
+    def make_private(cls, key_params: object) -> 'SSHKey':
+        """Construct an RSA private key"""
+
+        raise NotImplementedError
+
+    @classmethod
+    def make_public(cls, key_params: object) -> 'SSHKey':
+        """Construct an RSA public key"""
+
+        raise NotImplementedError
+
+    @classmethod
+    def decode_pkcs1_private(cls, key_data: object) -> object:
+        """Decode a PKCS#1 format private key"""
+
+    @classmethod
+    def decode_pkcs1_public(cls, key_data: object) -> object:
+        """Decode a PKCS#1 format public key"""
+
+    @classmethod
+    def decode_pkcs8_private(cls, alg_params: object, data: bytes) -> object:
+        """Decode a PKCS#8 format private key"""
+
+    @classmethod
+    def decode_pkcs8_public(cls, alg_params: object, data: bytes) -> object:
+        """Decode a PKCS#8 format public key"""
+
+    @classmethod
+    def decode_ssh_private(cls, packet: SSHPacket) -> object:
+        """Decode an SSH format private key"""
+
+    @classmethod
+    def decode_ssh_public(cls, packet: SSHPacket) -> object:
+        """Decode an SSH format public key"""
+
     @property
-    def private_data(self):
+    def private_data(self) -> bytes:
         """Return private key data in OpenSSH binary format"""
 
         return String(self.algorithm) + self.encode_ssh_private()
 
     @property
-    def public_data(self):
+    def public_data(self) -> bytes:
         """Return public key data in OpenSSH binary format"""
 
         return String(self.algorithm) + self.encode_ssh_public()
 
     @property
-    def pyca_key(self):
+    def pyca_key(self) -> PyCAKey:
         """Return PyCA key for use in X.509 module"""
 
+        assert self._key is not None
         return self._key.pyca_key
 
-    def _generate_certificate(self, key, version, serial, cert_type,
-                              key_id, principals, valid_after,
-                              valid_before, cert_options, comment):
+    def _generate_certificate(self, key: 'SSHKey', version: int, serial: int,
+                              cert_type: int, key_id: str,
+                              principals: _CertPrincipals,
+                              valid_after: _Time, valid_before: _Time,
+                              cert_options: _OpenSSHCertOptions,
+                              comment: DefTuple[_Comment]) -> \
+            'SSHOpenSSHCertificate':
         """Generate a new SSH certificate"""
 
+        if isinstance(principals, str):
+            principals = [p.strip() for p in principals.split(',')]
+        else:
+            principals = list(principals)
+
         valid_after = _parse_time(valid_after)
         valid_before = _parse_time(valid_before)
 
         if valid_before <= valid_after:
             raise ValueError('Valid before time must be later than '
                              'valid after time')
 
+        if comment == ():
+            comment = key.get_comment_bytes()
+
+        comment: _Comment
+
         try:
             algorithm, cert_handler = _certificate_version_map[key.algorithm,
                                                                version]
         except KeyError:
             raise KeyGenerationError('Unknown certificate version') from None
 
         return cert_handler.generate(self, algorithm, key, serial, cert_type,
                                      key_id, principals, valid_after,
                                      valid_before, cert_options, comment)
 
-    def _generate_x509_certificate(self, key, subject, issuer, serial,
-                                   valid_after, valid_before, ca, ca_path_len,
-                                   purposes, user_principals, host_principals,
-                                   hash_alg, comment):
+    def _generate_x509_certificate(self, key: 'SSHKey', subject: str,
+                                   issuer: Optional[str],
+                                   serial: Optional[int],
+                                   valid_after: _Time, valid_before: _Time,
+                                   ca: bool, ca_path_len: Optional[int],
+                                   purposes: X509CertPurposes,
+                                   user_principals: _CertPrincipals,
+                                   host_principals: _CertPrincipals,
+                                   hash_name: DefTuple[str],
+                                   comment: DefTuple[_Comment]) -> \
+            'SSHX509Certificate':
         """Generate a new X.509 certificate"""
 
         if not _x509_available: # pragma: no cover
             raise KeyGenerationError('X.509 certificate generation '
                                      'requires PyOpenSSL')
 
         if not self.x509_algorithms:
@@ -253,47 +373,54 @@
         valid_after = _parse_time(valid_after)
         valid_before = _parse_time(valid_before)
 
         if valid_before <= valid_after:
             raise ValueError('Valid before time must be later than '
                              'valid after time')
 
-        if hash_alg == ():
-            hash_alg = key.default_hash_alg
+        if hash_name == ():
+            hash_name = key.default_hash_name
 
-        return SSHX509Certificate.generate(self, key, subject, issuer, serial,
-                                           valid_after, valid_before, ca,
-                                           ca_path_len, purposes,
+        if comment == ():
+            comment = key.get_comment_bytes()
+
+        hash_name: str
+        comment: _Comment
+
+        return SSHX509Certificate.generate(self, key, subject, issuer,
+                                           serial, valid_after, valid_before,
+                                           ca, ca_path_len, purposes,
                                            user_principals, host_principals,
-                                           hash_alg, comment)
+                                           hash_name, comment)
 
-    def get_algorithm(self):
+    def get_algorithm(self) -> str:
         """Return the algorithm associated with this key"""
 
         return self.algorithm.decode('ascii')
 
-    def has_comment(self):
+    def has_comment(self) -> bool:
         """Return whether a comment is set for this key
 
            :returns: `bool`
 
         """
 
         return bool(self._comment)
 
-    def get_comment_bytes(self):
+    def get_comment_bytes(self) -> Optional[bytes]:
         """Return the comment associated with this key as a byte string
 
            :returns: `bytes` or `None`
 
         """
 
         return self._comment or self._filename
 
-    def get_comment(self, encoding='utf-8', errors='strict'):
+    def get_comment(self, encoding: str = 'utf-8',
+                    errors: str = 'strict') -> Optional[str]:
         """Return the comment associated with this key as a Unicode string
 
            :param encoding:
                The encoding to use to decode the comment as a Unicode
                string, defaulting to UTF-8
            :param errors:
                The error handling scheme to use for Unicode decode errors
@@ -307,15 +434,16 @@
 
         """
 
         comment = self.get_comment_bytes()
 
         return comment.decode(encoding, errors) if comment else None
 
-    def set_comment(self, comment, encoding='utf-8', errors='strict'):
+    def set_comment(self, comment: _Comment, encoding: str = 'utf-8',
+                    errors: str = 'strict') -> None:
         """Set the comment associated with this key
 
            :param comment:
                The new comment to associate with this key
            :param encoding:
                The Unicode encoding to use to encode the comment,
                defaulting to UTF-8
@@ -331,41 +459,41 @@
         """
 
         if isinstance(comment, str):
             comment = comment.encode(encoding, errors)
 
         self._comment = comment or None
 
-    def get_filename(self):
+    def get_filename(self) -> Optional[bytes]:
         """Return the filename associated with this key
 
            :returns: `bytes` or `None`
 
         """
 
         return self._filename
 
-    def set_filename(self, filename):
+    def set_filename(self, filename: Union[None, bytes, FilePath]) -> None:
         """Set the filename associated with this key
 
            :param filename:
                The new filename to associate with this key
-           :type filename: `str`, `bytes`, or `None`
+           :type filename: `PurePath`, `str`, `bytes`, or `None`
 
         """
 
         if isinstance(filename, PurePath):
             filename = str(filename)
 
         if isinstance(filename, str):
             filename = filename.encode('utf-8')
 
         self._filename = filename or None
 
-    def get_fingerprint(self, hash_name='sha256'):
+    def get_fingerprint(self, hash_name: str = 'sha256') -> str:
         """Get the fingerprint of this key
 
            Available hashes include:
 
                md5, sha1, sha256, sha384, sha512
 
            :param hash_name: (optional)
@@ -385,125 +513,138 @@
 
         h = hash_alg(self.public_data)
 
         if hash_name == 'md5':
             fp = h.hexdigest()
             fp_text = ':'.join(fp[i:i+2] for i in range(0, len(fp), 2))
         else:
-            fp = h.digest()
-            fp_text = binascii.b2a_base64(fp).decode('ascii')[:-1].strip('=')
+            fpb = h.digest()
+            fp_text = binascii.b2a_base64(fpb).decode('ascii')[:-1].strip('=')
 
         return hash_name.upper() + ':' + fp_text
 
-    def set_touch_required(self, touch_required):
+    def set_touch_required(self, touch_required: bool) -> None:
         """Set whether touch is required when using a security key"""
 
         self._touch_required = touch_required
 
-    def sign_raw(self, data, hash_alg):
+    def sign_raw(self, data: bytes, hash_name: str) -> bytes:
         """Return a raw signature of the specified data"""
 
-        return self._key.sign(data, hash_alg)
+        assert self._key is not None
+        return self._key.sign(data, hash_name)
 
-    def sign_ssh(self, data, sig_algorithm):
+    def sign_ssh(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Abstract method to compute an SSH-encoded signature"""
 
         raise NotImplementedError
 
-    def verify_ssh(self, data, sig_algorithm, packet):
+    def verify_ssh(self, data: bytes, sig_algorithm: bytes,
+                   packet: SSHPacket) -> bool:
         """Abstract method to verify an SSH-encoded signature"""
 
         raise NotImplementedError
 
-    def sign(self, data, sig_algorithm):
+    def sign(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Return an SSH-encoded signature of the specified data"""
 
         if sig_algorithm.startswith(b'x509v3-'):
             sig_algorithm = sig_algorithm[7:]
 
         if sig_algorithm not in self.all_sig_algorithms:
             raise ValueError('Unrecognized signature algorithm')
 
         return b''.join((String(sig_algorithm),
                          self.sign_ssh(data, sig_algorithm)))
 
-    def verify(self, data, sig):
+    def verify(self, data: bytes, sig: bytes) -> bool:
         """Verify an SSH signature of the specified data using this key"""
 
         try:
             packet = SSHPacket(sig)
             sig_algorithm = packet.get_string()
 
             if sig_algorithm not in self.all_sig_algorithms:
                 return False
 
             return self.verify_ssh(data, sig_algorithm, packet)
         except PacketDecodeError:
             return False
 
-    def encode_pkcs1_private(self):
+    def encode_pkcs1_private(self) -> object:
         """Export parameters associated with a PKCS#1 private key"""
 
         # pylint: disable=no-self-use
         raise KeyExportError('PKCS#1 private key export not supported')
 
-    def encode_pkcs1_public(self):
+    def encode_pkcs1_public(self) -> object:
         """Export parameters associated with a PKCS#1 public key"""
 
         # pylint: disable=no-self-use
         raise KeyExportError('PKCS#1 public key export not supported')
 
-    def encode_pkcs8_private(self):
+    def encode_pkcs8_private(self) -> Tuple[object, object]:
         """Export parameters associated with a PKCS#8 private key"""
 
         # pylint: disable=no-self-use
         raise KeyExportError('PKCS#8 private key export not supported')
 
-    def encode_pkcs8_public(self):
+    def encode_pkcs8_public(self) -> Tuple[object, object]:
         """Export parameters associated with a PKCS#8 public key"""
 
         # pylint: disable=no-self-use
         raise KeyExportError('PKCS#8 public key export not supported')
 
-    def encode_ssh_private(self):
+    def encode_ssh_private(self) -> bytes:
         """Export parameters associated with an OpenSSH private key"""
 
         # pylint: disable=no-self-use
         raise KeyExportError('OpenSSH private key export not supported')
 
-    def encode_ssh_public(self):
+    def encode_ssh_public(self) -> bytes:
         """Export parameters associated with an OpenSSH public key"""
 
         # pylint: disable=no-self-use
         raise KeyExportError('OpenSSH public key export not supported')
 
-    def convert_to_public(self):
+    def encode_agent_cert_private(self) -> bytes:
+        """Encode certificate private key data for agent"""
+
+        raise NotImplementedError
+
+    def convert_to_public(self) -> 'SSHKey':
         """Return public key corresponding to this key
 
            This method converts an :class:`SSHKey` object which contains
            a private key into one which contains only the corresponding
            public key. If it is called on something which is already
            a public key, it has no effect.
 
         """
 
         result = decode_ssh_public_key(self.public_data)
         result.set_comment(self._comment)
         result.set_filename(self._filename)
         return result
 
-    def generate_user_certificate(self, user_key, key_id, version=1,
-                                  serial=0, principals=(), valid_after=0,
-                                  valid_before=0xffffffffffffffff,
-                                  force_command=None, source_address=None,
-                                  permit_x11_forwarding=True,
-                                  permit_agent_forwarding=True,
-                                  permit_port_forwarding=True,
-                                  permit_pty=True, permit_user_rc=True,
-                                  touch_required=True, comment=()):
+    def generate_user_certificate(self, user_key: 'SSHKey', key_id: str,
+                                  version: int = 1, serial: int = 0,
+                                  principals: _CertPrincipals = (),
+                                  valid_after: _Time = 0,
+                                  valid_before: _Time = 0xffffffffffffffff,
+                                  force_command: str = None,
+                                  source_address: Sequence[str] = None,
+                                  permit_x11_forwarding: bool = True,
+                                  permit_agent_forwarding: bool = True,
+                                  permit_port_forwarding: bool = True,
+                                  permit_pty: bool = True,
+                                  permit_user_rc: bool = True,
+                                  touch_required: bool = True,
+                                  comment: DefTuple[_Comment] = ()) -> \
+            'SSHOpenSSHCertificate':
         """Generate a new SSH user certificate
 
            This method returns an SSH user certifcate with the requested
            attributes signed by this private key.
 
            :param user_key:
                The user's public key.
@@ -552,15 +693,15 @@
                The comment to associate with this certificate. By default,
                the comment will be set to the comment currently set on
                user_key.
            :type user_key: :class:`SSHKey`
            :type key_id: `str`
            :type version: `int`
            :type serial: `int`
-           :type principals: `list` of `str`
+           :type principals: `str` or `list` of `str`
            :type force_command: `str` or `None`
            :type source_address: list of ip_address and ip_network values
            :type permit_x11_forwarding: `bool`
            :type permit_agent_forwarding: `bool`
            :type permit_port_forwarding: `bool`
            :type permit_pty: `bool`
            :type permit_user_rc: `bool`
@@ -571,15 +712,15 @@
 
            :raises: | :exc:`ValueError` if the validity times are invalid
                     | :exc:`KeyGenerationError` if the requested certificate
                       parameters are unsupported
 
         """
 
-        cert_options = {}
+        cert_options: _OpenSSHCertOptions = {}
 
         if force_command:
             cert_options['force-command'] = force_command
 
         if source_address:
             cert_options['source-address'] = [ip_network(addr)
                                               for addr in source_address]
@@ -598,26 +739,26 @@
 
         if permit_user_rc:
             cert_options['permit-user-rc'] = True
 
         if not touch_required:
             cert_options['no-touch-required'] = True
 
-        if comment == ():
-            comment = user_key.get_comment_bytes()
-
         return self._generate_certificate(user_key, version, serial,
                                           CERT_TYPE_USER, key_id,
                                           principals, valid_after,
                                           valid_before, cert_options, comment)
 
-    def generate_host_certificate(self, host_key, key_id, version=1,
-                                  serial=0, principals=(), valid_after=0,
-                                  valid_before=0xffffffffffffffff,
-                                  comment=()):
+    def generate_host_certificate(self, host_key: 'SSHKey', key_id: str,
+                                  version: int = 1, serial: int = 0,
+                                  principals: _CertPrincipals = (),
+                                  valid_after: _Time = 0,
+                                  valid_before: _Time = 0xffffffffffffffff,
+                                  comment: DefTuple[_Comment] = ()) -> \
+            'SSHOpenSSHCertificate':
         """Generate a new SSH host certificate
 
            This method returns an SSH host certifcate with the requested
            attributes signed by this private key.
 
            :param host_key:
                The host's public key.
@@ -642,15 +783,15 @@
                The comment to associate with this certificate. By default,
                the comment will be set to the comment currently set on
                host_key.
            :type host_key: :class:`SSHKey`
            :type key_id: `str`
            :type version: `int`
            :type serial: `int`
-           :type principals: `list` of `str`
+           :type principals: `str` or `list` of `str`
            :type comment: `str`, `bytes`, or `None`
 
            :returns: :class:`SSHCertificate`
 
            :raises: | :exc:`ValueError` if the validity times are invalid
                     | :exc:`KeyGenerationError` if the requested certificate
                       parameters are unsupported
@@ -660,20 +801,24 @@
             comment = host_key.get_comment_bytes()
 
         return self._generate_certificate(host_key, version, serial,
                                           CERT_TYPE_HOST, key_id,
                                           principals, valid_after,
                                           valid_before, {}, comment)
 
-    def generate_x509_user_certificate(self, user_key, subject, issuer=None,
-                                       serial=None, principals=(),
-                                       valid_after=0,
-                                       valid_before=0xffffffffffffffff,
-                                       purposes='secureShellClient',
-                                       hash_alg=(), comment=()):
+    def generate_x509_user_certificate(self, user_key: 'SSHKey', subject: str,
+                                       issuer: str = None, serial: int = None,
+                                       principals: _CertPrincipals = (),
+                                       valid_after: _Time = 0,
+                                       valid_before: _Time = 0xffffffffffffffff,
+                                       purposes: X509CertPurposes = \
+                                            'secureShellClient',
+                                       hash_alg: DefTuple[str] = (),
+                                       comment: DefTuple[_Comment] = ()) -> \
+            'SSHX509Certificate':
         """Generate a new X.509 user certificate
 
            This method returns an X.509 user certifcate with the requested
            attributes signed by this private key.
 
            :param user_key:
                The user's public key.
@@ -710,42 +855,43 @@
                The comment to associate with this certificate. By default,
                the comment will be set to the comment currently set on
                user_key.
            :type user_key: :class:`SSHKey`
            :type subject: `str`
            :type issuer: `str`
            :type serial: `int`
-           :type principals: `list` of `str`
-           :type purposes: `list` of `str` or `None`
+           :type principals: `str` or `list` of `str`
+           :type purposes: `str`, `list` of `str`, or `None`
            :type hash_alg: `str`
            :type comment: `str`, `bytes`, or `None`
 
            :returns: :class:`SSHCertificate`
 
            :raises: | :exc:`ValueError` if the validity times are invalid
                     | :exc:`KeyGenerationError` if the requested certificate
                       parameters are unsupported
 
         """
 
-        if comment == ():
-            comment = user_key.get_comment_bytes()
-
         return self._generate_x509_certificate(user_key, subject, issuer,
                                                serial, valid_after,
                                                valid_before, False, None,
                                                purposes, principals, (),
                                                hash_alg, comment)
 
-    def generate_x509_host_certificate(self, host_key, subject, issuer=None,
-                                       serial=None, principals=(),
-                                       valid_after=0,
-                                       valid_before=0xffffffffffffffff,
-                                       purposes='secureShellServer',
-                                       hash_alg=(), comment=()):
+    def generate_x509_host_certificate(self, host_key: 'SSHKey', subject: str,
+                                       issuer: str = None, serial: int = None,
+                                       principals: _CertPrincipals = (),
+                                       valid_after: _Time = 0,
+                                       valid_before: _Time = 0xffffffffffffffff,
+                                       purposes: X509CertPurposes = \
+                                            'secureShellServer',
+                                       hash_alg: DefTuple[str] = (),
+                                       comment: DefTuple[_Comment] = ()) -> \
+            'SSHX509Certificate':
         """Generate a new X.509 host certificate
 
            This method returns a X.509 host certifcate with the requested
            attributes signed by this private key.
 
            :param host_key:
                The host's public key.
@@ -782,40 +928,41 @@
                The comment to associate with this certificate. By default,
                the comment will be set to the comment currently set on
                host_key.
            :type host_key: :class:`SSHKey`
            :type subject: `str`
            :type issuer: `str`
            :type serial: `int`
-           :type principals: `list` of `str`
-           :type purposes: `list` of `str` or `None`
+           :type principals: `str` or `list` of `str`
+           :type purposes: `str`, `list` of `str`, or `None`
            :type hash_alg: `str`
            :type comment: `str`, `bytes`, or `None`
 
            :returns: :class:`SSHCertificate`
 
            :raises: | :exc:`ValueError` if the validity times are invalid
                     | :exc:`KeyGenerationError` if the requested certificate
                       parameters are unsupported
         """
 
-        if comment == ():
-            comment = host_key.get_comment_bytes()
-
         return self._generate_x509_certificate(host_key, subject, issuer,
                                                serial, valid_after,
                                                valid_before, False, None,
                                                purposes, (), principals,
                                                hash_alg, comment)
 
-    def generate_x509_ca_certificate(self, ca_key, subject, issuer=None,
-                                     serial=None, valid_after=0,
-                                     valid_before=0xffffffffffffffff,
-                                     ca_path_len=None, hash_alg=(),
-                                     comment=()):
+    def generate_x509_ca_certificate(self, ca_key: 'SSHKey', subject: str,
+                                     issuer: Optional[str] = None,
+                                     serial: Optional[int] = None,
+                                     valid_after: _Time = 0,
+                                     valid_before: _Time = 0xffffffffffffffff,
+                                     ca_path_len: Optional[int] = None,
+                                     hash_alg: DefTuple[str] = (),
+                                     comment: DefTuple[_Comment] = ()) -> \
+            'SSHX509Certificate':
         """Generate a new X.509 CA certificate
 
            This method returns a X.509 CA certifcate with the requested
            attributes signed by this private key.
 
            :param ca_key:
                The new CA's public key.
@@ -860,26 +1007,26 @@
            :returns: :class:`SSHCertificate`
 
            :raises: | :exc:`ValueError` if the validity times are invalid
                     | :exc:`KeyGenerationError` if the requested certificate
                       parameters are unsupported
         """
 
-        if comment == ():
-            comment = ca_key.get_comment_bytes()
-
         return self._generate_x509_certificate(ca_key, subject, issuer,
                                                serial, valid_after,
                                                valid_before, True,
                                                ca_path_len, None, (), (),
                                                hash_alg, comment)
 
-    def export_private_key(self, format_name='openssh', passphrase=None,
-                           cipher_name='aes256-cbc', hash_name='sha256',
-                           pbe_version=2, rounds=128, ignore_few_rounds=False):
+    def export_private_key(self, format_name: str = 'openssh',
+                           passphrase: Optional[BytesOrStr] = None,
+                           cipher_name: str = 'aes256-cbc',
+                           hash_name: str = 'sha256',
+                           pbe_version: int = 2, rounds: int = 128,
+                           ignore_few_rounds: bool = False) -> bytes:
         """Export a private key in the requested format
 
            This method returns this object's private key encoded in the
            requested format. If a passphrase is specified, the key will
            be exported in encrypted form.
 
            Available formats include:
@@ -970,20 +1117,20 @@
                 keytype = self.pem_name + b' PRIVATE KEY'
                 data = (b'-----BEGIN ' + keytype + b'-----\n' +
                         headers + _wrap_base64(data) +
                         b'-----END ' + keytype + b'-----\n')
 
             return data
         elif format_name in ('pkcs8-der', 'pkcs8-pem'):
-            alg_params, data = self.encode_pkcs8_private()
+            alg_params, pkcs8_data = self.encode_pkcs8_private()
 
             if alg_params is OMIT:
-                data = der_encode((0, (self.pkcs8_oid,), data))
+                data = der_encode((0, (self.pkcs8_oid,), pkcs8_data))
             else:
-                data = der_encode((0, (self.pkcs8_oid, alg_params), data))
+                data = der_encode((0, (self.pkcs8_oid, alg_params), pkcs8_data))
 
             if passphrase is not None:
                 data = pkcs8_encrypt(data, cipher_name, hash_name,
                                      pbe_version, passphrase)
 
             if format_name == 'pkcs8-pem':
                 if passphrase is not None:
@@ -999,14 +1146,16 @@
         elif format_name == 'openssh':
             check = os.urandom(4)
             nkeys = 1
 
             data = b''.join((check, check, self.private_data,
                              String(self._comment or b'')))
 
+            cipher: Optional[Encryption]
+
             if passphrase is not None:
                 try:
                     alg = cipher_name.encode('ascii')
                     key_size, iv_size, block_size, _, _, _ = \
                         get_encryption_params(alg)
                 except (KeyError, UnicodeEncodeError):
                     raise KeyEncryptionError('Unknown cipher: %s' %
@@ -1051,15 +1200,15 @@
 
             return (b'-----BEGIN OPENSSH PRIVATE KEY-----\n' +
                     _wrap_base64(data, _OPENSSH_WRAP_LEN) +
                     b'-----END OPENSSH PRIVATE KEY-----\n')
         else:
             raise KeyExportError('Unknown export format')
 
-    def export_public_key(self, format_name='openssh'):
+    def export_public_key(self, format_name: str = 'openssh') -> bytes:
         """Export a public key in the requested format
 
            This method returns this object's public key encoded in the
            requested format. Available formats include:
 
                pkcs1-der, pkcs1-pem, pkcs8-der, pkcs8-pem, openssh, rfc4716
 
@@ -1080,21 +1229,21 @@
                 keytype = self.pem_name + b' PUBLIC KEY'
                 data = (b'-----BEGIN ' + keytype + b'-----\n' +
                         _wrap_base64(data) +
                         b'-----END ' + keytype + b'-----\n')
 
             return data
         elif format_name in ('pkcs8-der', 'pkcs8-pem'):
-            alg_params, data = self.encode_pkcs8_public()
-            data = BitString(data)
+            alg_params, pkcs8_data = self.encode_pkcs8_public()
+            pkcs8_data = BitString(pkcs8_data)
 
             if alg_params is OMIT:
-                data = der_encode(((self.pkcs8_oid,), data))
+                data = der_encode(((self.pkcs8_oid,), pkcs8_data))
             else:
-                data = der_encode(((self.pkcs8_oid, alg_params), data))
+                data = der_encode(((self.pkcs8_oid, alg_params), pkcs8_data))
 
             if format_name == 'pkcs8-pem':
                 data = (b'-----BEGIN PUBLIC KEY-----\n' +
                         _wrap_base64(data) +
                         b'-----END PUBLIC KEY-----\n')
 
             return data
@@ -1115,15 +1264,15 @@
 
             return (b'---- BEGIN SSH2 PUBLIC KEY ----\n' +
                     comment + _wrap_base64(self.public_data) +
                     b'---- END SSH2 PUBLIC KEY ----\n')
         else:
             raise KeyExportError('Unknown export format')
 
-    def write_private_key(self, filename, *args, **kwargs):
+    def write_private_key(self, filename: FilePath, *args, **kwargs) -> None:
         """Write a private key to a file in the requested format
 
            This method is a simple wrapper around :meth:`export_private_key`
            which writes the exported key data to a file.
 
            :param filename:
                The filename to write the private key to.
@@ -1132,15 +1281,15 @@
                :meth:`export_private_key`.
            :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
 
         """
 
         write_file(filename, self.export_private_key(*args, **kwargs))
 
-    def write_public_key(self, filename, *args, **kwargs):
+    def write_public_key(self, filename: FilePath, *args, **kwargs) -> None:
         """Write a public key to a file in the requested format
 
            This method is a simple wrapper around :meth:`export_public_key`
            which writes the exported key data to a file.
 
            :param filename:
                The filename to write the public key to.
@@ -1149,15 +1298,15 @@
                :meth:`export_public_key`.
            :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
 
         """
 
         write_file(filename, self.export_public_key(*args, **kwargs))
 
-    def append_private_key(self, filename, *args, **kwargs):
+    def append_private_key(self, filename: FilePath, *args, **kwargs) -> None:
         """Append a private key to a file in the requested format
 
            This method is a simple wrapper around :meth:`export_private_key`
            which appends the exported key data to an existing file.
 
            :param filename:
                The filename to append the private key to.
@@ -1166,15 +1315,15 @@
                :meth:`export_private_key`.
            :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
 
         """
 
         write_file(filename, self.export_private_key(*args, **kwargs), 'ab')
 
-    def append_public_key(self, filename, *args, **kwargs):
+    def append_public_key(self, filename: FilePath, *args, **kwargs) -> None:
         """Append a public key to a file in the requested format
 
            This method is a simple wrapper around :meth:`export_public_key`
            which appends the exported key data to an existing file.
 
            :param filename:
                The filename to append the public key to.
@@ -1190,56 +1339,64 @@
 
 class SSHCertificate:
     """Parent class which holds an SSH certificate"""
 
     is_x509 = False
     is_x509_chain = False
 
-    def __init__(self, algorithm, sig_algorithms, host_key_algorithms,
-                 key, public_data, comment):
+    def __init__(self, algorithm: bytes, sig_algorithms: Sequence[bytes],
+                 host_key_algorithms: Sequence[bytes], key: SSHKey,
+                 public_data: bytes, comment: _Comment):
         self.algorithm = algorithm
         self.sig_algorithms = sig_algorithms
         self.host_key_algorithms = host_key_algorithms
         self.key = key
         self.public_data = public_data
 
         self.set_comment(comment)
 
-    def __eq__(self, other):
+    @classmethod
+    def construct(cls, packet: SSHPacket, algorithm: bytes,
+                  key_handler: Optional[Type[SSHKey]],
+                  comment: _Comment) -> 'SSHCertificate':
+        """Construct an SSH certificate from packetized data"""
+
+    def __eq__(self, other: object) -> bool:
         return (isinstance(other, type(self)) and
                 self.public_data == other.public_data)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash(self.public_data)
 
-    def get_algorithm(self):
+    def get_algorithm(self) -> str:
         """Return the algorithm associated with this certificate"""
 
         return self.algorithm.decode('ascii')
 
-    def has_comment(self):
+    def has_comment(self) -> bool:
         """Return whether a comment is set for this certificate
 
            :returns: `bool`
 
         """
 
         return bool(self._comment)
 
-    def get_comment_bytes(self):
+    def get_comment_bytes(self) -> Optional[bytes]:
         """Return the comment associated with this certificate as a
            byte string
 
            :returns: `bytes` or `None`
 
         """
 
         return self._comment
 
-    def get_comment(self, encoding='utf-8', errors='strict'):
+    def get_comment(self, encoding: str = 'utf-8',
+                    errors: str = 'strict') -> Optional[str]:
         """Return the comment associated with this certificate as a
            Unicode string
 
            :param encoding:
                The encoding to use to decode the comment as a Unicode
                string, defaulting to UTF-8
            :param errors:
@@ -1252,15 +1409,16 @@
            :raises: :exc:`UnicodeDecodeError` if the comment cannot be
                     decoded using the specified encoding
 
         """
 
         return self._comment.decode(encoding, errors) if self._comment else None
 
-    def set_comment(self, comment, encoding='utf-8', errors='strict'):
+    def set_comment(self, comment: _Comment, encoding: str = 'utf-8',
+                    errors: str = 'strict') -> None:
         """Set the comment associated with this certificate
 
            :param comment:
                The new comment to associate with this key
            :param encoding:
                The Unicode encoding to use to encode the comment,
                defaulting to UTF-8
@@ -1276,15 +1434,15 @@
         """
 
         if isinstance(comment, str):
             comment = comment.encode(encoding, errors)
 
         self._comment = comment or None
 
-    def export_certificate(self, format_name='openssh'):
+    def export_certificate(self, format_name: str = 'openssh') -> bytes:
         """Export a certificate in the requested format
 
            This function returns this certificate encoded in the requested
            format. Available formats include:
 
                der, pem, openssh, rfc4716
 
@@ -1330,85 +1488,91 @@
 
             return (b'---- BEGIN SSH2 PUBLIC KEY ----\n' +
                     comment + _wrap_base64(self.public_data) +
                     b'---- END SSH2 PUBLIC KEY ----\n')
         else:
             raise KeyExportError('Unknown export format')
 
-    def write_certificate(self, filename, *args, **kwargs):
+    def write_certificate(self, filename: FilePath,
+                          format_name: str = 'openssh') -> None:
         """Write a certificate to a file in the requested format
 
            This function is a simple wrapper around export_certificate
            which writes the exported certificate to a file.
 
            :param filename:
                The filename to write the certificate to.
-           :param \\*args,\\ \\*\\*kwargs:
-               Additional arguments to pass through to
-               :meth:`export_certificate`.
+           :param format_name: (optional)
+               The format to export the certificate in.
            :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
+           :type format_name: `str`
 
         """
 
-        write_file(filename, self.export_certificate(*args, **kwargs))
+        write_file(filename, self.export_certificate(format_name))
 
-    def append_certificate(self, filename, *args, **kwargs):
+    def append_certificate(self, filename: FilePath,
+                           format_name: str = 'openssh') -> None:
         """Append a certificate to a file in the requested format
 
            This function is a simple wrapper around export_certificate
            which appends the exported certificate to an existing file.
 
            :param filename:
                The filename to append the certificate to.
-           :param \\*args,\\ \\*\\*kwargs:
-               Additional arguments to pass through to
-               :meth:`export_certificate`.
+           :param format_name: (optional)
+               The format to export the certificate in.
            :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
+           :type format_name: `str`
 
         """
 
-        write_file(filename, self.export_certificate(*args, **kwargs), 'ab')
+        write_file(filename, self.export_certificate(format_name), 'ab')
 
 
 class SSHOpenSSHCertificate(SSHCertificate):
     """Class which holds an OpenSSH certificate"""
 
-    _user_option_encoders = []
-    _user_extension_encoders = []
-    _host_option_encoders = []
-    _host_extension_encoders = []
-
-    _user_option_decoders = {}
-    _user_extension_decoders = {}
-    _host_option_decoders = {}
-    _host_extension_decoders = {}
-
-    def __init__(self, algorithm, key, data, principals, options, signing_key,
-                 serial, cert_type, key_id, valid_after, valid_before,
-                 comment):
+    _user_option_encoders: _OpenSSHCertEncoders = ()
+    _user_extension_encoders: _OpenSSHCertEncoders = ()
+    _host_option_encoders: _OpenSSHCertEncoders = ()
+    _host_extension_encoders: _OpenSSHCertEncoders = ()
+
+    _user_option_decoders: _OpenSSHCertDecoders = {}
+    _user_extension_decoders: _OpenSSHCertDecoders = {}
+    _host_option_decoders: _OpenSSHCertDecoders = {}
+    _host_extension_decoders: _OpenSSHCertDecoders = {}
+
+    def __init__(self, algorithm: bytes, key: SSHKey, data: bytes,
+                 principals: Sequence[str], options: _OpenSSHCertOptions,
+                 signing_key: SSHKey, serial: int, cert_type: int,
+                 key_id: str, valid_after: int, valid_before: int,
+                 comment: _Comment):
         super().__init__(algorithm, key.sig_algorithms, (algorithm,),
                          key, data, comment)
 
         self.principals = principals
         self.options = options
         self.signing_key = signing_key
 
         self._serial = serial
         self._cert_type = cert_type
         self._key_id = key_id
         self._valid_after = valid_after
         self._valid_before = valid_before
 
     @classmethod
-    def generate(cls, signing_key, algorithm, key, serial, cert_type, key_id,
-                 principals, valid_after, valid_before, options, comment):
+    def generate(cls, signing_key: 'SSHKey', algorithm: bytes, key: 'SSHKey',
+                 serial: int, cert_type: int, key_id: str,
+                 principals: Sequence[str], valid_after: int,
+                 valid_before: int, options: _OpenSSHCertOptions,
+                 comment: _Comment) -> 'SSHOpenSSHCertificate':
         """Generate a new SSH certificate"""
 
-        principals = list(principals)
-        cert_principals = b''.join(String(p) for p in principals)
+        principal_bytes = b''.join(String(p) for p in principals)
 
         if cert_type == CERT_TYPE_USER:
             cert_options = cls._encode_options(options,
                                                cls._user_option_encoders)
             cert_extensions = cls._encode_options(options,
                                                   cls._user_extension_encoders)
         else:
@@ -1417,157 +1581,165 @@
             cert_extensions = cls._encode_options(options,
                                                   cls._host_extension_encoders)
 
         key = key.convert_to_public()
 
         data = b''.join((String(algorithm),
                          cls._encode(key, serial, cert_type, key_id,
-                                     cert_principals, valid_after,
+                                     principal_bytes, valid_after,
                                      valid_before, cert_options,
                                      cert_extensions),
                          String(signing_key.public_data)))
 
         data += String(signing_key.sign(data, signing_key.algorithm))
 
         signing_key = signing_key.convert_to_public()
 
         return cls(algorithm, key, data, principals, options, signing_key,
                    serial, cert_type, key_id, valid_after, valid_before,
                    comment)
 
     @classmethod
-    def construct(cls, packet, algorithm, key_handler, comment):
+    def construct(cls, packet: SSHPacket, algorithm: bytes,
+                  key_handler: Optional[Type[SSHKey]],
+                  comment: _Comment) -> 'SSHCertificate':
         """Construct an SSH certificate from packetized data"""
 
+        assert key_handler is not None
+
         key_params, serial, cert_type, key_id, \
             principals, valid_after, valid_before, \
             options, extensions = cls._decode(packet, key_handler)
 
         signing_key = decode_ssh_public_key(packet.get_string())
         data = packet.get_consumed_payload()
         signature = packet.get_string()
         packet.check_end()
 
         if not signing_key.verify(data, signature):
             raise KeyImportError('Invalid certificate signature')
 
-        key = key_handler.make_public(*key_params)
+        key = key_handler.make_public(key_params)
         data = packet.get_consumed_payload()
 
         try:
-            key_id = key_id.decode('utf-8')
+            key_id_bytes = key_id.decode('utf-8')
         except UnicodeDecodeError:
             raise KeyImportError('Invalid characters in key ID') from None
 
         packet = SSHPacket(principals)
-        principals = []
+        principals: List[str] = []
 
         while packet:
             try:
                 principal = packet.get_string().decode('utf-8')
             except UnicodeDecodeError:
                 raise KeyImportError('Invalid characters in principal '
                                      'name') from None
 
             principals.append(principal)
 
         if cert_type == CERT_TYPE_USER:
-            options = cls._decode_options(options, cls._user_option_decoders,
-                                          True)
-            options.update(cls._decode_options(extensions,
-                                               cls._user_extension_decoders,
-                                               False))
+            cert_options = cls._decode_options(
+                options, cls._user_option_decoders, True)
+            cert_options.update(cls._decode_options(
+                extensions, cls._user_extension_decoders, False))
         elif cert_type == CERT_TYPE_HOST:
-            options = cls._decode_options(options, cls._host_option_decoders,
-                                          True)
-            options.update(cls._decode_options(extensions,
-                                               cls._host_extension_decoders,
-                                               False))
+            cert_options = cls._decode_options(
+                options, cls._host_option_decoders, True)
+            cert_options.update(cls._decode_options(
+                extensions, cls._host_extension_decoders, False))
         else:
             raise KeyImportError('Unknown certificate type')
 
-        return cls(algorithm, key, data, principals, options, signing_key,
-                   serial, cert_type, key_id, valid_after, valid_before,
+        return cls(algorithm, key, data, principals, cert_options, signing_key,
+                   serial, cert_type, key_id_bytes, valid_after, valid_before,
                    comment)
 
     @classmethod
-    def _encode(cls, key, serial, cert_type, key_id, principals,
-                valid_after, valid_before, options, extensions):
+    def _encode(cls, key: SSHKey, serial: int, cert_type: int, key_id: str,
+                principals: bytes, valid_after: int, valid_before: int,
+                options: bytes, extensions: bytes) -> bytes:
+
         """Encode an SSH certificate"""
 
         raise NotImplementedError
 
     @classmethod
-    def _decode(cls, packet, key_handler):
+    def _decode(cls, packet: SSHPacket,
+                key_handler: Type[SSHKey]) -> _OpenSSHCertParams:
         """Decode an SSH certificate"""
 
         raise NotImplementedError
 
     @staticmethod
-    def _encode_options(options, encoders):
+    def _encode_options(options: _OpenSSHCertOptions,
+                        encoders: _OpenSSHCertEncoders) -> bytes:
         """Encode options found in this certificate"""
 
         result = []
 
         for name, encoder in encoders:
             value = options.get(name)
             if value:
                 result.append(String(name) + String(encoder(value)))
 
         return b''.join(result)
 
     @staticmethod
-    def _encode_bool(_value):
+    def _encode_bool(_value: object) -> bytes:
         """Encode a boolean option value"""
 
         return b''
 
     @staticmethod
-    def _encode_force_cmd(force_command):
+    def _encode_force_cmd(force_command: object) -> bytes:
         """Encode a force-command option"""
 
-        return String(force_command)
+        return String(cast(BytesOrStr, force_command))
 
     @staticmethod
-    def _encode_source_addr(source_address):
+    def _encode_source_addr(source_address: object) -> bytes:
         """Encode a source-address option"""
 
-        return NameList(str(addr).encode('ascii') for addr in source_address)
+        return NameList(str(addr).encode('ascii')
+                        for addr in cast(Sequence[IPNetwork], source_address))
 
     @staticmethod
-    def _decode_bool(_packet):
+    def _decode_bool(_packet: SSHPacket) -> bool:
         """Decode a boolean option value"""
 
         return True
 
     @staticmethod
-    def _decode_force_cmd(packet):
+    def _decode_force_cmd(packet: SSHPacket) -> str:
         """Decode a force-command option"""
 
         try:
             return packet.get_string().decode('utf-8')
         except UnicodeDecodeError:
             raise KeyImportError('Invalid characters in command') from None
 
     @staticmethod
-    def _decode_source_addr(packet):
+    def _decode_source_addr(packet: SSHPacket) -> Sequence[IPNetwork]:
         """Decode a source-address option"""
 
         try:
             return [ip_network(addr.decode('ascii'))
                     for addr in packet.get_namelist()]
         except (UnicodeDecodeError, ValueError):
             raise KeyImportError('Invalid source address') from None
 
     @staticmethod
-    def _decode_options(options, decoders, critical=True):
+    def _decode_options(options: bytes, decoders: _OpenSSHCertDecoders,
+                        critical: bool = True) -> _OpenSSHCertOptions:
         """Decode options found in this certificate"""
 
         packet = SSHPacket(options)
-        result = {}
+        result: _OpenSSHCertOptions = {}
 
         while packet:
             name = packet.get_string()
 
             decoder = decoders.get(name)
             if decoder:
                 data_packet = SSHPacket(packet.get_string())
@@ -1575,15 +1747,15 @@
                 data_packet.check_end()
             elif critical:
                 raise KeyImportError('Unrecognized critical option: %s' %
                                      name.decode('ascii', errors='replace'))
 
         return result
 
-    def validate(self, cert_type, principal):
+    def validate(self, cert_type: int, principal: str) -> None:
         """Validate an OpenSSH certificate"""
 
         if self._cert_type != cert_type:
             raise ValueError('Invalid certificate type')
 
         now = time.time()
 
@@ -1625,26 +1797,28 @@
         b'permit-port-forwarding':  SSHOpenSSHCertificate._decode_bool,
         b'permit-pty':              SSHOpenSSHCertificate._decode_bool,
         b'permit-user-rc':          SSHOpenSSHCertificate._decode_bool,
         b'no-touch-required':       SSHOpenSSHCertificate._decode_bool
     }
 
     @classmethod
-    def _encode(cls, key, serial, cert_type, key_id, principals,
-                valid_after, valid_before, options, extensions):
+    def _encode(cls, key: SSHKey, serial: int, cert_type: int, key_id: str,
+                principals: bytes, valid_after: int, valid_before: int,
+                options: bytes, extensions: bytes) -> bytes:
         """Encode a version 01 SSH certificate"""
 
         return b''.join((String(os.urandom(32)), key.encode_ssh_public(),
                          UInt64(serial), UInt32(cert_type), String(key_id),
                          String(principals), UInt64(valid_after),
                          UInt64(valid_before), String(options),
                          String(extensions), String('')))
 
     @classmethod
-    def _decode(cls, packet, key_handler):
+    def _decode(cls, packet: SSHPacket,
+                key_handler: Type[SSHKey]) -> _OpenSSHCertParams:
         """Decode a version 01 SSH certificate"""
 
         _ = packet.get_string()                             # nonce
         key_params = key_handler.decode_ssh_public(packet)
         serial = packet.get_uint64()
         cert_type = packet.get_uint32()
         key_id = packet.get_string()
@@ -1660,85 +1834,94 @@
 
 
 class SSHX509Certificate(SSHCertificate):
     """Encoder/decoder class for SSH X.509 certificates"""
 
     is_x509 = True
 
-    def __init__(self, key, x509_cert, comment=None):
+    def __init__(self, key: SSHKey, x509_cert: 'X509Certificate',
+                 comment: _Comment = None):
         super().__init__(b'x509v3-' + key.algorithm, key.x509_algorithms,
                          key.x509_algorithms, key, x509_cert.data,
                          x509_cert.comment or comment)
 
         self.subject = x509_cert.subject
         self.issuer = x509_cert.issuer
         self.issuer_hash = x509_cert.issuer_hash
         self.user_principals = x509_cert.user_principals
         self.x509_cert = x509_cert
 
-    def _expand_trust_store(self, cert, trusted_cert_paths, trust_store):
+    def _expand_trust_store(self, cert: 'SSHX509Certificate',
+                            trusted_cert_paths: Sequence[FilePath],
+                            trust_store: Set['SSHX509Certificate']) -> None:
         """Look up certificates by issuer hash to build a trust store"""
 
         issuer_hash = cert.issuer_hash
 
         for path in trusted_cert_paths:
             idx = 0
 
             try:
                 while True:
                     cert_path = Path(path, issuer_hash + '.' + str(idx))
                     idx += 1
 
-                    c = read_certificate(cert_path)
+                    c = cast('SSHX509Certificate', read_certificate(cert_path))
 
                     if c.subject != cert.issuer or c in trust_store:
                         continue
 
                     trust_store.add(c)
                     self._expand_trust_store(c, trusted_cert_paths, trust_store)
             except (OSError, KeyImportError):
                 pass
 
     @classmethod
-    def generate(cls, signing_key, key, subject, issuer, serial, valid_after,
-                 valid_before, ca, ca_path_len, purposes, user_principals,
-                 host_principals, hash_alg, comment):
+    def generate(cls, signing_key: 'SSHKey', key: 'SSHKey', subject: str,
+                 issuer: Optional[str], serial: Optional[int],
+                 valid_after: int, valid_before: int, ca: bool,
+                 ca_path_len: Optional[int], purposes: X509CertPurposes,
+                 user_principals: _CertPrincipals,
+                 host_principals: _CertPrincipals, hash_name: str,
+                 comment: _Comment) -> 'SSHX509Certificate':
         """Generate a new X.509 certificate"""
 
         key = key.convert_to_public()
 
-        if isinstance(comment, str):
-            comment = comment.encode('utf-8')
-
-        x509_cert = generate_x509_certificate(signing_key, key, subject, issuer,
+        x509_cert = generate_x509_certificate(signing_key.pyca_key,
+                                              key.pyca_key, subject, issuer,
                                               serial, valid_after, valid_before,
                                               ca, ca_path_len, purposes,
                                               user_principals, host_principals,
-                                              hash_alg, comment)
+                                              hash_name, comment)
 
         return cls(key, x509_cert)
 
     @classmethod
-    def construct(cls, data, comment=None):
+    def construct_from_der(cls, data: bytes,
+                           comment: _Comment = None) -> 'SSHX509Certificate':
         """Construct an SSH X.509 certificate from DER data"""
 
         try:
             x509_cert = import_x509_certificate(data)
             key = import_public_key(x509_cert.key_data)
         except ValueError as exc:
             raise KeyImportError(str(exc)) from None
 
         return cls(key, x509_cert, comment)
 
-    def validate_chain(self, trust_chain, trusted_certs, trusted_cert_paths,
-                       purposes, user_principal=None, host_principal=None):
+    def validate_chain(self, trust_chain: Sequence['SSHX509Certificate'],
+                       trusted_certs: Sequence['SSHX509Certificate'],
+                       trusted_cert_paths: Sequence[FilePath],
+                       purposes: X509CertPurposes, user_principal: str = '',
+                       host_principal: str = '') -> None:
         """Validate an X.509 certificate chain"""
 
-        trust_chain = set(c for c in trust_chain if c.subject != c.issuer)
-        trust_store = trust_chain | set(c for c in trusted_certs)
+        trust_store = set(c for c in trust_chain if c.subject != c.issuer) | \
+            set(c for c in trusted_certs)
 
         if trusted_cert_paths:
             self._expand_trust_store(self, trusted_cert_paths, trust_store)
 
             for c in trust_chain:
                 self._expand_trust_store(c, trusted_cert_paths, trust_store)
 
@@ -1747,39 +1930,47 @@
 
 
 class SSHX509CertificateChain(SSHCertificate):
     """Encoder/decoder class for an SSH X.509 certificate chain"""
 
     is_x509_chain = True
 
-    def __init__(self, algorithm, certs, ocsp_responses, comment):
+    def __init__(self, algorithm: bytes, certs: Sequence[SSHCertificate],
+                 ocsp_responses: Sequence[bytes], comment: _Comment):
         key = certs[0].key
         data = self._public_data(algorithm, certs, ocsp_responses)
 
         super().__init__(algorithm, key.x509_algorithms, key.x509_algorithms,
                          key, data, comment)
 
-        self.subject = certs[0].subject
-        self.issuer = certs[-1].issuer
-        self.user_principals = certs[0].user_principals
+        x509_certs = cast(Sequence[SSHX509Certificate], certs)
+        first_cert = x509_certs[0]
+        last_cert = x509_certs[-1]
+
+        self.subject = first_cert.subject
+        self.issuer = last_cert.issuer
+        self.user_principals = first_cert.user_principals
 
-        self._certs = certs
+        self._certs = x509_certs
         self._ocsp_responses = ocsp_responses
 
     @staticmethod
-    def _public_data(algorithm, certs, ocsp_responses):
+    def _public_data(algorithm: bytes, certs: Sequence[SSHCertificate],
+                     ocsp_responses: Sequence[bytes]) -> bytes:
         """Return the X509 chain public data"""
 
         return (String(algorithm) + UInt32(len(certs)) +
                 b''.join(String(c.public_data) for c in certs) +
                 UInt32(len(ocsp_responses)) +
                 b''.join(String(resp) for resp in ocsp_responses))
 
     @classmethod
-    def construct(cls, packet, algorithm, _key_handler, comment=None):
+    def construct(cls, packet: SSHPacket, algorithm: bytes,
+                  key_handler: Optional[Type[SSHKey]],
+                  comment: _Comment) -> 'SSHX509CertificateChain':
         """Construct an SSH X.509 certificate from packetized data"""
 
         cert_count = packet.get_uint32()
         certs = [import_certificate(packet.get_string())
                  for _ in range(cert_count)]
 
         ocsp_resp_count = packet.get_uint32()
@@ -1789,28 +1980,32 @@
 
         if not certs:
             raise KeyImportError('No certificates present')
 
         return cls(algorithm, certs, ocsp_responses, comment)
 
     @classmethod
-    def construct_from_certs(cls, certs):
+    def construct_from_certs(cls, certs: Sequence['SSHCertificate']) -> \
+            'SSHX509CertificateChain':
         """Construct an SSH X.509 certificate chain from certificates"""
 
         cert = certs[0]
 
         return cls(cert.algorithm, certs, (), cert.get_comment_bytes())
 
-    def adjust_public_data(self, algorithm):
+    def adjust_public_data(self, algorithm: bytes) -> bytes:
         """Adjust public data to reflect chosen signature algorithm"""
 
         return self._public_data(algorithm, self._certs, self._ocsp_responses)
 
-    def validate_chain(self, trusted_certs, trusted_cert_paths, revoked_certs,
-                       purposes, user_principal=None, host_principal=None):
+    def validate_chain(self, trusted_certs: Sequence[SSHX509Certificate],
+                       trusted_cert_paths: Sequence[FilePath],
+                       revoked_certs: Set[SSHX509Certificate],
+                       purposes: X509CertPurposes, user_principal: str = '',
+                       host_principal: str = '') -> None:
         """Validate an X.509 certificate chain"""
 
         if revoked_certs:
             for cert in self._certs:
                 if cert in revoked_certs:
                     raise ValueError('Revoked X.509 certificate in '
                                      'certificate chain')
@@ -1828,17 +2023,20 @@
        algorithm and public key or certificate information needed to
        identify what key was used for signing.
 
     """
 
     _key_type = 'unknown'
 
-    def __init__(self, algorithm, sig_algorithm, sig_algorithms,
-                 host_key_algorithms, public_data, comment,
-                 cert=None, filename=None, use_executor=False):
+    def __init__(self, algorithm: bytes, sig_algorithm: bytes,
+                 sig_algorithms: Sequence[bytes],
+                 host_key_algorithms: Sequence[bytes],
+                 public_data: bytes, comment: _Comment,
+                 cert: SSHCertificate = None, filename: bytes = None,
+                 use_executor: bool = False):
         self.key_algorithm = algorithm
         self.key_public_data = public_data
 
         self.set_comment(comment)
         self._cert = cert
         self._filename = filename
 
@@ -1861,40 +2059,47 @@
         else:
             self.algorithm = algorithm
             self.sig_algorithm = algorithm
             self.sig_algorithms = sig_algorithms
             self.host_key_algorithms = host_key_algorithms
             self.public_data = public_data
 
-    def get_key_type(self):
+    def get_key_type(self) -> str:
         """Return what type of key pair this is
 
            This method returns 'local' for locally loaded keys, and
            'agent' for keys managed by an SSH agent.
 
         """
 
         return self._key_type
 
-    def get_algorithm(self):
+    def get_algorithm(self) -> str:
         """Return the algorithm associated with this key pair"""
 
         return self.algorithm.decode('ascii')
 
-    def get_comment_bytes(self):
+    def get_agent_private_key(self) -> bytes:
+        """Return binary encoding of keypair for upload to SSH agent"""
+
+        # pylint: disable=no-self-use
+        raise KeyImportError('Private key export to agent not supported')
+
+    def get_comment_bytes(self) -> Optional[bytes]:
         """Return the comment associated with this key pair as a
            byte string
 
            :returns: `bytes` or `None`
 
         """
 
         return self._comment or self._filename
 
-    def get_comment(self, encoding='utf-8', errors='strict'):
+    def get_comment(self, encoding: str = 'utf-8',
+                    errors: str = 'strict') -> Optional[str]:
         """Return the comment associated with this key pair as a
            Unicode string
 
            :param encoding:
                The encoding to use to decode the comment as a Unicode
                string, defaulting to UTF-8
            :param errors:
@@ -1909,15 +2114,16 @@
 
         """
 
         comment = self.get_comment_bytes()
 
         return comment.decode(encoding, errors) if comment else None
 
-    def set_comment(self, comment, encoding='utf-8', errors='strict'):
+    def set_comment(self, comment: _Comment, encoding: str = 'utf-8',
+                    errors: str = 'strict') -> None:
         """Set the comment associated with this key pair
 
            :param comment:
                The new comment to associate with this key
            :param encoding:
                The Unicode encoding to use to encode the comment,
                defaulting to UTF-8
@@ -1933,15 +2139,15 @@
         """
 
         if isinstance(comment, str):
             comment = comment.encode(encoding, errors)
 
         self._comment = comment or None
 
-    def set_certificate(self, cert):
+    def set_certificate(self, cert: SSHCertificate) -> None:
         """Set certificate to use with this key"""
 
         if cert.key.public_data != self.key_public_data:
             raise ValueError('Certificate key mismatch')
 
         self._cert = cert
         self.algorithm = cert.algorithm
@@ -1951,43 +2157,44 @@
         else:
             self.sig_algorithm = self.key_algorithm
 
         self.sig_algorithms = cert.sig_algorithms
         self.host_key_algorithms = cert.host_key_algorithms
         self.public_data = cert.public_data
 
-    def set_sig_algorithm(self, sig_algorithm):
+    def set_sig_algorithm(self, sig_algorithm: bytes) -> None:
         """Set the signature algorithm to use when signing data"""
 
         self.sig_algorithm = sig_algorithm
 
         if not self._cert:
             self.algorithm = sig_algorithm
         elif self._cert.is_x509_chain:
             self.algorithm = sig_algorithm
-            self.public_data = self._cert.adjust_public_data(sig_algorithm)
 
-    def sign(self, data):
-        """Sign a block of data with this private key"""
+            cert = cast('SSHX509CertificateChain', self._cert)
+            self.public_data = cert.adjust_public_data(sig_algorithm)
 
-        raise NotImplementedError
+    def sign(self, data: bytes) -> bytes:
+        """Sign a block of data with this private key"""
 
 
 class SSHLocalKeyPair(SSHKeyPair):
     """Class which holds a local asymmetric key pair
 
        This class holds a private key and associated public data
        which can either be the matching public key or a certificate
        which has signed that public key.
 
     """
 
     _key_type = 'local'
 
-    def __init__(self, key, pubkey=None, cert=None):
+    def __init__(self, key: SSHKey, pubkey: SSHKey = None,
+                 cert: SSHCertificate = None):
         if pubkey and pubkey.public_data != key.public_data:
             raise ValueError('Public key mismatch')
 
         if key.has_comment():
             comment = key.get_comment_bytes()
         elif cert and cert.has_comment():
             comment = cert.get_comment_bytes()
@@ -1998,32 +2205,32 @@
 
         super().__init__(key.algorithm, key.algorithm, key.sig_algorithms,
                          key.sig_algorithms, key.public_data, comment, cert,
                          key.get_filename(), key.use_executor)
 
         self._key = key
 
-    def get_agent_private_key(self):
+    def get_agent_private_key(self) -> bytes:
         """Return binary encoding of keypair for upload to SSH agent"""
 
         if self._cert:
             data = String(self.public_data) + \
                        self._key.encode_agent_cert_private()
         else:
             data = self._key.encode_ssh_private()
 
         return String(self.algorithm) + data
 
-    def sign(self, data):
+    def sign(self, data: bytes) -> bytes:
         """Sign a block of data with this private key"""
 
         return self._key.sign(data, self.sig_algorithm)
 
 
-def _parse_openssh(data):
+def _parse_openssh(data: bytes) -> Tuple[bytes, Optional[bytes], bytes]:
     """Parse an OpenSSH format public key or certificate"""
 
     line = data.split(None, 2)
 
     if len(line) < 2:
         raise KeyImportError('Invalid OpenSSH public key or certificate')
     elif len(line) == 2:
@@ -2038,20 +2245,20 @@
     try:
         return line[0], comment, binascii.a2b_base64(line[1])
     except binascii.Error:
         raise KeyImportError('Invalid OpenSSH public key '
                              'or certificate') from None
 
 
-def _parse_pem(data):
+def _parse_pem(data: bytes) -> Tuple[Mapping[bytes, bytes], bytes]:
     """Parse a PEM data block"""
 
     start = 0
-    end = None
-    headers = {}
+    end: Optional[int] = None
+    headers: Dict[bytes, bytes] = {}
 
     while True:
         end = data.find(b'\n', start) + 1
 
         line = data[start:end] if end else data[start:]
         line = line.rstrip()
 
@@ -2065,15 +2272,15 @@
 
     try:
         return headers, binascii.a2b_base64(data[start:])
     except binascii.Error:
         raise KeyImportError('Invalid PEM data') from None
 
 
-def _parse_rfc4716(data):
+def _parse_rfc4716(data: bytes) -> Tuple[Optional[bytes], bytes]:
     """Parse an RFC 4716 data block"""
 
     start = 0
     end = None
     hdr = b''
     comment = None
 
@@ -2102,38 +2309,36 @@
 
     try:
         return comment, binascii.a2b_base64(data[start:])
     except binascii.Error:
         raise KeyImportError('Invalid RFC 4716 data') from None
 
 
-def _match_block(data, start, header, fmt):
+def _match_block(data: bytes, start: int, header: bytes,
+                 fmt: str) -> Tuple[bytes, int]:
     """Match a block of data wrapped in a header/footer"""
 
     match = re.compile(b'^' + header[:5] + b'END' + header[10:] +
                        rb'[ \t\r\f\v]*$', re.M).search(data, start)
 
     if not match:
         raise KeyImportError('Missing %s footer' % fmt)
 
     return data[start:match.start()], match.end()
 
 
-def _match_next(data, keytype, public=False):
+def _match_next(data: bytes, keytype: bytes, public: bool = False) -> \
+        Tuple[Optional[str], Tuple, Optional[int]]:
     """Find the next key/certificate and call the appropriate decode"""
 
-    if isinstance(data, str):
-        try:
-            data = data.encode('ascii')
-        except UnicodeEncodeError:
-            raise KeyImportError('Invalid encoding for key') from None
+    end: Optional[int]
 
     if data.startswith(b'\x30'):
         try:
-            key_data, end = der_decode(data, partial_ok=True)
+            key_data, end = der_decode_partial(data)
             return 'der', (key_data,), end
         except ASN1DecodeError:
             pass
 
     start = 0
     end = None
 
@@ -2162,47 +2367,47 @@
                     return 'openssh', cert, (end if end else len(data))
 
         start = end
 
     return None, (), len(data)
 
 
-def _decode_pkcs1_private(pem_name, key_data):
+def _decode_pkcs1_private(pem_name: bytes, key_data: object) -> SSHKey:
     """Decode a PKCS#1 format private key"""
 
     handler = _pem_map.get(pem_name)
     if handler is None:
         raise KeyImportError('Unknown PEM key type: %s' %
                              pem_name.decode('ascii'))
 
     key_params = handler.decode_pkcs1_private(key_data)
     if key_params is None:
         raise KeyImportError('Invalid %s private key' %
                              pem_name.decode('ascii'))
 
-    return handler.make_private(*key_params)
+    return handler.make_private(key_params)
 
 
-def _decode_pkcs1_public(pem_name, key_data):
+def _decode_pkcs1_public(pem_name: bytes, key_data: object) -> SSHKey:
     """Decode a PKCS#1 format public key"""
 
     handler = _pem_map.get(pem_name)
     if handler is None:
         raise KeyImportError('Unknown PEM key type: %s' %
                              pem_name.decode('ascii'))
 
     key_params = handler.decode_pkcs1_public(key_data)
     if key_params is None:
         raise KeyImportError('Invalid %s public key' %
                              pem_name.decode('ascii'))
 
-    return handler.make_public(*key_params)
+    return handler.make_public(key_params)
 
 
-def _decode_pkcs8_private(key_data):
+def _decode_pkcs8_private(key_data: object) -> SSHKey:
     """Decode a PKCS#8 format private key"""
 
     if (isinstance(key_data, tuple) and len(key_data) >= 3 and
             key_data[0] in (0, 1) and isinstance(key_data[1], tuple) and
             1 <= len(key_data[1]) <= 2 and isinstance(key_data[2], bytes)):
         if len(key_data[1]) == 2:
             alg, alg_params = key_data[1]
@@ -2215,20 +2420,20 @@
 
         key_params = handler.decode_pkcs8_private(alg_params, key_data[2])
         if key_params is None:
             raise KeyImportError('Invalid %s private key' %
                                  handler.pem_name.decode('ascii')
                                  if handler.pem_name else 'PKCS#8')
 
-        return handler.make_private(*key_params)
+        return handler.make_private(key_params)
     else:
         raise KeyImportError('Invalid PKCS#8 private key')
 
 
-def _decode_pkcs8_public(key_data):
+def _decode_pkcs8_public(key_data: object) -> SSHKey:
     """Decode a PKCS#8 format public key"""
 
     if (isinstance(key_data, tuple) and len(key_data) == 2 and
             isinstance(key_data[0], tuple) and 1 <= len(key_data[0]) <= 2 and
             isinstance(key_data[1], BitString) and key_data[1].unused == 0):
         if len(key_data[0]) == 2:
             alg, alg_params = key_data[0]
@@ -2241,20 +2446,21 @@
 
         key_params = handler.decode_pkcs8_public(alg_params, key_data[1].value)
         if key_params is None:
             raise KeyImportError('Invalid %s public key' %
                                  handler.pem_name.decode('ascii')
                                  if handler.pem_name else 'PKCS#8')
 
-        return handler.make_public(*key_params)
+        return handler.make_public(key_params)
     else:
         raise KeyImportError('Invalid PKCS#8 public key')
 
 
-def _decode_openssh_private(data, passphrase):
+def _decode_openssh_private(data: bytes,
+                            passphrase: Optional[BytesOrStr]) -> SSHKey:
     """Decode an OpenSSH format private key"""
 
     try:
         if not data.startswith(_OPENSSH_KEY_V1):
             raise KeyImportError('Unrecognized OpenSSH private key type')
 
         data = data[len(_OPENSSH_KEY_V1):]
@@ -2296,27 +2502,29 @@
             rounds = packet.get_uint32()
             packet.check_end()
 
             if isinstance(passphrase, str):
                 passphrase = passphrase.encode('utf-8')
 
             try:
-                key = bcrypt.kdf(passphrase, salt, key_size + iv_size,
-                                 rounds, ignore_few_rounds=True)
+                bcrypt_key = bcrypt.kdf(passphrase, salt, key_size + iv_size,
+                                        rounds, ignore_few_rounds=True)
             except ValueError:
                 raise KeyEncryptionError('Invalid OpenSSH '
                                          'private key') from None
 
-            cipher = get_encryption(cipher_name, key[:key_size], key[key_size:])
+            cipher = get_encryption(cipher_name, bcrypt_key[:key_size],
+                                    bcrypt_key[key_size:])
 
-            key_data = cipher.decrypt_packet(0, b'', key_data, 0, mac)
+            decrypted_key = cipher.decrypt_packet(0, b'', key_data, 0, mac)
 
-            if key_data is None:
+            if decrypted_key is None:
                 raise KeyEncryptionError('Incorrect passphrase')
 
+            key_data = decrypted_key
             block_size = max(block_size, 8)
         else:
             block_size = 8
 
         packet = SSHPacket(key_data)
 
         check1 = packet.get_uint32()
@@ -2335,22 +2543,22 @@
         key_params = handler.decode_ssh_private(packet)
         comment = packet.get_string()
         pad = packet.get_remaining_payload()
 
         if len(pad) >= block_size or pad != bytes(range(1, len(pad) + 1)):
             raise KeyImportError('Invalid OpenSSH private key')
 
-        key = handler.make_private(*key_params)
+        key = handler.make_private(key_params)
         key.set_comment(comment)
         return key
     except PacketDecodeError:
         raise KeyImportError('Invalid OpenSSH private key') from None
 
 
-def _decode_openssh_public(data):
+def _decode_openssh_public(data: bytes) -> SSHKey:
     """Decode public key within OpenSSH format private key"""
 
     try:
         if not data.startswith(_OPENSSH_KEY_V1):
             raise KeyImportError('Unrecognized OpenSSH private key type')
 
         data = data[len(_OPENSSH_KEY_V1):]
@@ -2366,15 +2574,16 @@
             raise KeyImportError('Invalid OpenSSH private key')
 
         return decode_ssh_public_key(pubkey)
     except PacketDecodeError:
         raise KeyImportError('Invalid OpenSSH private key') from None
 
 
-def _decode_der_private(key_data, passphrase):
+def _decode_der_private(key_data: object,
+                        passphrase: Optional[BytesOrStr]) -> SSHKey:
     """Decode a DER format private key"""
 
     # First, if there's a passphrase, try to decrypt PKCS#8
     if passphrase is not None:
         try:
             key_data = pkcs8_decrypt(key_data, passphrase)
         except KeyEncryptionError:
@@ -2395,15 +2604,15 @@
         except KeyImportError:
             # Try the next PKCS#1 encoding
             pass
 
     raise KeyImportError('Invalid DER private key')
 
 
-def _decode_der_public(key_data):
+def _decode_der_public(key_data: object) -> SSHKey:
     """Decode a DER format public key"""
 
     # First, try to decode PKCS#8
     try:
         return _decode_pkcs8_public(key_data)
     except KeyImportError:
         # PKCS#8 failed - try PKCS#1 instead
@@ -2416,21 +2625,24 @@
         except KeyImportError:
             # Try the next PKCS#1 encoding
             pass
 
     raise KeyImportError('Invalid DER public key')
 
 
-def _decode_der_certificate(data, comment=None):
+def _decode_der_certificate(data: bytes,
+                            comment: _Comment = None) -> SSHCertificate:
     """Decode a DER format X.509 certificate"""
 
-    return SSHX509Certificate.construct(data, comment)
+    return SSHX509Certificate.construct_from_der(data, comment)
 
 
-def _decode_pem_private(pem_name, headers, data, passphrase):
+def _decode_pem_private(pem_name: bytes, headers: Mapping[bytes, bytes],
+                        data: bytes, passphrase: Optional[BytesOrStr]) -> \
+        SSHKey:
     """Decode a PEM format private key"""
 
     if pem_name == b'OPENSSH':
         return _decode_openssh_private(data, passphrase)
 
     if headers.get(b'Proc-Type') == b'4,ENCRYPTED':
         if passphrase is None:
@@ -2473,65 +2685,70 @@
 
     if pem_name:
         return _decode_pkcs1_private(pem_name, key_data)
     else:
         return _decode_pkcs8_private(key_data)
 
 
-def _decode_pem_public(pem_name, data):
+def _decode_pem_public(pem_name: bytes, data: bytes) -> SSHKey:
     """Decode a PEM format public key"""
 
     try:
         key_data = der_decode(data)
     except ASN1DecodeError:
         raise KeyImportError('Invalid PEM public key') from None
 
     if pem_name:
         return _decode_pkcs1_public(pem_name, key_data)
     else:
         return _decode_pkcs8_public(key_data)
 
 
-def _decode_pem_certificate(pem_name, data):
+def _decode_pem_certificate(pem_name: bytes, data: bytes) -> SSHCertificate:
     """Decode a PEM format X.509 certificate"""
 
     if pem_name == b'TRUSTED':
         # Strip off OpenSSL trust information
         try:
-            _, end = der_decode(data, partial_ok=True)
+            _, end = der_decode_partial(data)
             data = data[:end]
         except ASN1DecodeError:
             raise KeyImportError('Invalid PEM trusted certificate') from None
     elif pem_name:
         raise KeyImportError('Invalid PEM certificate')
 
-    return SSHX509Certificate.construct(data)
+    return SSHX509Certificate.construct_from_der(data)
 
 
-def _decode_private(data, passphrase):
+def _decode_private(data: bytes, passphrase: Optional[BytesOrStr]) -> \
+        Tuple[Optional[SSHKey], Optional[int]]:
     """Decode a private key"""
 
     fmt, key_info, end = _match_next(data, b'PRIVATE KEY')
 
+    key: Optional[SSHKey]
+
     if fmt == 'der':
         key = _decode_der_private(key_info[0], passphrase)
     elif fmt == 'pem':
         pem_name, headers, data = key_info
         key = _decode_pem_private(pem_name, headers, data, passphrase)
     else:
         key = None
 
     return key, end
 
 
-def _decode_public(data):
+def _decode_public(data: bytes) -> Tuple[Optional[SSHKey], Optional[int]]:
     """Decode a public key"""
 
     fmt, key_info, end = _match_next(data, b'PUBLIC KEY', public=True)
 
+    key: Optional[SSHKey]
+
     if fmt == 'der':
         key = _decode_der_public(key_info[0])
     elif fmt == 'pem':
         pem_name, _, data = key_info
         key = _decode_pem_public(pem_name, data)
     elif fmt == 'openssh':
         algorithm, comment, data = key_info
@@ -2555,19 +2772,22 @@
 
             if key:
                 key = key.convert_to_public()
 
     return key, end
 
 
-def _decode_certificate(data):
+def _decode_certificate(data: bytes) -> \
+        Tuple[Optional[SSHCertificate], Optional[int]]:
     """Decode a certificate"""
 
     fmt, key_info, end = _match_next(data, b'CERTIFICATE', public=True)
 
+    cert: Optional[SSHCertificate]
+
     if fmt == 'der':
         cert = _decode_der_certificate(data[:end])
     elif fmt == 'pem':
         pem_name, _, data = key_info
         cert = _decode_pem_certificate(pem_name, data)
     elif fmt == 'openssh':
         algorithm, comment, data = key_info
@@ -2581,36 +2801,71 @@
         cert = decode_ssh_certificate(data, comment)
     else:
         cert = None
 
     return cert, end
 
 
-def _decode_list(data, decoder, *args, **kwargs):
-    """Decode a key or certificate list"""
+def _decode_private_list(data: bytes, passphrase: Optional[BytesOrStr]) -> \
+        Sequence[SSHKey]:
+    """Decode a private key list"""
 
-    result = []
+    keys: List[SSHKey] = []
 
     while data:
-        obj, end = decoder(data, *args, **kwargs)
+        key, end = _decode_private(data, passphrase)
 
-        if obj:
-            result.append(obj)
+        if key:
+            keys.append(key)
 
         data = data[end:]
 
-    return result
+    return keys
+
+
+def _decode_public_list(data: bytes) -> Sequence[SSHKey]:
+    """Decode a public key list"""
+
+    keys: List[SSHKey] = []
+
+    while data:
+        key, end = _decode_public(data)
+
+        if key:
+            keys.append(key)
+
+        data = data[end:]
+
+    return keys
+
+
+def _decode_certificate_list(data: bytes) -> Sequence[SSHCertificate]:
+    """Decode a certificate list"""
+
+    certs: List[SSHCertificate] = []
+
+    while data:
+        cert, end = _decode_certificate(data)
+
+        if cert:
+            certs.append(cert)
+
+        data = data[end:]
 
+    return certs
 
-def register_sk_alg(sk_alg, handler, *args):
+
+def register_sk_alg(sk_alg: int, handler: Type[SSHKey], *args: object) -> None:
     """Register a new security key algorithm"""
 
     _sk_alg_map[sk_alg] = handler, args
 
-def register_public_key_alg(algorithm, handler, default, sig_algorithms=None):
+def register_public_key_alg(algorithm: bytes, handler: Type[SSHKey],
+                            default: bool,
+                            sig_algorithms: Sequence[bytes] = None) -> None:
     """Register a new public key algorithm"""
 
     if not sig_algorithms:
         sig_algorithms = handler.sig_algorithms
 
     _public_key_algs.extend(sig_algorithms)
 
@@ -2622,100 +2877,104 @@
     if handler.pem_name:
         _pem_map[handler.pem_name] = handler
 
     if handler.pkcs8_oid: # pragma: no branch
         _pkcs8_oid_map[handler.pkcs8_oid] = handler
 
 
-def register_certificate_alg(version, algorithm, cert_algorithm,
-                             key_handler, cert_handler, default):
+def register_certificate_alg(version: int, algorithm: bytes,
+                             cert_algorithm: bytes,
+                             key_handler: Type[SSHKey],
+                             cert_handler: Type[SSHOpenSSHCertificate],
+                             default: bool) -> None:
     """Register a new certificate algorithm"""
 
     _certificate_algs.append(cert_algorithm)
 
     if default:
         _default_certificate_algs.append(cert_algorithm)
 
     _certificate_alg_map[cert_algorithm] = (key_handler, cert_handler)
 
     _certificate_version_map[algorithm, version] = \
         (cert_algorithm, cert_handler)
 
 
-def register_x509_certificate_alg(cert_algorithm, default):
+def register_x509_certificate_alg(cert_algorithm: bytes, default: bool) -> None:
     """Register a new X.509 certificate algorithm"""
 
     if _x509_available: # pragma: no branch
         _x509_certificate_algs.append(cert_algorithm)
 
         if default:
             _default_x509_certificate_algs.append(cert_algorithm)
 
         _certificate_alg_map[cert_algorithm] = (None, SSHX509CertificateChain)
 
 
-def get_public_key_algs():
+def get_public_key_algs() -> List[bytes]:
     """Return supported public key algorithms"""
 
     return _public_key_algs
 
 
-def get_default_public_key_algs():
+def get_default_public_key_algs() -> List[bytes]:
     """Return default public key algorithms"""
 
     return _default_public_key_algs
 
 
-def get_certificate_algs():
+def get_certificate_algs() -> List[bytes]:
     """Return supported certificate-based public key algorithms"""
 
     return _certificate_algs
 
 
-def get_default_certificate_algs():
+def get_default_certificate_algs() -> List[bytes]:
     """Return default certificate-based public key algorithms"""
 
     return _default_certificate_algs
 
 
-def get_x509_certificate_algs():
+def get_x509_certificate_algs() -> List[bytes]:
     """Return supported X.509 certificate-based public key algorithms"""
 
     return _x509_certificate_algs
 
 
-def get_default_x509_certificate_algs():
+def get_default_x509_certificate_algs() -> List[bytes]:
     """Return default X.509 certificate-based public key algorithms"""
 
     return _default_x509_certificate_algs
 
 
-def decode_ssh_public_key(data):
+def decode_ssh_public_key(data: bytes) -> SSHKey:
     """Decode a packetized SSH public key"""
 
     try:
         packet = SSHPacket(data)
         alg = packet.get_string()
         handler = _public_key_alg_map.get(alg)
 
         if handler:
             key_params = handler.decode_ssh_public(packet)
             packet.check_end()
 
-            key = handler.make_public(*key_params)
+            key = handler.make_public(key_params)
             key.algorithm = alg
             return key
         else:
             raise KeyImportError('Unknown key algorithm: %s' %
                                  alg.decode('ascii', errors='replace'))
     except PacketDecodeError:
         raise KeyImportError('Invalid public key') from None
 
 
-def decode_ssh_certificate(data, comment=None):
+def decode_ssh_certificate(data: bytes,
+                           comment: _Comment = None) -> SSHCertificate:
     """Decode a packetized SSH certificate"""
 
     try:
         packet = SSHPacket(data)
         alg = packet.get_string()
         key_handler, cert_handler = _certificate_alg_map.get(alg, (None, None))
 
@@ -2724,15 +2983,16 @@
         else:
             raise KeyImportError('Unknown certificate algorithm: %s' %
                                  alg.decode('ascii', errors='replace'))
     except (PacketDecodeError, ValueError):
         raise KeyImportError('Invalid OpenSSH certificate') from None
 
 
-def generate_private_key(alg_name, comment=None, **kwargs):
+def generate_private_key(alg_name: str, comment: _Comment = None,
+                         **kwargs) -> SSHKey:
     """Generate a new private key
 
        This function generates a new private key of a type matching
        the requested SSH algorithm. Depending on the algorithm, additional
        parameters can be passed which affect the generated key.
 
        Available algorithms include:
@@ -2823,15 +3083,16 @@
             raise KeyGenerationError(str(exc)) from None
     else:
         raise KeyGenerationError('Unknown algorithm: %s' % alg_name)
 
     key.set_comment(comment)
     return key
 
-def import_private_key(data, passphrase=None):
+def import_private_key(data: BytesOrStr,
+                       passphrase: Optional[BytesOrStr] = None) -> SSHKey:
     """Import a private key
 
        This function imports a private key encoded in PKCS#1 or PKCS#8 DER
        or PEM format or OpenSSH format. Encrypted private keys can be
        imported by specifying the passphrase needed to decrypt them.
 
        :param data:
@@ -2841,91 +3102,113 @@
        :type data: `bytes` or ASCII `str`
        :type passphrase: `str` or `bytes`
 
        :returns: An :class:`SSHKey` private key
 
     """
 
+    if isinstance(data, str):
+        try:
+            data = data.encode('ascii')
+        except UnicodeEncodeError:
+            raise KeyImportError('Invalid encoding for key') from None
+
     key, _ = _decode_private(data, passphrase)
 
     if key:
         return key
     else:
         raise KeyImportError('Invalid private key')
 
 
-def import_private_key_and_certs(data, passphrase=None):
+def import_private_key_and_certs(data: bytes,
+                                 passphrase: Optional[BytesOrStr] = None) -> \
+        Tuple[SSHKey, Optional[SSHX509CertificateChain]]:
     """Import a private key and optional certificate chain"""
 
     key, end = _decode_private(data, passphrase)
 
     if key:
         return key, import_certificate_chain(data[end:])
     else:
         raise KeyImportError('Invalid private key')
 
 
-def import_public_key(data):
+def import_public_key(data: BytesOrStr) -> SSHKey:
     """Import a public key
 
        This function imports a public key encoded in OpenSSH, RFC4716, or
        PKCS#1 or PKCS#8 DER or PEM format.
 
        :param data:
            The data to import.
        :type data: `bytes` or ASCII `str`
 
        :returns: An :class:`SSHKey` public key
 
     """
 
+    if isinstance(data, str):
+        try:
+            data = data.encode('ascii')
+        except UnicodeEncodeError:
+            raise KeyImportError('Invalid encoding for key') from None
+
     key, _ = _decode_public(data)
 
     if key:
         return key
     else:
         raise KeyImportError('Invalid public key')
 
 
-def import_certificate(data):
+def import_certificate(data: BytesOrStr) -> SSHCertificate:
     """Import a certificate
 
        This function imports an SSH certificate in DER, PEM, OpenSSH, or
        RFC4716 format.
 
        :param data:
            The data to import.
        :type data: `bytes` or ASCII `str`
 
        :returns: An :class:`SSHCertificate` object
 
     """
 
+    if isinstance(data, str):
+        try:
+            data = data.encode('ascii')
+        except UnicodeEncodeError:
+            raise KeyImportError('Invalid encoding for key') from None
+
     cert, _ = _decode_certificate(data)
 
     if cert:
         return cert
     else:
         raise KeyImportError('Invalid certificate')
 
 
-def import_certificate_chain(data):
+def import_certificate_chain(data: bytes) -> Optional[SSHX509CertificateChain]:
     """Import an X.509 certificate chain"""
 
-    certs = _decode_list(data, _decode_certificate)
+    certs = _decode_certificate_list(data)
+
+    chain: Optional[SSHX509CertificateChain]
 
     if certs:
         chain = SSHX509CertificateChain.construct_from_certs(certs)
     else:
         chain = None
 
     return chain
 
 
-def import_certificate_subject(data):
+def import_certificate_subject(data: str) -> str:
     """Import an X.509 certificate subject name"""
 
     try:
         algorithm, data = data.strip().split(None, 1)
     except ValueError:
         raise KeyImportError('Missing certificate subject algorithm') from None
 
@@ -2934,15 +3217,16 @@
 
         if match:
             return data[match.end():]
 
     raise KeyImportError('Invalid certificate subject')
 
 
-def read_private_key(filename, passphrase=None):
+def read_private_key(filename: FilePath,
+                     passphrase: Optional[BytesOrStr] = None) -> SSHKey:
     """Read a private key from a file
 
        This function reads a private key from a file. See the function
        :func:`import_private_key` for information about the formats
        supported.
 
        :param filename:
@@ -2959,25 +3243,27 @@
     key = import_private_key(read_file(filename), passphrase)
 
     key.set_filename(filename)
 
     return key
 
 
-def read_private_key_and_certs(filename, passphrase=None):
+def read_private_key_and_certs(filename: FilePath,
+                               passphrase: Optional[BytesOrStr] = None) -> \
+        Tuple[SSHKey, Optional[SSHX509CertificateChain]]:
     """Read a private key and optional certificate chain from a file"""
 
     key, cert = import_private_key_and_certs(read_file(filename), passphrase)
 
     key.set_filename(filename)
 
     return key, cert
 
 
-def read_public_key(filename):
+def read_public_key(filename: FilePath) -> SSHKey:
     """Read a public key from a file
 
        This function reads a public key from a file. See the function
        :func:`import_public_key` for information about the formats
        supported.
 
        :param filename:
@@ -2991,15 +3277,15 @@
     key = import_public_key(read_file(filename))
 
     key.set_filename(filename)
 
     return key
 
 
-def read_certificate(filename):
+def read_certificate(filename: FilePath) -> SSHCertificate:
     """Read a certificate from a file
 
        This function reads an SSH certificate from a file. See the
        function :func:`import_certificate` for information about the
        formats supported.
 
        :param filename:
@@ -3009,15 +3295,17 @@
        :returns: An :class:`SSHCertificate` object
 
     """
 
     return import_certificate(read_file(filename))
 
 
-def read_private_key_list(filename, passphrase=None):
+def read_private_key_list(filename: FilePath,
+                          passphrase: Optional[BytesOrStr] = None) -> \
+        Sequence[SSHKey]:
     """Read a list of private keys from a file
 
        This function reads a list of private keys from a file. See the
        function :func:`import_private_key` for information about the
        formats supported. If any of the keys are encrypted, they must
        all be encrypted with the same passphrase.
 
@@ -3028,65 +3316,67 @@
        :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
        :type passphrase: `str` or `bytes`
 
        :returns: A list of :class:`SSHKey` private keys
 
     """
 
-    keys = _decode_list(read_file(filename), _decode_private, passphrase)
+    keys = _decode_private_list(read_file(filename), passphrase)
 
     for key in keys:
         key.set_filename(filename)
 
     return keys
 
 
-def read_public_key_list(filename):
+def read_public_key_list(filename: FilePath) -> Sequence[SSHKey]:
     """Read a list of public keys from a file
 
        This function reads a list of public keys from a file. See the
        function :func:`import_public_key` for information about the
        formats supported.
 
        :param filename:
            The file to read the keys from.
        :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
 
        :returns: A list of :class:`SSHKey` public keys
 
     """
 
-    keys = _decode_list(read_file(filename), _decode_public)
+    keys = _decode_public_list(read_file(filename))
 
     for key in keys:
         key.set_filename(filename)
 
     return keys
 
 
-def read_certificate_list(filename):
+def read_certificate_list(filename: FilePath) -> Sequence[SSHCertificate]:
     """Read a list of certificates from a file
 
        This function reads a list of SSH certificates from a file. See
        the function :func:`import_certificate` for information about
        the formats supported.
 
        :param filename:
            The file to read the certificates from.
        :type filename: :class:`PurePath <pathlib.PurePath>` or `str`
 
        :returns: A list of :class:`SSHCertificate` certificates
 
     """
 
-    return _decode_list(read_file(filename), _decode_certificate)
+    return _decode_certificate_list(read_file(filename))
 
 
-def load_keypairs(keylist, passphrase=None, certlist=(),
-                  skip_public=False, ignore_encrypted=False):
+def load_keypairs(keylist: KeyPairListArg,
+                  passphrase: Optional[BytesOrStr] = None,
+                  certlist: CertListArg = (), skip_public: bool = False,
+                  ignore_encrypted: bool = False) -> Sequence[SSHKeyPair]:
     """Load SSH private keys and optional matching certificates
 
        This function loads a list of SSH keys and optional matching
        certificates.
 
        When certificates are specified, the private key is added to
        the list both with and without the certificate.
@@ -3107,97 +3397,109 @@
        :type certlist: *see* :ref:`SpecifyingCertificates`
        :type skip_public: `bool`
 
        :returns: A list of :class:`SSHKeyPair` objects
 
     """
 
-    result = []
+    keys_to_load: Sequence[_KeyPairArg]
+    result: List[SSHKeyPair] = []
 
     certlist = load_certificates(certlist)
     certdict = {cert.key.public_data: cert for cert in certlist}
 
     if isinstance(keylist, (PurePath, str)):
         try:
-            keys = read_private_key_list(keylist, passphrase)
-
-            if len(keys) > 1:
-                keylist = keys
-            else:
-                keylist = [keylist]
+            priv_keys = read_private_key_list(keylist, passphrase)
+            keys_to_load = [keylist] if len(priv_keys) <= 1 else priv_keys
         except KeyImportError:
-            keylist = [keylist]
+            keys_to_load = [keylist]
     elif isinstance(keylist, (tuple, bytes, SSHKey, SSHKeyPair)):
-        keylist = [keylist]
-    elif not keylist:
-        keylist = []
+        keys_to_load = [cast(_KeyPairArg, keylist)]
+    else:
+        keys_to_load = keylist if keylist else []
 
-    for key in keylist:
+    for key_to_load in keys_to_load:
         allow_certs = False
         key_prefix = None
-        pubkey_or_certs = None
-        certs = None
-        pubkey = None
         saved_exc = None
+        pubkey_or_certs = None
+        pubkey_to_load: Optional[_KeyArg] = None
+        certs_to_load: Optional[_CertArg] = None
+        key: Union['SSHKey', 'SSHKeyPair']
 
-        if isinstance(key, (PurePath, str, bytes)):
+        if isinstance(key_to_load, (PurePath, str, bytes)):
             allow_certs = True
-        elif isinstance(key, tuple):
-            key, pubkey_or_certs = key
+        elif isinstance(key_to_load, tuple):
+            key_to_load, pubkey_or_certs = key_to_load
 
         try:
-            if isinstance(key, (PurePath, str)):
-                key_prefix = str(key)
+            if isinstance(key_to_load, (PurePath, str)):
+                key_prefix = str(key_to_load)
 
                 if allow_certs:
-                    key, certs = read_private_key_and_certs(key, passphrase)
+                    key, certs_to_load = \
+                        read_private_key_and_certs(key_to_load, passphrase)
 
-                    if not certs:
-                        certs = key_prefix + '-cert.pub'
+                    if not certs_to_load:
+                        certs_to_load = key_prefix + '-cert.pub'
                 else:
-                    key = read_private_key(key, passphrase)
+                    key = read_private_key(key_to_load, passphrase)
 
-                pubkey = key_prefix + '.pub'
-            elif isinstance(key, bytes):
+                pubkey_to_load = key_prefix + '.pub'
+            elif isinstance(key_to_load, bytes):
                 if allow_certs:
-                    key, certs = import_private_key_and_certs(key, passphrase)
+                    key, certs_to_load = \
+                        import_private_key_and_certs(key_to_load, passphrase)
                 else:
-                    key = import_private_key(key, passphrase)
+                    key = import_private_key(key_to_load, passphrase)
+            else:
+                key = key_to_load
         except KeyImportError as exc:
             if skip_public or \
                     (ignore_encrypted and str(exc).startswith('Passphrase')):
                 continue
 
             raise
 
+        certs: Optional[Sequence[SSHCertificate]]
+
         if pubkey_or_certs:
             try:
                 certs = load_certificates(pubkey_or_certs)
             except (TypeError, OSError, KeyImportError) as exc:
                 saved_exc = exc
                 certs = None
 
             if not certs:
-                pubkey = pubkey_or_certs
-        elif certs:
+                pubkey_to_load = cast(_KeyArg, pubkey_or_certs)
+        elif certs_to_load:
             try:
-                certs = load_certificates(certs)
-            except (OSError, KeyImportError) as exc:
+                certs = load_certificates(certs_to_load)
+            except (OSError, KeyImportError):
                 certs = None
+        else:
+            certs = None
+
+        pubkey: Optional[SSHKey]
 
-        if pubkey:
+        if pubkey_to_load:
             try:
-                if isinstance(pubkey, (PurePath, str)):
-                    pubkey = read_public_key(pubkey)
-                elif isinstance(pubkey, bytes):
-                    pubkey = import_public_key(pubkey)
+                if isinstance(pubkey_to_load, (PurePath, str)):
+                    pubkey = read_public_key(pubkey_to_load)
+                elif isinstance(pubkey_to_load, bytes):
+                    pubkey = import_public_key(pubkey_to_load)
+                else:
+                    pubkey = pubkey_to_load
             except (OSError, KeyImportError):
                 pubkey = None
             else:
                 saved_exc = None
+        else:
+            pubkey = None
 
         if saved_exc:
             raise saved_exc # pylint: disable=raising-bad-type
 
         if not certs:
             if isinstance(key, SSHKeyPair):
                 pubdata = key.key_public_data
@@ -3223,32 +3525,34 @@
                 result.append(SSHLocalKeyPair(key, pubkey, cert))
 
             result.append(SSHLocalKeyPair(key, pubkey))
 
     return result
 
 
-def load_default_keypairs(passphrase=None, certlist=()):
+def load_default_keypairs(passphrase: Optional[BytesOrStr] = None,
+                          certlist: CertListArg = ()) -> \
+        Sequence[SSHKeyPair]:
     """Return a list of default keys from the user's home directory"""
 
-    result = []
+    result: List[SSHKeyPair] = []
 
     for file, condition in _DEFAULT_KEY_FILES:
         if condition: # pragma: no branch
             try:
-                file = Path('~', '.ssh', file).expanduser()
-                result.extend(load_keypairs(file, passphrase, certlist,
+                path = Path('~', '.ssh', file).expanduser()
+                result.extend(load_keypairs(path, passphrase, certlist,
                                             ignore_encrypted=True))
             except OSError:
                 pass
 
     return result
 
 
-def load_public_keys(keylist):
+def load_public_keys(keylist: KeyListArg) -> Sequence[SSHKey]:
     """Load public keys
 
        This function loads a list of SSH public keys.
 
        :param keylist:
            The list of public keys to load.
        :type keylist: *see* :ref:`SpecifyingPublicKeys`
@@ -3256,31 +3560,31 @@
        :returns: A list of :class:`SSHKey` objects
 
     """
 
     if isinstance(keylist, (PurePath, str)):
         return read_public_key_list(keylist)
     else:
-        result = []
+        result: List[SSHKey] = []
 
         for key in keylist:
             if isinstance(key, (PurePath, str)):
                 key = read_public_key(key)
             elif isinstance(key, bytes):
                 key = import_public_key(key)
 
             result.append(key)
 
         return result
 
 
-def load_default_host_public_keys():
+def load_default_host_public_keys() -> Sequence[Union[SSHKey, SSHCertificate]]:
     """Return a list of default host public keys or certificates"""
 
-    result = []
+    result: List[Union[SSHKey, SSHCertificate]] = []
 
     for host_key_dir in _DEFAULT_HOST_KEY_DIRS:
         for file in _DEFAULT_HOST_KEY_FILES:
             try:
                 cert = read_certificate(Path(host_key_dir, file + '-cert.pub'))
             except (OSError, KeyImportError):
                 pass
@@ -3295,15 +3599,15 @@
                 pass
             else:
                 result.append(key)
 
     return result
 
 
-def load_certificates(certlist):
+def load_certificates(certlist: CertListArg) -> Sequence[SSHCertificate]:
     """Load certificates
 
        This function loads a list of OpenSSH or X.509 certificates.
 
        :param certlist:
            The list of certificates to load.
        :type certlist: *see* :ref:`SpecifyingCertificates`
@@ -3313,64 +3617,68 @@
     """
 
     if isinstance(certlist, SSHCertificate):
         return [certlist]
     elif isinstance(certlist, (PurePath, str, bytes)):
         certlist = [certlist]
 
-    result = []
+    result: List[SSHCertificate] = []
 
     for cert in certlist:
         if isinstance(cert, (PurePath, str)):
             certs = read_certificate_list(cert)
         elif isinstance(cert, bytes):
-            certs = _decode_list(cert, _decode_certificate)
+            certs = _decode_certificate_list(cert)
         elif isinstance(cert, SSHCertificate):
             certs = [cert]
         else:
             certs = cert
 
         result.extend(certs)
 
     return result
 
 
-def load_identities(keylist, skip_private=False):
+def load_identities(keylist: IdentityListArg,
+                    skip_private: bool = False) -> Sequence[bytes]:
     """Load public key and certificate identities"""
 
-    if isinstance(keylist, (PurePath, str, bytes, SSHKey, SSHCertificate)):
-        keylist = [keylist]
+    if isinstance(keylist, (bytes, str, PurePath, SSHKey, SSHCertificate)):
+        identities: Sequence[_IdentityArg] = [keylist]
+    else:
+        identities = keylist
 
     result = []
 
-    for identity in keylist:
+    for identity in identities:
         if isinstance(identity, (PurePath, str)):
             try:
-                identity = read_certificate(identity)
+                pubdata = read_certificate(identity).public_data
             except KeyImportError:
                 try:
-                    identity = read_public_key(identity)
+                    pubdata = read_public_key(identity).public_data
                 except KeyImportError:
                     if skip_private:
                         continue
 
                     raise
+        elif isinstance(identity, (SSHKey, SSHCertificate)):
+            pubdata = identity.public_data
+        else:
+            pubdata = identity
 
-        if isinstance(identity, (SSHKey, SSHCertificate)):
-            identity = identity.public_data
-
-        result.append(identity)
+        result.append(pubdata)
 
     return result
 
 
-def load_default_identities():
+def load_default_identities() -> Sequence[bytes]:
     """Return a list of default public key and certificate identities"""
 
-    result = []
+    result: List[bytes] = []
 
     for file, condition in _DEFAULT_KEY_FILES:
         if condition: # pragma: no branch
             try:
                 cert = read_certificate(Path('~', '.ssh', file + '-cert.pub'))
             except (OSError, KeyImportError):
                 pass
@@ -3383,16 +3691,16 @@
                 pass
             else:
                 result.append(key.public_data)
 
     return result
 
 
-def load_resident_keys(pin, *, application='ssh:', user=None,
-                       touch_required=True):
+def load_resident_keys(pin: str, *, application: str = 'ssh:', user: str = None,
+                       touch_required: bool = True) -> Sequence[SSHKey]:
     """Load keys resident on attached FIDO2 security keys
 
        This function loads keys resident on any FIDO2 security keys
        currently attached to the system. The user name associated
        with each key is returned in the key's comment field.
 
        :param pin:
@@ -3418,19 +3726,19 @@
     reserved = b''
 
     try:
         resident_keys = sk_get_resident(application, user, pin)
     except ValueError as exc:
         raise KeyImportError(str(exc)) from None
 
-    result = []
+    result: List[SSHKey] = []
 
     for sk_alg, name, public_value, key_handle in resident_keys:
-        handler, args = _sk_alg_map[sk_alg]
+        handler, key_params = _sk_alg_map[sk_alg]
+        key_params += (public_value, application, flags, key_handle, reserved)
 
-        key = handler.make_private(*args, public_value, application,
-                                   flags, key_handle, reserved)
+        key = handler.make_private(key_params)
         key.set_comment(name)
 
         result.append(key)
 
     return result
```

### Comparing `asyncssh-2.8.1/asyncssh/agent_win32.py` & `asyncssh-2.9.0/asyncssh/agent_win32.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -23,17 +23,24 @@
 # Some of the imports below won't be found when running pylint on UNIX
 # pylint: disable=import-error
 
 import asyncio
 import ctypes
 import ctypes.wintypes
 import errno
+from typing import TYPE_CHECKING, Optional, Tuple, Union, cast
 
 from .misc import open_file
 
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .agent import AgentReader, AgentWriter
+
+
 try:
     import mmapfile
     import win32api
     import win32con
     import win32ui
     _pywin32_available = True
 except ImportError:
@@ -43,15 +50,15 @@
 _AGENT_COPYDATA_ID = 0x804e50ba
 _AGENT_MAX_MSGLEN = 8192
 _AGENT_NAME = 'Pageant'
 
 _DEFAULT_OPENSSH_PATH = r'\\.\pipe\openssh-ssh-agent'
 
 
-def _find_agent_window():
+def _find_agent_window() -> 'win32ui.PyCWnd':
     """Find and return the Pageant window"""
 
     if _pywin32_available:
         try:
             return win32ui.FindWindow(_AGENT_NAME, _AGENT_NAME)
         except win32ui.error:
             raise OSError(errno.ENOENT, 'Agent not found') from None
@@ -66,105 +73,112 @@
                 ('cbData', ctypes.wintypes.DWORD),
                 ('lpData', ctypes.c_char_p))
 
 
 class _PageantTransport:
     """Transport to connect to Pageant agent on Windows"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         self._mapname = '%s%08x' % (_AGENT_NAME, win32api.GetCurrentThreadId())
 
         try:
-            self._mapfile = mmapfile.mmapfile(None, self._mapname,
+            self._mapfile = mmapfile.mmapfile('', self._mapname,
                                               _AGENT_MAX_MSGLEN, 0, 0)
         except mmapfile.error as exc:
             raise OSError(errno.EIO, str(exc)) from None
 
         self._cds = _CopyDataStruct(_AGENT_COPYDATA_ID, len(self._mapname) + 1,
                                     self._mapname.encode())
 
         self._writing = False
 
-    def write(self, data):
+    def write(self, data: bytes) -> None:
         """Write request data to Pageant agent"""
 
         if not self._writing:
             self._mapfile.seek(0)
             self._writing = True
 
         try:
             self._mapfile.write(data)
         except ValueError as exc:
             raise OSError(errno.EIO, str(exc)) from None
 
-    async def readexactly(self, n):
+    async def readexactly(self, n: int) -> bytes:
         """Read response data from Pageant agent"""
 
         if self._writing:
             cwnd = _find_agent_window()
 
-            if not cwnd.SendMessage(win32con.WM_COPYDATA, None, self._cds):
+            if not cwnd.SendMessage(win32con.WM_COPYDATA, 0,
+                                    cast(int, self._cds)):
                 raise OSError(errno.EIO, 'Unable to send agent request')
 
             self._writing = False
             self._mapfile.seek(0)
 
         result = self._mapfile.read(n)
 
         if len(result) != n:
             raise asyncio.IncompleteReadError(result, n)
 
         return result
 
-    def close(self):
+    def close(self) -> None:
         """Close the connection to Pageant"""
 
         if self._mapfile:
             self._mapfile.close()
-            self._mapfile = None
+
+    async def wait_closed(self) -> None:
+        """Wait for the transport to close"""
 
 
 class _W10OpenSSHTransport:
     """Transport to connect to OpenSSH agent on Windows 10"""
 
-    def __init__(self, agent_path):
+    def __init__(self, agent_path: str):
         self._agentfile = open_file(agent_path, 'r+b')
 
-    def write(self, data):
-        """Write request data to OpenSSH agent"""
-
-        self._agentfile.write(data)
-
-    async def readexactly(self, n):
+    async def readexactly(self, n: int) -> bytes:
         """Read response data from OpenSSH agent"""
 
         result = self._agentfile.read(n)
 
         if len(result) != n:
             raise asyncio.IncompleteReadError(result, n)
 
         return result
 
-    def close(self):
+    def write(self, data: bytes) -> None:
+        """Write request data to OpenSSH agent"""
+
+        self._agentfile.write(data)
+
+    def close(self) -> None:
         """Close the connection to OpenSSH"""
 
         if self._agentfile:
             self._agentfile.close()
-            self._agentfile = None
+
+    async def wait_closed(self) -> None:
+        """Wait for the transport to close"""
 
 
-async def open_agent(agent_path):
+async def open_agent(agent_path: Optional[str]) -> \
+        Tuple['AgentReader', 'AgentWriter']:
     """Open a connection to the Pageant or Windows 10 OpenSSH agent"""
 
-    transport = None
+    transport: Union[None, _PageantTransport, _W10OpenSSHTransport] = None
 
     if not agent_path:
         try:
             _find_agent_window()
             transport = _PageantTransport()
         except OSError:
             agent_path = _DEFAULT_OPENSSH_PATH
 
     if not transport:
+        assert agent_path is not None
         transport = _W10OpenSSHTransport(agent_path)
 
     return transport, transport
```

### Comparing `asyncssh-2.8.1/asyncssh/eddsa.py` & `asyncssh-2.9.0/asyncssh/eddsa.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2019-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2019-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,147 +16,164 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """EdDSA public key encryption handler"""
 
+from typing import Optional, Tuple, Union, cast
+
 from .asn1 import ASN1DecodeError, ObjectIdentifier, der_encode, der_decode
 from .crypto import EdDSAPrivateKey, EdDSAPublicKey
 from .crypto import ed25519_available, ed448_available
-from .packet import String
+from .packet import String, SSHPacket
 from .public_key import OMIT, SSHKey, SSHOpenSSHCertificateV01
 from .public_key import KeyImportError, KeyExportError
 from .public_key import register_public_key_alg, register_certificate_alg
 from .public_key import register_x509_certificate_alg
 
 
+_PrivateKeyArgs = Tuple[bytes]
+_PublicKeyArgs = Tuple[bytes]
+
+
 class _EdKey(SSHKey):
     """Handler for EdDSA public key encryption"""
 
+    _key: Union[EdDSAPrivateKey, EdDSAPublicKey]
+
     algorithm = b''
 
-    def __eq__(self, other):
+    def __eq__(self, other: object) -> bool:
         # This isn't protected access - both objects are _EdKey instances
         # pylint: disable=protected-access
 
         return (isinstance(other, type(self)) and
                 self._key.public_value == other._key.public_value and
                 self._key.private_value == other._key.private_value)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self._key.public_value, self._key.private_value))
 
     @classmethod
-    def generate(cls, algorithm):
+    def generate(cls, algorithm: bytes) -> '_EdKey': # type: ignore
         """Generate a new EdDSA private key"""
 
+        # pylint: disable=arguments-differ
+
         # Strip 'ssh-' prefix of algorithm to get curve_id
         return cls(EdDSAPrivateKey.generate(algorithm[4:]))
 
     @classmethod
-    def make_private(cls, private_value):
+    def make_private(cls, key_params: object) -> SSHKey:
         """Construct an EdDSA private key"""
 
         try:
+            private_value, = cast(_PrivateKeyArgs, key_params)
+
             return cls(EdDSAPrivateKey.construct(cls.algorithm[4:],
                                                  private_value))
         except (TypeError, ValueError):
             raise KeyImportError('Invalid EdDSA private key') from None
 
     @classmethod
-    def make_public(cls, public_value):
+    def make_public(cls, key_params: object) -> SSHKey:
         """Construct an EdDSA public key"""
 
         try:
+            public_value, = cast(_PublicKeyArgs, key_params)
+
             return cls(EdDSAPublicKey.construct(cls.algorithm[4:],
                                                 public_value))
         except (TypeError, ValueError):
             raise KeyImportError('Invalid EdDSA public key') from None
 
     @classmethod
-    def decode_pkcs8_private(cls, alg_params, data):
+    def decode_pkcs8_private(cls, alg_params: object,
+                             data: bytes) -> Optional[_PrivateKeyArgs]:
         """Decode a PKCS#8 format EdDSA private key"""
 
         # pylint: disable=unused-argument
 
         try:
-            return (der_decode(data),)
+            return (cast(bytes, der_decode(data)),)
         except ASN1DecodeError:
             return None
 
     @classmethod
-    def decode_pkcs8_public(cls, alg_params, key_data):
+    def decode_pkcs8_public(cls, alg_params: object,
+                            data: bytes) -> Optional[_PublicKeyArgs]:
         """Decode a PKCS#8 format EdDSA public key"""
 
         # pylint: disable=unused-argument
 
-        return (key_data,)
+        return (data,)
 
     @classmethod
-    def decode_ssh_private(cls, packet):
+    def decode_ssh_private(cls, packet: SSHPacket) -> _PrivateKeyArgs:
         """Decode an SSH format EdDSA private key"""
 
         public_value = packet.get_string()
         private_value = packet.get_string()
 
         return (private_value[:-len(public_value)],)
 
     @classmethod
-    def decode_ssh_public(cls, packet):
+    def decode_ssh_public(cls, packet: SSHPacket) -> _PublicKeyArgs:
         """Decode an SSH format EdDSA public key"""
 
         public_value = packet.get_string()
 
         return (public_value,)
 
-    def encode_pkcs8_private(self):
+    def encode_pkcs8_private(self) -> Tuple[object, object]:
         """Encode a PKCS#8 format EdDSA private key"""
 
         if not self._key.private_value:
             raise KeyExportError('Key is not private')
 
         return OMIT, der_encode(self._key.private_value)
 
-    def encode_pkcs8_public(self):
+    def encode_pkcs8_public(self) -> Tuple[object, object]:
         """Encode a PKCS#8 format EdDSA public key"""
 
         return OMIT, self._key.public_value
 
-    def encode_ssh_private(self):
+    def encode_ssh_private(self) -> bytes:
         """Encode an SSH format EdDSA private key"""
 
         if self._key.private_value is None:
             raise KeyExportError('Key is not private')
 
         return b''.join((String(self._key.public_value),
                          String(self._key.private_value +
                                 self._key.public_value)))
 
-    def encode_ssh_public(self):
+    def encode_ssh_public(self) -> bytes:
         """Encode an SSH format EdDSA public key"""
 
         return String(self._key.public_value)
 
-    def encode_agent_cert_private(self):
+    def encode_agent_cert_private(self) -> bytes:
         """Encode EdDSA certificate private key data for agent"""
 
         return self.encode_ssh_private()
 
-    def sign_ssh(self, data, sig_algorithm):
+    def sign_ssh(self, data: bytes, sig_algorithm: bytes) -> bytes:
         """Compute an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         if not self._key.private_value:
             raise ValueError('Private key needed for signing')
 
         return String(self._key.sign(data))
 
-    def verify_ssh(self, data, sig_algorithm, packet):
+    def verify_ssh(self, data: bytes, sig_algorithm: bytes,
+                   packet: SSHPacket) -> bool:
         """Verify an SSH-encoded signature of the specified data"""
 
         # pylint: disable=unused-argument
 
         sig = packet.get_string()
         packet.check_end()
```

### Comparing `asyncssh-2.8.1/asyncssh/scp.py` & `asyncssh-2.9.0/asyncssh/scp.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2017-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2017-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -26,102 +26,155 @@
 import asyncio
 import posixpath
 from pathlib import PurePath
 import shlex
 import stat
 import string
 import sys
+from types import TracebackType
+from typing import TYPE_CHECKING, List, NoReturn, Optional
+from typing import Sequence, Tuple, Type, Union, cast
+from typing_extensions import Protocol
 
 from .constants import DEFAULT_LANG
+from .logging import SSHLogger
+from .misc import BytesOrStr, FilePath, HostPort, MaybeAwait
+from .misc import async_context_manager, plural
+from .sftp import SFTPAttrs, SFTPServer, SFTPServerFS, SFTPFileProtocol
+from .sftp import SFTPError, SFTPFailure, SFTPBadMessage, SFTPConnectionLost
+from .sftp import SFTPErrorHandler, SFTPProgressHandler
+from .sftp import SFTP_BLOCK_SIZE, local_fs, match_glob
 
-from .misc import plural
 
-from .sftp import LocalFile, match_glob
-from .sftp import SFTP_BLOCK_SIZE, SFTPAttrs, SFTPServerFile
-from .sftp import SFTPError, SFTPFailure, SFTPBadMessage, SFTPConnectionLost
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHServerChannel
+    from .connection import SSHClientConnection
+    from .stream import SSHReader, SSHWriter
+
+
+_SCPConn = Union[None, bytes, str, HostPort, 'SSHClientConnection']
+_SCPPath = Union[bytes, FilePath]
+_SCPConnPath = Union[Tuple[_SCPConn, _SCPPath], _SCPConn, _SCPPath]
+
+
+class _SCPFSProtocol(Protocol):
+    """Protocol for accessing a filesystem during an SCP copy"""
+
+    @staticmethod
+    def basename(path: bytes) -> bytes:
+        """Return the final component of a POSIX-style path"""
+
+    async def stat(self, path: bytes) -> 'SFTPAttrs':
+        """Get attributes of a file or directory, following symlinks"""
+
+    async def setstat(self, path: bytes, attrs: 'SFTPAttrs') -> None:
+        """Set attributes of a file or directory"""
 
+    async def exists(self, path: bytes) -> bool:
+        """Return if a path exists"""
 
-def _scp_error(exc_class, reason, path=None, fatal=False,
-               suppress_send=False, lang=DEFAULT_LANG):
+    async def isdir(self, path: bytes) -> bool:
+        """Return if the path refers to a directory"""
+
+    async def listdir(self, path: bytes) -> Sequence[bytes]:
+        """List the contents of a directory"""
+
+    async def mkdir(self, path: bytes) -> None:
+        """Create a directory"""
+
+    @async_context_manager
+    async def open(self, path: bytes, mode: str) -> SFTPFileProtocol:
+        """Open a file"""
+
+
+def _scp_error(exc_class: Type[Exception], reason: BytesOrStr,
+               path: Optional[bytes] = None, fatal: bool = False,
+               suppress_send: bool = False,
+               lang: str = DEFAULT_LANG) -> Exception:
     """Construct SCP version of SFTPError exception"""
 
     if isinstance(reason, bytes):
         reason = reason.decode('utf-8', errors='replace')
 
-    if isinstance(path, bytes):
-        path = path.decode('utf-8', errors='replace')
-
     if path:
-        reason = reason + ': ' + path
+        reason = reason + ': ' + path.decode('utf-8', errors='replace')
 
     exc = exc_class(reason, lang)
 
-    # pylint: disable=attribute-defined-outside-init
-    exc.fatal = fatal
-    exc.suppress_send = suppress_send
+    setattr(exc, 'fatal', fatal)
+    setattr(exc, 'suppress_send', suppress_send)
 
     return exc
 
 
-def _parse_cd_args(args):
+def _parse_cd_args(args: bytes) -> Tuple[int, int, bytes]:
     """Parse arguments to an SCP copy or dir request"""
 
     try:
         permissions, size, name = args.split(None, 2)
         return int(permissions, 8), int(size), name
     except ValueError:
         raise _scp_error(SFTPBadMessage,
                          'Invalid copy or dir request') from None
 
 
-def _parse_t_args(args):
+def _parse_t_args(args: bytes) -> Tuple[int, int]:
     """Parse argument to an SCP time request"""
 
     try:
         mtime, _, atime, _ = args.split()
         return int(atime), int(mtime)
     except ValueError:
         raise _scp_error(SFTPBadMessage, 'Invalid time request') from None
 
 
-async def _parse_path(path, **kwargs):
+async def _parse_path(path: _SCPConnPath, **kwargs) -> \
+        Tuple[Optional['SSHClientConnection'], _SCPPath, bool]:
     """Convert an SCP path into an SSHClientConnection and path"""
 
     # pylint: disable=cyclic-import,import-outside-toplevel
     from . import connect
 
+    conn: _SCPConn
+
     if isinstance(path, tuple):
-        conn, path = path
+        conn, path = cast(Tuple[_SCPConn, _SCPPath], path)
     elif isinstance(path, str) and sys.platform == 'win32' and \
             path[:1] in string.ascii_letters and \
             path[1:2] == ':': # pragma: no cover (win32)
         conn = None
     elif isinstance(path, str) and ':' in path:
         conn, path = path.split(':', 1)
     elif isinstance(path, bytes) and b':' in path:
         conn, path = path.split(b':', 1)
-    elif isinstance(path, (str, bytes, PurePath)):
+        conn = conn.decode('utf-8')
+    elif isinstance(path, (bytes, str, PurePath)):
         conn = None
     else:
         conn = path
         path = b'.'
 
-    if isinstance(conn, (str, bytes)):
+    if isinstance(conn, str):
         close_conn = True
         conn = await connect(conn, **kwargs)
     elif isinstance(conn, tuple):
         close_conn = True
         conn = await connect(*conn, **kwargs)
     else:
         close_conn = False
 
-    return conn, path, close_conn
+    return (cast(Optional['SSHClientConnection'], conn),
+            cast(_SCPPath, path), close_conn)
 
 
-async def _start_remote(conn, source, must_be_dir, preserve, recurse, path):
+async def _start_remote(conn: 'SSHClientConnection', source: bool,
+                        must_be_dir: bool, preserve: bool,
+                        recurse: bool, path: _SCPPath) -> \
+        Tuple['SSHReader[bytes]', 'SSHWriter[bytes]']:
     """Start remote SCP server"""
 
     if isinstance(path, PurePath):
         path = str(path)
 
     if isinstance(path, str):
         path = path.encode('utf-8')
@@ -135,139 +188,166 @@
                                        command[4:])
 
     writer, reader, _ = await conn.open_session(command, encoding=None)
 
     return reader, writer
 
 
+class _SCPArgs(argparse.Namespace):
+    """SCP command line arguments"""
+
+    path: str
+    source: bool
+    must_be_dir: bool
+    preserve: bool
+    recurse: bool
+
+
 class _SCPArgParser(argparse.ArgumentParser):
     """A parser for SCP arguments"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         super().__init__(add_help=False)
 
         group = self.add_mutually_exclusive_group(required=True)
         group.add_argument('-f', dest='source', action='store_true')
         group.add_argument('-t', dest='source', action='store_false')
 
         self.add_argument('-d', dest='must_be_dir', action='store_true')
         self.add_argument('-p', dest='preserve', action='store_true')
         self.add_argument('-r', dest='recurse', action='store_true')
         self.add_argument('-v', dest='verbose', action='store_true')
 
         self.add_argument('path')
 
-    def error(self, message):
+    def error(self, message: str) -> NoReturn:
         raise ValueError(message)
 
-    def parse(self, command):
+    def parse(self, command: str) -> _SCPArgs:
         """Parse an SCP command"""
 
-        return self.parse_args(shlex.split(command)[1:])
+        return self.parse_args(shlex.split(command)[1:], namespace=_SCPArgs())
 
 
 class _SCPHandler:
     """SCP handler"""
 
-    def __init__(self, reader, writer, error_handler=None, server=False):
+    def __init__(self, reader: 'SSHReader[bytes]', writer: 'SSHWriter[bytes]',
+                 error_handler: SFTPErrorHandler = None, server: bool = False):
         self._reader = reader
         self._writer = writer
         self._error_handler = error_handler
         self._server = server
 
         self._logger = reader.logger.get_child('sftp')
 
+    async def __aenter__(self) -> '_SCPHandler': # pragma: no cover
+        """Allow _SCPHandler to be used as an async context manager"""
+
+        return self
+
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> \
+            bool: # pragma: no cover
+        """Wait for file close when used as an async context manager"""
+
+        await self.close()
+        return False
+
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this SCP handler"""
 
         return self._logger
 
-    async def await_response(self):
+    async def await_response(self) -> Optional[Exception]:
         """Wait for an SCP response"""
 
         result = await self._reader.read(1)
 
         if result != b'\0':
             reason = await self._reader.readline()
 
             if not result or not reason.endswith(b'\n'):
                 raise _scp_error(SFTPConnectionLost, 'Connection lost',
                                  fatal=True, suppress_send=True)
 
             if result not in b'\x01\x02':
                 reason = result + reason
 
-            return _scp_error(SFTPFailure, reason[:-1], fatal=result != b'\x01',
-                              suppress_send=True)
+            return _scp_error(SFTPFailure, reason[:-1],
+                              fatal=result != b'\x01', suppress_send=True)
 
         self.logger.debug1('Received SCP OK')
 
         return None
 
-    def send_request(self, *args):
+    def send_request(self, *args: bytes) -> None:
         """Send an SCP request"""
 
         request = b''.join(args)
 
         self.logger.debug1('Sending SCP request: %s', request)
 
         self._writer.write(request + b'\n')
 
-    async def make_request(self, *args):
+    async def make_request(self, *args: bytes) -> None:
         """Send an SCP request and wait for a response"""
 
         self.send_request(*args)
 
         exc = await self.await_response()
 
         if exc:
             raise exc
 
-    async def send_data(self, data):
+    async def send_data(self, data: bytes) -> None:
         """Send SCP file data"""
 
         self.logger.debug1('Sending %s', plural(len(data), 'SCP data byte'))
 
         self._writer.write(data)
         await self._writer.drain()
         await asyncio.sleep(0)
 
-    def send_ok(self):
+    def send_ok(self) -> None:
         """Send an SCP OK response"""
 
         self.logger.debug1('Sending SCP OK')
 
         self._writer.write(b'\0')
 
-    def send_error(self, exc):
+    def send_error(self, exc: Exception) -> None:
         """Send an SCP error response"""
 
         if isinstance(exc, SFTPError):
             reason = exc.reason.encode('utf-8')
         elif isinstance(exc, OSError): # pragma: no branch (win32)
             reason = exc.strerror.encode('utf-8')
 
-            if exc.filename:
-                if isinstance(exc.filename, str): # pragma: no cover (win32)
-                    exc.filename = exc.filename.encode('utf-8')
+            filename = cast(BytesOrStr, exc.filename)
 
-                reason += b': ' + exc.filename
+            if filename:
+                if isinstance(filename, str): # pragma: no cover (win32)
+                    filename = filename.encode('utf-8')
+
+                reason += b': ' + filename
         else: # pragma: no cover (win32)
             reason = str(exc).encode('utf-8')
 
-        fatal = getattr(exc, 'fatal', False)
+        fatal = cast(bool, getattr(exc, 'fatal', False))
 
         self.logger.debug1('Sending SCP %serror: %s',
                            'fatal ' if fatal else '', reason)
 
         self._writer.write((b'\x02' if fatal else b'\x01') +
                            b'scp: ' + reason + b'\n')
 
-    async def recv_request(self):
+    async def recv_request(self) -> Tuple[Optional[bytes], Optional[bytes]]:
         """Receive SCP request"""
 
         request = await self._reader.readline()
 
         if not request:
             return None, None
 
@@ -278,86 +358,97 @@
         else:
             self.logger.debug1('Received SCP %serror: %s',
                                'fatal ' if action != b'\x01'  else '', args)
 
         return action, args
 
 
-    async def recv_data(self, n):
+    async def recv_data(self, n: int) -> bytes:
         """Receive SCP file data"""
 
-        data = (await self._reader.read(n))
+        data = await self._reader.read(n)
 
         self.logger.debug1('Received %s', plural(len(data), 'SCP data byte'))
 
         return data
 
-    def handle_error(self, exc):
+    def handle_error(self, exc: Exception) -> None:
         """Handle an SCP error"""
 
         if isinstance(exc, BrokenPipeError):
             exc = _scp_error(SFTPConnectionLost, 'Connection lost',
                              fatal=True, suppress_send=True)
 
         if not getattr(exc, 'suppress_send', False):
             self.send_error(exc)
 
-        self.logger.debug1('Handling SCP error: %s', exc)
+        self.logger.debug1('Handling SCP error: %s', str(exc))
 
         if getattr(exc, 'fatal', False) or self._error_handler is None:
             raise exc from None
         elif self._error_handler:
             self._error_handler(exc)
 
-    async def close(self):
+    async def close(self) -> None:
         """Close an SCP session"""
 
         self.logger.info('Stopping remote SCP')
 
         if self._server:
-            self._writer.channel.exit(0)
+            cast('SSHServerChannel', self._writer.channel).exit(0)
         else:
             self._writer.close()
 
         await self._writer.channel.wait_closed()
 
 
 class _SCPSource(_SCPHandler):
     """SCP handler for sending files"""
 
-    def __init__(self, fs, reader, writer, preserve, recurse,
-                 block_size=SFTP_BLOCK_SIZE, progress_handler=None,
-                 error_handler=None, server=False):
+    def __init__(self, fs: _SCPFSProtocol, reader: 'SSHReader[bytes]',
+                 writer: 'SSHWriter[bytes]', preserve: bool, recurse: bool,
+                 block_size: int = SFTP_BLOCK_SIZE,
+                 progress_handler: SFTPProgressHandler = None,
+                 error_handler: SFTPErrorHandler = None, server: bool = False):
         super().__init__(reader, writer, error_handler, server)
 
         self._fs = fs
         self._preserve = preserve
         self._recurse = recurse
         self._block_size = block_size
         self._progress_handler = progress_handler
 
-    async def _make_cd_request(self, action, attrs, size, path):
+    async def _make_cd_request(self, action: bytes, attrs: SFTPAttrs,
+                               size: int, path: bytes) -> None:
         """Make an SCP copy or dir request"""
 
+        assert attrs.permissions is not None
+
         args = '%04o %d ' % (attrs.permissions & 0o7777, size)
         await self.make_request(action, args.encode('ascii'),
                                 self._fs.basename(path))
 
-    async def _make_t_request(self, attrs):
+    async def _make_t_request(self, attrs: SFTPAttrs) -> None:
         """Make an SCP time request"""
 
         self.logger.info('    Preserving attrs: %s',
                          SFTPAttrs(atime=attrs.atime, mtime=attrs.mtime))
 
+        assert attrs.mtime is not None
+        assert attrs.atime is not None
+
         args = '%d 0 %d 0' % (attrs.mtime, attrs.atime)
         await self.make_request(b'T', args.encode('ascii'))
 
-    async def _send_file(self, srcpath, dstpath, attrs):
+    async def _send_file(self, srcpath: bytes,
+                         dstpath: bytes, attrs: SFTPAttrs) -> None:
         """Send a file over SCP"""
 
+        assert attrs.size is not None
+
         file_obj = await self._fs.open(srcpath, 'rb')
         size = attrs.size
         local_exc = None
         offset = 0
 
         self.logger.info('  Sending file %s, size %d', srcpath, size)
 
@@ -370,15 +461,16 @@
             while offset < size:
                 blocklen = min(size - offset, self._block_size)
 
                 if local_exc:
                     data = blocklen * b'\0'
                 else:
                     try:
-                        data = await file_obj.read(blocklen, offset)
+                        data = cast(bytes,
+                                    await file_obj.read(blocklen, offset))
 
                         if not data:
                             raise _scp_error(SFTPFailure, 'Unexpected EOF')
                     except (OSError, SFTPError) as exc:
                         local_exc = exc
 
                 await self.send_data(data)
@@ -387,25 +479,26 @@
                 if self._progress_handler:
                     self._progress_handler(srcpath, dstpath, offset, size)
         finally:
             await file_obj.close()
 
         if local_exc:
             self.send_error(local_exc)
-            local_exc.suppress_send = True
+            setattr(local_exc, 'suppress_send', True)
         else:
             self.send_ok()
 
         remote_exc = await self.await_response()
-        exc = remote_exc or local_exc
+        final_exc = remote_exc or local_exc
 
-        if exc:
-            raise exc
+        if final_exc:
+            raise final_exc
 
-    async def _send_dir(self, srcpath, dstpath, attrs):
+    async def _send_dir(self, srcpath: bytes,
+                        dstpath: bytes, attrs: SFTPAttrs) -> None:
         """Send directory over SCP"""
 
         self.logger.info('  Starting send of directory %s', srcpath)
 
         await self._make_cd_request(b'D', attrs, 0, srcpath)
 
         for name in await self._fs.listdir(srcpath):
@@ -415,33 +508,34 @@
             await self._send_files(posixpath.join(srcpath, name),
                                    posixpath.join(dstpath, name))
 
         await self.make_request(b'E')
 
         self.logger.info('  Finished send of directory %s', srcpath)
 
-    async def _send_files(self, srcpath, dstpath):
+    async def _send_files(self, srcpath: bytes, dstpath: bytes) -> None:
         """Send files via SCP"""
 
         try:
             attrs = await self._fs.stat(srcpath)
+            assert attrs.permissions is not None
 
             if self._preserve:
                 await self._make_t_request(attrs)
 
             if self._recurse and stat.S_ISDIR(attrs.permissions):
                 await self._send_dir(srcpath, dstpath, attrs)
             elif stat.S_ISREG(attrs.permissions):
                 await self._send_file(srcpath, dstpath, attrs)
             else:
                 raise _scp_error(SFTPFailure, 'Not a regular file', srcpath)
         except (OSError, SFTPError, ValueError) as exc:
             self.handle_error(exc)
 
-    async def run(self, srcpath):
+    async def run(self, srcpath: _SCPPath) -> None:
         """Start SCP transfer"""
 
         try:
             if isinstance(srcpath, PurePath):
                 srcpath = str(srcpath)
 
             if isinstance(srcpath, str):
@@ -459,27 +553,30 @@
         finally:
             await self.close()
 
 
 class _SCPSink(_SCPHandler):
     """SCP handler for receiving files"""
 
-    def __init__(self, fs, reader, writer, must_be_dir, preserve, recurse,
-                 block_size=SFTP_BLOCK_SIZE, progress_handler=None,
-                 error_handler=None, server=False):
+    def __init__(self, fs: _SCPFSProtocol, reader: 'SSHReader[bytes]',
+                 writer: 'SSHWriter[bytes]', must_be_dir: bool, preserve: bool,
+                 recurse: bool, block_size: int = SFTP_BLOCK_SIZE,
+                 progress_handler: SFTPProgressHandler = None,
+                 error_handler: SFTPErrorHandler = None, server: bool = False):
         super().__init__(reader, writer, error_handler, server)
 
         self._fs = fs
         self._must_be_dir = must_be_dir
         self._preserve = preserve
         self._recurse = recurse
         self._block_size = block_size
         self._progress_handler = progress_handler
 
-    async def _recv_file(self, srcpath, dstpath, size):
+    async def _recv_file(self, srcpath: bytes,
+                         dstpath: bytes, size: int) -> None:
         """Receive a file via SCP"""
 
         file_obj = await self._fs.open(dstpath, 'wb')
         local_exc = None
         offset = 0
 
         self.logger.info('  Receiving file %s, size %d', dstpath, size)
@@ -511,24 +608,24 @@
         finally:
             await file_obj.close()
 
         remote_exc = await self.await_response()
 
         if local_exc:
             self.send_error(local_exc)
-            local_exc.suppress_send = True
+            setattr(local_exc, 'suppress_send',True)
         else:
             self.send_ok()
 
-        exc = remote_exc or local_exc
+        final_exc = remote_exc or local_exc
 
-        if exc:
-            raise exc
+        if final_exc:
+            raise final_exc
 
-    async def _recv_dir(self, srcpath, dstpath):
+    async def _recv_dir(self, srcpath: bytes, dstpath: bytes) -> None:
         """Receive a directory over SCP"""
 
         if not self._recurse:
             raise _scp_error(SFTPBadMessage,
                              'Directory received without recurse')
 
         self.logger.info('  Starting receive of directory %s', dstpath)
@@ -539,27 +636,29 @@
         else:
             await self._fs.mkdir(dstpath)
 
         await self._recv_files(srcpath, dstpath)
 
         self.logger.info('  Finished receive of directory %s', dstpath)
 
-    async def _recv_files(self, srcpath, dstpath):
+    async def _recv_files(self, srcpath: bytes, dstpath: bytes) -> None:
         """Receive files over SCP"""
 
         self.send_ok()
 
         attrs = SFTPAttrs()
 
         while True:
             action, args = await self.recv_request()
 
             if not action:
                 break
 
+            assert args is not None
+
             try:
                 if action in b'\x01\x02':
                     raise _scp_error(SFTPFailure, args, fatal=action != b'\x01',
                                      suppress_send=True)
                 elif action == b'T':
                     if self._preserve:
                         attrs.atime, attrs.mtime = _parse_t_args(args)
@@ -591,15 +690,15 @@
                     finally:
                         attrs = SFTPAttrs()
                 else:
                     raise _scp_error(SFTPBadMessage, 'Unknown request')
             except (OSError, SFTPError) as exc:
                 self.handle_error(exc)
 
-    async def run(self, dstpath):
+    async def run(self, dstpath: _SCPPath) -> None:
         """Start SCP file receive"""
 
         try:
             if isinstance(dstpath, PurePath):
                 dstpath = str(dstpath)
 
             if isinstance(dstpath, str):
@@ -615,44 +714,49 @@
         finally:
             await self.close()
 
 
 class _SCPCopier:
     """SCP handler for remote-to-remote copies"""
 
-    def __init__(self, src_reader, src_writer, dst_reader, dst_writer,
-                 block_size=SFTP_BLOCK_SIZE, progress_handler=None,
-                 error_handler=None):
+    def __init__(self, src_reader: 'SSHReader[bytes]',
+                 src_writer: 'SSHWriter[bytes]',
+                 dst_reader: 'SSHReader[bytes]',
+                 dst_writer: 'SSHWriter[bytes]',
+                 block_size: int = SFTP_BLOCK_SIZE,
+                 progress_handler: SFTPProgressHandler = None,
+                 error_handler: SFTPErrorHandler = None):
         self._source = _SCPHandler(src_reader, src_writer)
         self._sink = _SCPHandler(dst_reader, dst_writer)
         self._logger = self._source.logger
         self._block_size = block_size
         self._progress_handler = progress_handler
         self._error_handler = error_handler
 
     @property
-    def logger(self):
+    def logger(self) -> SSHLogger:
         """A logger associated with this SCP handler"""
 
         return self._logger
 
-    def _handle_error(self, exc):
+    def _handle_error(self, exc: Exception) -> None:
         """Handle an SCP error"""
 
         if isinstance(exc, BrokenPipeError):
             exc = _scp_error(SFTPConnectionLost, 'Connection lost', fatal=True)
 
-        self.logger.debug1('Handling SCP error: %s', exc)
+        self.logger.debug1('Handling SCP error: %s', str(exc))
 
         if self._error_handler and not getattr(exc, 'fatal', False):
             self._error_handler(exc)
         else:
             raise exc
 
-    async def _forward_response(self, src, dst):
+    async def _forward_response(self, src: _SCPHandler,
+                                dst: _SCPHandler) -> Optional[Exception]:
         """Forward an SCP response between two remote SCP servers"""
 
         # pylint: disable=no-self-use
 
         try:
             exc = await src.await_response()
 
@@ -661,15 +765,15 @@
                 return exc
             else:
                 dst.send_ok()
                 return None
         except OSError as exc:
             return exc
 
-    async def _copy_file(self, path, size):
+    async def _copy_file(self, path: bytes, size: int) -> None:
         """Copy a file from one remote SCP server to another"""
 
         self.logger.info('  Copying file %s, size %d', path, size)
 
         offset = 0
 
         if self._progress_handler and size == 0:
@@ -693,32 +797,34 @@
         sink_exc = await self._forward_response(self._sink, self._source)
 
         exc = sink_exc or source_exc
 
         if exc:
             self._handle_error(exc)
 
-    async def _copy_files(self):
+    async def _copy_files(self) -> None:
         """Copy files from one SCP server to another"""
 
         exc = await self._forward_response(self._sink, self._source)
 
         if exc:
             self._handle_error(exc)
 
-        pathlist = []
-        attrlist = []
+        pathlist: List[bytes] = []
+        attrlist: List[SFTPAttrs] = []
         attrs = SFTPAttrs()
 
         while True:
             action, args = await self._source.recv_request()
 
             if not action:
                 break
 
+            assert args is not None
+
             self._sink.send_request(action, args)
 
             if action in b'\x01\x02':
                 exc = _scp_error(SFTPFailure, args, fatal=action != b'\x01')
                 self._handle_error(exc)
                 continue
 
@@ -755,29 +861,31 @@
                 else:
                     break
             elif action == b'T':
                 attrs.atime, attrs.mtime = _parse_t_args(args)
             else:
                 raise _scp_error(SFTPBadMessage, 'Unknown SCP action')
 
-    async def run(self):
+    async def run(self) -> None:
         """Start SCP remote-to-remote transfer"""
 
         try:
             await self._copy_files()
         except (OSError, SFTPError) as exc:
             self._handle_error(exc)
         finally:
             await self._source.close()
             await self._sink.close()
 
 
-async def scp(srcpaths, dstpath=None, *, preserve=False, recurse=False,
-              block_size=SFTP_BLOCK_SIZE, progress_handler=None,
-              error_handler=None, **kwargs):
+async def scp(srcpaths: Union[_SCPConnPath, Sequence[_SCPConnPath]],
+              dstpath: _SCPConnPath = None, *, preserve: bool = False,
+              recurse: bool = False, block_size: int = SFTP_BLOCK_SIZE,
+              progress_handler: SFTPProgressHandler = None,
+              error_handler: SFTPErrorHandler = None, **kwargs) -> None:
     """Copy files using SCP
 
        This function is a coroutine which copies one or more files or
        directories using the SCP protocol. Source and destination paths
        can be `str` or `bytes` values to reference local files or can be
        a tuple of the form `(conn, path)` where `conn` is an open
        :class:`SSHClientConnection` to reference files and directories
@@ -873,17 +981,19 @@
 
        :raises: | :exc:`OSError` if a local file I/O error occurs
                 | :exc:`SFTPError` if the server returns an error
                 | :exc:`ValueError` if both source and destination are local
 
     """
 
-    if (isinstance(srcpaths, (str, bytes, PurePath)) or
+    if (isinstance(srcpaths, (bytes, str, PurePath)) or
             (isinstance(srcpaths, tuple) and len(srcpaths) == 2)):
-        srcpaths = [srcpaths]
+        srcpaths = [srcpaths] # type: ignore
+
+    srcpaths: Sequence[_SCPConnPath]
 
     must_be_dir = len(srcpaths) > 1
 
     dstconn, dstpath, close_dst = await _parse_path(dstpath, **kwargs)
 
     try:
         for srcpath in srcpaths:
@@ -902,64 +1012,70 @@
                                         progress_handler, error_handler)
 
                     await copier.run()
                 elif srcconn:
                     reader, writer = await _start_remote(
                         srcconn, True, must_be_dir, preserve, recurse, srcpath)
 
-                    sink = _SCPSink(LocalFile, reader, writer, must_be_dir,
+                    sink = _SCPSink(local_fs, reader, writer, must_be_dir,
                                     preserve, recurse, block_size,
                                     progress_handler, error_handler)
 
                     await sink.run(dstpath)
                 elif dstconn:
                     reader, writer = await _start_remote(
                         dstconn, False, must_be_dir, preserve, recurse, dstpath)
 
-                    source = _SCPSource(LocalFile, reader, writer,
+                    source = _SCPSource(local_fs, reader, writer,
                                         preserve, recurse, block_size,
                                         progress_handler, error_handler)
 
                     await source.run(srcpath)
                 else:
                     raise ValueError('Local copy not supported')
             finally:
                 if close_src:
+                    assert srcconn is not None
                     srcconn.close()
                     await srcconn.wait_closed()
     finally:
         if close_dst:
+            assert dstconn is not None
             dstconn.close()
             await dstconn.wait_closed()
 
 
-def run_scp_server(sftp_server, command, stdin, stdout, stderr):
+def run_scp_server(sftp_server: SFTPServer, command: str,
+                   stdin: 'SSHReader[bytes]', stdout: 'SSHWriter[bytes]',
+                   stderr: 'SSHWriter[bytes]') -> MaybeAwait[None]:
     """Return a handler for an SCP server session"""
 
-    async def run_handler():
+    async def _run_handler() -> None:
         """Run an SCP server to handle this request"""
 
         try:
             await handler.run(args.path)
         finally:
             sftp_server.exit()
 
     try:
         args = _SCPArgParser().parse(command)
     except ValueError as exc:
         stdin.logger.info('Error starting SCP server: %s', str(exc))
         stderr.write(b'scp: ' + str(exc).encode('utf-8') + b'\n')
-        stderr.channel.exit(1)
-        return
+        cast('SSHServerChannel', stderr.channel).exit(1)
+        return None
 
     stdin.logger.info('Starting SCP server, args: %s', command[4:].strip())
 
-    fs = SFTPServerFile(sftp_server)
+    fs = SFTPServerFS(sftp_server)
+
+    handler: Union[_SCPSource, _SCPSink]
 
     if args.source:
         handler = _SCPSource(fs, stdin, stdout, args.preserve, args.recurse,
                              error_handler=False, server=True)
     else:
         handler = _SCPSink(fs, stdin, stdout, args.must_be_dir, args.preserve,
                            args.recurse, error_handler=False, server=True)
 
-    return run_handler()
+    return _run_handler()
```

### Comparing `asyncssh-2.8.1/asyncssh/gss_win32.py` & `asyncssh-2.9.0/asyncssh/gss_win32.py`

 * *Files 20% similar despite different names*

```diff
@@ -19,14 +19,16 @@
 #     Ron Frederick - initial implementation, API, and documentation
 
 """GSSAPI wrapper for Windows"""
 
 # Some of the imports below won't be found when running pylint on UNIX
 # pylint: disable=import-error
 
+from typing import Optional, Sequence, Union
+
 from sspi import ClientAuth, ServerAuth
 from sspi import error as SSPIError
 
 from sspicon import ISC_REQ_DELEGATE, ISC_REQ_INTEGRITY, ISC_REQ_MUTUAL_AUTH
 from sspicon import ISC_RET_INTEGRITY, ISC_RET_MUTUAL_AUTH
 from sspicon import ASC_REQ_INTEGRITY, ASC_REQ_MUTUAL_AUTH
 from sspicon import ASC_RET_INTEGRITY, ASC_RET_MUTUAL_AUTH
@@ -34,113 +36,131 @@
 
 from .asn1 import ObjectIdentifier, der_encode
 
 
 _krb5_oid = der_encode(ObjectIdentifier('1.2.840.113554.1.2.2'))
 
 
-class _GSSBase:
+class GSSBase:
     """GSS base class"""
 
     # Overridden in child classes
     _mutual_auth_flag = 0
     _integrity_flag = 0
 
-    def __init__(self, host):
+    def __init__(self, host: str):
         if '@' in host:
             self._host = host
         else:
             self._host = 'host/' + host
 
-        self._ctx = None
-        self._init_token = None
+        self._ctx: Optional[Union[ClientAuth, ServerAuth]] = None
+        self._init_token: Optional[bytes] = None
 
     @property
-    def mechs(self):
+    def mechs(self) -> Sequence[bytes]:
         """Return GSS mechanisms available for this host"""
 
         return [_krb5_oid]
 
     @property
-    def complete(self):
+    def complete(self) -> bool:
         """Return whether or not GSS negotiation is complete"""
 
+        assert self._ctx is not None
+
         return self._ctx.authenticated
 
     @property
-    def provides_mutual_auth(self):
+    def provides_mutual_auth(self) -> bool:
         """Return whether or not this context provides mutual authentication"""
 
-        return self._ctx.ctxt_attr & self._mutual_auth_flag
+        assert self._ctx is not None
+
+        return bool(self._ctx.ctxt_attr & self._mutual_auth_flag)
 
     @property
-    def provides_integrity(self):
+    def provides_integrity(self) -> bool:
         """Return whether or not this context provides integrity protection"""
 
-        return self._ctx.ctxt_attr & self._integrity_flag
+        assert self._ctx is not None
+
+        return bool(self._ctx.ctxt_attr & self._integrity_flag)
 
     @property
-    def user(self):
+    def user(self) -> str:
         """Return user principal associated with this context"""
 
+        assert self._ctx is not None
+
         names = self._ctx.ctxt.QueryContextAttributes(SECPKG_ATTR_NATIVE_NAMES)
         return names[0]
 
     @property
-    def host(self):
+    def host(self) -> str:
         """Return host principal associated with this context"""
 
+        assert self._ctx is not None
+
         names = self._ctx.ctxt.QueryContextAttributes(SECPKG_ATTR_NATIVE_NAMES)
         return names[1]
 
-    def reset(self):
+    def reset(self) -> None:
         """Reset GSS security context"""
 
+        assert self._ctx is not None
+
         if self._ctx.authenticated:
             self._ctx.reset()
 
-    def step(self, token=None):
+    def step(self, token: Optional[bytes] = None) -> Optional[bytes]:
         """Perform next step in GSS security exchange"""
 
+        assert self._ctx is not None
+
         if self._init_token:
             token = self._init_token
             self._init_token = None
             return token
 
         try:
             _, buf = self._ctx.authorize(token)
             return buf[0].Buffer
         except SSPIError as exc:
             raise GSSError(details=exc.strerror) from None
 
-    def sign(self, data):
+    def sign(self, data: bytes) -> bytes:
         """Sign a block of data"""
 
+        assert self._ctx is not None
+
         try:
             return self._ctx.sign(data)
         except SSPIError as exc:
             raise GSSError(details=exc.strerror) from None
 
-    def verify(self, data, sig):
+    def verify(self, data: bytes, sig: bytes) -> bool:
         """Verify a signature for a block of data"""
 
+        assert self._ctx is not None
+
         try:
             self._ctx.verify(data, sig)
             return True
         except SSPIError:
             return False
 
 
-class GSSClient(_GSSBase):
+class GSSClient(GSSBase):
     """GSS client"""
 
     _mutual_auth_flag = ISC_RET_MUTUAL_AUTH
     _integrity_flag = ISC_RET_INTEGRITY
 
-    def __init__(self, host, delegate_creds):
+    def __init__(self, host: str, delegate_creds: bool):
         super().__init__(host)
 
         flags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_INTEGRITY
 
         if delegate_creds:
             flags |= ISC_REQ_DELEGATE
 
@@ -149,33 +169,34 @@
                                    scflags=flags)
         except SSPIError as exc:
             raise GSSError(1, 1, details=exc.strerror) from None
 
         self._init_token = self.step(None)
 
 
-class GSSServer(_GSSBase):
+class GSSServer(GSSBase):
     """GSS server"""
 
     _mutual_auth_flag = ASC_RET_MUTUAL_AUTH
     _integrity_flag = ASC_RET_INTEGRITY
 
-    def __init__(self, host):
+    def __init__(self, host: str):
         super().__init__(host)
 
         flags = ASC_REQ_MUTUAL_AUTH | ASC_REQ_INTEGRITY
 
         try:
             self._ctx = ServerAuth('Kerberos', spn=self._host, scflags=flags)
         except SSPIError as exc:
             raise GSSError(1, 1, details=exc.strerror) from None
 
 
 class GSSError(Exception):
-    """Stub class for reporting that GSS is not available"""
+    """Class for reporting GSS errors"""
 
-    def __init__(self, maj_code=0, min_code=0, token=None, details=''):
+    def __init__(self, maj_code: int = 0, min_code: int = 0,
+                 token: bytes = None, details: str = ''):
         super().__init__(details)
 
         self.maj_code = maj_code
         self.min_code = min_code
         self.token = token
```

### Comparing `asyncssh-2.8.1/asyncssh/x11.py` & `asyncssh-2.9.0/asyncssh/x11.py`

 * *Files 9% similar despite different names*

```diff
@@ -18,25 +18,36 @@
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """X11 forwarding support"""
 
 import asyncio
 import os
+from pathlib import Path
 import socket
 import time
-
-from collections import namedtuple
-from pathlib import Path
+from typing import TYPE_CHECKING, Callable, Dict, Iterable
+from typing import NamedTuple, Optional, Sequence, Set, Tuple
 
 from .constants import OPEN_CONNECT_FAILED
-from .forward import SSHForwarder
-from .listener import create_tcp_forward_listener
+from .forward import SSHForwarder, SSHForwarderCoro
+from .listener import SSHListener, create_tcp_forward_listener
 from .logging import logger
 from .misc import ChannelOpenError
+from .session import DataType
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHChannel
+    from .connection import SSHServerConnection
+
+
+_RecvHandler = Optional[Callable[[bytes], None]]
+
 
 # Xauth address families
 XAUTH_FAMILY_IPV4     = 0
 XAUTH_FAMILY_DECNET   = 1
 XAUTH_FAMILY_IPV6     = 6
 XAUTH_FAMILY_HOSTNAME = 256
 XAUTH_FAMILY_WILD     = 65535
@@ -56,15 +67,15 @@
 X11_DISPLAY_START     = 10
 X11_MAX_DISPLAYS      = 64
 
 # Host to listen on when doing X11 forwarding
 X11_LISTEN_HOST       = 'localhost'
 
 
-def _parse_display(display):
+def _parse_display(display: str) -> Tuple[str, str, int]:
     """Parse an X11 display value"""
 
     try:
         host, dpynum = display.rsplit(':', 1)
 
         if host.startswith('[') and host.endswith(']'):
             host = host[1:-1]
@@ -76,122 +87,128 @@
         else:
             screen = 0
     except (ValueError, UnicodeEncodeError):
         raise ValueError('Invalid X11 display') from None
 
     return host, dpynum, screen
 
-async def _lookup_host(loop, host, family):
+async def _lookup_host(loop: asyncio.AbstractEventLoop, host: str,
+                       family: int) -> Sequence[str]:
     """Look up IPv4 or IPv6 addresses of a host name"""
 
     try:
         addrinfo = await loop.getaddrinfo(host, 0, family=family,
                                           type=socket.SOCK_STREAM)
     except socket.gaierror:
         return []
 
     return [ai[4][0] for ai in addrinfo]
 
 
-class SSHXAuthorityEntry(namedtuple('SSHXAuthorityEntry',
-                                    'family addr dpynum proto data')):
+class SSHXAuthorityEntry(NamedTuple):
     """An entry in an Xauthority file"""
 
-    def __bytes__(self):
+    family: int
+    addr: bytes
+    dpynum: bytes
+    proto: bytes
+    data: bytes
+
+    def __bytes__(self) -> bytes:
         """Construct an Xauthority entry"""
 
-        def _uint16(value):
+        def _uint16(value: int) -> bytes:
             """Construct a big-endian 16-bit unsigned integer"""
 
             return value.to_bytes(2, 'big')
 
-        def _string(data):
+        def _string(data: bytes) -> bytes:
             """Construct a binary string with a 16-bit length"""
 
             return _uint16(len(data)) + data
 
         return b''.join((_uint16(self.family), _string(self.addr),
                          _string(self.dpynum), _string(self.proto),
                          _string(self.data)))
 
 
 class SSHX11ClientForwarder(SSHForwarder):
     """X11 forwarding connection handler"""
 
-    def __init__(self, listener, peer):
+    def __init__(self, listener: 'SSHX11ClientListener', peer: SSHForwarder):
         super().__init__(peer)
 
         self._listener = listener
 
         self._inpbuf = b''
         self._bytes_needed = 12
-        self._recv_handler = self._recv_prefix
+        self._recv_handler: _RecvHandler = self._recv_prefix
 
         self._endian = b''
         self._prefix = b''
         self._auth_proto_len = 0
         self._auth_data_len = 0
 
         self._auth_proto = b''
         self._auth_proto_pad = b''
 
         self._auth_data = b''
         self._auth_data_pad = b''
 
-    def _encode_uint16(self, value):
+    def _encode_uint16(self, value: int) -> bytes:
         """Encode a 16-bit unsigned integer"""
 
         if self._endian == b'B':
             return bytes((value >> 8, value & 255))
         else:
             return bytes((value & 255, value >> 8))
 
-    def _decode_uint16(self, value):
+    def _decode_uint16(self, value: bytes) -> int:
         """Decode a 16-bit unsigned integer"""
 
         if self._endian == b'B':
             return (value[0] << 8) + value[1]
         else:
             return (value[1] << 8) + value[0]
 
     @staticmethod
-    def _padded_len(length):
+    def _padded_len(length: int) -> int:
         """Return length rounded up to the next multiple of 4 bytes"""
 
         return ((length + 3) // 4) * 4
 
     @staticmethod
-    def _pad(data):
+    def _pad(data: bytes) -> bytes:
         """Pad a string to a multiple of 4 bytes"""
 
         length = len(data) % 4
         return data + ((4 - length) * b'\00' if length else b'')
 
-    def _recv_prefix(self, data):
+    def _recv_prefix(self, data: bytes) -> None:
         """Parse X11 client prefix"""
 
         self._endian = data[:1]
         self._prefix = data
 
         self._auth_proto_len = self._decode_uint16(data[6:8])
         self._auth_data_len = self._decode_uint16(data[8:10])
 
         self._recv_handler = self._recv_auth_proto
         self._bytes_needed = self._padded_len(self._auth_proto_len)
 
-    def _recv_auth_proto(self, data):
+    def _recv_auth_proto(self, data: bytes) -> None:
         """Extract X11 auth protocol"""
 
         self._auth_proto = data[:self._auth_proto_len]
         self._auth_proto_pad = data[self._auth_proto_len:]
 
         self._recv_handler = self._recv_auth_data
         self._bytes_needed = self._padded_len(self._auth_data_len)
 
-    def _recv_auth_data(self, data):
+    def _recv_auth_data(self, data: bytes) -> None:
         """Extract X11 auth data"""
 
         self._auth_data = data[:self._auth_data_len]
         self._auth_data_pad = data[self._auth_data_len:]
 
         try:
             self._auth_data = self._listener.validate_auth(self._auth_data)
@@ -215,15 +232,15 @@
             self._inpbuf = (self._prefix + self._auth_proto +
                             self._auth_proto_pad + self._auth_data +
                             self._auth_data_pad)
 
         self._recv_handler = None
         self._bytes_needed = 0
 
-    def data_received(self, data, datatype=None):
+    def data_received(self, data: bytes, datatype: DataType = None) -> None:
         """Handle incoming data from the X11 client"""
 
         if self._recv_handler:
             self._inpbuf += data
 
             while self._recv_handler:
                 if len(self._inpbuf) >= self._bytes_needed:
@@ -239,144 +256,147 @@
         if data:
             super().data_received(data, datatype)
 
 
 class SSHX11ClientListener:
     """Client listener used to accept forwarded X11 connections"""
 
-    def __init__(self, loop, host, dpynum, auth_proto, auth_data):
+    def __init__(self, loop: asyncio.AbstractEventLoop, host: str, dpynum: str,
+                 auth_proto: bytes, auth_data: bytes):
         self._host = host
         self._dpynum = dpynum
         self._auth_proto = auth_proto
         self._local_auth = auth_data
 
         if host.startswith('/'):
-            self._connect_coro = loop.create_unix_connection
-            self._connect_args = (host + ':' + dpynum,)
+            self._connect_coro: SSHForwarderCoro = loop.create_unix_connection
+            self._connect_args: Sequence[object] = (host + ':' + dpynum,)
         elif host in ('', 'unix'):
             self._connect_coro = loop.create_unix_connection
             self._connect_args = ('/tmp/.X11-unix/X' + dpynum,)
         else:
             self._connect_coro = loop.create_connection
             self._connect_args = (host, X11_BASE_PORT + int(dpynum))
 
-        self._remote_auth = {}
-        self._channel = {}
+        self._remote_auth: Dict['SSHChannel', bytes] = {}
+        self._channel: Dict[bytes, Tuple['SSHChannel', bool]] = {}
 
-    def attach(self, display, chan, single_connection):
+    def attach(self, display: str, chan: 'SSHChannel',
+               single_connection: bool) -> Tuple[bytes, bytes, int]:
         """Attach a channel to this listener"""
 
         host, dpynum, screen = _parse_display(display)
 
         if self._host != host or self._dpynum != dpynum:
             raise ValueError('Already forwarding to another X11 display')
 
         remote_auth = os.urandom(len(self._local_auth))
 
         self._remote_auth[chan] = remote_auth
         self._channel[remote_auth] = chan, single_connection
 
         return self._auth_proto, remote_auth, screen
 
-    def detach(self, chan):
+    def detach(self, chan: 'SSHChannel') -> bool:
         """Detach a channel from this listener"""
 
         try:
             remote_auth = self._remote_auth.pop(chan)
             del self._channel[remote_auth]
         except KeyError:
             pass
 
-        return self._remote_auth == {}
+        return not bool(self._remote_auth)
 
-    async def forward_connection(self):
+    async def forward_connection(self) -> SSHX11ClientForwarder:
         """Forward an incoming connection to the local X server"""
 
+        peer: SSHForwarder
+
         try:
             _, peer = await self._connect_coro(SSHForwarder,
                                                *self._connect_args)
         except OSError as exc:
             raise ChannelOpenError(OPEN_CONNECT_FAILED, str(exc)) from None
 
         return SSHX11ClientForwarder(self, peer)
 
-    def validate_auth(self, remote_auth):
+    def validate_auth(self, remote_auth: bytes) -> bytes:
         """Validate client auth and enforce single connection flag"""
 
         chan, single_connection = self._channel[remote_auth]
 
         if single_connection:
             del self._channel[remote_auth]
             del self._remote_auth[chan]
 
         return self._local_auth
 
 
 class SSHX11ServerListener:
     """Server listener used to forward X11 connections"""
 
-    def __init__(self, tcp_listener, display):
+    def __init__(self, tcp_listener: SSHListener, display: str):
         self._tcp_listener = tcp_listener
         self._display = display
-        self._channels = set()
+        self._channels: Set[object] = set()
 
-    def attach(self, chan, screen):
+    def attach(self, chan: 'SSHChannel', screen: int) -> str:
         """Attach a channel to this listener and return its display"""
 
         self._channels.add(chan)
 
         return '%s.%s' % (self._display, screen)
 
-    def detach(self, chan):
+    def detach(self, chan: 'SSHChannel') -> bool:
         """Detach a channel from this listener"""
 
         try:
             self._channels.remove(chan)
         except KeyError:
             pass
 
         if not self._channels:
             self._tcp_listener.close()
-            self._tcp_listener = None
             return True
         else:
             return False
 
 
-def get_xauth_path(auth_path):
+def get_xauth_path(auth_path: Optional[str]) -> str:
     """Compute the path to the Xauthority file"""
 
     if not auth_path:
         auth_path = os.environ.get('XAUTHORITY')
 
     if not auth_path:
         auth_path = str(Path('~', '.Xauthority').expanduser())
 
     return auth_path
 
 
-def walk_xauth(auth_path):
+def walk_xauth(auth_path: str) -> Iterable[SSHXAuthorityEntry]:
     """Walk the entries in an Xauthority file"""
 
-    def _read_bytes(n):
+    def _read_bytes(n: int) -> bytes:
         """Read exactly n bytes"""
 
         data = auth_file.read(n)
 
         if len(data) != n:
             raise EOFError
 
         return data
 
-    def _read_uint16():
+    def _read_uint16() -> int:
         """Read a 16-bit unsigned integer"""
 
         return int.from_bytes(_read_bytes(2), 'big')
 
-    def _read_string():
+    def _read_string() -> bytes:
         """Read a string"""
 
         return _read_bytes(_read_uint16())
 
     try:
         with open(auth_path, 'rb') as auth_file:
             while True:
@@ -391,26 +411,28 @@
                                              _read_string())
                 except EOFError:
                     raise ValueError('Incomplete Xauthority entry') from None
     except OSError:
         pass
 
 
-async def lookup_xauth(loop, auth_path, host, dpynum):
+async def lookup_xauth(loop: asyncio.AbstractEventLoop,
+                       auth_path: Optional[str], host: str,
+                       dpynum: str) -> Tuple[bytes, bytes]:
     """Look up Xauthority data for the specified display"""
 
     auth_path = get_xauth_path(auth_path)
 
     if host.startswith('/') or host in ('', 'unix', 'localhost'):
         host = socket.gethostname()
 
     dpynum = dpynum.encode('ascii')
 
-    ipv4_addrs = []
-    ipv6_addrs = []
+    ipv4_addrs: Sequence[str] = []
+    ipv6_addrs: Sequence[str] = []
 
     for entry in walk_xauth(auth_path):
         if entry.dpynum and entry.dpynum != dpynum:
             continue
 
         if entry.family == XAUTH_FAMILY_IPV4:
             if not ipv4_addrs:
@@ -433,15 +455,17 @@
 
         if match:
             return entry.proto, entry.data
 
     logger.debug1('No xauth entry found for display: using random auth')
     return XAUTH_PROTO_COOKIE, os.urandom(XAUTH_COOKIE_LEN)
 
-async def update_xauth(auth_path, host, dpynum, auth_proto, auth_data):
+
+async def update_xauth(auth_path: Optional[str], host: str, dpynum: str,
+                       auth_proto: bytes, auth_data: bytes) -> None:
     """Update Xauthority data for the specified display"""
 
     if host.startswith('/') or host in ('', 'unix', 'localhost'):
         host = socket.gethostname()
 
     host = host.encode('idna')
     dpynum = str(dpynum).encode('ascii')
@@ -463,55 +487,61 @@
             await asyncio.sleep(XAUTH_LOCK_DELAY)
         else:
             break
 
     if not new_file:
         raise ValueError('Unable to acquire Xauthority lock')
 
-    new_entry = SSHXAuthorityEntry(XAUTH_FAMILY_HOSTNAME, host, dpynum,
-                                   auth_proto, auth_data)
+    new_entry = SSHXAuthorityEntry(XAUTH_FAMILY_HOSTNAME, host,
+                                   dpynum, auth_proto, auth_data)
 
     new_file.write(bytes(new_entry))
 
     for entry in walk_xauth(auth_path):
         if (entry.family != new_entry.family or entry.addr != new_entry.addr or
                 entry.dpynum != new_entry.dpynum):
             new_file.write(bytes(entry))
 
     new_file.close()
 
     os.replace(new_auth_path, auth_path)
 
 
-async def create_x11_client_listener(loop, display, auth_path):
+async def create_x11_client_listener(loop: asyncio.AbstractEventLoop,
+                                     display: str,
+                                     auth_path: Optional[str]) -> \
+        SSHX11ClientListener:
     """Create a listener to accept X11 connections forwarded over SSH"""
 
     host, dpynum, _ = _parse_display(display)
 
     auth_proto, auth_data = await lookup_xauth(loop, auth_path, host, dpynum)
 
     return SSHX11ClientListener(loop, host, dpynum, auth_proto, auth_data)
 
 
-async def create_x11_server_listener(conn, loop, auth_path,
-                                     auth_proto, auth_data):
+async def create_x11_server_listener(conn: 'SSHServerConnection',
+                                     loop: asyncio.AbstractEventLoop,
+                                     auth_path: Optional[str],
+                                     auth_proto: bytes, auth_data: bytes) -> \
+        Optional[SSHX11ServerListener]:
     """Create a listener to forward X11 connections over SSH"""
 
     for dpynum in range(X11_DISPLAY_START, X11_MAX_DISPLAYS):
         try:
             tcp_listener = await create_tcp_forward_listener(
                 conn, loop, conn.create_x11_connection,
                 X11_LISTEN_HOST, X11_BASE_PORT + dpynum)
         except OSError:
             continue
 
         display = '%s:%d' % (X11_LISTEN_HOST, dpynum)
 
         try:
-            await update_xauth(auth_path, X11_LISTEN_HOST, dpynum,
+            await update_xauth(auth_path, X11_LISTEN_HOST, str(dpynum),
                                auth_proto, auth_data)
         except ValueError:
             tcp_listener.close()
             break
 
         return SSHX11ServerListener(tcp_listener, display)
```

### Comparing `asyncssh-2.8.1/asyncssh/listener.py` & `asyncssh-2.9.0/asyncssh/listener.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2013-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -19,33 +19,56 @@
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH listeners"""
 
 import asyncio
 import errno
 import socket
+from types import TracebackType
+from typing import TYPE_CHECKING, AnyStr, Callable, Generic, List, Optional
+from typing import Sequence, Tuple, Type, Union
 
+from .forward import SSHForwarderCoro
 from .forward import SSHLocalPortForwarder, SSHLocalPathForwarder
+from .misc import HostPort, MaybeAwait
+from .session import SSHTCPSession, SSHUNIXSession
 from .socks import SSHSOCKSForwarder
 
 
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .channel import SSHTCPChannel, SSHUNIXChannel
+    from .connection import SSHConnection, SSHClientConnection
+
+
+_LocalListenerFactory = Callable[[], asyncio.BaseProtocol]
+
+ListenKey = Union[HostPort, str]
+
+TCPListenerFactory = Callable[[str, int], MaybeAwait[SSHTCPSession[AnyStr]]]
+UNIXListenerFactory = Callable[[], MaybeAwait[SSHUNIXSession[AnyStr]]]
+
+
 class SSHListener:
     """SSH listener for inbound connections"""
 
-    def __init__(self):
-        self._tunnel = None
+    def __init__(self) -> None:
+        self._tunnel: Optional['SSHConnection'] = None
 
-    async def __aenter__(self):
+    async def __aenter__(self) -> 'SSHListener':
         return self
 
-    async def __aexit__(self, *exc_info):
+    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],
+                        _exc_value: Optional[BaseException],
+                        _traceback: Optional[TracebackType]) -> bool:
         self.close()
         await self.wait_closed()
+        return False
 
-    def get_port(self):
+    def get_port(self) -> int:
         """Return the port number being listened on
 
            This method returns the port number that the remote listener
            was bound to. When the requested remote listening port is `0`
            to indicate a dynamic port, this method can be called to
            determine what listening port was selected. This function
            only applies to TCP listeners.
@@ -54,31 +77,31 @@
 
         """
 
         # pylint: disable=no-self-use
 
         return 0
 
-    def set_tunnel(self, tunnel):
+    def set_tunnel(self, tunnel: 'SSHConnection') -> None:
         """Set tunnel associated with listener"""
 
         self._tunnel = tunnel
 
-    def close(self):
+    def close(self) -> None:
         """Stop listening for new connections
 
            This method can be called to stop listening for connections.
            Existing connections will remain open.
 
         """
 
         if self._tunnel:
             self._tunnel.close()
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for the listener to close
 
            This method is a coroutine which waits for the associated
            listeners to be closed.
 
         """
 
@@ -86,170 +109,181 @@
             await self._tunnel.wait_closed()
             self._tunnel = None
 
 
 class SSHClientListener(SSHListener):
     """Client listener used to accept inbound forwarded connections"""
 
-    def __init__(self, conn, session_factory,
-                 encoding, errors, window, max_pktsize):
+    def __init__(self, conn: 'SSHClientConnection', encoding: Optional[str],
+                 errors: str, window: int, max_pktsize: int):
         super().__init__()
 
-        self._conn = conn
-        self._session_factory = session_factory
+        self._conn: Optional['SSHClientConnection'] = conn
         self._encoding = encoding
         self._errors = errors
         self._window = window
         self._max_pktsize = max_pktsize
         self._close_event = asyncio.Event()
 
-    async def _close(self):
+    async def _close(self) -> None:
         """Close this listener"""
 
         self._close_event.set()
         self._conn = None
 
-    def close(self):
+    def close(self) -> None:
         """Close this listener asynchronously"""
 
         super().close()
 
         if self._conn:
             self._conn.create_task(self._close())
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this listener to finish closing"""
 
         await super().wait_closed()
 
         await self._close_event.wait()
 
 
-class SSHTCPClientListener(SSHClientListener):
+class SSHTCPClientListener(SSHClientListener, Generic[AnyStr]):
     """Client listener used to accept inbound forwarded TCP connections"""
 
-    def __init__(self, conn, session_factory, listen_host, listen_port,
-                 encoding, errors, window, max_pktsize):
-        super().__init__(conn, session_factory, encoding,
-                         errors, window, max_pktsize)
+    def __init__(self, conn: 'SSHClientConnection',
+                 session_factory: TCPListenerFactory[AnyStr],
+                 listen_host: str, listen_port: int,
+                 encoding: Optional[str], errors: str,
+                 window: int, max_pktsize: int):
+        super().__init__(conn, encoding, errors, window, max_pktsize)
 
+        self._session_factory: TCPListenerFactory[AnyStr] = session_factory
         self._listen_host = listen_host
         self._listen_port = listen_port
 
-    async def _close(self):
+    async def _close(self) -> None:
         """Close this listener"""
 
         if self._conn: # pragma: no branch
             await self._conn.close_client_tcp_listener(self._listen_host,
                                                        self._listen_port)
 
         await super()._close()
 
-    def process_connection(self, orig_host, orig_port):
+    def process_connection(self, orig_host: str, orig_port: int) -> \
+            Tuple['SSHTCPChannel[AnyStr]',
+                  MaybeAwait[SSHTCPSession[AnyStr]]]:
         """Process a forwarded TCP connection"""
 
+        assert self._conn is not None
+
         chan = self._conn.create_tcp_channel(self._encoding, self._errors,
                                              self._window, self._max_pktsize)
 
         chan.set_inbound_peer_names(self._listen_host, self._listen_port,
                                     orig_host, orig_port)
 
         return chan, self._session_factory(orig_host, orig_port)
 
-    def get_port(self):
+    def get_port(self) -> int:
         """Return the port number being listened on"""
 
         return self._listen_port
 
 
-class SSHUNIXClientListener(SSHClientListener):
+class SSHUNIXClientListener(SSHClientListener, Generic[AnyStr]):
     """Client listener used to accept inbound forwarded UNIX connections"""
 
-    def __init__(self, conn, session_factory, listen_path,
-                 encoding, errors, window, max_pktsize):
-        super().__init__(conn, session_factory, encoding,
-                         errors, window, max_pktsize)
+    def __init__(self, conn: 'SSHClientConnection',
+                 session_factory: UNIXListenerFactory[AnyStr],
+                 listen_path: str, encoding: Optional[str],
+                 errors: str, window: int, max_pktsize: int):
+        super().__init__(conn, encoding, errors, window, max_pktsize)
 
+        self._session_factory: UNIXListenerFactory[AnyStr] = session_factory
         self._listen_path = listen_path
 
-    async def _close(self):
+    async def _close(self) -> None:
         """Close this listener"""
 
         if self._conn: # pragma: no branch
             await self._conn.close_client_unix_listener(self._listen_path)
 
         await super()._close()
 
-    def process_connection(self):
+    def process_connection(self) -> \
+            Tuple['SSHUNIXChannel[AnyStr]',
+                  MaybeAwait[SSHUNIXSession[AnyStr]]]:
         """Process a forwarded UNIX connection"""
 
+        assert self._conn is not None
+
         chan = self._conn.create_unix_channel(self._encoding, self._errors,
                                               self._window, self._max_pktsize)
 
         chan.set_inbound_peer_names(self._listen_path)
 
         return chan, self._session_factory()
 
 
 class SSHForwardListener(SSHListener):
     """A listener used when forwarding traffic from local ports"""
 
-    def __init__(self, conn, servers, listen_key, listen_port=0):
+    def __init__(self, conn: 'SSHConnection',
+                 servers: Sequence[asyncio.AbstractServer],
+                 listen_key: ListenKey, listen_port: int = 0):
         super().__init__()
 
-        self._conn = conn
+        self._conn: Optional['SSHConnection'] = conn
         self._servers = servers
         self._listen_key = listen_key
         self._listen_port = listen_port
 
-    def get_port(self):
+    def get_port(self) -> int:
         """Return the port number being listened on"""
 
         return self._listen_port
 
-    def close(self):
+    def close(self) -> None:
         """Close this listener"""
 
-        super().close()
-
-        if self._conn:
+        if self._conn: # pragma: no branch
             self._conn.close_forward_listener(self._listen_key)
 
             for server in self._servers:
                 server.close()
 
             self._conn = None
 
-    async def wait_closed(self):
+    async def wait_closed(self) -> None:
         """Wait for this listener to finish closing"""
 
         await super().wait_closed()
 
         for server in self._servers:
             await server.wait_closed()
 
         self._servers = []
 
 
-async def create_tcp_local_listener(conn, loop, protocol_factory,
-                                    listen_host, listen_port):
+async def create_tcp_local_listener(
+        conn: 'SSHConnection', loop: asyncio.AbstractEventLoop,
+        protocol_factory: _LocalListenerFactory, listen_host: str,
+        listen_port: int) -> 'SSHForwardListener':
     """Create a listener to forward traffic from a local TCP port over SSH"""
 
-    if listen_host == '':
-        listen_host = None
-
-    addrinfo = await loop.getaddrinfo(listen_host, listen_port,
+    addrinfo = await loop.getaddrinfo(listen_host or None, listen_port,
                                       family=socket.AF_UNSPEC,
                                       type=socket.SOCK_STREAM,
                                       flags=socket.AI_PASSIVE)
 
     if not addrinfo: # pragma: no cover
         raise OSError('getaddrinfo() returned empty list')
 
-    servers = []
+    servers: List[asyncio.AbstractServer] = []
 
     for family, socktype, proto, _, sa in addrinfo:
         try:
             sock = socket.socket(family, socktype, proto)
         except OSError: # pragma: no cover
             continue
 
@@ -258,72 +292,83 @@
         if family == socket.AF_INET6:
             try:
                 sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, True)
             except AttributeError: # pragma: no cover
                 pass
 
         if sa[1] == 0:
-            sa = sa[:1] + (listen_port,) + sa[2:]
+            sa = sa[:1] + (listen_port,) + sa[2:] # type: ignore
 
         try:
             sock.bind(sa)
         except (OSError, OverflowError) as exc:
             sock.close()
 
             for server in servers:
                 server.close()
 
             if isinstance(exc, OverflowError): # pragma: no cover
-                exc.errno = errno.EOVERFLOW
-                exc.strerror = str(exc)
+                exc.errno = errno.EOVERFLOW # type: ignore
+                exc.strerror = str(exc) # type: ignore
 
             # pylint: disable=no-member
-            raise OSError(exc.errno, 'error while attempting to bind on '
-                          'address %r: %s' % (sa, exc.strerror)) from None
+            raise OSError(exc.errno, 'error while attempting ' # type: ignore
+                          'to bind on address %r: %s' %
+                          (sa, exc.strerror)) from None # type: ignore
 
         if listen_port == 0:
             listen_port = sock.getsockname()[1]
             conn.logger.debug1('Assigning dynamic port %d', listen_port)
 
         server = await loop.create_server(protocol_factory, sock=sock)
         servers.append(server)
 
-    listen_key = listen_host, listen_port
+    listen_key = listen_host or '', listen_port
     return SSHForwardListener(conn, servers, listen_key, listen_port)
 
 
-async def create_tcp_forward_listener(conn, loop, coro,
-                                      listen_host, listen_port):
+async def create_tcp_forward_listener(conn: 'SSHConnection',
+                                      loop: asyncio.AbstractEventLoop,
+                                      coro: SSHForwarderCoro, listen_host: str,
+                                      listen_port: int) -> \
+        'SSHForwardListener':
     """Create a listener to forward traffic from a local TCP port over SSH"""
 
-    def protocol_factory():
+    def protocol_factory() -> asyncio.BaseProtocol:
         """Start a port forwarder for each new local connection"""
 
         return SSHLocalPortForwarder(conn, coro)
 
     return await create_tcp_local_listener(conn, loop, protocol_factory,
                                            listen_host, listen_port)
 
 
-async def create_unix_forward_listener(conn, loop, coro, listen_path):
+async def create_unix_forward_listener(conn: 'SSHConnection',
+                                       loop: asyncio.AbstractEventLoop,
+                                       coro: SSHForwarderCoro,
+                                       listen_path: str) -> \
+        'SSHForwardListener':
     """Create a listener to forward a local UNIX domain socket over SSH"""
 
-    def protocol_factory():
+    def protocol_factory() -> asyncio.BaseProtocol:
         """Start a path forwarder for each new local connection"""
 
         return SSHLocalPathForwarder(conn, coro)
 
     server = await loop.create_unix_server(protocol_factory, listen_path)
 
     return SSHForwardListener(conn, [server], listen_path)
 
 
-async def create_socks_listener(conn, loop, coro, listen_host, listen_port):
+async def create_socks_listener(conn: 'SSHConnection',
+                                loop: asyncio.AbstractEventLoop,
+                                coro: SSHForwarderCoro, listen_host: str,
+                                listen_port: int) -> SSHForwardListener:
     """Create a SOCKS listener to forward traffic over SSH"""
 
-    def protocol_factory():
+    def protocol_factory() -> asyncio.BaseProtocol:
         """Start a port forwarder for each new SOCKS connection"""
 
         return SSHSOCKSForwarder(conn, coro)
 
     return await create_tcp_local_listener(conn, loop, protocol_factory,
                                            listen_host, listen_port)
```

### Comparing `asyncssh-2.8.1/asyncssh/asn1.py` & `asyncssh-2.9.0/asyncssh/asn1.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,14 +28,22 @@
    non-standard types can be encoded by placing them in a RawDERObject.
 
    The der_decode function takes a byte string in DER format and decodes
    it into the corresponding Python values.
 
 """
 
+from typing import Dict, FrozenSet, Sequence, Set, Tuple, Type, TypeVar, Union
+from typing import cast
+
+
+_DERClass = Type['DERType']
+_DERClassVar = TypeVar('_DERClassVar', bound='_DERClass')
+
+
 # ASN.1 object classes
 UNIVERSAL         = 0x00
 APPLICATION       = 0x01
 CONTEXT_SPECIFIC  = 0x02
 PRIVATE           = 0x03
 
 # ASN.1 universal object tags
@@ -49,19 +57,19 @@
 UTF8_STRING       = 0x0c
 SEQUENCE          = 0x10
 SET               = 0x11
 IA5_STRING        = 0x16
 
 _asn1_class = ('Universal', 'Application', 'Context-specific', 'Private')
 
-_der_class_by_tag = {}
-_der_class_by_type = {}
+_der_class_by_tag: Dict[int, _DERClass] = {}
+_der_class_by_type: Dict[Union[object, _DERClass], _DERClass] = {}
 
 
-def _encode_identifier(asn1_class, constructed, tag):
+def _encode_identifier(asn1_class: int, constructed: bool, tag: int) -> bytes:
     """Encode a DER object's identifier"""
 
     if asn1_class not in (UNIVERSAL, APPLICATION, CONTEXT_SPECIFIC, PRIVATE):
         raise ASN1EncodeError('Invalid ASN.1 class')
 
     flags = (asn1_class << 6) | (0x20 if constructed else 0x00)
 
@@ -87,14 +95,32 @@
     """ASN.1 DER encoding error"""
 
 
 class ASN1DecodeError(ASN1Error):
     """ASN.1 DER decoding error"""
 
 
+class DERType:
+    """Parent class for classes which use DERTag decorator"""
+
+    identifier: bytes = b''
+
+    @staticmethod
+    def encode(value: object) -> bytes:
+        """Encode value as a DER byte string"""
+
+        raise NotImplementedError
+
+    @classmethod
+    def decode(cls, constructed: bool, content: bytes) -> object:
+        """Decode a DER byte string into an object"""
+
+        raise NotImplementedError
+
+
 class DERTag:
     """A decorator used by classes which convert values to/from DER
 
        Classes which convert Python values to and from DER format
        should use the DERTag decorator to indicate what DER tag value
        they understand. When DER data is decoded, the tag is looked
        up in the list to see which class to call to perform the
@@ -103,20 +129,21 @@
        Classes which convert existing Python types to and from DER
        format can specify the list of types they understand in the
        optional "types" argument. Otherwise, conversion is expected
        to be to and from the new class being defined.
 
     """
 
-    def __init__(self, tag, types=(), constructed=False):
+    def __init__(self, tag: int, types: Sequence[object] = (),
+                 constructed: bool = False):
         self._tag = tag
         self._types = types
         self._identifier = _encode_identifier(UNIVERSAL, constructed, tag)
 
-    def __call__(self, cls):
+    def __call__(self, cls: _DERClassVar) -> _DERClassVar:
         cls.identifier = self._identifier
 
         _der_class_by_tag[self._tag] = cls
 
         if self._types:
             for t in self._types:
                 _der_class_by_type[t] = cls
@@ -132,267 +159,279 @@
        This object is initialized with an ASN.1 class, tag, and a
        byte string representing the already encoded data. Such
        objects will never have the constructed flag set, since
        that is represented here as a TaggedDERObject.
 
     """
 
-    def __init__(self, tag, content, asn1_class):
+    def __init__(self, tag: int, content: bytes, asn1_class: int):
         self.asn1_class = asn1_class
         self.tag = tag
         self.content = content
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return ('RawDERObject(%s, %s, %r)' %
                 (_asn1_class[self.asn1_class], self.tag, self.content))
 
-    def __eq__(self, other):
-        return (isinstance(other, type(self)) and
-                self.asn1_class == other.asn1_class and
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, RawDERObject): # pragma: no cover
+            return NotImplemented
+
+        return (self.asn1_class == other.asn1_class and
                 self.tag == other.tag and self.content == other.content)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self.asn1_class, self.tag, self.content))
 
-    def encode_identifier(self):
+    def encode_identifier(self) -> bytes:
         """Encode the DER identifier for this object as a byte string"""
 
         return _encode_identifier(self.asn1_class, False, self.tag)
 
-    def encode(self):
+    @staticmethod
+    def encode(value: object) -> bytes:
         """Encode the content for this object as a DER byte string"""
 
-        return self.content
+        return cast('RawDERObject', value).content
 
 
 class TaggedDERObject:
     """An explicitly tagged DER object
 
        This object provides a way to wrap an ASN.1 object with an
        explicit tag. The value (including the tag representing its
        actual type) is then encoded as part of its value. By
        default, the ASN.1 class for these objects is CONTEXT_SPECIFIC,
        and the DER encoding always marks these values as constructed.
 
     """
 
-    def __init__(self, tag, value, asn1_class=CONTEXT_SPECIFIC):
+    def __init__(self, tag: int, value: object,
+                 asn1_class: int = CONTEXT_SPECIFIC):
         self.asn1_class = asn1_class
         self.tag = tag
         self.value = value
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         if self.asn1_class == CONTEXT_SPECIFIC:
             return 'TaggedDERObject(%s, %r)' % (self.tag, self.value)
         else:
             return ('TaggedDERObject(%s, %s, %r)' %
                     (_asn1_class[self.asn1_class], self.tag, self.value))
 
-    def __eq__(self, other):
-        return (isinstance(other, type(self)) and
-                self.asn1_class == other.asn1_class and
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, TaggedDERObject): # pragma: no cover
+            return NotImplemented
+
+        return (self.asn1_class == other.asn1_class and
                 self.tag == other.tag and self.value == other.value)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash((self.asn1_class, self.tag, self.value))
 
-    def encode_identifier(self):
+    def encode_identifier(self) -> bytes:
         """Encode the DER identifier for this object as a byte string"""
 
         return _encode_identifier(self.asn1_class, True, self.tag)
 
-    def encode(self):
+    @staticmethod
+    def encode(value: object) -> bytes:
         """Encode the content for this object as a DER byte string"""
 
-        return der_encode(self.value)
+        return der_encode(cast('TaggedDERObject', value).value)
 
 
 @DERTag(NULL, (type(None),))
-class _Null:
+class _Null(DERType):
     """A null value"""
 
     @staticmethod
-    def encode(_value):
+    def encode(value: object) -> bytes:
         """Encode a DER null value"""
 
+        # pylint: disable=unused-argument
+
         return b''
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> None:
         """Decode a DER null value"""
 
         if constructed:
             raise ASN1DecodeError('NULL should not be constructed')
 
         if content:
             raise ASN1DecodeError('NULL should not have associated content')
 
         return None
 
 
 @DERTag(BOOLEAN, (bool,))
-class _Boolean:
+class _Boolean(DERType):
     """A boolean value"""
 
     @staticmethod
-    def encode(value):
+    def encode(value: object) -> bytes:
         """Encode a DER boolean value"""
 
         return b'\xff' if value else b'\0'
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> bool:
         """Decode a DER boolean value"""
 
         if constructed:
             raise ASN1DecodeError('BOOLEAN should not be constructed')
 
         if content not in {b'\x00', b'\xff'}:
             raise ASN1DecodeError('BOOLEAN content must be 0x00 or 0xff')
 
         return bool(content[0])
 
 
 @DERTag(INTEGER, (int,))
-class _Integer:
+class _Integer(DERType):
     """An integer value"""
 
     @staticmethod
-    def encode(value):
+    def encode(value: object) -> bytes:
         """Encode a DER integer value"""
 
-        l = value.bit_length()
+        i = cast(int, value)
+        l = i.bit_length()
         l = l // 8 + 1 if l % 8 == 0 else (l + 7) // 8
-        result = value.to_bytes(l, 'big', signed=True)
+        result = i.to_bytes(l, 'big', signed=True)
         return result[1:] if result.startswith(b'\xff\x80') else result
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> int:
         """Decode a DER integer value"""
 
         if constructed:
             raise ASN1DecodeError('INTEGER should not be constructed')
 
         return int.from_bytes(content, 'big', signed=True)
 
 
 @DERTag(OCTET_STRING, (bytes, bytearray))
-class _OctetString:
+class _OctetString(DERType):
     """An octet string value"""
 
     @staticmethod
-    def encode(value):
+    def encode(value: object) -> bytes:
         """Encode a DER octet string"""
 
-        return value
+        return cast(bytes, value)
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> bytes:
         """Decode a DER octet string"""
 
         if constructed:
             raise ASN1DecodeError('OCTET STRING should not be constructed')
 
         return content
 
 
 @DERTag(UTF8_STRING, (str,))
-class _UTF8String:
+class _UTF8String(DERType):
     """A UTF-8 string value"""
 
     @staticmethod
-    def encode(value):
+    def encode(value: object) -> bytes:
         """Encode a DER UTF-8 string"""
 
-        return value.encode('utf-8')
+        return cast(str, value).encode('utf-8')
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> str:
         """Decode a DER UTF-8 string"""
 
         if constructed:
             raise ASN1DecodeError('UTF8 STRING should not be constructed')
 
         return content.decode('utf-8')
 
 
 @DERTag(SEQUENCE, (list, tuple), constructed=True)
-class _Sequence:
+class _Sequence(DERType):
     """A sequence of values"""
 
     @staticmethod
-    def encode(value):
+    def encode(value: object) -> bytes:
         """Encode a sequence of DER values"""
 
-        return b''.join(der_encode(item) for item in value)
+        seq_value = cast(Sequence[object], value)
+        return b''.join(der_encode(item) for item in seq_value)
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> Sequence[object]:
         """Decode a sequence of DER values"""
 
         if not constructed:
             raise ASN1DecodeError('SEQUENCE should always be constructed')
 
         offset = 0
         length = len(content)
 
         value = []
         while offset < length:
-            item, consumed = der_decode(content[offset:], partial_ok=True)
+            item, consumed = der_decode_partial(content[offset:])
             value.append(item)
             offset += consumed
 
         return tuple(value)
 
 
 @DERTag(SET, (set, frozenset), constructed=True)
-class _Set:
+class _Set(DERType):
     """A set of DER values"""
 
     @staticmethod
-    def encode(value):
+    def encode(value: object) -> bytes:
         """Encode a set of DER values"""
 
-        return b''.join(sorted(der_encode(item) for item in value))
+        set_value = cast(Union[FrozenSet[object], Set[object]], value)
+        return b''.join(sorted(der_encode(item) for item in set_value))
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> FrozenSet[object]:
         """Decode a set of DER values"""
 
         if not constructed:
             raise ASN1DecodeError('SET should always be constructed')
 
         offset = 0
         length = len(content)
 
         value = set()
         while offset < length:
-            item, consumed = der_decode(content[offset:], partial_ok=True)
+            item, consumed = der_decode_partial(content[offset:])
             value.add(item)
             offset += consumed
 
         return frozenset(value)
 
 
 @DERTag(BIT_STRING)
-class BitString:
+class BitString(DERType):
     """A string of bits
 
        This object can be initialized either with a byte string and an
        optional count of the number of least-significant bits in the last
        byte which should not be included in the value, or with a string
        consisting only of the digits '0' and '1'.
 
        An optional 'named' flag can also be set, indicating that the
        BitString was specified with named bits, indicating that the proper
        DER encoding of it should strip any trailing zeroes.
 
     """
 
-    def __init__(self, value, unused=0, named=False):
+    def __init__(self, value: object, unused: int = 0, named: bool = False):
         if unused < 0 or unused > 7:
             raise ASN1EncodeError('Unused bit count must be between 0 and 7')
 
         if isinstance(value, bytes):
             if unused:
                 if not value:
                     raise ASN1EncodeError('Can\'t have unused bits with empty '
@@ -419,140 +458,154 @@
                 if unused == 8:
                     value = value[:-1]
                     unused = 0
 
         self.value = value
         self.unused = unused
 
-    def __str__(self):
+    def __str__(self) -> str:
         result = ''.join(bin(b)[2:].zfill(8) for b in self.value)
         if self.unused:
             result = result[:-self.unused]
         return result
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return "BitString('%s')" % self
 
-    def __eq__(self, other):
-        return (isinstance(other, type(self)) and
-                self.value == other.value and self.unused == other.unused)
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, BitString): # pragma: no cover
+            return NotImplemented
 
-    def __hash__(self):
+        return self.value == other.value and self.unused == other.unused
+
+    def __hash__(self) -> int:
         return hash((self.value, self.unused))
 
-    def encode(self):
+    @staticmethod
+    def encode(value: object) -> bytes:
         """Encode a DER bit string"""
 
-        return bytes((self.unused,)) + self.value
+        bitstr_value = cast('BitString', value)
+        return bytes((bitstr_value.unused,)) + bitstr_value.value
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> 'BitString':
         """Decode a DER bit string"""
 
         if constructed:
             raise ASN1DecodeError('BIT STRING should not be constructed')
 
         if not content or content[0] > 7:
             raise ASN1DecodeError('Invalid unused bit count')
 
         return cls(content[1:], unused=content[0])
 
 
 @DERTag(IA5_STRING)
-class IA5String:
+class IA5String(DERType):
     """An ASCII string value"""
 
-    def __init__(self, value):
+    def __init__(self, value: Union[bytes, bytearray]):
         self.value = value
 
-    def __str__(self):
-        return '%s' % self.value
+    def __str__(self) -> str:
+        return '%s' % self.value.decode('ascii')
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return 'IA5String(%r)' % self.value
 
-    def __eq__(self, other):
-        return isinstance(other, type(self)) and self.value == other.value
+    def __eq__(self, other: object) -> bool: # pragma: no cover
+        if not isinstance(other, IA5String):
+            return NotImplemented
+
+        return self.value == other.value
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash(self.value)
 
-    def encode(self):
+    @staticmethod
+    def encode(value: object) -> bytes:
         """Encode a DER IA5 string"""
 
         # ASN.1 defines this type as only containing ASCII characters, but
         # some tools expecting ASN.1 allow IA5Strings to contain other
         # characters, so we leave it up to the caller to pass in a byte
         # string which has already done the appropriate encoding of any
         # non-ASCII characters.
 
-        return self.value
+        return cast('IA5String', value).value
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> 'IA5String':
         """Decode a DER IA5 string"""
 
         if constructed:
             raise ASN1DecodeError('IA5 STRING should not be constructed')
 
         # As noted in the encode method above, the decoded value for this
         # type is a byte string, leaving the decoding of any non-ASCII
         # characters up to the caller.
 
         return cls(content)
 
 
 @DERTag(OBJECT_IDENTIFIER)
-class ObjectIdentifier:
+class ObjectIdentifier(DERType):
     """An object identifier (OID) value
 
        This object can be initialized from a string of dot-separated
        integer values, representing a hierarchical namespace. All OIDs
        show have at least two components, with the first being between
        0 and 2 (indicating ITU-T, ISO, or joint assignment). In cases
        where the first component is 0 or 1, the second component must
        be in the range 0 to 39 due to the way these first two components
        are encoded.
 
     """
 
-    def __init__(self, value):
+    def __init__(self, value: str):
         self.value = value
 
-    def __str__(self):
+    def __str__(self) -> str:
         return self.value
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return "ObjectIdentifier('%s')" % self.value
 
-    def __eq__(self, other):
-        return isinstance(other, type(self)) and self.value == other.value
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, ObjectIdentifier): # pragma: no cover
+            return NotImplemented
 
-    def __hash__(self):
+        return self.value == other.value
+
+    def __hash__(self) -> int:
         return hash(self.value)
 
-    def encode(self):
+    @staticmethod
+    def encode(value: object) -> bytes:
         """Encode a DER object identifier"""
 
-        def _bytes(component):
+        def _bytes(component: int) -> bytes:
             """Convert a single element of an OID to a DER byte string"""
 
             if component < 0:
                 raise ASN1EncodeError('Components of object identifier must '
                                       'be greater than or equal to 0')
 
             result = [component & 0x7f]
             while component >= 0x80:
                 component >>= 7
                 result.append(0x80 | (component & 0x7f))
 
             return bytes(result[::-1])
 
+        oid_value = cast('ObjectIdentifier', value)
+
         try:
-            components = [int(c) for c in self.value.split('.')]
+            components = [int(c) for c in oid_value.value.split('.')]
         except ValueError:
             raise ASN1EncodeError('Component values must be '
                                   'integers') from None
 
         if len(components) < 2:
             raise ASN1EncodeError('Object identifiers must have at least two '
                                   'components')
@@ -563,15 +616,15 @@
             raise ASN1EncodeError('Second component of object identifier must '
                                   'be between 0 and 39')
 
         components[0:2] = [components[0]*40 + components[1]]
         return b''.join(_bytes(c) for c in components)
 
     @classmethod
-    def decode(cls, constructed, content):
+    def decode(cls, constructed: bool, content: bytes) -> 'ObjectIdentifier':
         """Decode a DER object identifier"""
 
         if constructed:
             raise ASN1DecodeError('OBJECT IDENTIFIER should not be '
                                   'constructed')
 
         if not content:
@@ -593,15 +646,15 @@
 
         if component:
             raise ASN1DecodeError('Incomplete component')
 
         return cls('.'.join(str(c) for c in components))
 
 
-def der_encode(value):
+def der_encode(value: object) -> bytes:
     """Encode a value in DER format
 
        This function takes a Python value and encodes it in DER format.
        The following mapping of types is used:
 
        NoneType            -> NULL
        bool                -> BOOLEAN
@@ -620,16 +673,17 @@
        Other types can be encoded by passing in a RawDERObject which
        specifies the ASN.1 class, tag, and raw content octets to encode.
 
     """
 
     t = type(value)
     if t in (RawDERObject, TaggedDERObject):
+        value = cast(Union[RawDERObject, TaggedDERObject], value)
         identifier = value.encode_identifier()
-        content = value.encode()
+        content = value.encode(value)
     elif t in _der_class_by_type:
         cls = _der_class_by_type[t]
         identifier = cls.identifier
         content = cls.encode(value)
     else:
         raise ASN1EncodeError('Cannot DER encode type %s' % t.__name__)
 
@@ -639,42 +693,16 @@
     else:
         len_bytes = length.to_bytes((length.bit_length() + 7) // 8, 'big')
         len_bytes = bytes((0x80 | len(len_bytes),)) + len_bytes
 
     return identifier + len_bytes + content
 
 
-def der_decode(data, partial_ok=False):
-    """Decode a value in DER format
-
-       This function takes a byte string in DER format and converts it
-       to a corresponding set of Python objects. The following mapping
-       of ASN.1 tags to Python types is used:
-
-       NULL              -> NoneType
-       BOOLEAN           -> bool
-       INTEGER           -> int
-       OCTET STRING      -> bytes
-       UTF8 STRING       -> str
-       SEQUENCE          -> tuple
-       SET               -> frozenset
-       BIT_STRING        -> BitString
-       OBJECT IDENTIFIER -> ObjectIdentifier
-
-       Explicitly tagged objects are returned as type TaggedDERObject,
-       with fields holding the object class, tag, and tagged value.
-
-       Other object tags are returned as type RawDERObject, with fields
-       holding the object class, tag, and raw content octets.
-
-       If partial_ok is True, this function returns a tuple of the decoded
-       value and number of bytes consumed. Otherwise, all data bytes must
-       be consumed and only the decoded value is returned.
-
-    """
+def der_decode_partial(data: bytes) -> Tuple[object, int]:
+    """Decode a value in DER format and return the number of bytes consumed"""
 
     if len(data) < 2:
         raise ASN1DecodeError('Incomplete data')
 
     tag = data[0]
     asn1_class, constructed, tag = tag >> 6, bool(tag & 0x20), tag & 0x1f
     offset = 1
@@ -700,26 +728,59 @@
     if length > 0x80:
         len_size = length & 0x7f
         length = int.from_bytes(data[offset:offset+len_size], 'big')
         offset += len_size
     elif length == 0x80:
         raise ASN1DecodeError('Indefinite length not allowed')
 
-    if offset+length > len(data):
-        raise ASN1DecodeError('Incomplete data')
+    end = offset + length
+    content = data[offset:end]
 
-    if not partial_ok and offset+length < len(data):
-        raise ASN1DecodeError('Data contains unexpected bytes at end')
+    if end > len(data):
+        raise ASN1DecodeError('Incomplete data')
 
     if asn1_class == UNIVERSAL and tag in _der_class_by_tag:
         cls = _der_class_by_tag[tag]
-        value = cls.decode(constructed, data[offset:offset+length])
+        value = cls.decode(constructed, content)
     elif constructed:
-        value = TaggedDERObject(tag, der_decode(data[offset:offset+length]),
-                                asn1_class)
+        value = TaggedDERObject(tag, der_decode(content), asn1_class)
     else:
-        value = RawDERObject(tag, data[offset:offset+length], asn1_class)
+        value = RawDERObject(tag, content, asn1_class)
 
-    if partial_ok:
-        return value, offset+length
-    else:
-        return value
+    return value, end
+
+
+def der_decode(data: bytes) -> object:
+    """Decode a value in DER format
+
+       This function takes a byte string in DER format and converts it
+       to a corresponding set of Python objects. The following mapping
+       of ASN.1 tags to Python types is used:
+
+       NULL              -> NoneType
+       BOOLEAN           -> bool
+       INTEGER           -> int
+       OCTET STRING      -> bytes
+       UTF8 STRING       -> str
+       SEQUENCE          -> tuple
+       SET               -> frozenset
+       BIT_STRING        -> BitString
+       OBJECT IDENTIFIER -> ObjectIdentifier
+
+       Explicitly tagged objects are returned as type TaggedDERObject,
+       with fields holding the object class, tag, and tagged value.
+
+       Other object tags are returned as type RawDERObject, with fields
+       holding the object class, tag, and raw content octets.
+
+       If partial_ok is True, this function returns a tuple of the decoded
+       value and number of bytes consumed. Otherwise, all data bytes must
+       be consumed and only the decoded value is returned.
+
+    """
+
+    value, end = der_decode_partial(data)
+
+    if end < len(data):
+        raise ASN1DecodeError('Data contains unexpected bytes at end')
+
+    return value
```

### Comparing `asyncssh-2.8.1/asyncssh/mac.py` & `asyncssh-2.9.0/asyncssh/mac.py`

 * *Files 13% similar despite different names*

```diff
@@ -16,154 +16,162 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 """SSH message authentication handlers"""
 
-import hmac
 from hashlib import md5, sha1, sha224, sha256, sha384, sha512
+import hmac
+from typing import Dict, Callable, List, Tuple
 
 from .packet import UInt32, UInt64
 
 try:
     from .crypto import umac64, umac128
     _umac_available = True
 except ImportError: # pragma: no cover
     _umac_available = False
 
 
+_MACAlgsArgs = Tuple[bytes, int, int, bool, Callable, Tuple, bool]
+_MACHandler = Tuple[Callable, int, Tuple]
+_MACParams = Tuple[int, int, bool]
+
+
 _OPENSSH = b'@openssh.com'
 _ETM = b'-etm' + _OPENSSH
 
-_mac_algs = []
-_default_mac_algs = []
-_mac_handler = {}
-_mac_params = {}
+_mac_algs: List[bytes] = []
+_default_mac_algs: List[bytes] = []
+_mac_handler: Dict[bytes, _MACHandler] = {}
+_mac_params: Dict[bytes, _MACParams] = {}
 
 
 class MAC:
     """Parent class for SSH message authentication handlers"""
 
-    def __init__(self, key, hash_size):
+    def __init__(self, key: bytes, hash_size: int):
         self._key = key
         self._hash_size = hash_size
 
-    def sign(self, seq, packet):
+    def sign(self, seq: int, packet: bytes) -> bytes:
         """Compute a signature for a message"""
 
         raise NotImplementedError
 
-    def verify(self, seq, packet, sig):
+    def verify(self, seq: int, packet: bytes, sig: bytes) -> bool:
         """Verify the signature of a message"""
 
         raise NotImplementedError
 
 
 class _NullMAC(MAC):
     """Null message authentication handler"""
 
-    def sign(self, seq, packet):
+    def sign(self, seq: int, packet: bytes) -> bytes:
         """Compute a signature for a message"""
 
         return b''
 
-    def verify(self, seq, packet, sig):
+    def verify(self, seq: int, packet: bytes, sig: bytes) -> bool:
         """Verify the signature of a message"""
 
         return sig == b''
 
 
 class _HMAC(MAC):
     """HMAC-based message authentication handler"""
 
-    def __init__(self, key, hash_size, hash_alg):
+    def __init__(self, key: bytes, hash_size: int, hash_alg: Callable):
         super().__init__(key, hash_size)
         self._hash_alg = hash_alg
 
-    def sign(self, seq, packet):
+    def sign(self, seq: int, packet: bytes) -> bytes:
         """Compute a signature for a message"""
 
         data = UInt32(seq) + packet
         sig = hmac.new(self._key, data, self._hash_alg).digest()
         return sig[:self._hash_size]
 
-    def verify(self, seq, packet, sig):
+    def verify(self, seq: int, packet: bytes, sig: bytes) -> bool:
         """Verify the signature of a message"""
 
         return hmac.compare_digest(self.sign(seq, packet), sig)
 
 
 class _UMAC(MAC):
     """UMAC-based message authentication handler"""
 
-    def __init__(self, key, hash_size, umac_alg):
+    def __init__(self, key: bytes, hash_size: int, umac_alg: Callable):
         super().__init__(key, hash_size)
         self._umac_alg = umac_alg
 
-    def sign(self, seq, packet):
+    def sign(self, seq: int, packet: bytes) -> bytes:
         """Compute a signature for a message"""
 
         return self._umac_alg(self._key, packet, UInt64(seq)).digest()
 
-    def verify(self, seq, packet, sig):
+    def verify(self, seq: int, packet: bytes, sig: bytes) -> bool:
         """Verify the signature of a message"""
 
         return hmac.compare_digest(self.sign(seq, packet), sig)
 
 
-def register_mac_alg(mac_alg, key_size, hash_size, etm, handler, args, default):
+def register_mac_alg(mac_alg: bytes, key_size: int, hash_size: int,
+                     etm: bool, handler: Callable, args: Tuple,
+                     default: bool) -> None:
     """Register a MAC algorithm"""
 
     if mac_alg:
         _mac_algs.append(mac_alg)
 
         if default:
             _default_mac_algs.append(mac_alg)
 
     _mac_handler[mac_alg] = (handler, hash_size, args)
     _mac_params[mac_alg] = (key_size, hash_size, etm)
 
 
-def get_mac_algs():
+def get_mac_algs() -> List[bytes]:
     """Return supported MAC algorithms"""
 
     return _mac_algs
 
 
-def get_default_mac_algs():
+def get_default_mac_algs() -> List[bytes]:
     """Return default MAC algorithms"""
 
     return _default_mac_algs
 
 
-def get_mac_params(mac_alg):
+def get_mac_params(mac_alg: bytes) -> _MACParams:
     """Get parameters of a MAC algorithm
 
        This function returns the key and hash sizes of a MAC algorithm and
        whether or not to compute the MAC before or after encryption.
 
     """
 
     return _mac_params[mac_alg]
 
 
-def get_mac(mac_alg, key):
+def get_mac(mac_alg: bytes, key: bytes) -> MAC:
     """Return a MAC handler
 
        This function returns a MAC object initialized with the specified
        key that can be used for data signing and verification.
 
     """
 
     handler, hash_size, args = _mac_handler[mac_alg]
     return handler(key, hash_size, *args)
 
 
-_mac_algs_list = (
+_mac_algs_list: Tuple[_MACAlgsArgs, ...] = (
     (b'',                         0,  0, False, _NullMAC, (),         True),
 )
 
 if _umac_available: # pragma: no branch
     _mac_algs_list += (
         (b'umac-64' + _ETM,      16,  8, True,  _UMAC,    (umac64,),  True),
         (b'umac-128' + _ETM,     16, 16, True,  _UMAC,    (umac128,), True))
```

### Comparing `asyncssh-2.8.1/CONTRIBUTING.rst` & `asyncssh-2.9.0/CONTRIBUTING.rst`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_x509.py` & `asyncssh-2.9.0/tests/test_x509.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,15 +51,16 @@
                              serial=None, valid_after=0,
                              valid_before=0xffffffffffffffff, ca=False,
                              ca_path_len=None, purposes=None,
                              user_principals=(), host_principals=(),
                              hash_alg='sha256', comment=None):
         """Generate and check an X.509 certificate"""
 
-        cert = generate_x509_certificate(self._privkey, self._pubkey,
+        cert = generate_x509_certificate(self._privkey.pyca_key,
+                                         self._pubkey.pyca_key,
                                          subject, issuer, serial,
                                          valid_after, valid_before,
                                          ca, ca_path_len, purposes,
                                          user_principals, host_principals,
                                          hash_alg, comment)
 
         self.assertEqual(cert.data, import_x509_certificate(cert.data).data)
```

### Comparing `asyncssh-2.8.1/tests/test_public_key.py` & `asyncssh-2.9.0/tests/test_public_key.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2014-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2014-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -73,15 +73,15 @@
 
 # The openssl "-v2prf" option is only available in OpenSSL 1.0.2 or later
 _openssl_supports_v2prf = _openssl_version >= b'OpenSSL 1.0.2'
 
 # Ed25519/Ed448 support via "pkey" is only available in OpenSSL 1.1.1 or later
 _openssl_supports_pkey = _openssl_version >= b'OpenSSL 1.1.1'
 
-if _openssl_version >= b'OpenSSL 3':
+if _openssl_version >= b'OpenSSL 3': # pragma: no branch
     _openssl_legacy = '-provider default -provider legacy '
 else: # pragma: no cover
     _openssl_legacy = ''
 
 try:
     if sys.platform != 'win32':
         _openssh_version = run('ssh -V')
@@ -1386,25 +1386,29 @@
             for fmt in ('openssh', 'rfc4716'):
                 cert = asyncssh.import_certificate(
                     self.usercert.export_certificate(fmt))
                 self.assertEqual(cert.get_comment_bytes(), b'user_comment')
                 self.assertEqual(cert.get_comment(), 'user_comment')
 
                 cert = self.privca.generate_user_certificate(
-                    self.pubkey, 'name', comment='cert_comment')
+                    self.pubkey, 'name', principals='name1,name2',
+                    comment='cert_comment')
+                self.assertEqual(cert.principals, ['name1', 'name2'])
                 self.assertEqual(cert.get_comment_bytes(), b'cert_comment')
                 self.assertEqual(cert.get_comment(), 'cert_comment')
 
                 cert = asyncssh.import_certificate(
                     self.hostcert.export_certificate(fmt))
                 self.assertEqual(cert.get_comment_bytes(), b'host_comment')
                 self.assertEqual(cert.get_comment(), 'host_comment')
 
                 cert = self.privca.generate_host_certificate(
-                    self.pubkey, 'name', comment=b'\xff')
+                    self.pubkey, 'name', principals=['name1', 'name2'],
+                    comment=b'\xff')
+                self.assertEqual(cert.principals, ['name1', 'name2'])
                 self.assertEqual(cert.get_comment_bytes(), b'\xff')
                 with self.assertRaises(UnicodeDecodeError):
                     cert.get_comment()
 
                 cert.set_comment('new_comment')
                 self.assertEqual(cert.get_comment_bytes(), b'new_comment')
                 self.assertEqual(cert.get_comment(), 'new_comment')
```

### Comparing `asyncssh-2.8.1/tests/test_compression.py` & `asyncssh-2.9.0/tests/test_compression.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_pkcs11.py` & `asyncssh-2.9.0/tests/test_pkcs11.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2020-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/server.py` & `asyncssh-2.9.0/tests/server.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_agent.py` & `asyncssh-2.9.0/tests/test_agent.py`

 * *Files 8% similar despite different names*

```diff
@@ -183,15 +183,15 @@
             pubkey = key.convert_to_public()
             cert = key.generate_user_certificate(key, 'name')
 
             await agent.add_keys([(key, cert)])
             agent_keys = await agent.get_keys()
 
             for agent_key in agent_keys:
-                sig = await agent_key.sign(b'test')
+                sig = await agent_key.sign_async(b'test')
                 self.assertTrue(pubkey.verify(b'test', sig))
 
             await agent.remove_keys(agent_keys)
 
     @agent_test
     async def test_set_certificate(self, agent):
         """Test setting certificate on an existing keypair"""
@@ -226,15 +226,15 @@
         pubkey = key.convert_to_public()
 
         async with agent:
             await agent.add_keys([key])
             agent_keys = await agent.get_keys()
 
         for agent_key in agent_keys:
-            sig = await agent_key.sign(b'test')
+            sig = await agent_key.sign_async(b'test')
             self.assertTrue(pubkey.verify(b'test', sig))
 
     @agent_test
     async def test_add_remove_keys(self, agent):
         """Test adding and removing keys"""
 
         await agent.add_keys()
@@ -263,16 +263,29 @@
         self.assertEqual(len(agent_keys), 1)
         await asyncio.sleep(2)
 
         agent_keys = await agent.get_keys()
         self.assertEqual(len(agent_keys), 0)
 
     @agent_test
+    async def test_add_nonlocal(self, agent):
+        """Test failure when adding a non-local key to an agent"""
+
+        key = asyncssh.generate_private_key('ssh-rsa')
+
+        async with agent:
+            await agent.add_keys([key])
+            agent_keys = await agent.get_keys()
+
+            with self.assertRaises(asyncssh.KeyImportError):
+                await agent.add_keys(agent_keys)
+
+    @agent_test
     async def test_add_keys_failure(self, agent):
-        """Test getting keys from the agent"""
+        """Test failure adding keys to the agent"""
 
         os.mkdir('.ssh', 0o700)
         key = asyncssh.generate_private_key('ssh-rsa')
         key.write_private_key(Path('.ssh', 'id_rsa'))
 
         try:
             mock_agent = _Agent(Byte(SSH_AGENT_FAILURE))
@@ -367,20 +380,20 @@
         await agent.add_keys([key], confirm=True)
         agent_keys = await agent.get_keys()
 
         self.set_askpass(1)
 
         for agent_key in agent_keys:
             with self.assertRaises(ValueError):
-                sig = await agent_key.sign(b'test')
+                sig = await agent_key.sign_async(b'test')
 
         self.set_askpass(0)
 
         for agent_key in agent_keys:
-            sig = await agent_key.sign(b'test')
+            sig = await agent_key.sign_async(b'test')
             self.assertTrue(pubkey.verify(b'test', sig))
 
     @agent_test
     async def test_lock(self, agent):
         """Test lock and unlock"""
 
         key = asyncssh.generate_private_key('ssh-rsa')
@@ -389,20 +402,20 @@
         await agent.add_keys([key])
         agent_keys = await agent.get_keys()
 
         await agent.lock('passphrase')
 
         for agent_key in agent_keys:
             with self.assertRaises(ValueError):
-                await agent_key.sign(b'test')
+                await agent_key.sign_async(b'test')
 
         await agent.unlock('passphrase')
 
         for agent_key in agent_keys:
-            sig = await agent_key.sign(b'test')
+            sig = await agent_key.sign_async(b'test')
             self.assertTrue(pubkey.verify(b'test', sig))
 
     @asynctest
     async def test_query_extensions(self):
         """Test query of supported extensions"""
 
         mock_agent = _Agent(Byte(SSH_AGENT_SUCCESS) + String('xxx'))
```

### Comparing `asyncssh-2.8.1/tests/test_logging.py` & `asyncssh-2.9.0/tests/test_logging.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_packet.py` & `asyncssh-2.9.0/tests/test_packet.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_kex.py` & `asyncssh-2.9.0/tests/test_kex.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_known_hosts.py` & `asyncssh-2.9.0/tests/test_known_hosts.py`

 * *Files 1% similar despite different names*

```diff
@@ -182,17 +182,17 @@
             with self.subTest(testname):
                 self.check_hosts(patlists, result)
 
     def test_no_addr(self):
         """Test match without providing addr"""
 
         self.check_hosts((['host'], [], [], [], [], [], []),
-                         ([0], [], [], [], [], [], []), addr=None)
+                         ([0], [], [], [], [], [], []), addr='')
         self.check_hosts((['1.2.3.4'], [], [], [], [], [], []),
-                         ([], [], [], [], [], [], []), addr=None)
+                         ([], [], [], [], [], [], []), addr='')
 
     def test_no_port(self):
         """Test match without providing port"""
 
         self.check_hosts((['host'], [], [], [], [], [], []),
                          ([0], [], [], [], [], [], []), port=None)
         self.check_hosts((['[host]:22'], [], [], [], [], [], []),
```

### Comparing `asyncssh-2.8.1/tests/util.py` & `asyncssh-2.9.0/tests/util.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_editor.py` & `asyncssh-2.9.0/tests/test_editor.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_connection.py` & `asyncssh-2.9.0/tests/test_connection.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -1797,14 +1797,37 @@
         """Test connecting to server with revoked X.509 intermediate CA"""
 
         with self.assertRaises(asyncssh.HostKeyNotVerifiable):
             await self.connect(known_hosts=([], [], [], ['root_ca_cert.pem'],
                                             ['int_ca_cert.pem'], [], []))
 
     @asynctest
+    async def test_connect_x509_openssh_known_hosts_trusted(self):
+        """Test connecting with OpenSSH cert in known hosts trusted list"""
+
+        with self.assertRaises(ValueError):
+            await self.connect(known_hosts=[[], [], [], 'skey-cert.pub',
+                                            [], [], []])
+
+    @asynctest
+    async def test_connect_x509_openssh_known_hosts_revoked(self):
+        """Test connecting with OpenSSH cert in known hosts revoked list"""
+
+        with self.assertRaises(ValueError):
+            await self.connect(known_hosts=[[], [], [], [], 'skey-cert.pub',
+                                            [], []])
+
+    @asynctest
+    async def test_connect_x509_openssh_x509_trusted(self):
+        """Test connecting with OpenSSH cert in X.509 trusted certs list"""
+
+        with self.assertRaises(ValueError):
+            await self.connect(x509_trusted_certs='skey-cert.pub')
+
+    @asynctest
     async def test_invalid_x509_path(self):
         """Test passing in invalid trusted X.509 certificate path"""
 
         with self.assertRaises(ValueError):
             await self.connect(x509_trusted_cert_paths='xxx')
```

### Comparing `asyncssh-2.8.1/tests/gss_stub.py` & `asyncssh-2.9.0/tests/gss_stub.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/__init__.py` & `asyncssh-2.9.0/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/sk_stub.py` & `asyncssh-2.9.0/tests/sk_stub.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2019-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2019-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/pkcs11_stub.py` & `asyncssh-2.9.0/tests/pkcs11_stub.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2020-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_channel.py` & `asyncssh-2.9.0/tests/test_channel.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2022 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -687,15 +687,15 @@
         """Test keepalive channel requests"""
 
         with patch('asyncssh.connection.SSHClientChannel', _ClientChannel):
             async with self.connect() as conn:
                 chan, _ = await _create_session(conn)
 
                 result = await chan.make_request(b'keepalive@openssh.com')
-                self.assertTrue(result)
+                self.assertFalse(result)
 
     @asynctest
     async def test_invalid_open_confirmation(self):
         """Test receiving an open confirmation on already open channel"""
 
         async with self.connect() as conn:
             chan, _ = await _create_session(conn, 'invalid_open_confirm')
```

### Comparing `asyncssh-2.8.1/tests/test_connection_auth.py` & `asyncssh-2.9.0/tests/test_connection_auth.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_subprocess.py` & `asyncssh-2.9.0/tests/test_subprocess.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_forward.py` & `asyncssh-2.9.0/tests/test_forward.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -201,14 +201,26 @@
 
         if listen_path == 'open':
             return _EchoPathListener(self._conn)
         else:
             return listen_path != 'fail'
 
 
+class _UNIXAsyncConnectionServer(_UNIXConnectionServer):
+    """Server for testing async direct and forwarded UNIX connections"""
+
+    async def unix_server_requested(self, listen_path):
+        """Handle a request to create a new UNIX domain listener"""
+
+        if listen_path == 'open':
+            return _EchoPathListener(self._conn)
+        else:
+            return listen_path != 'fail'
+
+
 class _CheckForwarding(ServerTestCase):
     """Utility functions for AsyncSSH forwarding unit tests"""
 
     async def _check_echo_line(self, reader, writer,
                                delay=False, encoded=False):
         """Check if an input line is properly echoed back"""
 
@@ -265,15 +277,16 @@
                                                     *kwargs)
 
         await self._check_echo_block(reader, writer)
 
     async def _check_local_connection(self, listen_port, delay=None):
         """Open a local connection and test if an input line is echoed back"""
 
-        reader, writer = await asyncio.open_connection(None, listen_port)
+        reader, writer = await asyncio.open_connection('127.0.0.1',
+                                                       listen_port)
 
         await self._check_echo_line(reader, writer, delay=delay)
 
     @asynctest
     async def test_ssh_create_tunnel(self):
         """Test creating a tunneled SSH connection"""
 
@@ -575,15 +588,15 @@
     async def test_forward_local_port_pause(self):
         """Test pause during forwarding of a local port"""
 
         async with self.connect() as conn:
             async with conn.forward_local_port('', 0, '', 8) as listener:
                 listen_port = listener.get_port()
 
-                reader, writer = await asyncio.open_connection(None,
+                reader, writer = await asyncio.open_connection('127.0.0.1',
                                                                listen_port)
 
                 writer.write(4*1024*1024*b'\0')
                 writer.write_eof()
                 await reader.read()
 
                 writer.close()
@@ -594,15 +607,15 @@
     async def test_forward_local_port_failure(self):
         """Test failure in forwarding a local port"""
 
         async with self.connect() as conn:
             async with conn.forward_local_port('', 0, '', 65535) as listener:
                 listen_port = listener.get_port()
 
-                reader, writer = await asyncio.open_connection(None,
+                reader, writer = await asyncio.open_connection('127.0.0.1',
                                                                listen_port)
 
                 self.assertEqual((await reader.read()), b'')
 
                 writer.close()
                 await maybe_wait_closed(writer)
 
@@ -611,54 +624,54 @@
     @asynctest
     async def test_forward_bind_error_ipv4(self):
         """Test error binding a local forwarding port"""
 
         async with self.connect() as conn:
             async with conn.forward_local_port('0.0.0.0', 0, '', 7) as listener:
                 with self.assertRaises(OSError):
-                    await conn.forward_local_port(None, listener.get_port(),
+                    await conn.forward_local_port('', listener.get_port(),
                                                   '', 7)
 
     @unittest.skipIf(sys.platform == 'win32',
                      'skip dual-stack tests on Windows')
     @asynctest
     async def test_forward_bind_error_ipv6(self):
         """Test error binding a local forwarding port"""
 
         async with self.connect() as conn:
             async with conn.forward_local_port('::', 0, '', 7) as listener:
                 with self.assertRaises(OSError):
-                    await conn.forward_local_port(None, listener.get_port(),
+                    await conn.forward_local_port('', listener.get_port(),
                                                   '', 7)
 
     @asynctest
     async def test_forward_connect_error(self):
         """Test error connecting a local forwarding port"""
 
         async with self.connect() as conn:
             async with conn.forward_local_port('', 0, '', 1) as listener:
                 listen_port = listener.get_port()
 
-                reader, writer = await asyncio.open_connection(None,
+                reader, writer = await asyncio.open_connection('127.0.0.1',
                                                                listen_port)
-
                 self.assertEqual((await reader.read()), b'')
 
                 writer.close()
                 await maybe_wait_closed(writer)
 
     @asynctest
     async def test_forward_immediate_eof(self):
         """Test getting EOF before forwarded connection is fully open"""
 
         async with self.connect() as conn:
             async with conn.forward_local_port('', 0, '', 7) as listener:
                 listen_port = listener.get_port()
 
-                _, writer = await asyncio.open_connection(None, listen_port)
+                _, writer = await asyncio.open_connection('127.0.0.1',
+                                                          listen_port)
 
                 writer.close()
                 await maybe_wait_closed(writer)
                 await asyncio.sleep(0.1)
 
     @asynctest
     async def test_forward_remote_port(self):
@@ -997,14 +1010,26 @@
             async with self.connect() as conn:
                 pkttype, _ = await conn.make_global_request(
                     b'cancel-streamlocal-forward@openssh.com', String(b'\xff'))
 
                 self.assertEqual(pkttype, asyncssh.MSG_REQUEST_FAILURE)
 
 
+class _TestAsyncUNIXForwarding(_TestUNIXForwarding):
+    """Unit tests for AsyncSSH UNIX connection forwarding with async return"""
+
+    @classmethod
+    async def start_server(cls):
+        """Start an SSH server which supports UNIX connection forwarding"""
+
+        return await cls.create_server(
+            _UNIXAsyncConnectionServer,
+            authorized_client_keys='authorized_keys')
+
+
 class _TestSOCKSForwarding(_CheckForwarding):
     """Unit tests for AsyncSSH SOCKS dynamic port forwarding"""
 
     @classmethod
     async def start_server(cls):
         """Start an SSH server which supports TCP connection forwarding"""
 
@@ -1068,15 +1093,16 @@
     async def _check_socks(self, handler, listen_port, msg,
                            data, *args):
         """Unit test SOCKS dynamic port forwarding"""
 
         with self.subTest(msg=msg, data=data):
             data = codecs.decode(data, 'hex')
 
-            reader, writer = await asyncio.open_connection(None, listen_port)
+            reader, writer = await asyncio.open_connection('127.0.0.1',
+                                                           listen_port)
 
             try:
                 await handler(reader, writer, data, *args)
             finally:
                 writer.close()
                 await maybe_wait_closed(writer)
 
@@ -1138,20 +1164,20 @@
 
         sock = socket.socket()
         sock.bind(('', 0))
         listen_port = sock.getsockname()[1]
         sock.close()
 
         async with self.connect() as conn:
-            async with conn.forward_socks(None, listen_port):
+            async with conn.forward_socks('', listen_port):
                 pass
 
     @unittest.skipIf(sys.platform == 'win32',
                      'Avoid issue with SO_REUSEADDR on Windows')
     @asynctest
     async def test_forward_bind_error_socks(self):
         """Test error binding a local dynamic forwarding port"""
 
         async with self.connect() as conn:
-            async with conn.forward_socks(None, 0) as listener:
+            async with conn.forward_socks('', 0) as listener:
                 with self.assertRaises(OSError):
-                    await conn.forward_socks(None, listener.get_port())
+                    await conn.forward_socks('', listener.get_port())
```

### Comparing `asyncssh-2.8.1/tests/gssapi_stub.py` & `asyncssh-2.9.0/tests/gssapi_stub.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_process.py` & `asyncssh-2.9.0/tests/test_process.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2016-2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_sk.py` & `asyncssh-2.9.0/tests/test_sk.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_config.py` & `asyncssh-2.9.0/tests/test_config.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2020 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2020-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -121,15 +121,15 @@
                          'zlib@openssh.com,zlib,none')
 
         config = self._parse_config('Compression no')
         self.assertEqual(config.get_compression_algs(),
                          'none,zlib@openssh.com,zlib')
 
         config = self._parse_config('')
-        self.assertEqual(config.get_compression_algs('default'), 'default')
+        self.assertEqual(config.get_compression_algs(), ())
 
     def test_include(self):
         """Test include config option"""
 
         with open('include', 'w') as f:
             f.write('Port 2222')
```

### Comparing `asyncssh-2.8.1/tests/test_auth_keys.py` & `asyncssh-2.9.0/tests/test_auth_keys.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_mac.py` & `asyncssh-2.9.0/tests/test_mac.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2019 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_x11.py` & `asyncssh-2.9.0/tests/test_x11.py`

 * *Files 2% similar despite different names*

```diff
@@ -234,14 +234,20 @@
             elif action == 'open':
                 try:
                     result = await self._conn.create_x11_connection(None)
                 except asyncssh.ChannelOpenError:
                     result = None
 
                 stdin.channel.exit(bool(result))
+            elif action == 'invalid':
+                try:
+                    result = await self._conn.create_x11_connection(
+                        None, b'\xff')
+                except asyncssh.ChannelOpenError:
+                    pass
             elif action == 'sleep':
                 await asyncio.sleep(0.1)
             else:
                 stdin.channel.exit(255)
 
         stdin.channel.close()
         await stdin.channel.wait_closed()
@@ -592,14 +598,22 @@
         """Test opening X11 connection when forwarding was never enabled"""
 
         async with self.connect() as conn:
             result = await conn.run('open')
             self.assertEqual(result.exit_status, 0)
 
     @asynctest
+    async def test_open_invalid_unicode(self):
+        """Test opening X11 connection with invalid unicode in original host"""
+
+        async with self.connect() as conn:
+            result = await conn.run('invalid')
+            self.assertEqual(result.exit_status, None)
+
+    @asynctest
     async def test_forwarding_not_allowed(self):
         """Test an X11 request from a non-authorized user"""
 
         ckey = asyncssh.read_private_key('ckey')
         cert = ckey.generate_user_certificate(ckey, 'name', principals=['ckey'],
                                               permit_x11_forwarding=False)
```

### Comparing `asyncssh-2.8.1/tests/test_asn1.py` & `asyncssh-2.9.0/tests/test_asn1.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/tests/test_saslprep.py` & `asyncssh-2.9.0/tests/test_saslprep.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/sspi_stub.py` & `asyncssh-2.9.0/tests/sspi_stub.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/keysign_stub.py` & `asyncssh-2.9.0/tests/keysign_stub.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_stream.py` & `asyncssh-2.9.0/tests/test_stream.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_encryption.py` & `asyncssh-2.9.0/tests/test_encryption.py`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/tests/test_sftp.py` & `asyncssh-2.9.0/tests/test_sftp.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2022 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -30,30 +30,99 @@
 import sys
 import time
 import unittest
 from unittest.mock import patch
 
 import asyncssh
 
-from asyncssh import SFTPError, SFTPFailure, SFTPNoSuchFile
-from asyncssh import SFTPPermissionDenied
+from asyncssh import SFTPError, SFTPNoSuchFile, SFTPPermissionDenied
+from asyncssh import SFTPFailure, SFTPBadMessage, SFTPNoConnection
+from asyncssh import SFTPConnectionLost, SFTPOpUnsupported, SFTPInvalidHandle
+from asyncssh import SFTPNoSuchPath, SFTPFileAlreadyExists, SFTPWriteProtect
+from asyncssh import SFTPNoMedia, SFTPNoSpaceOnFilesystem, SFTPQuotaExceeded
+from asyncssh import SFTPUnknownPrincipal, SFTPLockConflict, SFTPDirNotEmpty
+from asyncssh import SFTPNotADirectory, SFTPInvalidFilename, SFTPLinkLoop
+from asyncssh import SFTPCannotDelete, SFTPInvalidParameter
+from asyncssh import SFTPFileIsADirectory, SFTPByteRangeLockConflict
+from asyncssh import SFTPByteRangeLockRefused, SFTPDeletePending
+from asyncssh import SFTPFileCorrupt, SFTPOwnerInvalid, SFTPGroupInvalid
+from asyncssh import SFTPNoMatchingByteRangeLock
 from asyncssh import SFTPAttrs, SFTPVFSAttrs, SFTPName, SFTPServer
 from asyncssh import SEEK_CUR, SEEK_END
 from asyncssh import FXP_INIT, FXP_VERSION, FXP_OPEN, FXP_READ
 from asyncssh import FXP_WRITE, FXP_STATUS, FXP_HANDLE, FXP_DATA
-from asyncssh import FILEXFER_ATTR_UNDEFINED, FX_OK
-from asyncssh import scp
+from asyncssh import FXF_WRITE, FXF_APPEND, FXF_CREAT, FXF_TRUNC
+from asyncssh import FXF_CREATE_NEW, FXF_CREATE_TRUNCATE, FXF_OPEN_EXISTING
+from asyncssh import FXF_OPEN_OR_CREATE, FXF_TRUNCATE_EXISTING
+from asyncssh import FXF_APPEND_DATA, FXF_BLOCK_READ
+from asyncssh import ACE4_READ_DATA, ACE4_WRITE_DATA, ACE4_APPEND_DATA
+from asyncssh import FXR_OVERWRITE
+from asyncssh import FXRP_STAT_IF_EXISTS, FXRP_STAT_ALWAYS
+from asyncssh import FILEXFER_ATTR_UIDGID, FILEXFER_ATTR_OWNERGROUP
+from asyncssh import FILEXFER_TYPE_REGULAR, FILEXFER_TYPE_DIRECTORY
+from asyncssh import FILEXFER_TYPE_SYMLINK, FILEXFER_TYPE_SPECIAL
+from asyncssh import FILEXFER_TYPE_UNKNOWN, FILEXFER_TYPE_SOCKET
+from asyncssh import FILEXFER_TYPE_CHAR_DEVICE, FILEXFER_TYPE_BLOCK_DEVICE
+from asyncssh import FILEXFER_TYPE_FIFO
+from asyncssh import FILEXFER_ATTR_BITS_READONLY, FILEXFER_ATTR_KNOWN_TEXT
+from asyncssh import FX_OK, scp
 
 from asyncssh.packet import SSHPacket, String, UInt32
 from asyncssh.sftp import LocalFile, SFTPHandler, SFTPServerHandler
 
 from .server import ServerTestCase
 from .util import asynctest
 
 
+def _getpwuid_error(uid):
+    """Simulate not being able to resolve user name"""
+
+    # pylint: disable=unused-argument
+
+    raise KeyError
+
+
+def _getgrgid_error(gid):
+    """Simulate not being able to resolve group name"""
+
+    # pylint: disable=unused-argument
+
+    raise KeyError
+
+
+def tuple_to_nsec(sec, nsec):
+    """Convert seconds and remainder to nanoseconds since epoch"""
+
+    return sec * 1_000_000_000 + (nsec or 0)
+
+
+def lookup_user(uid):
+    """Return the user name associated with a uid"""
+
+    try:
+        # pylint: disable=import-outside-toplevel
+        import pwd
+
+        return pwd.getpwuid(uid).pw_name
+    except ImportError: # pragma: no cover
+        return ''
+
+
+def lookup_group(gid):
+    """Return the group name associated with a gid"""
+
+    try:
+        # pylint: disable=import-outside-toplevel
+        import grp
+
+        return grp.getgrgid(gid).gr_name
+    except ImportError: # pragma: no cover
+        return ''
+
+
 def remove(files):
     """Remove files and directories"""
 
     for f in files.split():
         try:
             if os.path.isdir(f) and not os.path.islink(f):
                 shutil.rmtree(f)
@@ -74,24 +143,80 @@
         async with self.connect() as conn:
             async with conn.start_sftp_client() as sftp:
                 await func(self, sftp)
 
     return sftp_wrapper
 
 
+def sftp_test_v4(func):
+    """Decorator for running SFTPv4 tests"""
+
+    @asynctest
+    @functools.wraps(func)
+    async def sftp_wrapper(self):
+        """Run a test after opening an SFTP client"""
+
+        async with self.connect() as conn:
+            async with conn.start_sftp_client(sftp_version=4) as sftp:
+                await func(self, sftp)
+
+    return sftp_wrapper
+
+
+def sftp_test_v5(func):
+    """Decorator for running SFTPv5 tests"""
+
+    @asynctest
+    @functools.wraps(func)
+    async def sftp_wrapper(self):
+        """Run a test after opening an SFTP client"""
+
+        async with self.connect() as conn:
+            async with conn.start_sftp_client(sftp_version=5) as sftp:
+                await func(self, sftp)
+
+    return sftp_wrapper
+
+
+def sftp_test_v6(func):
+    """Decorator for running SFTPv6 tests"""
+
+    @asynctest
+    @functools.wraps(func)
+    async def sftp_wrapper(self):
+        """Run a test after opening an SFTP client"""
+
+        async with self.connect() as conn:
+            async with conn.start_sftp_client(sftp_version=6) as sftp:
+                await func(self, sftp)
+
+    return sftp_wrapper
+
+
 class _ResetFileHandleServerHandler(SFTPServerHandler):
     """Reset file handle counter on each request to test handle-in-use check"""
 
     async def recv_packet(self):
         """Reset next handle counter to test handle-in-use check"""
 
         self._next_handle = 0
         return await super().recv_packet()
 
 
+class _IncompleteMessageServerHandler(SFTPServerHandler):
+    """Close the SFTP session in the middle of sending a message"""
+
+    async def run(self):
+        """Close the session after sending an incomplete message"""
+
+        await self.recv_packet()
+        self._writer.write(UInt32(1))
+        self._writer.close()
+
+
 class _WriteCloseServerHandler(SFTPServerHandler):
     """Close the SFTP session in the middle of a write request"""
 
     async def _process_packet(self, pkttype, pktid, packet):
         """Close the session when a file close request is received"""
 
         if pkttype == FXP_WRITE:
@@ -142,14 +267,29 @@
         super().__init__(chan, 'chroot')
 
     def exit(self):
         """Clean up the changed root directory"""
 
         remove('chroot')
 
+    def stat(self, path):
+        """Get attributes of a file or directory, following symlinks"""
+
+        return SFTPAttrs.from_local(super().stat(path))
+
+
+class _OpenErrorSFTPServer(SFTPServer):
+    """Return an error on file open"""
+
+    async def open56(self, path, desired_access, flags, attrs):
+        """Return an error when opening a file"""
+
+        err = getattr(errno, path.decode('ascii'))
+        raise OSError(err, os.strerror(err))
+
 
 class _IOErrorSFTPServer(SFTPServer):
     """Return an I/O error during file writing"""
 
     async def read(self, file_obj, offset, size):
         """Return an error for reads past 64 KB in a file"""
 
@@ -192,28 +332,49 @@
 
     async def symlink(self, oldpath, newpath):
         """Return that symlinks aren't implemented"""
 
         raise NotImplementedError
 
 
+class _FileTypeSFTPServer(SFTPServer):
+    """Return a list of files of each possible file type"""
+
+    _file_types = ((FILEXFER_TYPE_REGULAR,      stat.S_IFREG),
+                   (FILEXFER_TYPE_DIRECTORY,    stat.S_IFDIR),
+                   (FILEXFER_TYPE_SYMLINK,      stat.S_IFLNK),
+                   (FILEXFER_TYPE_SPECIAL,      0xf000),
+                   (FILEXFER_TYPE_UNKNOWN,      0),
+                   (FILEXFER_TYPE_SOCKET,       stat.S_IFSOCK),
+                   (FILEXFER_TYPE_CHAR_DEVICE,  stat.S_IFCHR),
+                   (FILEXFER_TYPE_BLOCK_DEVICE, stat.S_IFBLK),
+                   (FILEXFER_TYPE_FIFO,         stat.S_IFIFO))
+
+    def listdir(self, path):
+        """List the contents of a directory"""
+
+        return [SFTPName(str(filetype).encode('ascii'),
+                         attrs=SFTPAttrs(permissions=mode))
+                for filetype, mode in self._file_types]
+
+
 class _LongnameSFTPServer(SFTPServer):
     """Return a fixed set of files in response to a listdir request"""
 
     def listdir(self, path):
         """List the contents of a directory"""
 
         return list((b'.',
                      b'..',
                      SFTPName(b'.file'),
                      SFTPName(b'file1'),
-                     SFTPName(b'file2', '', SFTPAttrs(permissions=0, nlink=1,
-                                                      uid=0, gid=0, size=0,
-                                                      mtime=0)),
-                     SFTPName(b'file3', '', SFTPAttrs(mtime=time.time())),
+                     SFTPName(b'file2', b'', SFTPAttrs(permissions=0, nlink=1,
+                                                       uid=0, gid=0,
+                                                       size=0, mtime=0)),
+                     SFTPName(b'file3', b'', SFTPAttrs(mtime=time.time())),
                      SFTPName(b'file4', 56*b' ' + b'file4')))
 
     def lstat(self, path):
         """Get attributes of a file, directory, or symlink"""
 
         return SFTPAttrs.from_local(super().lstat(path))
 
@@ -253,24 +414,26 @@
     """Simulate file ownership changes"""
 
     _ownership = {}
 
     def setstat(self, path, attrs):
         """Set attributes of a file or directory"""
 
-        self._ownership[self.map_path(path)] = (attrs.uid, attrs.gid)
+        self._ownership[self.map_path(path)] = \
+            (attrs.uid, attrs.gid, attrs.owner, attrs.group)
 
     def stat(self, path):
         """Get attributes of a file or directory, following symlinks"""
 
         path = self.map_path(path)
         attrs = SFTPAttrs.from_local(os.stat(path))
 
         if path in self._ownership: # pragma: no branch
-            attrs.uid, attrs.gid = self._ownership[path]
+            attrs.uid, attrs.gid, attrs.owner, attrs.group = \
+                self._ownership[path]
 
         return attrs
 
 
 class _SymlinkSFTPServer(SFTPServer):
     """Implement symlink with non-standard argument order"""
 
@@ -291,14 +454,19 @@
             return SFTPAttrs.from_local(super().stat(path))
         except OSError as exc:
             if exc.errno == errno.EACCES:
                 raise SFTPPermissionDenied(exc.strerror) from None
             else:
                 raise SFTPError(99, exc.strerror) from None
 
+    async def fstat(self, file_obj):
+        """Get attributes of an open file"""
+
+        return SFTPAttrs.from_local(super().fstat(file_obj))
+
 
 class _AsyncSFTPServer(SFTPServer):
     """Implement all SFTP callbacks as async methods"""
 
     # pylint: disable=useless-super-delegation
 
     async def format_longname(self, name):
@@ -407,14 +575,24 @@
         return super().fstatvfs(file_obj)
 
     async def link(self, oldpath, newpath):
         """Create a hard link"""
 
         super().link(oldpath, newpath)
 
+    async def lock(self, file_obj, offset, length, flags):
+        """Acquire a byte range lock on an open file"""
+
+        super().lock(file_obj, offset, length, flags)
+
+    async def unlock(self, file_obj, offset, length):
+        """Release a byte range lock on an open file"""
+
+        super().unlock(file_obj, offset, length)
+
     async def fsync(self, file_obj):
         """Force file data to be written to disk"""
 
         super().fsync(file_obj)
 
 
 class _CheckSFTP(ServerTestCase):
@@ -482,34 +660,62 @@
         self.assertEqual(sftp_stat.size, local_stat.st_size)
         self.assertEqual(sftp_stat.uid, local_stat.st_uid)
         self.assertEqual(sftp_stat.gid, local_stat.st_gid)
         self.assertEqual(sftp_stat.permissions, local_stat.st_mode)
         self.assertEqual(sftp_stat.atime, int(local_stat.st_atime))
         self.assertEqual(sftp_stat.mtime, int(local_stat.st_mtime))
 
+    def _check_stat_v4(self, sftp_stat, local_stat):
+        """Check if file attributes are equal"""
+
+        self.assertEqual(sftp_stat.size, local_stat.st_size)
+
+        if sys.platform != 'win32': # pragma: no branch
+            self.assertEqual(sftp_stat.owner, lookup_user(local_stat.st_uid))
+            self.assertEqual(sftp_stat.group, lookup_group(local_stat.st_gid))
+
+        self.assertEqual(sftp_stat.permissions,
+                         stat.S_IMODE(local_stat.st_mode))
+        self.assertEqual(tuple_to_nsec(sftp_stat.atime, sftp_stat.atime_ns),
+                         local_stat.st_atime_ns)
+        self.assertEqual(tuple_to_nsec(sftp_stat.mtime, sftp_stat.mtime_ns),
+                         local_stat.st_mtime_ns)
+
     def _check_link(self, link, target):
         """Check if a symlink points to the right target"""
 
         self.assertEqual(os.readlink(link), target)
 
 
 class _TestSFTP(_CheckSFTP):
     """Unit tests for AsyncSSH SFTP client and server"""
 
-    # pylint: disable=too-many-public-methods
-
     @classmethod
     async def start_server(cls):
         """Start an SFTP server for the tests to use"""
 
-        return await cls.create_server(sftp_factory=True)
+        return await cls.create_server(sftp_factory=True, sftp_version=6)
 
     @sftp_test
     async def _dummy_sftp_client(self, sftp):
-        """Test starting a new SFTP client session and immediately exiting"""
+        """Test starting a new SFTPv3 client session and immediately exiting"""
+
+        self.assertEqual(sftp.version, 3)
+
+    @sftp_test_v5
+    async def _dummy_sftp_client_v5(self, sftp):
+        """Test starting a new SFTPv5 client session and immediately exiting"""
+
+        self.assertEqual(sftp.version, 5)
+
+    @sftp_test_v6
+    async def _dummy_sftp_client_v6(self, sftp):
+        """Test starting a new SFTPv6 client session and immediately exiting"""
+
+        self.assertEqual(sftp.version, 6)
 
     @sftp_test
     async def test_copy(self, sftp):
         """Test copying a file over SFTP"""
 
         for method in ('get', 'put', 'copy'):
             for src in ('src', b'src', Path('src')):
@@ -626,27 +832,40 @@
 
     @sftp_test
     async def test_copy_invalid_name(self, sftp):
         """Test copying a file with an invalid name over SFTP"""
 
         for method in ('get', 'put', 'copy', 'mget', 'mput', 'mcopy'):
             with self.subTest(method=method):
-                with self.assertRaises((FileNotFoundError, SFTPError,
-                                        UnicodeDecodeError)):
+                with self.assertRaises((FileNotFoundError, SFTPNoSuchFile,
+                                        SFTPFailure, UnicodeDecodeError)):
                     await getattr(sftp, method)(b'\xff')
 
     @sftp_test
     async def test_copy_directory_no_recurse(self, sftp):
         """Test copying a directory over SFTP without recurse option"""
 
         for method in ('get', 'put', 'copy', 'mget', 'mput', 'mcopy'):
             with self.subTest(method=method):
                 try:
                     os.mkdir('dir')
-                    with self.assertRaises(SFTPError):
+                    with self.assertRaises(SFTPFailure):
+                        await getattr(sftp, method)('dir')
+                finally:
+                    remove('dir')
+
+    @sftp_test_v6
+    async def test_copy_directory_no_recurse_v6(self, sftp):
+        """Test copying a directory over SFTPv6 without recurse option"""
+
+        for method in ('get', 'put', 'copy', 'mget', 'mput', 'mcopy'):
+            with self.subTest(method=method):
+                try:
+                    os.mkdir('dir')
+                    with self.assertRaises(SFTPFileIsADirectory):
                         await getattr(sftp, method)('dir')
                 finally:
                     remove('dir')
 
     @sftp_test
     async def test_multiple_copy(self, sftp):
         """Test copying multiple files over SFTP"""
@@ -663,26 +882,86 @@
                                                     'dst')
 
                         self._check_file('src1', 'dst/src1')
                         self._check_file('src2', 'dst/src2')
                     finally:
                         remove('src1 src2 dst')
 
+    @sftp_test_v4
+    async def test_multiple_copy_v4(self, sftp):
+        """Test copying multiple files over SFTPv4"""
+
+        for method in ('get', 'put', 'copy'):
+            for seq in (list, tuple):
+                with self.subTest(method=method):
+                    try:
+                        self._create_file('src1', 'xxx')
+                        self._create_file('src2', 'yyy')
+                        os.mkdir('dst')
+
+                        await getattr(sftp, method)(seq(('src1', 'src2')),
+                                                    'dst')
+
+                        self._check_file('src1', 'dst/src1')
+                        self._check_file('src2', 'dst/src2')
+                    finally:
+                        remove('src1 src2 dst')
+
+    @sftp_test_v5
+    async def test_multiple_copy_v5(self, sftp):
+        """Test copying multiple files over SFTPv5"""
+
+        for method in ('get', 'put', 'copy'):
+            for seq in (list, tuple):
+                with self.subTest(method=method):
+                    try:
+                        self._create_file('src1', 'xxx')
+                        self._create_file('src2', 'yyy')
+                        os.mkdir('dst')
+
+                        await getattr(sftp, method)(seq(('src1', 'src2')),
+                                                    'dst')
+
+                        self._check_file('src1', 'dst/src1')
+                        self._check_file('src2', 'dst/src2')
+                    finally:
+                        remove('src1 src2 dst')
+
+    @sftp_test_v6
+    async def test_multiple_copy_v6(self, sftp):
+        """Test copying multiple files over SFTPv6"""
+
+        for method in ('get', 'put', 'copy'):
+            for seq in (list, tuple):
+                with self.subTest(method=method):
+                    try:
+                        self._create_file('src1', 'xxx')
+                        self._create_file('src2', 'yyy')
+                        os.mkdir('dst')
+
+                        await getattr(sftp, method)(seq(('src1', 'src2')),
+                                                    'dst')
+
+                        self._check_file('src1', 'dst/src1')
+                        self._check_file('src2', 'dst/src2')
+                    finally:
+                        remove('src1 src2 dst')
+
     @sftp_test
     async def test_multiple_copy_glob(self, sftp):
         """Test copying multiple files via glob over SFTP"""
 
         for method in ('mget', 'mput', 'mcopy'):
             with self.subTest(method=method):
                 try:
                     self._create_file('src1', 'xxx')
                     self._create_file('src2', 'yyy')
                     os.mkdir('dst')
 
-                    await getattr(sftp, method)('src*', 'dst')
+                    await getattr(sftp, method)(['', 'src*'], 'dst')
 
                     self._check_file('src1', 'dst/src1')
                     self._check_file('src2', 'dst/src2')
                 finally:
                     remove('src1 src2 dst')
 
     @sftp_test
@@ -724,18 +1003,34 @@
     @sftp_test
     async def test_multiple_copy_target_not_dir(self, sftp):
         """Test copying multiple files over SFTP with non-directory target"""
 
         for method in ('mget', 'mput', 'mcopy'):
             with self.subTest(method=method):
                 try:
-                    self._create_file('src')
+                    self._create_file('src1')
+                    self._create_file('src2')
 
-                    with self.assertRaises(SFTPError):
-                        await getattr(sftp, method)('src', 'dst')
+                    with self.assertRaises(SFTPFailure):
+                        await getattr(sftp, method)('src*', 'dst')
+                finally:
+                    remove('src')
+
+    @sftp_test_v6
+    async def test_multiple_copy_target_not_dir_v6(self, sftp):
+        """Test copying multiple files over SFTP with non-directory target"""
+
+        for method in ('mget', 'mput', 'mcopy'):
+            with self.subTest(method=method):
+                try:
+                    self._create_file('src1')
+                    self._create_file('src2')
+
+                    with self.assertRaises(SFTPNotADirectory):
+                        await getattr(sftp, method)('src*', 'dst')
                 finally:
                     remove('src')
 
     @sftp_test
     async def test_multiple_copy_error_handler(self, sftp):
         """Test copying multiple files over SFTP with error handler"""
 
@@ -813,15 +1108,22 @@
         finally:
             remove('file1 filedir')
 
     @sftp_test
     async def test_glob_error(self, sftp):
         """Test a glob pattern match error over SFTP"""
 
-        with self.assertRaises(SFTPError):
+        with self.assertRaises(SFTPNoSuchFile):
+            await sftp.glob('file*')
+
+    @sftp_test_v4
+    async def test_glob_error_v4(self, sftp):
+        """Test a glob pattern match error over SFTP"""
+
+        with self.assertRaises(SFTPNoSuchPath):
             await sftp.glob('file*')
 
     @sftp_test
     async def test_glob_error_handler(self, sftp):
         """Test a glob pattern match with error handler over SFTP"""
 
         def err_handler(exc):
@@ -856,16 +1158,16 @@
 
             if self._symlink_supported: # pragma: no branch
                 self._check_stat((await sftp.stat('dirlink')),
                                  os.stat('dir'))
                 self._check_stat((await sftp.stat('filelink')),
                                  os.stat('file'))
 
-                with self.assertRaises(SFTPError):
-                    await sftp.stat('badlink') # pragma: no branch
+                with self.assertRaises(SFTPNoSuchFile):
+                    await sftp.stat('badlink')
 
             self.assertTrue((await sftp.isdir('dir')))
             self.assertFalse((await sftp.isdir('file')))
 
             if self._symlink_supported: # pragma: no branch
                 self.assertFalse((await sftp.isdir('badlink')))
                 self.assertTrue((await sftp.isdir('dirlink')))
@@ -898,22 +1200,78 @@
 
         try:
             os.symlink('file', 'link')
             self._check_stat((await sftp.lstat('link')), os.lstat('link'))
         finally:
             remove('link')
 
+    @sftp_test_v4
+    async def test_lstat_v4(self, sftp):
+        """Test getting attributes on a link with SFTPv4"""
+
+        if not self._symlink_supported: # pragma: no cover
+            raise unittest.SkipTest('symlink not available')
+
+        try:
+            os.symlink('file', 'link')
+            self._check_stat_v4((await sftp.lstat('link')), os.lstat('link'))
+        finally:
+            remove('link')
+
     @sftp_test
     async def test_setstat(self, sftp):
         """Test setting attributes on a file"""
 
         try:
             self._create_file('file')
             await sftp.setstat('file', SFTPAttrs(permissions=0o666))
             self.assertEqual(stat.S_IMODE(os.stat('file').st_mode), 0o666)
+
+            with self.assertRaises(ValueError):
+                await sftp.setstat('file', SFTPAttrs(owner='root',
+                                                     group='wheel'))
+        finally:
+            remove('file')
+
+    @sftp_test_v4
+    async def test_setstat_v4(self, sftp):
+        """Test setting attributes on a file"""
+
+        try:
+            self._create_file('file')
+
+            await sftp.setstat('file', SFTPAttrs(atime=1))
+
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 1)
+
+            await sftp.setstat('file', SFTPAttrs(mtime=2))
+
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_mtime, 2)
+        finally:
+            remove('file')
+
+    @unittest.skipIf(sys.platform == 'win32', 'skip uid/gid tests on Windows')
+    @sftp_test_v6
+    async def test_setstat_invalid_owner_group_v6(self, sftp):
+        """Test setting invalid owner/group on a file"""
+
+        try:
+            self._create_file('file')
+
+            with patch('pwd.getpwuid', _getpwuid_error):
+                with self.assertRaises(SFTPOwnerInvalid):
+                    await sftp.setstat('file', SFTPAttrs(owner='xxx',
+                                                         group='0'))
+
+            with patch('grp.getgrgid', _getgrgid_error):
+                with self.assertRaises(SFTPGroupInvalid):
+                    await sftp.setstat('file', SFTPAttrs(owner='0',
+                                                         group='yyy'))
         finally:
             remove('file')
 
     @unittest.skipIf(sys.platform == 'win32', 'skip statvfs tests on Windows')
     @sftp_test
     async def test_statvfs(self, sftp):
         """Test getting attributes on a filesystem
@@ -952,21 +1310,72 @@
            _TestSFTPChown class for a more complete test, but this is
            left in for code coverage purposes.
 
         """
 
         try:
             self._create_file('file')
-            attrs = os.stat('file')
+            stat_result = os.stat('file')
+
+            await sftp.chown('file', stat_result.st_uid, stat_result.st_gid)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+        finally:
+            remove('file')
+
+    @unittest.skipIf(sys.platform == 'win32', 'skip chown tests on Windows')
+    @sftp_test_v4
+    async def test_chown_v4(self, sftp):
+        """Test changing ownership of a file
+
+           We can't change to a different user/group here if we're not
+           root, so just change to the same user/group. See the separate
+           _TestSFTPChown class for a more complete test, but this is
+           left in for code coverage purposes.
+
+        """
+
+        try:
+            self._create_file('file')
+            stat_result = os.stat('file')
+
+            owner = lookup_user(stat_result.st_uid)
+            group = lookup_group(stat_result.st_gid)
+
+            await sftp.chown('file', owner, group)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+
+            await sftp.chown('file', str(stat_result.st_uid), group)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+
+            await sftp.chown('file', owner, str(stat_result.st_gid))
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+
+            await sftp.chown('file', str(stat_result.st_uid), group)
 
-            await sftp.chown('file', attrs.st_uid, attrs.st_gid)
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
 
-            new_attrs = os.stat('file')
-            self.assertEqual(new_attrs.st_uid, attrs.st_uid)
-            self.assertEqual(new_attrs.st_gid, attrs.st_gid)
+            await sftp.chown('file', owner, str(stat_result.st_gid))
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
         finally:
             remove('file')
 
     @unittest.skipIf(sys.platform == 'win32', 'skip chmod tests on Windows')
     @sftp_test
     async def test_chmod(self, sftp):
         """Test changing permissions on a file"""
@@ -984,34 +1393,69 @@
 
         try:
             self._create_file('file')
 
             await sftp.utime('file')
             await sftp.utime('file', (1, 2))
 
-            attrs = os.stat('file')
-            self.assertEqual(attrs.st_atime, 1)
-            self.assertEqual(attrs.st_mtime, 2)
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 1)
+            self.assertEqual(stat_result.st_mtime, 2)
             self.assertEqual((await sftp.getatime('file')), 1)
             self.assertEqual((await sftp.getmtime('file')), 2)
         finally:
             remove('file')
 
+    @sftp_test_v4
+    async def test_utime_v4(self, sftp):
+        """Test changing access and modify times on a file with SFTPv4"""
+
+        try:
+            self._create_file('file')
+
+            await sftp.utime('file')
+            await sftp.utime('file', (1.0, 2.25))
+
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 1.0)
+            self.assertEqual(stat_result.st_atime_ns, 1000000000)
+            self.assertEqual(stat_result.st_mtime, 2.25)
+            self.assertEqual(stat_result.st_mtime_ns, 2250000000)
+            self.assertEqual((await sftp.getatime('file')), 1.0)
+            self.assertEqual((await sftp.getatime_ns('file')), 1000000000)
+            self.assertIsNotNone((await sftp.getcrtime('file')))
+            self.assertIsNotNone((await sftp.getcrtime_ns('file')))
+            self.assertEqual((await sftp.getmtime('file')), 2.25)
+            self.assertEqual((await sftp.getmtime_ns('file')), 2250000000)
+
+            await sftp.utime('file', ns=(3500000000, 4750000000))
+
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 3.5)
+            self.assertEqual(stat_result.st_atime_ns, 3500000000)
+            self.assertEqual(stat_result.st_mtime, 4.75)
+            self.assertEqual(stat_result.st_mtime_ns, 4750000000)
+            self.assertEqual((await sftp.getatime('file')), 3.5)
+            self.assertEqual((await sftp.getatime_ns('file')), 3500000000)
+            self.assertIsNotNone((await sftp.getcrtime('file')))
+            self.assertIsNotNone((await sftp.getcrtime_ns('file')))
+            self.assertEqual((await sftp.getmtime('file')), 4.75)
+            self.assertEqual((await sftp.getmtime_ns('file')), 4750000000)
+        finally:
+            remove('file')
+
     @sftp_test
     async def test_exists(self, sftp):
         """Test checking whether a file exists"""
 
         try:
             self._create_file('file1')
 
             self.assertTrue((await sftp.exists('file1')))
             self.assertFalse((await sftp.exists('file2')))
-
-            with self.assertRaises(SFTPError):
-                await sftp.exists(65536*'a')
         finally:
             remove('file1')
 
     @sftp_test
     async def test_lexists(self, sftp):
         """Test checking whether a link exists"""
 
@@ -1031,50 +1475,80 @@
         """Test removing a file"""
 
         try:
             self._create_file('file')
             await sftp.remove('file')
 
             with self.assertRaises(FileNotFoundError):
-                os.stat('file') # pragma: no branch
+                os.stat('file')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPNoSuchFile):
                 await sftp.remove('file')
         finally:
             remove('file')
 
     @sftp_test
     async def test_unlink(self, sftp):
         """Test unlinking a file"""
 
         try:
             self._create_file('file')
             await sftp.unlink('file')
 
             with self.assertRaises(FileNotFoundError):
-                os.stat('file') # pragma: no branch
+                os.stat('file')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPNoSuchFile):
                 await sftp.unlink('file')
         finally:
             remove('file')
 
     @sftp_test
     async def test_rename(self, sftp):
         """Test renaming a file"""
 
         try:
-            self._create_file('file1')
-            self._create_file('file2')
+            self._create_file('file1', 'xxx')
+            self._create_file('file2', 'yyy')
+
+            with self.assertRaises(SFTPFailure):
+                await sftp.rename('file1', 'file2')
+
+            await sftp.rename('file1', 'file3')
+
+            with open('file3') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+
+            await sftp.rename('file2', 'file3', FXR_OVERWRITE)
+
+            with open('file3') as localf:
+                self.assertEqual(localf.read(), 'yyy')
+        finally:
+            remove('file1 file2 file3')
+
+    @sftp_test_v6
+    async def test_rename_v6(self, sftp):
+        """Test renaming a file with SFTPv6"""
+
+        try:
+            self._create_file('file1', 'xxx')
+            self._create_file('file2', 'yyy')
 
-            with self.assertRaises(SFTPError):
-                await sftp.rename('file1', 'file2') # pragma: no branch
+            with self.assertRaises(SFTPFileAlreadyExists):
+                await sftp.rename('file1', 'file2')
 
             await sftp.rename('file1', 'file3')
-            self.assertTrue(os.path.exists('file3'))
+
+            with open('file3') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+
+            await sftp.rename('file2', 'file3', FXR_OVERWRITE)
+
+            with open('file3') as localf:
+                self.assertEqual(localf.read(), 'yyy')
         finally:
             remove('file1 file2 file3')
 
     @sftp_test
     async def test_posix_rename(self, sftp):
         """Test renaming a file that replaces a target file"""
 
@@ -1085,44 +1559,74 @@
             await sftp.posix_rename('file1', 'file2')
 
             with open('file2') as localf:
                 self.assertEqual(localf.read(), 'xxx')
         finally:
             remove('file1 file2')
 
+    @sftp_test_v6
+    async def test_posix_rename_v6(self, sftp):
+        """Test renaming a file that replaces a target file"""
+
+        try:
+            self._create_file('file1', 'xxx')
+            self._create_file('file2', 'yyy')
+
+            await sftp.posix_rename('file1', 'file2')
+
+            with open('file2') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+        finally:
+            remove('file1 file2')
+
     @sftp_test
     async def test_listdir(self, sftp):
         """Test listing files in a directory"""
 
         try:
             os.mkdir('dir')
             self._create_file('dir/file1')
             self._create_file('dir/file2')
             self.assertEqual(sorted((await sftp.listdir('dir'))),
                              ['.', '..', 'file1', 'file2'])
         finally:
             remove('dir')
 
-    @sftp_test
-    async def test_listdir_error(self, sftp):
+    @sftp_test_v4
+    async def test_listdir_v4(self, sftp):
+        """Test listing files in a directory with SFTPv4"""
+
+        try:
+            os.mkdir('dir')
+            self._create_file('dir/file1')
+            self._create_file('dir/file2')
+            self.assertEqual(sorted((await sftp.listdir('dir'))),
+                             ['.', '..', 'file1', 'file2'])
+        finally:
+            remove('dir')
+
+    @sftp_test_v4
+    async def test_listdir_error_v4(self, sftp):
         """Test error while listing contents of a directory"""
 
+        orig_readdir = asyncssh.sftp.SFTPClientHandler.readdir
+
         async def _readdir_error(self, handle):
             """Return an error on an SFTP readdir request"""
 
             # pylint: disable=unused-argument
 
-            raise SFTPFailure('I/O error')
+            return await orig_readdir(self, b'\xff\xff\xff\xff')
 
         try:
             os.mkdir('dir')
 
             with patch('asyncssh.sftp.SFTPClientHandler.readdir',
                        _readdir_error):
-                with self.assertRaises(SFTPError):
+                with self.assertRaises(SFTPInvalidHandle):
                     await sftp.listdir('dir')
         finally:
             remove('dir')
 
     @sftp_test
     async def test_mkdir(self, sftp):
         """Test creating a directory"""
@@ -1142,14 +1646,40 @@
             await sftp.rmdir('dir')
 
             with self.assertRaises(FileNotFoundError):
                 os.stat('dir')
         finally:
             remove('dir')
 
+    @sftp_test_v6
+    async def test_rmdir_not_empty_v6(self, sftp):
+        """Test rmdir on a non-empty directory"""
+
+        try:
+            os.mkdir('dir')
+            self._create_file('dir/file')
+
+            with self.assertRaises(SFTPDirNotEmpty):
+                await sftp.rmdir('dir')
+        finally:
+            remove('dir')
+
+    @sftp_test_v6
+    async def test_open_file_dir_v6(self, sftp):
+        """Test open on a directory"""
+
+        try:
+            os.mkdir('dir')
+
+            with self.assertRaises((SFTPPermissionDenied,
+                                    SFTPFileIsADirectory)):
+                await sftp.open('dir')
+        finally:
+            remove('dir')
+
     @sftp_test
     async def test_rmtree(self, sftp):
         """Test removing a directory tree"""
 
         try:
             os.mkdir('dir')
             os.mkdir('dir/dir1')
@@ -1279,81 +1809,138 @@
         try:
             os.symlink('/file', 'link')
             self.assertEqual((await sftp.readlink('link')), '/file')
             self.assertEqual((await sftp.readlink(b'link')), b'/file')
         finally:
             remove('link')
 
+    @sftp_test_v6
+    async def test_readlink_v6(self, sftp):
+        """Test reading a symlink with SFTPv6"""
+
+        if not self._symlink_supported: # pragma: no cover
+            raise unittest.SkipTest('symlink not available')
+
+        try:
+            os.symlink('/file', 'link')
+            self.assertEqual((await sftp.readlink('link')), '/file')
+            self.assertEqual((await sftp.readlink(b'link')), b'/file')
+        finally:
+            remove('link')
+
     @sftp_test
     async def test_readlink_decode_error(self, sftp):
         """Test unicode decode error while reading a symlink"""
 
         async def _readlink_error(self, path):
             """Return invalid unicode on an SFTP readlink request"""
 
             # pylint: disable=unused-argument
 
-            return [SFTPName(b'\xff')]
+            return [SFTPName(b'\xff')], False
 
         with patch('asyncssh.sftp.SFTPClientHandler.readlink',
                    _readlink_error):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.readlink('link')
 
     @sftp_test
     async def test_symlink(self, sftp):
         """Test creating a symlink"""
 
         if not self._symlink_supported: # pragma: no cover
             raise unittest.SkipTest('symlink not available')
 
         try:
             await sftp.symlink('file', 'link')
             self._check_link('link', 'file')
+
+            with self.assertRaises(SFTPFailure):
+                await sftp.symlink('file', 'link')
+        finally:
+            remove('file link')
+
+    @sftp_test_v4
+    async def test_symlink_v4(self, sftp):
+        """Test creating a symlink with SFTPv4"""
+
+        if not self._symlink_supported: # pragma: no cover
+            raise unittest.SkipTest('symlink not available')
+
+        try:
+            await sftp.symlink('file', 'link')
+            self._check_link('link', 'file')
+
+            with self.assertRaises(SFTPFileAlreadyExists):
+                await sftp.symlink('file', 'link')
+        finally:
+            remove('file link')
+
+    @sftp_test_v6
+    async def test_symlink_v6(self, sftp):
+        """Test creating a symlink with SFTPv6"""
+
+        try:
+            await sftp.symlink('file', 'link')
+            self._check_link('link', 'file')
+
+            with self.assertRaises(SFTPFileAlreadyExists):
+                await sftp.symlink('file', 'link')
         finally:
             remove('file link')
 
     @asynctest
     async def test_symlink_encode_error(self):
         """Test creating a unicode symlink with no path encoding set"""
 
         if not self._symlink_supported: # pragma: no cover
             raise unittest.SkipTest('symlink not available')
 
         async with self.connect() as conn:
             async with conn.start_sftp_client(path_encoding=None) as sftp:
-                with self.assertRaises(SFTPError):
+                with self.assertRaises(SFTPBadMessage):
                     await sftp.symlink('file', 'link')
 
     @asynctest
     async def test_nonstandard_symlink_client(self):
         """Test creating a symlink with opposite argument order"""
 
         if not self._symlink_supported: # pragma: no cover
             raise unittest.SkipTest('symlink not available')
 
         try:
             async with self.connect(client_version='OpenSSH') as conn:
                 async with conn.start_sftp_client() as sftp:
                     await sftp.symlink('link', 'file')
-                    self._check_link('link', 'file') # pragma: no branch
+                    self._check_link('link', 'file')
         finally:
             remove('file link')
 
     @sftp_test
     async def test_link(self, sftp):
         """Test creating a hard link"""
 
         try:
             self._create_file('file1')
             await sftp.link('file1', 'file2')
             self._check_file('file1', 'file2')
         finally:
             remove('file1 file2')
 
+    @sftp_test_v6
+    async def test_link_v6(self, sftp):
+        """Test creating a hard link with SFTPv6"""
+
+        try:
+            self._create_file('file1')
+            await sftp.link('file1', 'file2')
+            self._check_file('file1', 'file2')
+        finally:
+            remove('file1 file2')
+
     @sftp_test
     async def test_open_read(self, sftp):
         """Test reading data from a file"""
 
         f = None
 
         try:
@@ -1460,15 +2047,15 @@
     @sftp_test
     async def test_open_read_nonexistent(self, sftp):
         """Test reading data from a nonexistent file"""
 
         f = None
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPNoSuchFile):
                 f = await sftp.open('file')
         finally:
             if f: # pragma: no cover
                 await f.close()
 
     @unittest.skipIf(sys.platform == 'win32',
                      'skip permission tests on Windows')
@@ -1477,15 +2064,15 @@
         """Test reading data from a file with no read permission"""
 
         f = None
 
         try:
             self._create_file('file', mode=0)
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPPermissionDenied):
                 f = await sftp.open('file')
         finally:
             if f: # pragma: no cover
                 await f.close()
 
             remove('file')
 
@@ -1523,14 +2110,52 @@
                 self.assertEqual(localf.read(), b'xxx')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open_write_v6(self, sftp):
+        """Test writing bytes to a file with SFTPv6 open"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'wb')
+            await f.write('xxx')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_open56_write_v6(self, sftp):
+        """Test writing bytes to a file with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            f = await sftp.open56('file', ACE4_WRITE_DATA, FXF_CREATE_TRUNCATE)
+            await f.write('xxx')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_truncate(self, sftp):
         """Test truncating a file at open time"""
 
         f = None
 
         try:
@@ -1544,14 +2169,57 @@
                 self.assertEqual(localf.read(), 'zzz')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open_truncate_v6(self, sftp):
+        """Test truncating a file at open time with SFTPv6 open"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxxyyy')
+
+            f = await sftp.open('file', FXF_WRITE | FXF_TRUNC)
+            await f.write('zzz')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'zzz')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_open56_truncate_v6(self, sftp):
+        """Test truncating a file at open time with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxxyyy')
+
+            f = await sftp.open56('file', ACE4_WRITE_DATA,
+                                  FXF_TRUNCATE_EXISTING)
+            await f.write('zzz')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'zzz')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_append(self, sftp):
         """Test appending data to an existing file"""
 
         f = None
 
         try:
@@ -1566,53 +2234,177 @@
                 self.assertEqual(localf.read(), 'xxxyyy')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open_append_v6(self, sftp):
+        """Test appending data to an existing file with SFTPv6 open"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxx')
+
+            f = await sftp.open('file', FXF_WRITE | FXF_APPEND)
+            await f.write('yyy')
+            self.assertEqual((await f.read()), '')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxxyyy')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_open56_append_v6(self, sftp):
+        """Test appending data to an existing file with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxx')
+
+            f = await sftp.open56('file', ACE4_READ_DATA | ACE4_WRITE_DATA |
+                                  ACE4_APPEND_DATA, FXF_OPEN_EXISTING |
+                                  FXF_APPEND_DATA)
+            await f.write('yyy')
+            self.assertEqual((await f.read()), '')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxxyyy')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_exclusive_create(self, sftp):
         """Test creating a new file"""
 
         f = None
 
         try:
             f = await sftp.open('file', 'x')
             await f.write('xxx')
             await f.close()
 
             with open('file') as localf:
-                self.assertEqual(localf.read(), 'xxx') # pragma: no branch
+                self.assertEqual(localf.read(), 'xxx')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 f = await sftp.open('file', 'x')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open_exclusive_create_v6(self, sftp):
+        """Test creating a new file with SFTPv6 open"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'x')
+            await f.write('xxx')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+
+            with self.assertRaises(SFTPFileAlreadyExists):
+                f = await sftp.open('file', 'x')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_open56_exclusive_create_v6(self, sftp):
+        """Test creating a new file with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            f = await sftp.open56('file', ACE4_WRITE_DATA, FXF_CREATE_NEW)
+            await f.write('xxx')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxx')
+
+            with self.assertRaises(SFTPFileAlreadyExists):
+                f = await sftp.open56('file', ACE4_WRITE_DATA, FXF_CREATE_NEW)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_exclusive_create_existing(self, sftp):
         """Test exclusive create of an existing file"""
 
         f = None
 
         try:
             self._create_file('file')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
+                f = await sftp.open('file', 'x')
+        finally:
+            if f: # pragma: no cover
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v4
+    async def test_open_exclusive_create_existing_v4(self, sftp):
+        """Test exclusive create of an existing file with SFTPv4"""
+
+        f = None
+
+        try:
+            self._create_file('file')
+
+            with self.assertRaises(SFTPFileAlreadyExists):
                 f = await sftp.open('file', 'x')
         finally:
             if f: # pragma: no cover
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open56_exclusive_create_existing_v6(self, sftp):
+        """Test exclusive create of an existing file with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            self._create_file('file')
+
+            with self.assertRaises(SFTPFileAlreadyExists):
+                f = await sftp.open56('file', ACE4_WRITE_DATA, FXF_CREATE_NEW)
+        finally:
+            if f: # pragma: no cover
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_overwrite(self, sftp):
         """Test overwriting part of an existing file"""
 
         f = None
 
         try:
@@ -1626,14 +2418,35 @@
                 self.assertEqual(localf.read(), 'zzzyyy')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open56_overwrite_v6(self, sftp):
+        """Test overwriting part of an existing file with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxxyyy')
+
+            f = await sftp.open56('file', ACE4_WRITE_DATA, FXF_OPEN_EXISTING)
+            await f.write('zzz')
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'zzzyyy')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_overwrite_offset_size(self, sftp):
         """Test writing data at a specific offset"""
 
         f = None
 
         try:
@@ -1647,27 +2460,87 @@
                 self.assertEqual(localf.read(), 'xxxzzyyy')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v6
+    async def test_open_overwrite_offset_size_v6(self, sftp):
+        """Test writing data at a specific offset with SFTPv6 open"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxxxyyyy')
+
+            f = await sftp.open('file', FXF_WRITE | FXF_CREAT)
+            await f.write('zz', 3)
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxxzzyyy')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_open56_overwrite_offset_size_v6(self, sftp):
+        """Test writing data at a specific offset with SFTPv6 open56"""
+
+        f = None
+
+        try:
+            self._create_file('file', 'xxxxyyyy')
+
+            f = await sftp.open56('file', ACE4_WRITE_DATA, FXF_OPEN_OR_CREATE)
+            await f.write('zz', 3)
+            await f.close()
+
+            with open('file') as localf:
+                self.assertEqual(localf.read(), 'xxxzzyyy')
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_open_overwrite_nonexistent(self, sftp):
         """Test overwriting a nonexistent file"""
 
         f = None
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPNoSuchFile):
                 f = await sftp.open('file', 'r+')
         finally:
             if f: # pragma: no cover
                 await f.close()
 
+    @sftp_test_v6
+    async def test_open_link_loop_v6(self, sftp):
+        """Test opening a symlink which is a loop"""
+
+        f = None
+
+        try:
+            os.symlink('link1', 'link2')
+            os.symlink('link2', 'link1')
+
+            with self.assertRaises((SFTPInvalidParameter, SFTPLinkLoop)):
+                f = await sftp.open('link1')
+        finally:
+            if f: # pragma: no cover
+                await f.close()
+
+            remove('link1 link2')
+
     @sftp_test
     async def test_file_seek(self, sftp):
         """Test seeking within a file"""
 
         f = None
 
         try:
@@ -1685,14 +2558,20 @@
             self.assertEqual((await f.read(1)), '')
 
             with self.assertRaises(ValueError):
                 await f.seek(0, -1)
 
             await f.close()
 
+            f = await sftp.open('file', 'a+')
+            await f.seek(-4, SEEK_CUR)
+            self.assertEqual((await f.read()), 'zyyy')
+
+            await f.close()
+
             with open('file') as localf:
                 self.assertEqual(localf.read(), 'xxxzzyyy')
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
@@ -1700,45 +2579,159 @@
     @sftp_test
     async def test_file_stat(self, sftp):
         """Test getting attributes on an open file"""
 
         f = None
 
         try:
-            self._create_file('file')
-
-            f = await sftp.open('file')
+            f = await sftp.open('file', 'w')
             self._check_stat((await f.stat()), os.stat('file'))
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @sftp_test_v4
+    async def test_file_stat_v4(self, sftp):
+        """Test getting attributes on an open file with SFTPv4"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+            self._check_stat_v4((await f.stat()), os.stat('file'))
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_file_stat_v6(self, sftp):
+        """Test getting attributes on an open file with SFTPv6"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+            self._check_stat_v4((await f.stat()), os.stat('file'))
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_file_setstat(self, sftp):
         """Test setting attributes on an open file"""
 
         f = None
 
         try:
-            self._create_file('file')
-            attrs = SFTPAttrs(permissions=0o666)
+            f = await sftp.open('file', 'w')
+            await f.setstat(SFTPAttrs(permissions=0o666))
 
-            f = await sftp.open('file')
-            await f.setstat(attrs)
-            await f.close()
+            self.assertEqual(stat.S_IMODE(os.stat('file').st_mode), 0o666)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_file_setstat_v6(self, sftp):
+        """Test setting attributes on an open file with SFTPv6"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+            await f.setstat(SFTPAttrs(permissions=0o666))
 
             self.assertEqual(stat.S_IMODE(os.stat('file').st_mode), 0o666)
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
+    @unittest.skipIf(sys.platform == 'win32', 'skip chown tests on Windows')
+    @sftp_test
+    async def test_file_chown(self, sftp):
+        """Test changing ownership of an open file
+
+           We can't change to a different user/group here if we're not
+           root, so just change to the same user/group. See the separate
+           _TestSFTPChown class for a more complete test, but this is
+           left in for code coverage purposes.
+
+        """
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+            stat_result = os.stat('file')
+
+            await f.chown(stat_result.st_uid, stat_result.st_gid)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+
+            await f.chown(uid=stat_result.st_uid, gid=stat_result.st_gid)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @unittest.skipIf(sys.platform == 'win32', 'skip chown tests on Windows')
+    @sftp_test_v4
+    async def test_file_chown_v4(self, sftp):
+        """Test changing ownership of an open file
+
+           We can't change to a different user/group here if we're not
+           root, so just change to the same user/group. See the separate
+           _TestSFTPChown class for a more complete test, but this is
+           left in for code coverage purposes.
+
+        """
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+            stat_result = os.stat('file')
+
+            owner = lookup_user(stat_result.st_uid)
+            group = lookup_group(stat_result.st_gid)
+
+            await f.chown(owner, group)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+
+            await f.chown(owner=owner, group=group)
+
+            new_stat_result = os.stat('file')
+            self.assertEqual(new_stat_result.st_uid, stat_result.st_uid)
+            self.assertEqual(new_stat_result.st_gid, stat_result.st_gid)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_file_truncate(self, sftp):
         """Test truncating an open file"""
 
         f = None
 
         try:
@@ -1758,24 +2751,63 @@
     @sftp_test
     async def test_file_utime(self, sftp):
         """Test changing access and modify times on an open file"""
 
         f = None
 
         try:
-            self._create_file('file')
-
-            f = await sftp.open('file')
+            f = await sftp.open('file', 'w')
             await f.utime()
             await f.utime((1, 2))
-            await f.close()
 
-            attrs = os.stat('file')
-            self.assertEqual(attrs.st_atime, 1)
-            self.assertEqual(attrs.st_mtime, 2)
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 1)
+            self.assertEqual(stat_result.st_mtime, 2)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v4
+    async def test_file_utime_v4(self, sftp):
+        """Test changing access and modify times on an open file with SFTPv4"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+            await f.utime()
+            await f.utime((1.0, 2.25))
+
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 1.0)
+            self.assertEqual(stat_result.st_atime_ns, 1000000000)
+            self.assertEqual(stat_result.st_mtime, 2.25)
+            self.assertEqual(stat_result.st_mtime_ns, 2250000000)
+            self.assertEqual((await sftp.getatime('file')), 1.0)
+            self.assertEqual((await sftp.getatime_ns('file')), 1000000000)
+            self.assertIsNotNone((await sftp.getcrtime('file')))
+            self.assertIsNotNone((await sftp.getcrtime_ns('file')))
+            self.assertEqual((await sftp.getmtime('file')), 2.25)
+            self.assertEqual((await sftp.getmtime_ns('file')), 2250000000)
+
+            await f.utime('file', ns=(3500000000, 4750000000))
+
+            stat_result = os.stat('file')
+            self.assertEqual(stat_result.st_atime, 3.5)
+            self.assertEqual(stat_result.st_atime_ns, 3500000000)
+            self.assertEqual(stat_result.st_mtime, 4.75)
+            self.assertEqual(stat_result.st_mtime_ns, 4750000000)
+            self.assertEqual((await sftp.getatime('file')), 3.5)
+            self.assertEqual((await sftp.getatime_ns('file')), 3500000000)
+            self.assertIsNotNone((await sftp.getcrtime('file')))
+            self.assertIsNotNone((await sftp.getcrtime_ns('file')))
+            self.assertEqual((await sftp.getmtime('file')), 4.75)
+            self.assertEqual((await sftp.getmtime_ns('file')), 4750000000)
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
     @unittest.skipIf(sys.platform == 'win32', 'skip statvfs tests on Windows')
@@ -1789,25 +2821,63 @@
            coverage purposes.
 
         """
 
         f = None
 
         try:
-            self._create_file('file')
-
-            f = await sftp.open('file')
+            f = await sftp.open('file', 'w')
             self.assertIsInstance((await f.statvfs()), SFTPVFSAttrs)
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
     @sftp_test
+    async def test_file_lock(self, sftp):
+        """Test file lock against earlier version SFTP server"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+
+            with self.assertRaises(SFTPOpUnsupported):
+                await f.lock(0, 0, FXF_BLOCK_READ)
+
+            with self.assertRaises(SFTPOpUnsupported):
+                await f.unlock(0, 0)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_file_lock_v6(self, sftp):
+        """Test file lock"""
+
+        f = None
+
+        try:
+            f = await sftp.open('file', 'w')
+
+            with self.assertRaises(SFTPOpUnsupported):
+                await f.lock(0, 0, FXF_BLOCK_READ)
+
+            with self.assertRaises(SFTPOpUnsupported):
+                await f.unlock(0, 0)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test
     async def test_file_sync(self, sftp):
         """Test file sync"""
 
         f = None
 
         try:
             f = await sftp.open('file', 'w')
@@ -1824,128 +2894,175 @@
 
         sftp.exit()
         await sftp.wait_closed()
 
         f = None
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPNoConnection):
                 f = await sftp.open('file')
         finally:
             if f: # pragma: no cover
                 await f.close()
 
     @sftp_test
     async def test_cleanup_open_files(self, sftp):
         """Test cleanup of open file handles on exit"""
 
         try:
-            self._create_file('file')
-
-            await sftp.open('file')
+            await sftp.open('file', 'w')
         finally:
             sftp.exit()
             await sftp.wait_closed()
 
             remove('file')
 
     @sftp_test
     async def test_invalid_open_mode(self, sftp):
         """Test opening file with invalid mode"""
 
         with self.assertRaises(ValueError):
             await sftp.open('file', 'z')
 
     @sftp_test
+    async def test_invalid_open56(self, sftp):
+        """Test calling open56 on an earlier version SFTP server"""
+
+        with self.assertRaises(SFTPOpUnsupported):
+            await sftp.open56('file', ACE4_WRITE_DATA, FXF_OPEN_OR_CREATE)
+
+    @sftp_test_v6
+    async def test_invalid_access_flags_v6(self, sftp):
+        """Test opening file with invalid access flags with SFTPv6"""
+
+        with self.assertRaises(SFTPInvalidParameter):
+            await sftp.open56('file', 0x80000000, FXF_OPEN_OR_CREATE)
+
+    @sftp_test_v6
+    async def test_invalid_open_flags_v6(self, sftp):
+        """Test opening file with invalid open flags with SFTPv6"""
+
+        with self.assertRaises(SFTPInvalidParameter):
+            await sftp.open56('file', ACE4_WRITE_DATA, 0x80000000)
+
+    @sftp_test
     async def test_invalid_handle(self, sftp):
         """Test sending requests associated with an invalid file handle"""
 
         async def _return_invalid_handle(self, path, pflags, attrs):
             """Return an invalid file handle"""
 
             # pylint: disable=unused-argument
 
             return UInt32(0xffffffff)
 
         with patch('asyncssh.sftp.SFTPClientHandler.open',
                    _return_invalid_handle):
             f = await sftp.open('file')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.read()
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.read(1)
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.write('')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.stat()
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.setstat(SFTPAttrs())
 
-            with self.assertRaises(SFTPError):
-                await f.statvfs()
+            if sys.platform != 'win32': # pragma: no branch
+                with self.assertRaises(SFTPFailure):
+                    await f.statvfs()
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.fsync()
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await f.close()
 
+    @sftp_test_v6
+    async def test_invalid_handle_v6(self, sftp):
+        """Test sending requests associated with an invalid file handle"""
+
+        async def _return_invalid_handle(self, path, pflags, attrs):
+            """Return an invalid file handle"""
+
+            # pylint: disable=unused-argument
+
+            return UInt32(0xffffffff)
+
+        with patch('asyncssh.sftp.SFTPClientHandler.open',
+                   _return_invalid_handle):
+            f = await sftp.open('file')
+
+            with self.assertRaises(SFTPInvalidHandle):
+                await f.lock(0, 0, FXF_BLOCK_READ)
+
+            with self.assertRaises(SFTPInvalidHandle):
+                await f.unlock(0, 0)
+
     @sftp_test
     async def test_closed_file(self, sftp):
         """Test I/O operations on a closed file"""
 
         f = None
 
         try:
             self._create_file('file')
 
             async with sftp.open('file') as f:
                 # Do an explicit close to test double-close
                 await f.close()
 
             with self.assertRaises(ValueError):
-                await f.read() # pragma: no branch
+                await f.read()
+
+            with self.assertRaises(ValueError):
+                await f.write('')
+
+            with self.assertRaises(ValueError):
+                await f.seek(0)
 
             with self.assertRaises(ValueError):
-                await f.write('') # pragma: no branch
+                await f.tell()
 
             with self.assertRaises(ValueError):
-                await f.seek(0) # pragma: no branch
+                await f.stat()
 
             with self.assertRaises(ValueError):
-                await f.tell() # pragma: no branch
+                await f.setstat(SFTPAttrs())
 
             with self.assertRaises(ValueError):
-                await f.stat() # pragma: no branch
+                await f.statvfs()
 
             with self.assertRaises(ValueError):
-                await f.setstat(SFTPAttrs()) # pragma: no branch
+                await f.truncate()
 
             with self.assertRaises(ValueError):
-                await f.statvfs() # pragma: no branch
+                await f.chown(0, 0)
 
             with self.assertRaises(ValueError):
-                await f.truncate() # pragma: no branch
+                await f.chmod(0)
 
             with self.assertRaises(ValueError):
-                await f.chown(0, 0) # pragma: no branch
+                await f.utime()
 
             with self.assertRaises(ValueError):
-                await f.chmod(0) # pragma: no branch
+                await f.lock(0, 0, FXF_BLOCK_READ)
 
             with self.assertRaises(ValueError):
-                await f.utime() # pragma: no branch
+                await f.unlock(0, 0)
 
             with self.assertRaises(ValueError):
-                await f.fsync() # pragma: no branch
+                await f.fsync()
         finally:
             if f: # pragma: no branch
                 await f.close()
 
             remove('file')
 
     def test_unexpected_client_close(self):
@@ -1969,15 +3086,24 @@
 
             packet = await SFTPHandler.recv_packet(self)
             self._writer.channel.get_connection().abort()
             return packet
 
         with patch('asyncssh.sftp.SFTPServerHandler.recv_packet',
                    _unexpected_server_close):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPConnectionLost):
+                # pylint: disable=no-value-for-parameter
+                self._dummy_sftp_client()
+
+    def test_incomplete_message(self):
+        """Test session cleanup in the middle of a write request"""
+
+        with patch('asyncssh.sftp.SFTPServerHandler',
+                   _IncompleteMessageServerHandler):
+            with self.assertRaises(SFTPConnectionLost):
                 # pylint: disable=no-value-for-parameter
                 self._dummy_sftp_client()
 
     def test_immediate_client_close(self):
         """Test closing SFTP channel immediately after opening"""
 
         async def _closing_start(self):
@@ -2022,22 +3148,22 @@
 
             packet = await SFTPHandler.recv_packet(self)
             self.send_packet(FXP_VERSION, None)
             return packet
 
         with patch('asyncssh.sftp.SFTPServerHandler.recv_packet',
                    _incomplete_version_response):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 # pylint: disable=no-value-for-parameter
                 self._dummy_sftp_client()
 
     def test_nonstandard_version(self):
         """Test sending init with non-standard version"""
 
-        with patch('asyncssh.sftp._SFTP_VERSION', 4):
+        with patch('asyncssh.sftp.MIN_SFTP_VERSION', 2):
             # pylint: disable=no-value-for-parameter
             self._dummy_sftp_client()
 
     def test_non_version_response(self):
         """Test sending a non-version message in response to init"""
 
         async def _non_version_response(self):
@@ -2045,50 +3171,71 @@
 
             packet = await SFTPHandler.recv_packet(self)
             self.send_packet(FXP_STATUS, None)
             return packet
 
         with patch('asyncssh.sftp.SFTPServerHandler.recv_packet',
                    _non_version_response):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 # pylint: disable=no-value-for-parameter
                 self._dummy_sftp_client()
 
     def test_unsupported_version_response(self):
         """Test sending an unsupported version in response to init"""
 
         async def _unsupported_version_response(self):
             """Send an unsupported version in response to init"""
 
             packet = await SFTPHandler.recv_packet(self)
-            self.send_packet(FXP_VERSION, None, UInt32(4))
+            self.send_packet(FXP_VERSION, None, UInt32(99))
             return packet
 
         with patch('asyncssh.sftp.SFTPServerHandler.recv_packet',
                    _unsupported_version_response):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 # pylint: disable=no-value-for-parameter
                 self._dummy_sftp_client()
 
-    def test_unknown_extension_request(self):
-        """Test sending an unknown extension in init request"""
+    def test_extension_in_init(self):
+        """Test sending an extension in version 3 init request"""
 
-        with patch('asyncssh.sftp.SFTPClientHandler._extensions',
-                   [(b'xxx', b'1')]):
+        async def _init_extension_start(self):
+            """Send an init request with missing version"""
+
+            self.send_packet(FXP_INIT, None, UInt32(3), String(b'xxx'),
+                             String(b'1'))
+
+        with patch('asyncssh.sftp.SFTPClientHandler.start',
+                   _init_extension_start):
             # pylint: disable=no-value-for-parameter
             self._dummy_sftp_client()
 
     def test_unknown_extension_response(self):
         """Test sending an unknown extension in version response"""
 
         with patch('asyncssh.sftp.SFTPServerHandler._extensions',
                    [(b'xxx', b'1')]):
             # pylint: disable=no-value-for-parameter
             self._dummy_sftp_client()
 
+    def test_empty_extension_response_v5(self):
+        """Test sending an empty extension list in SFTPv5 version response"""
+
+        with patch('asyncssh.sftp.SFTPServerHandler._extensions', []):
+            # pylint: disable=no-value-for-parameter
+            self._dummy_sftp_client_v5()
+
+    def test_attrib_extension_response_v6(self):
+        """Test sending an attrib extension in version response"""
+
+        with patch('asyncssh.sftp.SFTPServerHandler._attrib_extensions',
+                   [b'xxx']):
+            # pylint: disable=no-value-for-parameter
+            self._dummy_sftp_client_v6()
+
     def test_close_after_init(self):
         """Test close immediately after init request at start"""
 
         async def _close_after_init_start(self):
             """Send a close immediately after init request at start"""
 
             self.send_packet(FXP_INIT, None, UInt32(3))
@@ -2154,30 +3301,30 @@
             """Send a malformed open request"""
 
             # pylint: disable=unused-argument
 
             return await self._make_request(FXP_OPEN)
 
         with patch('asyncssh.sftp.SFTPClientHandler.open', _malformed_open):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.open('file')
 
     @sftp_test
     async def test_unknown_request(self, sftp):
         """Test sending unknown request type"""
 
         async def _unknown_request(self, filename, pflags, attrs):
             """Send a request with an unknown type"""
 
             # pylint: disable=unused-argument
 
             return await self._make_request(0xff)
 
         with patch('asyncssh.sftp.SFTPClientHandler.open', _unknown_request):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPOpUnsupported):
                 await sftp.open('file')
 
     @sftp_test
     async def test_unrecognized_response_pktid(self, sftp):
         """Test sending a response with an unrecognized packet ID"""
 
         async def _unrecognized_response_pktid(self, pkttype, pktid, packet):
@@ -2186,15 +3333,15 @@
             # pylint: disable=unused-argument
 
             self.send_packet(FXP_HANDLE, 0xffffffff,
                              UInt32(0xffffffff), String(''))
 
         with patch('asyncssh.sftp.SFTPServerHandler._process_packet',
                    _unrecognized_response_pktid):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.open('file')
 
     @sftp_test
     async def test_bad_response_type(self, sftp):
         """Test sending a response with an incorrect response type"""
 
         async def _bad_response_type(self, pkttype, pktid, packet):
@@ -2202,15 +3349,15 @@
 
             # pylint: disable=unused-argument
 
             self.send_packet(FXP_DATA, pktid, UInt32(pktid), String(''))
 
         with patch('asyncssh.sftp.SFTPServerHandler._process_packet',
                    _bad_response_type):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.open('file')
 
     @sftp_test
     async def test_unexpected_ok_response(self, sftp):
         """Test sending an unexpected FX_OK response"""
 
         async def _unexpected_ok_response(self, pkttype, pktid, packet):
@@ -2219,15 +3366,15 @@
             # pylint: disable=unused-argument
 
             self.send_packet(FXP_STATUS, pktid, UInt32(pktid), UInt32(FX_OK),
                              String(''), String(''))
 
         with patch('asyncssh.sftp.SFTPServerHandler._process_packet',
                    _unexpected_ok_response):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.open('file')
 
     @sftp_test
     async def test_malformed_ok_response(self, sftp):
         """Test sending an FX_OK response containing invalid Unicode"""
 
         async def _malformed_ok_response(self, pkttype, pktid, packet):
@@ -2236,15 +3383,15 @@
             # pylint: disable=unused-argument
 
             self.send_packet(FXP_STATUS, pktid, UInt32(pktid), UInt32(FX_OK),
                              String(b'\xff'), String(''))
 
         with patch('asyncssh.sftp.SFTPServerHandler._process_packet',
                    _malformed_ok_response):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.open('file')
 
     @sftp_test
     async def test_short_ok_response(self, sftp):
         """Test sending an FX_OK response without a reason and lang"""
 
         async def _short_ok_response(self, pkttype, pktid, packet):
@@ -2263,94 +3410,344 @@
         """Test receiving malformed realpath response"""
 
         async def _malformed_realpath(self, path):
             """Return a malformed realpath response"""
 
             # pylint: disable=unused-argument
 
-            return [SFTPName(''), SFTPName('')]
+            return [SFTPName(''), SFTPName('')], False
 
         with patch('asyncssh.sftp.SFTPClientHandler.realpath',
                    _malformed_realpath):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.realpath('.')
 
     @sftp_test
     async def test_malformed_readlink_response(self, sftp):
         """Test receiving malformed readlink response"""
 
         async def _malformed_readlink(self, path):
             """Return a malformed readlink response"""
 
             # pylint: disable=unused-argument
 
-            return [SFTPName(''), SFTPName('')]
+            return [SFTPName(''), SFTPName('')], False
 
         with patch('asyncssh.sftp.SFTPClientHandler.readlink',
                    _malformed_readlink):
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await sftp.readlink('.')
 
     def test_unsupported_extensions(self):
         """Test using extensions on a server that doesn't support them"""
 
         @sftp_test
         async def _unsupported_extensions(self, sftp):
             """Try using unsupported extensions"""
 
+            f = None
+
             try:
-                self._create_file('file1')
+                self._create_file('file1', 'xxx')
+                self._create_file('file2', 'yyy')
 
-                with self.assertRaises(SFTPError):
-                    await sftp.statvfs('.') # pragma: no branch
+                with self.assertRaises(SFTPOpUnsupported):
+                    await sftp.statvfs('.')
 
                 f = await sftp.open('file1')
 
-                with self.assertRaises(SFTPError):
-                    await f.statvfs() # pragma: no branch
+                with self.assertRaises(SFTPOpUnsupported):
+                    await f.statvfs()
+
+                with self.assertRaises(SFTPOpUnsupported):
+                    await sftp.posix_rename('file1', 'file2')
 
-                with self.assertRaises(SFTPError):
-                    await sftp.posix_rename('file1', # pragma: no branch
-                                            'file2')
+                with self.assertRaises(SFTPOpUnsupported):
+                    await sftp.rename('file1', 'file2', flags=FXR_OVERWRITE)
 
-                with self.assertRaises(SFTPError):
-                    await sftp.link('file1', 'file2') # pragma: no branch
+                with self.assertRaises(SFTPOpUnsupported):
+                    await sftp.link('file1', 'file2')
 
-                with self.assertRaises(SFTPError):
+                with self.assertRaises(SFTPOpUnsupported):
                     await f.fsync()
             finally:
                 if f: # pragma: no branch
                     await f.close()
 
                 remove('file1')
 
         with patch('asyncssh.sftp.SFTPServerHandler._extensions', []):
             # pylint: disable=no-value-for-parameter
             _unsupported_extensions(self)
 
+    def test_unsupported_extensions_v6(self):
+        """Test using extensions on a server that doesn't support them"""
+
+        @sftp_test_v6
+        async def _unsupported_extensions_v6(self, sftp):
+            """Try using unsupported extensions"""
+
+            try:
+                self._create_file('file1', 'xxx')
+                self._create_file('file2', 'yyy')
+                self._create_file('file3', 'zzz')
+
+                await sftp.posix_rename('file1', 'file2')
+
+                with open('file2') as localf:
+                    self.assertEqual(localf.read(), 'xxx')
+
+                await sftp.rename('file2', 'file3', FXR_OVERWRITE)
+
+                with open('file3') as localf:
+                    self.assertEqual(localf.read(), 'xxx')
+
+                await sftp.link('file3', 'file4')
+
+                with open('file4') as localf:
+                    self.assertEqual(localf.read(), 'xxx')
+            finally:
+                remove('file1 file2 file3 file4')
+
+        with patch('asyncssh.sftp.SFTPServerHandler._extensions', []):
+            # pylint: disable=no-value-for-parameter
+            _unsupported_extensions_v6(self)
+
     def test_write_close(self):
         """Test session cleanup in the middle of a write request"""
 
         @sftp_test
         async def _write_close(self, sftp):
             """Initiate write that triggers cleanup"""
 
             try:
                 async with sftp.open('file', 'w') as f:
-                    with self.assertRaises(SFTPError):
+                    with self.assertRaises(SFTPConnectionLost):
                         await f.write('a')
             finally:
                 sftp.exit()
 
                 remove('file')
 
         with patch('asyncssh.sftp.SFTPServerHandler', _WriteCloseServerHandler):
             # pylint: disable=no-value-for-parameter
             _write_close(self)
 
+    @sftp_test_v4
+    async def test_write_protect_v4(self, sftp):
+        """Test write protect error in SFTPv4"""
+
+        def _write_error(self, file_obj, offset, data):
+            """Return read-only FS error when writing to a file"""
+
+            raise OSError(errno.EROFS, 'Read-only filesystem')
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.write', _write_error):
+                with self.assertRaises(SFTPWriteProtect):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.write(b'\0')
+        finally:
+            remove('file')
+
+    @sftp_test_v4
+    async def test_no_media_v4(self, sftp):
+        """Test no media error in SFTPv4"""
+
+        def _write_error(self, file_obj, offset, data):
+            """Return read-only FS error when writing to a file"""
+
+            raise SFTPNoMedia('No media in requested drive')
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.write', _write_error):
+                with self.assertRaises(SFTPNoMedia):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.write(b'\0')
+        finally:
+            remove('file')
+
+    @sftp_test_v5
+    async def test_no_space_v5(self, sftp):
+        """Test no space on filesystem error in SFTPv5"""
+
+        def _write_error(self, file_obj, offset, data):
+            """Return no space error when writing to a file"""
+
+            raise OSError(errno.ENOSPC, 'No space left on device')
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.write', _write_error):
+                with self.assertRaises(SFTPNoSpaceOnFilesystem):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.write(b'\0')
+        finally:
+            remove('file')
+
+    @sftp_test_v5
+    async def test_quota_exceeded_v5(self, sftp):
+        """Test quota exceeded error in SFTPv5"""
+
+        def _write_error(self, file_obj, offset, data):
+            """Return quota exceeded error when writing to a file"""
+
+            raise OSError(errno.EDQUOT, 'Disk quota exceeded')
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.write', _write_error):
+                with self.assertRaises(SFTPQuotaExceeded):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.write(b'\0')
+        finally:
+            remove('file')
+
+    @sftp_test_v5
+    async def test_unknown_principal_v5(self, sftp):
+        """Test unknown principal error in SFTPv5"""
+
+        def _open56_error(self, path, desired_access, flags, attrs):
+            """Return unknown principal error when opening a file"""
+
+            raise SFTPUnknownPrincipal('Unknown principal',
+                unknown_names=(attrs.owner, attrs.group or b'\xff'))
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.open56', _open56_error):
+                with self.assertRaises(SFTPUnknownPrincipal):
+                    await sftp.open('file', 'wb', SFTPAttrs(owner='aaa',
+                                                            group='bbb'))
+
+                with self.assertRaises(SFTPBadMessage):
+                    await sftp.open('file', 'wb', SFTPAttrs(owner=b'aaa',
+                                                            group=''))
+        finally:
+            remove('file')
+
+    @sftp_test_v5
+    async def test_lock_conflict_v5(self, sftp):
+        """Test lock conflict error in SFTPv5"""
+
+        def _open56_error(self, path, desired_access, flags, attrs):
+            """Return lock conflict error when opening a file"""
+
+            raise SFTPLockConflict('Lock conflict')
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.open56', _open56_error):
+                with self.assertRaises(SFTPLockConflict):
+                    await sftp.open56('file', ACE4_WRITE_DATA, FXF_WRITE |
+                                      FXF_CREATE_TRUNCATE)
+        finally:
+            remove('file')
+
+    @sftp_test_v6
+    async def test_cannot_delete_v6(self, sftp):
+        """Test cannot delete error in SFTPv6"""
+
+        def _remove_error(self, path):
+            """Return cannot delete error when removing a file"""
+
+            raise SFTPCannotDelete('Cannot delete file')
+
+        with patch('asyncssh.sftp.SFTPServer.remove', _remove_error):
+            with self.assertRaises(SFTPCannotDelete):
+                await sftp.remove('file')
+
+    @sftp_test_v6
+    async def test_byte_range_lock_conflict_v6(self, sftp):
+        """Test byte range lock conflict error in SFTPv6"""
+
+        def _lock_error(self, file_obj, offset, length, flags):
+            """Return byte range lock conflict error"""
+
+            raise SFTPByteRangeLockConflict('Byte range lock conflict')
+
+        f = None
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.lock', _lock_error):
+                with self.assertRaises(SFTPByteRangeLockConflict):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.lock(0, 0, FXF_BLOCK_READ)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_byte_range_lock_refused_v6(self, sftp):
+        """Test byte range lock refused error in SFTPv6"""
+
+        def _lock_error(self, file_obj, offset, length, flags):
+            """Return byte range lock refused error"""
+
+            raise SFTPByteRangeLockRefused('Byte range lock refused')
+
+        f = None
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.lock', _lock_error):
+                with self.assertRaises(SFTPByteRangeLockRefused):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.lock(0, 0, FXF_BLOCK_READ)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
+    @sftp_test_v6
+    async def test_delete_pending_v6(self, sftp):
+        """Test delete pending error in SFTPv6"""
+
+        def _remove_error(self, path):
+            """Return delete pending error when removing a file"""
+
+            raise SFTPDeletePending('Delete of file is pending')
+
+        with patch('asyncssh.sftp.SFTPServer.remove', _remove_error):
+            with self.assertRaises(SFTPDeletePending):
+                await sftp.remove('file')
+
+    @sftp_test_v6
+    async def test_file_corrupt_v6(self, sftp):
+        """Test file corrupt error in SFTPv6"""
+
+        def _open56_error(self, path, desired_access, flags, attrs):
+            """Return file corrupt  error when opening a file"""
+
+            raise SFTPFileCorrupt('Filesystem is corrupt')
+
+        with patch('asyncssh.sftp.SFTPServer.open56', _open56_error):
+            with self.assertRaises(SFTPFileCorrupt):
+                await sftp.open('file')
+
+    @sftp_test_v6
+    async def test_byte_range_unlock_mismatch_v6(self, sftp):
+        """Test byte range unlock mismatch error in SFTPv6"""
+
+        def _unlock_error(self, file_obj, offset, length):
+            """Return byte range unlock mismatch error"""
+
+            raise SFTPNoMatchingByteRangeLock('Byte range unlock mismatch')
+
+        f = None
+
+        try:
+            with patch('asyncssh.sftp.SFTPServer.unlock', _unlock_error):
+                with self.assertRaises(SFTPNoMatchingByteRangeLock):
+                    async with sftp.open('file', 'wb') as f:
+                        await f.unlock(0, 0)
+        finally:
+            if f: # pragma: no branch
+                await f.close()
+
+            remove('file')
+
     @sftp_test
     async def test_log_formatting(self, sftp):
         """Exercise log formatting of SFTP objects"""
 
         asyncssh.set_sftp_log_level('DEBUG')
 
         with self.assertLogs(level='DEBUG'):
@@ -2408,15 +3805,16 @@
 class _TestSFTPChroot(_CheckSFTP):
     """Unit test for SFTP server with changed root"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server with a changed root"""
 
-        return await cls.create_server(sftp_factory=_ChrootSFTPServer)
+        return await cls.create_server(sftp_factory=_ChrootSFTPServer,
+                                       sftp_version=6)
 
     @sftp_test
     async def test_chroot_copy(self, sftp):
         """Test copying a file to an FTP server with a changed root"""
 
         try:
             self._create_file('src')
@@ -2439,14 +3837,50 @@
 
     @sftp_test
     async def test_chroot_realpath(self, sftp):
         """Test canonicalizing a path on an SFTP server with a changed root"""
 
         self.assertEqual((await sftp.realpath('/dir/../file')), '/file')
 
+        self._create_file('chroot/file1')
+
+        name = await sftp.realpath('/dir/..', 'file1',
+                                   check=FXRP_STAT_IF_EXISTS)
+
+        self.assertEqual(name.attrs.type, FILEXFER_TYPE_REGULAR)
+
+        name = await sftp.realpath('/dir/..', 'file2', FXRP_STAT_IF_EXISTS)
+
+        self.assertEqual(name.attrs.type, FILEXFER_TYPE_UNKNOWN)
+
+        with self.assertRaises(SFTPNoSuchFile):
+            await sftp.realpath('/dir', '..', 'file2', check=FXRP_STAT_ALWAYS)
+
+    @sftp_test_v6
+    async def test_chroot_realpath_v6(self, sftp):
+        """Test canonicalizing a path on an SFTP server with a changed root"""
+
+        self.assertEqual((await sftp.realpath('/dir/../file')), '/file')
+
+        self._create_file('chroot/file1')
+
+        name = await sftp.realpath('/dir/..', 'file1', FXRP_STAT_IF_EXISTS)
+
+        self.assertEqual(name.attrs.type, FILEXFER_TYPE_REGULAR)
+
+        name = await sftp.realpath('/dir/..', 'file2',
+                                   check=FXRP_STAT_IF_EXISTS)
+
+        self.assertEqual(name.attrs.type, FILEXFER_TYPE_UNKNOWN)
+
+        with self.assertRaises(SFTPNoSuchFile):
+            await sftp.realpath('/dir', '..', 'file2', check=FXRP_STAT_ALWAYS)
+
+        with self.assertRaises(SFTPInvalidParameter):
+            await sftp.realpath('.', check=99)
     @sftp_test
     async def test_getcwd_and_chdir(self, sftp):
         """Test changing directory on an SFTP server with a changed root"""
 
         try:
             os.mkdir('chroot/dir')
 
@@ -2469,15 +3903,15 @@
 
             os.symlink(root, 'chroot/link1')
             os.symlink(os.path.join(root, 'file'), 'chroot/link2')
             os.symlink('/xxx', 'chroot/link3')
 
             self.assertEqual((await sftp.readlink('link1')), '/')
             self.assertEqual((await sftp.readlink('link2')), '/file')
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPNoSuchFile):
                 await sftp.readlink('link3')
         finally:
             remove('chroot/link1 chroot/link2 chroot/link3')
 
     @sftp_test
     async def test_chroot_symlink(self, sftp):
         """Test setting a symlink on an SFTP server with a changed root"""
@@ -2514,14 +3948,60 @@
 
             self._create_file('chroot/file')
             with self.assertRaises(SFTPFailure):
                 await sftp.makedirs('file/dir')
         finally:
             remove('chroot/dir')
 
+    @sftp_test_v6
+    async def test_chroot_makedirs_v6(self, sftp):
+        """Test creating a directory path with SFTPv6"""
+
+        try:
+            await sftp.makedirs('dir/dir1')
+            self.assertTrue(os.path.isdir('chroot/dir'))
+            self.assertTrue(os.path.isdir('chroot/dir/dir1'))
+
+            await sftp.makedirs('dir/dir2')
+            self.assertTrue(os.path.isdir('chroot/dir/dir2'))
+
+            await sftp.makedirs('dir/dir2', exist_ok=True)
+            self.assertTrue(os.path.isdir('chroot/dir/dir2'))
+
+            with self.assertRaises(SFTPFileAlreadyExists):
+                await sftp.makedirs('/dir/dir2')
+
+            self._create_file('chroot/file')
+            with self.assertRaises(SFTPNotADirectory):
+                await sftp.makedirs('file/dir')
+        finally:
+            remove('chroot/dir')
+
+
+class _TestSFTPReadEOFWithAttrs(_CheckSFTP):
+    """Unit test for SFTP server read EOF flags with SFTPAttrs from fstat"""
+
+    @classmethod
+    async def start_server(cls):
+        """Start an SFTP server which returns SFTPAttrs on fstat"""
+
+        return await cls.create_server(sftp_factory=_SFTPAttrsSFTPServer,
+                                       sftp_version=6)
+
+    @sftp_test_v6
+    async def test_get(self, sftp):
+        """Test copying a file over SFTP"""
+
+        try:
+            self._create_file('src')
+            await sftp.get('src', 'dst')
+            self._check_file('src', 'dst')
+        finally:
+            remove('src dst')
+
 
 class _TestSFTPUnknownError(_CheckSFTP):
     """Unit test for SFTP server returning unknown error"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server which returns unknown error"""
@@ -2534,14 +4014,38 @@
 
         with self.assertRaises(SFTPError) as exc:
             await sftp.stat('file')
 
         self.assertEqual(exc.exception.code, 99)
 
 
+class _TestSFTPOpenError(_CheckSFTP):
+    """Unit test for SFTP server returning error on file open"""
+
+    @classmethod
+    async def start_server(cls):
+        """Start an SFTP server which returns file I/O errors"""
+
+        return await cls.create_server(sftp_factory=_OpenErrorSFTPServer,
+                                       sftp_version=6)
+
+    @sftp_test_v6
+    async def test_open_error_v6(self, sftp):
+        """Test error when opening a file on an SFTP server"""
+
+        with self.assertRaises(SFTPInvalidFilename):
+            await sftp.open('ENAMETOOLONG')
+
+        with self.assertRaises(SFTPInvalidParameter):
+            await sftp.open('EINVAL')
+
+        with self.assertRaises(SFTPFailure):
+            await sftp.open('ENXIO')
+
+
 class _TestSFTPIOError(_CheckSFTP):
     """Unit test for SFTP server returning file I/O error"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server which returns file I/O errors"""
 
@@ -2552,38 +4056,38 @@
         """Test error when putting a file to an SFTP server"""
 
         for method in ('get', 'put', 'copy'):
             with self.subTest(method=method):
                 try:
                     self._create_file('src', 4*1024*1024*'\0')
 
-                    with self.assertRaises((FileNotFoundError, SFTPError)):
+                    with self.assertRaises(SFTPFailure):
                         await getattr(sftp, method)('src', 'dst')
                 finally:
                     remove('src dst')
 
     @sftp_test
     async def test_read_error(self, sftp):
         """Test error when reading a file on an SFTP server"""
 
         try:
             self._create_file('file', 4*1024*1024*'\0')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 async with sftp.open('file') as f:
                     await f.read(4*1024*1024)
         finally:
             remove('file')
 
     @sftp_test
     async def test_write_error(self, sftp):
         """Test error when writing a file on an SFTP server"""
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 async with sftp.open('file', 'w') as f:
                     await f.write(4*1024*1024*'\0')
         finally:
             remove('file')
 
 
 class _TestSFTPSmallBlockSize(_CheckSFTP):
@@ -2636,15 +4140,15 @@
     @sftp_test
     async def test_get(self, sftp):
         """Test getting a file from an SFTP server truncated during the copy"""
 
         try:
             self._create_file('src', 65536*'\0')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await sftp.get('src', 'dst')
         finally:
             remove('src dst')
 
 
 class _TestSFTPNotImplemented(_CheckSFTP):
     """Unit test for SFTP server returning not-implemented error"""
@@ -2655,30 +4159,47 @@
 
         return await cls.create_server(sftp_factory=_NotImplSFTPServer)
 
     @sftp_test
     async def test_symlink_error(self, sftp):
         """Test error when creating a symbolic link on an SFTP server"""
 
-        with self.assertRaises(SFTPError):
+        with self.assertRaises(SFTPOpUnsupported):
             await sftp.symlink('file', 'link')
 
 
+class _TestSFTPFileType(_CheckSFTP):
+    """Unit test for SFTP server formatting directory listings"""
+
+    @classmethod
+    async def start_server(cls):
+        """Start an SFTP server which returns a fixed directory listing"""
+
+        return await cls.create_server(sftp_factory=_FileTypeSFTPServer)
+
+    @sftp_test
+    async def test_filetype(self, sftp):
+        """Test permission to filetype conversion in SFTP readdir call"""
+
+        for file in await sftp.readdir('/'):
+            self.assertEqual(file.filename, str(file.attrs.type))
+
+
 class _TestSFTPLongname(_CheckSFTP):
     """Unit test for SFTP server formatting directory listings"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server which returns a fixed directory listing"""
 
         return await cls.create_server(sftp_factory=_LongnameSFTPServer)
 
     @sftp_test
     async def test_longname(self, sftp):
-        """Test long name formatting in SFTP opendir call"""
+        """Test long name formatting in SFTP readdir call"""
 
         for file in await sftp.readdir('/'):
             self.assertEqual(file.longname[56:], file.filename)
 
     @sftp_test
     async def test_glob_hidden(self, sftp):
         """Test a glob pattern match on hidden files"""
@@ -2686,40 +4207,26 @@
         self.assertEqual((await sftp.glob('/.*')), ['/.file'])
 
     @unittest.skipIf(sys.platform == 'win32', 'skip uid/gid tests on Windows')
     @sftp_test
     async def test_getpwuid_error(self, sftp):
         """Test long name formatting where user name can't be resolved"""
 
-        def getpwuid_error(uid):
-            """Simulate not being able to resolve user name"""
-
-            # pylint: disable=unused-argument
-
-            raise KeyError
-
-        with patch('pwd.getpwuid', getpwuid_error):
+        with patch('pwd.getpwuid', _getpwuid_error):
             result = await sftp.readdir('/')
 
         self.assertEqual(result[3].longname[16:24], '        ')
         self.assertEqual(result[4].longname[16:24], '0       ')
 
     @unittest.skipIf(sys.platform == 'win32', 'skip uid/gid tests on Windows')
     @sftp_test
     async def test_getgrgid_error(self, sftp):
         """Test long name formatting where group name can't be resolved"""
 
-        def getgrgid_error(gid):
-            """Simulate not being able to resolve group name"""
-
-            # pylint: disable=unused-argument
-
-            raise KeyError
-
-        with patch('grp.getgrgid', getgrgid_error):
+        with patch('grp.getgrgid', _getgrgid_error):
             result = await sftp.readdir('/')
 
         self.assertEqual(result[3].longname[25:33], '        ')
         self.assertEqual(result[4].longname[25:33], '0       ')
 
     @sftp_test
     async def test_strftime_error(self, sftp):
@@ -2815,50 +4322,133 @@
 class _TestSFTPChown(_CheckSFTP):
     """Unit test for SFTP server file ownership"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server which simulates file ownership changes"""
 
-        return await cls.create_server(sftp_factory=_ChownSFTPServer)
+        return await cls.create_server(sftp_factory=_ChownSFTPServer,
+                                       sftp_version=6)
 
     @sftp_test
     async def test_chown(self, sftp):
         """Test changing ownership of a file"""
 
         try:
             self._create_file('file')
             await sftp.chown('file', 1, 2)
             attrs = await sftp.stat('file')
             self.assertEqual(attrs.uid, 1)
             self.assertEqual(attrs.gid, 2)
         finally:
             remove('file')
 
+    @sftp_test_v4
+    async def test_chown_v4(self, sftp):
+        """Test changing ownership of a file with SFTPv4"""
+
+        try:
+            self._create_file('file')
+            await sftp.chown('file', owner='root', group='wheel')
+            attrs = await sftp.stat('file')
+            self.assertEqual(attrs.owner, 'root')
+            self.assertEqual(attrs.group, 'wheel')
+        finally:
+            remove('file')
+
 
 class _TestSFTPAttrs(unittest.TestCase):
     """Unit test for SFTPAttrs object"""
 
     def test_attrs(self):
         """Test encoding and decoding of SFTP attributes"""
 
         for kwargs in ({'size': 1234},
                        {'uid': 1, 'gid': 2},
                        {'permissions': 0o7777},
                        {'atime': 1, 'mtime': 2},
                        {'extended': [(b'a1', b'v1'), (b'a2', b'v2')]}):
             attrs = SFTPAttrs(**kwargs)
-            packet = SSHPacket(attrs.encode())
-            self.assertEqual(repr(SFTPAttrs.decode(packet)), repr(attrs))
+            packet = SSHPacket(attrs.encode(3))
+            self.assertEqual(repr(SFTPAttrs.decode(packet, 3)), repr(attrs))
+
+        for kwargs in ({'type': FILEXFER_TYPE_REGULAR},
+                       {'size': 1234},
+                       {'owner': 'a', 'group': 'b'},
+                       {'permissions': 0o7777},
+                       {'atime': 1, 'atime_ns': 2},
+                       {'crtime': 3, 'crtime_ns': 4},
+                       {'mtime': 5, 'mtime_ns': 6},
+                       {'atime': 7, 'crtime': 8, 'mtime': 9},
+                       {'acl': b''}):
+            attrs = SFTPAttrs(**kwargs)
+            packet = SSHPacket(attrs.encode(4))
+            self.assertEqual(repr(SFTPAttrs.decode(packet, 4)), repr(attrs))
+
+            packet = SSHPacket(SFTPAttrs(uid=1, gid=2).encode(4))
+            self.assertEqual(repr(SFTPAttrs.decode(packet, 4)),
+                             repr(SFTPAttrs(owner='1', group='2')))
+
+        for kwargs in ({'type': FILEXFER_TYPE_REGULAR},
+                       {'size': 1234},
+                       {'owner': 'a', 'group': 'b'},
+                       {'permissions': 0o7777},
+                       {'atime': 1, 'atime_ns': 2},
+                       {'crtime': 3, 'crtime_ns': 4},
+                       {'mtime': 5, 'mtime_ns': 6},
+                       {'atime': 7, 'crtime': 8, 'mtime': 9},
+                       {'acl': b''},
+                       {'attrib_bits': FILEXFER_ATTR_BITS_READONLY,
+                        'attrib_valid': FILEXFER_ATTR_BITS_READONLY}):
+            attrs = SFTPAttrs(**kwargs)
+            packet = SSHPacket(attrs.encode(5))
+            self.assertEqual(repr(SFTPAttrs.decode(packet, 5)), repr(attrs))
+
+        for kwargs in ({'type': FILEXFER_TYPE_REGULAR},
+                       {'size': 1234, 'alloc_size': 5678},
+                       {'owner': 'a', 'group': 'b'},
+                       {'permissions': 0o7777},
+                       {'atime': 1, 'atime_ns': 2},
+                       {'crtime': 3, 'crtime_ns': 4},
+                       {'mtime': 5, 'mtime_ns': 6},
+                       {'ctime': 7, 'ctime_ns': 8},
+                       {'atime': 7, 'crtime': 8, 'mtime': 9, 'ctime': 10},
+                       {'acl': b''},
+                       {'attrib_bits': FILEXFER_ATTR_BITS_READONLY,
+                        'attrib_valid': FILEXFER_ATTR_BITS_READONLY},
+                       {'text_hint': FILEXFER_ATTR_KNOWN_TEXT},
+                       {'mime_type': 'application/octet-stream'},
+                       {'untrans_name': b'\xff'},
+                       {'extended': [(b'a1', b'v1'), (b'a2', b'v2')]}):
+            attrs = SFTPAttrs(**kwargs)
+            packet = SSHPacket(attrs.encode(6))
+            self.assertEqual(repr(SFTPAttrs.decode(packet, 6)), repr(attrs))
 
     def test_illegal_attrs(self):
         """Test decoding illegal SFTP attributes value"""
 
-        with self.assertRaises(SFTPError):
-            SFTPAttrs.decode(SSHPacket(UInt32(FILEXFER_ATTR_UNDEFINED)))
+        with self.assertRaises(SFTPBadMessage):
+            SFTPAttrs.decode(SSHPacket(UInt32(FILEXFER_ATTR_OWNERGROUP)), 3)
+
+        for version in range(4, 7):
+            with self.assertRaises(SFTPBadMessage):
+                SFTPAttrs.decode(SSHPacket(
+                    UInt32(FILEXFER_ATTR_UIDGID)), version)
+
+        with self.assertRaises(SFTPOwnerInvalid):
+            SFTPAttrs.decode(SSHPacket(
+                SFTPAttrs(owner=b'\xff', group='').encode(6)), 6)
+
+        with self.assertRaises(SFTPGroupInvalid):
+            SFTPAttrs.decode(SSHPacket(
+                SFTPAttrs(owner='', group=b'\xff').encode(6)), 6)
+
+        with self.assertRaises(SFTPBadMessage):
+            SFTPAttrs.decode(SSHPacket(
+                SFTPAttrs(mime_type=b'\xff').encode(6)), 6)
 
 
 class _TestSFTPNonstandardSymlink(_CheckSFTP):
     """Unit tests for SFTP server with non-standard symlink order"""
 
     @classmethod
     async def start_server(cls):
@@ -2886,23 +4476,36 @@
 class _TestSFTPAsync(_TestSFTP):
     """Unit test for an async SFTPServer"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server with async callbacks"""
 
-        return await cls.create_server(sftp_factory=_AsyncSFTPServer)
+        return await cls.create_server(sftp_factory=_AsyncSFTPServer,
+                                       sftp_version=6)
 
     @sftp_test
     async def test_async_realpath(self, sftp):
         """Test canonicalizing a path on an async SFTP server"""
 
         self.assertEqual((await sftp.realpath('dir/../file')),
                          posixpath.join((await sftp.getcwd()), 'file'))
 
+    @sftp_test_v6
+    async def test_async_realpath_v6(self, sftp):
+        """Test canonicalizing a path on an async SFTPv6 server"""
+
+        self._create_file('file1')
+
+        self.assertEqual((await sftp.realpath('dir/../file')),
+                         posixpath.join((await sftp.getcwd()), 'file'))
+
+        name = await sftp.realpath('dir/../file1', check=FXRP_STAT_ALWAYS)
+        self.assertEqual(name.attrs.type, FILEXFER_TYPE_REGULAR)
+
 
 class _CheckSCP(_CheckSFTP):
     """Utility functions for AsyncSSH SCP unit tests"""
 
     @classmethod
     async def asyncSetUpClass(cls):
         """Set up SCP target host/port tuple"""
@@ -3031,53 +4634,53 @@
     @asynctest
     async def test_get_not_permitted(self):
         """Test getting a file with no read permissions over SCP"""
 
         try:
             self._create_file('src', mode=0)
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp((self._scp_server, 'src'), 'dst')
         finally:
             remove('src dst')
 
     @asynctest
     async def test_get_directory_as_file(self):
         """Test getting a file which is actually a directory over SCP"""
 
         try:
             os.mkdir('src')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp((self._scp_server, 'src'), 'dst')
         finally:
             remove('src dst')
 
     @asynctest
     async def test_get_non_directory_in_path(self):
         """Test getting a file with a non-directory in path over SCP"""
 
         try:
             self._create_file('src')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp((self._scp_server, 'src/xxx'), 'dst')
         finally:
             remove('src dst')
 
     @asynctest
     async def test_get_recurse_not_directory(self):
         """Test getting a directory over SCP where target is not directory"""
 
         try:
             os.mkdir('src')
             self._create_file('dst')
             self._create_file('src/file1')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp((self._scp_server, 'src'), 'dst', recurse=True)
         finally:
             remove('src dst')
 
     @asynctest
     async def test_put(self):
         """Test putting a file over SCP"""
@@ -3138,15 +4741,15 @@
         """Test putting multiple files to a non-directory over SCP"""
 
         try:
             self._create_file('src1')
             self._create_file('src2')
             self._create_file('dst')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp(['src1', 'src2'], (self._scp_server, 'dst'))
         finally:
             remove('src1 src2 dst')
 
     @asynctest
     async def test_put_non_directory_in_path(self):
         """Test putting a file with a non-directory in path over SCP"""
@@ -3164,15 +4767,15 @@
         """Test putting a directory over SCP where target is not directory"""
 
         try:
             os.mkdir('src')
             self._create_file('dst')
             self._create_file('src/file1')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp('src', (self._scp_server, 'dst'), recurse=True)
         finally:
             remove('src dst')
 
     @asynctest
     async def test_put_read_error(self):
         """Test read errors when putting a file over SCP"""
@@ -3210,28 +4813,28 @@
 
         try:
             self._create_file('src', 128*1024*'\0')
 
             orig_read = LocalFile.read
 
             with patch('asyncssh.sftp.LocalFile.read', _read_early_eof):
-                with self.assertRaises(SFTPError):
+                with self.assertRaises(SFTPFailure):
                     await scp('src', (self._scp_server, 'dst'))
         finally:
             remove('src dst')
 
     @asynctest
     async def test_put_name_too_long(self):
         """Test putting a file over SCP with too long a name"""
 
         try:
             self._create_file('src')
 
-            with self.assertRaises(SFTPError):
-                await scp('src', (self._scp_server, 65536*'a'))
+            with self.assertRaises(SFTPFailure):
+                await scp('src', (self._scp_server, 256*'a'))
         finally:
             remove('src dst')
 
     @asynctest
     async def test_copy(self):
         """Test copying a file between remote hosts over SCP"""
 
@@ -3365,15 +4968,15 @@
         """Test copying a directory over SCP where target is not directory"""
 
         try:
             os.mkdir('src')
             self._create_file('dst')
             self._create_file('src/file1')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp((self._scp_server, 'src'), (self._scp_server, 'dst'),
                           recurse=True)
         finally:
             remove('src dst')
 
     @asynctest
     async def test_source_string(self):
@@ -3495,46 +5098,34 @@
         """Test putting a directory over SCP where target is not directory"""
 
         try:
             os.mkdir('src')
             self._create_file('dst')
             self._create_file('src/file1')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp('src', (self._scp_server, 'dst'), recurse=True)
         finally:
             remove('src dst')
 
     @asynctest
     async def test_put_not_permitted(self):
         """Test putting a file over SCP onto an unwritable target"""
 
         try:
             self._create_file('src')
             os.mkdir('dst')
             os.chmod('dst', 0)
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp('src', (self._scp_server, 'dst/src'))
         finally:
             os.chmod('dst', 0o755)
             remove('src dst')
 
-    @asynctest
-    async def test_put_name_too_long(self):
-        """Test putting a file over SCP with too long a name"""
-
-        try:
-            self._create_file('src')
-
-            with self.assertRaises(SFTPError):
-                await scp('src', (self._scp_server, 65536*'a'))
-        finally:
-            remove('src dst')
-
 
 class _TestSCPIOError(_CheckSCP):
     """Unit test for SCP with SFTP server returning file I/O error"""
 
     @classmethod
     async def start_server(cls):
         """Start an SFTP server which returns file I/O errors"""
@@ -3545,27 +5136,27 @@
     @asynctest
     async def test_put_error(self):
         """Test error when putting a file over SCP"""
 
         try:
             self._create_file('src', 4*1024*1024*'\0')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp('src', (self._scp_server, 'dst'))
         finally:
             remove('src dst')
 
     @asynctest
     async def test_copy_error(self):
         """Test error when copying a file over SCP"""
 
         try:
             self._create_file('src', 4*1024*1024*'\0')
 
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPFailure):
                 await scp((self._scp_server, 'src'),
                           (self._scp_server, 'dst'))
         finally:
             remove('src dst')
 
 
 class _TestSCPErrors(_CheckSCP):
@@ -3619,25 +5210,25 @@
         return await cls.create_server(process_factory=_handle_client)
 
     @asynctest
     async def test_get_directory_without_recurse(self):
         """Test receiving directory when recurse wasn't requested"""
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises((SFTPBadMessage, SFTPConnectionLost)):
                 await scp((self._scp_server, 'get_dir_no_recurse'), 'dst')
         finally:
             remove('dst')
 
     @asynctest
     async def test_get_early_eof(self):
         """Test getting early EOF when getting a file over SCP"""
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPConnectionLost):
                 await scp((self._scp_server, 'get_early_eof'), 'dst')
         finally:
             remove('dst')
 
     @asynctest
     async def test_get_t_without_preserve(self):
         """Test getting timestamps with requesting preserve"""
@@ -3648,89 +5239,89 @@
             remove('dst')
 
     @asynctest
     async def test_get_unknown_action(self):
         """Test getting unknown action from SCP server during get"""
 
         try:
-            with self.assertRaises(SFTPError):
+            with self.assertRaises(SFTPBadMessage):
                 await scp((self._scp_server, 'get_unknown_action'), 'dst')
         finally:
             remove('dst')
 
     @asynctest
     async def test_put_startup_error(self):
         """Test SCP server returning an error on startup"""
 
         try:
             self._create_file('src')
 
-            with self.assertRaises(SFTPError) as exc:
+            with self.assertRaises(SFTPFailure) as exc:
                 await scp('src', (self._scp_server, 'put_startup_error'))
 
             self.assertEqual(exc.exception.reason, 'Error starting SCP')
         finally:
             remove('src')
 
     @asynctest
     async def test_put_connection_lost(self):
         """Test SCP server abruptly closing connection on put"""
 
         try:
             self._create_file('src')
 
-            with self.assertRaises(SFTPError) as exc:
+            with self.assertRaises(SFTPConnectionLost) as exc:
                 await scp('src', (self._scp_server, 'put_connection_lost'))
 
             self.assertEqual(exc.exception.reason, 'Connection lost')
         finally:
             remove('src')
 
     @asynctest
     async def test_copy_connection_lost_source(self):
         """Test source abruptly closing connection during SCP copy"""
 
-        with self.assertRaises(SFTPError) as exc:
+        with self.assertRaises(SFTPConnectionLost) as exc:
             await scp((self._scp_server, 'get_connection_lost'),
                       (self._scp_server, 'recv_early_eof'))
 
         self.assertEqual(exc.exception.reason, 'Connection lost')
 
     @asynctest
     async def test_copy_connection_lost_sink(self):
         """Test sink abruptly closing connection during SCP copy"""
 
-        with self.assertRaises(SFTPError) as exc:
+        with self.assertRaises(SFTPConnectionLost) as exc:
             await scp((self._scp_server, 'get_early_eof'),
                       (self._scp_server, 'put_connection_lost'))
 
         self.assertEqual(exc.exception.reason, 'Connection lost')
 
     @asynctest
     async def test_copy_early_eof(self):
         """Test getting early EOF when copying a file over SCP"""
 
-        with self.assertRaises(SFTPError):
+        with self.assertRaises(SFTPConnectionLost):
             await scp((self._scp_server, 'get_early_eof'),
                       (self._scp_server, 'recv_early_eof'))
 
     @asynctest
     async def test_copy_extra_e(self):
         """Test getting extra E when copying a file over SCP"""
 
         await scp((self._scp_server, 'get_extra_e'),
                   (self._scp_server, 'recv_early_eof'))
 
     @asynctest
     async def test_copy_unknown_action(self):
         """Test getting unknown action from SCP server during copy"""
 
-        with self.assertRaises(SFTPError):
+        with self.assertRaises(SFTPBadMessage):
             await scp((self._scp_server, 'get_unknown_action'),
                       (self._scp_server, 'recv_early_eof'))
 
     @asynctest
     async def test_unknown(self):
         """Test unknown SCP server request for code coverage"""
 
-        with self.assertRaises(SFTPError):
+        with self.assertRaises(SFTPConnectionLost):
             await scp('src', (self._scp_server, 'unknown'))
```

### Comparing `asyncssh-2.8.1/docs/index.rst` & `asyncssh-2.9.0/docs/index.rst`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/docs/conf.py` & `asyncssh-2.9.0/docs/conf.py`

 * *Files 1% similar despite different names*

```diff
@@ -241,7 +241,9 @@
 # If false, no module index is generated.
 #texinfo_domain_indices = True
 
 # How to display URL addresses: 'footnote', 'no', or 'inline'.
 #texinfo_show_urls = 'footnote'
 
 intersphinx_mapping = {'python': ('https://docs.python.org/3', None)}
+
+autodoc_typehints = "none"
```

### Comparing `asyncssh-2.8.1/docs/changes.rst` & `asyncssh-2.9.0/docs/changes.rst`

 * *Files 1% similar despite different names*

```diff
@@ -1,26 +1,54 @@
 .. currentmodule:: asyncssh
 
 Change Log
 ==========
 
+Release 2.9.0 (23 Jan 2022)
+---------------------------
+
+* Added mypy-compatible type annotations to all AsyncSSH modules, and a
+  "py.typed" file to signal that annotations are now available for this
+  package.
+
+* Added experimental support for SFTP versions 4-6. While AsyncSSH still
+  defaults to only advertising version 3 when acting as both a client and
+  a server, applications can explicitly enable support for later versions,
+  which will be used if both ends of the connection agree. Not all features
+  are fully supported, but a number of useful enhancements are now
+  available, including as users and groups specified by name, higher
+  resolution timestamps, and more granular error reporting.
+
+* Updated documentation to make it clear that keys from a PKCS11 provider
+  or ssh-agent will be used even when client_keys is specified, unless
+  those sources are explicitly disabled.
+
+* Improved handling of task cancellation in AsyncSSH to avoid triggering
+  an error of "Future exception was never retrieved". Thanks go to Krzysztof
+  Kotlenga for reporting this issue and providing test code to reliably
+  reproduce it.
+
+* Changed implementation of OpenSSH keepalive handler to improve
+  interoperability with servers which don't expect a "success" response
+  when this message is sent.
+
 Release 2.8.1 (8 Nov 2021)
 --------------------------
 
 * Fixed a regression in handling of the passphrase argument used to
   decrypt private keys.
 
 Release 2.8.0 (3 Nov 2021)
 --------------------------
 
 * Added new connect_timeout option to set a timeout which includes the
   time taken to open an outbound TCP connection, allowing connections
   to be aborted without waiting for the default socket connect timeout.
   The existing login_timeout option only applies after the TCP connection
-  was established, so it could not be used for this.. The support for the
+  was established, so it could not be used for this. The support for the
   ConnectTimeout config file option has also been updated to use this new
   capability, making it more consistent with OpenSSH's behavior.
 
 * Added the ability to use the passphrase argument specified in a connect
   call to be used to decrypt keys used to connect to bastion hosts.
   Previously, this argument was only applied when making a connection
   to the main host and encrypted keys could only be used when they
```

### Comparing `asyncssh-2.8.1/docs/api.rst` & `asyncssh-2.9.0/docs/api.rst`

 * *Files 6% similar despite different names*

```diff
@@ -290,19 +290,19 @@
 ==================
 
 SSHClientConnection
 -------------------
 
 .. autoclass:: SSHClientConnection()
 
-   ========================= =
+   ======================================================================= =
    Connection attributes
-   ========================= =
+   ======================================================================= =
    .. autoattribute:: logger
-   ========================= =
+   ======================================================================= =
 
    =================================== =
    General connection methods
    =================================== =
    .. automethod:: get_extra_info
    .. automethod:: set_extra_info
    .. automethod:: set_keepalive
@@ -360,19 +360,19 @@
    =========================== =
 
 SSHServerConnection
 -------------------
 
 .. autoclass:: SSHServerConnection()
 
-   ========================= =
+   ======================================================================= =
    Connection attributes
-   ========================= =
+   ======================================================================= =
    .. autoattribute:: logger
-   ========================= =
+   ======================================================================= =
 
    ============================== =
    General connection methods
    ============================== =
    .. automethod:: get_extra_info
    .. automethod:: set_extra_info
    .. automethod:: set_keepalive
@@ -437,52 +437,52 @@
 ===============
 
 SSHClientProcess
 ----------------
 
 .. autoclass:: SSHClientProcess
 
-   ============================== =
+   ======================================================================= =
    Client process attributes
-   ============================== =
+   ======================================================================= =
    .. autoattribute:: channel
    .. autoattribute:: logger
    .. autoattribute:: env
    .. autoattribute:: command
    .. autoattribute:: subsystem
    .. autoattribute:: stdin
    .. autoattribute:: stdout
    .. autoattribute:: stderr
    .. autoattribute:: exit_status
    .. autoattribute:: exit_signal
    .. autoattribute:: returncode
-   ============================== =
+   ======================================================================= =
 
    ==================================== =
    Other client process methods
    ==================================== =
    .. automethod:: get_extra_info
    .. automethod:: redirect
    .. automethod:: collect_output
    .. automethod:: communicate
    .. automethod:: wait
    .. automethod:: change_terminal_size
    .. automethod:: send_break
    .. automethod:: send_signal
    ==================================== =
 
-   ============================ =
+   ======================================================================= =
    Client process close methods
-   ============================ =
+   ======================================================================= =
    .. automethod:: terminate
    .. automethod:: kill
    .. automethod:: close
    .. automethod:: is_closing
    .. automethod:: wait_closed
-   ============================ =
+   ======================================================================= =
 
 SSHServerProcess
 ----------------
 
 .. autoclass:: SSHServerProcess
 
    ============================== =
@@ -530,55 +530,55 @@
 
    ==================================== =
    General subprocess pipe info methods
    ==================================== =
    .. automethod:: get_extra_info
    ==================================== =
 
-   ============================== =
+   ======================================================================= =
    Subprocess pipe read methods
-   ============================== =
+   ======================================================================= =
    .. automethod:: pause_reading
    .. automethod:: resume_reading
-   ============================== =
+   ======================================================================= =
 
-   ===================================== =
+   ======================================================================= =
    General subprocess pipe close methods
-   ===================================== =
+   ======================================================================= =
    .. automethod:: close
-   ===================================== =
+   ======================================================================= =
 
 SSHSubprocessWritePipe
 ----------------------
 
 .. autoclass:: SSHSubprocessWritePipe()
 
    ==================================== =
    General subprocess pipe info methods
    ==================================== =
    .. automethod:: get_extra_info
    ==================================== =
 
-   ======================================= =
+   ======================================================================= =
    Subprocess pipe write methods
-   ======================================= =
+   ======================================================================= =
    .. automethod:: can_write_eof
    .. automethod:: get_write_buffer_size
    .. automethod:: set_write_buffer_limits
    .. automethod:: write
    .. automethod:: writelines
    .. automethod:: write_eof
-   ======================================= =
+   ======================================================================= =
 
-   ===================================== =
+   ======================================================================= =
    General subprocess pipe close methods
-   ===================================== =
+   ======================================================================= =
    .. automethod:: abort
    .. automethod:: close
-   ===================================== =
+   ======================================================================= =
 
 SSHSubprocessProtocol
 ---------------------
 
 .. autoclass:: SSHSubprocessProtocol
 
    ==================================== =
@@ -613,23 +613,23 @@
    .. automethod:: get_pipe_transport
    .. automethod:: get_returncode
    .. automethod:: change_terminal_size
    .. automethod:: send_break
    .. automethod:: send_signal
    ==================================== =
 
-   ================================== =
+   ======================================================================= =
    Subprocess transport close methods
-   ================================== =
+   ======================================================================= =
    .. automethod:: terminate
    .. automethod:: kill
    .. automethod:: close
    .. automethod:: is_closing
    .. automethod:: wait_closed
-   ================================== =
+   ======================================================================= =
 
 Session Classes
 ===============
 
 SSHClientSession
 ----------------
 
@@ -828,19 +828,19 @@
    ============================= =
 
 SSHServerChannel
 ----------------
 
 .. autoclass:: SSHServerChannel()
 
-   ========================= =
+   ======================================================================= =
    Channel attributes
-   ========================= =
+   ======================================================================= =
    .. autoattribute:: logger
-   ========================= =
+   ======================================================================= =
 
    =============================== =
    General channel info methods
    =============================== =
    .. automethod:: get_extra_info
    .. automethod:: set_extra_info
    .. automethod:: get_environment
@@ -911,19 +911,19 @@
    ============================== =
 
 SSHTCPChannel
 -------------
 
 .. autoclass:: SSHTCPChannel()
 
-   ========================= =
+   ======================================================================= =
    Channel attributes
-   ========================= =
+   ======================================================================= =
    .. autoattribute:: logger
-   ========================= =
+   ======================================================================= =
 
    ============================== =
    General channel info methods
    ============================== =
    .. automethod:: get_extra_info
    .. automethod:: set_extra_info
    ============================== =
@@ -956,19 +956,19 @@
    ============================= =
 
 SSHUNIXChannel
 --------------
 
 .. autoclass:: SSHUNIXChannel()
 
-   ========================= =
+   ======================================================================= =
    Channel attributes
-   ========================= =
+   ======================================================================= =
    .. autoattribute:: logger
-   ========================= =
+   ======================================================================= =
 
    ============================== =
    General channel info methods
    ============================== =
    .. automethod:: get_extra_info
    .. automethod:: set_extra_info
    ============================== =
@@ -1067,65 +1067,71 @@
 ============
 
 SFTPClient
 ----------
 
 .. autoclass:: SFTPClient()
 
-   ========================= =
+   ======================================================================= =
    SFTP client attributes
-   ========================= =
+   ======================================================================= =
    .. autoattribute:: logger
-   ========================= =
+   .. autoattribute:: version
+   ======================================================================= =
 
    ===================== =
    File transfer methods
    ===================== =
    .. automethod:: get
    .. automethod:: put
    .. automethod:: copy
    .. automethod:: mget
    .. automethod:: mput
    .. automethod:: mcopy
    ===================== =
 
-   ============================================================================================================================== =
+   ============================================================================================================================================================================================================================== =
    File access methods
-   ============================================================================================================================== =
-   .. automethod:: open(path, mode='r', attrs=SFTPAttrs(), encoding='utf-8', errors='strict', block_size=16384, max_requests=128)
+   ============================================================================================================================================================================================================================== =
+   .. automethod:: open(path, mode='r', attrs=SFTPAttrs(), encoding='utf-8', errors='strict', block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS)
+   .. automethod:: open56(path, desired_access=ACE4_READ_DATA | ACE4_READ_ATTRIBUTES, flags=FXF_OPEN_EXISTING, attrs=SFTPAttrs(), encoding='utf-8', errors='strict', block_size=SFTP_BLOCK_SIZE, max_requests=_MAX_SFTP_REQUESTS)
    .. automethod:: truncate
    .. automethod:: rename
    .. automethod:: posix_rename
    .. automethod:: remove
    .. automethod:: unlink
    .. automethod:: readlink
    .. automethod:: symlink
    .. automethod:: link
    .. automethod:: realpath
-   ============================================================================================================================== =
+   ============================================================================================================================================================================================================================== =
 
-   ============================= =
+   ======================================================= =
    File attribute access methods
-   ============================= =
+   ======================================================= =
    .. automethod:: stat
    .. automethod:: lstat
    .. automethod:: setstat
    .. automethod:: statvfs
-   .. automethod:: chown
+   .. automethod:: chown(path, uid or owner, gid or group)
    .. automethod:: chmod
    .. automethod:: utime
    .. automethod:: exists
    .. automethod:: lexists
    .. automethod:: getatime
+   .. automethod:: getatime_ns
    .. automethod:: getmtime
+   .. automethod:: getcrtime_ns
+   .. automethod:: getcrtime
+   .. automethod:: getmtime_ns
    .. automethod:: getsize
    .. automethod:: isdir
    .. automethod:: isfile
    .. automethod:: islink
-   ============================= =
+   ======================================================= =
 
    ================================================= =
    Directory access methods
    ================================================= =
    .. automethod:: chdir
    .. automethod:: getcwd
    .. automethod:: mkdir(path, attrs=SFTPAttrs())
@@ -1146,29 +1152,31 @@
    =========================== =
 
 SFTPClientFile
 --------------
 
 .. autoclass:: SFTPClientFile()
 
-   ================================================ =
+   ================================================= =
    .. automethod:: read
    .. automethod:: write
    .. automethod:: seek(offset, from_what=SEEK_SET)
    .. automethod:: tell
    .. automethod:: stat
    .. automethod:: setstat
    .. automethod:: statvfs
    .. automethod:: truncate
-   .. automethod:: chown
+   .. automethod:: chown(uid or owner, gid or group)
    .. automethod:: chmod
    .. automethod:: utime
+   .. automethod:: lock
+   .. automethod:: unlock
    .. automethod:: fsync
    .. automethod:: close
-   ================================================ =
+   ================================================= =
 
 SFTPServer
 ----------
 
 .. autoclass:: SFTPServer
 
    ============================= =
@@ -1190,14 +1198,15 @@
    .. automethod:: reverse_map_path
    ================================== =
 
    ============================ =
    File access methods
    ============================ =
    .. automethod:: open
+   .. automethod:: open56
    .. automethod:: close
    .. automethod:: read
    .. automethod:: write
    .. automethod:: rename
    .. automethod:: posix_rename
    .. automethod:: remove
    .. automethod:: readlink
@@ -1212,14 +1221,16 @@
    .. automethod:: stat
    .. automethod:: lstat
    .. automethod:: fstat
    .. automethod:: setstat
    .. automethod:: fsetstat
    .. automethod:: statvfs
    .. automethod:: fstatvfs
+   .. automethod:: lock
+   .. automethod:: unlock
    ============================= =
 
    ======================== =
    Directory access methods
    ======================== =
    .. automethod:: listdir
    .. automethod:: mkdir
@@ -1387,14 +1398,17 @@
 -------------------------
 
 When performing X.509 certificate authentication, AsyncSSH can be
 passed in an allowed set of ExtendedKeyUsage purposes. Purposes are
 matched in X.509 certificates as OID values, but AsyncSSH also allows
 the following well-known purpose values to be specified by name:
 
+.. table::
+  :align: left
+
   ================= ==================
   Name              OID
   ================= ==================
   serverAuth        1.3.6.1.5.5.7.3.1
   clientAuth        1.3.6.1.5.5.7.3.2
   secureShellClient 1.3.6.1.5.5.7.3.20
   secureShellServer 1.3.6.1.5.5.7.3.21
@@ -1715,14 +1729,17 @@
   | Host
   | LocalUser
   | OriginalHost
   | User
 
 The following client config token expansions are currently supported:
 
+.. table::
+  :align: left
+
   ===== ============================================================
   Token Expansion
   ===== ============================================================
   %%    Literal '%'
   %C    SHA-1 Hash of connection info (local host, host, port, user)
   %d    Local user's home directory
   %h    Remote host
@@ -1785,14 +1802,17 @@
   | Host
   | LocalAddress
   | LocalPort
   | User
 
 The following server config token expansions are currently supported:
 
+.. table::
+  :align: left
+
   ===== ===========
   Token Expansion
   ===== ===========
   %%    Literal '%'
   %u    Username
   ===== ===========
 
@@ -2053,14 +2073,37 @@
 .. autoexception:: SFTPNoSuchFile
 .. autoexception:: SFTPPermissionDenied
 .. autoexception:: SFTPFailure
 .. autoexception:: SFTPBadMessage
 .. autoexception:: SFTPNoConnection
 .. autoexception:: SFTPConnectionLost
 .. autoexception:: SFTPOpUnsupported
+.. autoexception:: SFTPInvalidHandle
+.. autoexception:: SFTPNoSuchPath
+.. autoexception:: SFTPFileAlreadyExists
+.. autoexception:: SFTPWriteProtect
+.. autoexception:: SFTPNoMedia
+.. autoexception:: SFTPNoSpaceOnFilesystem
+.. autoexception:: SFTPQuotaExceeded
+.. autoexception:: SFTPUnknownPrincipal
+.. autoexception:: SFTPLockConflict
+.. autoexception:: SFTPDirNotEmpty
+.. autoexception:: SFTPNotADirectory
+.. autoexception:: SFTPInvalidFilename
+.. autoexception:: SFTPLinkLoop
+.. autoexception:: SFTPCannotDelete
+.. autoexception:: SFTPInvalidParameter
+.. autoexception:: SFTPFileIsADirectory
+.. autoexception:: SFTPByteRangeLockConflict
+.. autoexception:: SFTPByteRangeLockRefused
+.. autoexception:: SFTPDeletePending
+.. autoexception:: SFTPFileCorrupt
+.. autoexception:: SFTPOwnerInvalid
+.. autoexception:: SFTPGroupInvalid
+.. autoexception:: SFTPNoMatchingByteRangeLock
 
 KeyImportError
 --------------
 
 .. autoexception:: KeyImportError
 
 KeyExportError
@@ -2399,27 +2442,56 @@
 
 .. index:: SFTP error codes
 .. _SFTPErrorCodes:
 
 SFTP error codes
 ----------------
 
-The following values defined in the `SSH File Transfer Internet Draft
-<http://www.openssh.com/txt/draft-ietf-secsh-filexfer-02.txt>`_ can be
-specified as SFTP error codes:
-
-  | FX_OK
-  | FX_EOF
-  | FX_NO_SUCH_FILE
-  | FX_PERMISSION_DENIED
-  | FX_FAILURE
-  | FX_BAD_MESSAGE
-  | FX_NO_CONNECTION
-  | FX_CONNECTION_LOST
-  | FX_OP_UNSUPPORTED
+The following values defined in section 9.1 of the `SSH File Transfer Protocol
+Internet Draft <https://datatracker.ietf.org/doc/html/draft-ietf-secsh-filexfer-13#section-9.1>`_ can be specified as SFTP error codes:
+
+.. table::
+  :align: left
+
+  =============================== ====================
+  Error code                      Minimum SFTP version
+  =============================== ====================
+  FX_OK                           3
+  FX_EOF                          3
+  FX_NO_SUCH_FILE                 3
+  FX_PERMISSION_DENIED            3
+  FX_FAILURE                      3
+  FX_BAD_MESSAGE                  3
+  FX_NO_CONNECTION                3
+  FX_CONNECTION_LOST              3
+  FX_OP_UNSUPPORTED               3
+  FX_INVALID_HANDLE               4
+  FX_NO_SUCH_PATH                 4
+  FX_FILE_ALREADY_EXISTS          4
+  FX_WRITE_PROTECT                4
+  FX_NO_MEDIA                     4
+  FX_NO_SPACE_ON_FILESYSTEM       5
+  FX_QUOTA_EXCEEDED               5
+  FX_UNKNOWN_PRINCIPAL            5
+  FX_LOCK_CONFLICT                5
+  FX_DIR_NOT_EMPTY                6
+  FX_NOT_A_DIRECTORY              6
+  FX_INVALID_FILENAME             6
+  FX_LINK_LOOP                    6
+  FX_CANNOT_DELETE                6
+  FX_INVALID_PARAMETER            6
+  FX_FILE_IS_A_DIRECTORY          6
+  FX_BYTE_RANGE_LOCK_CONFLICT     6
+  FX_BYTE_RANGE_LOCK_REFUSED      6
+  FX_DELETE_PENDING               6
+  FX_FILE_CORRUPT                 6
+  FX_OWNER_INVALID                6
+  FX_GROUP_INVALID                6
+  FX_NO_MATCHING_BYTE_RANGE_LOCK  6
+  =============================== ====================
 
 .. index:: Extended data types
 .. _ExtendedDataTypes:
 
 Extended data types
 -------------------
```

### Comparing `asyncssh-2.8.1/setup.py` & `asyncssh-2.9.0/setup.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 
-# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2022 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -48,25 +48,26 @@
       author_email = __author_email__,
       url = __url__,
       license = 'Eclipse Public License v2.0',
       description = doclines[0],
       long_description = long_description,
       platforms = 'Any',
       python_requires = '>= 3.6',
-      install_requires = ['cryptography >= 2.8'],
+      install_requires = ['cryptography >= 2.8', 'typing_extensions >= 3.6'],
       extras_require = {
           'bcrypt':     ['bcrypt >= 3.1.3'],
           'fido2':      ['fido2 == 0.9.1'],
           'gssapi':     ['gssapi >= 1.2.0'],
           'libnacl':    ['libnacl >= 1.4.2'],
           'pkcs11':     ['python-pkcs11 >= 0.7.0'],
           'pyOpenSSL':  ['pyOpenSSL >= 17.0.0'],
           'pywin32':    ['pywin32 >= 227']
       },
       packages = ['asyncssh', 'asyncssh.crypto'],
+      package_data = {'asyncssh': ['py.typed']},
       scripts = [],
       test_suite = 'tests',
       classifiers = [
           'Development Status :: 5 - Production/Stable',
           'Environment :: Console',
           'Intended Audience :: Developers',
           'License :: OSI Approved',
```

### Comparing `asyncssh-2.8.1/examples/remote_forwarding_client2.py` & `asyncssh-2.9.0/examples/remote_forwarding_client2.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,24 +18,26 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 from functools import partial
+from typing import Awaitable
 
-def connection_requested(conn, orig_host, orig_port):
+def connection_requested(conn: asyncssh.SSHServerConnection, orig_host: str,
+                         orig_port: int) -> Awaitable[asyncssh.SSHForwarder]:
     if orig_host in ('127.0.0.1', '::1'):
         return conn.forward_connection('localhost', 80)
     else:
         raise asyncssh.ChannelOpenError(
             asyncssh.OPEN_ADMINISTRATIVELY_PROHIBITED,
             'Connections only allowed from localhost')
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         listener = await conn.create_server(
             partial(connection_requested, conn), '', 8080)
         await listener.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
```

### Comparing `asyncssh-2.8.1/examples/simple_keyed_server.py` & `asyncssh-2.9.0/examples/simple_keyed_server.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -26,32 +26,32 @@
 #
 # Authentication requires the directory authorized_keys to exist with
 # files in it named based on the username containing the client keys
 # and certificate authority keys which are accepted for that user.
 
 import asyncio, asyncssh, sys
 
-def handle_client(process):
+def handle_client(process: asyncssh.SSHServerProcess) -> None:
     process.stdout.write('Welcome to my SSH server, %s!\n' %
                          process.get_extra_info('username'))
     process.exit(0)
 
 class MySSHServer(asyncssh.SSHServer):
-    def connection_made(self, conn):
+    def connection_made(self, conn: asyncssh.SSHServerConnection) -> None:
         self._conn = conn
 
-    def begin_auth(self, username):
+    def begin_auth(self, username: str) -> bool:
         try:
             self._conn.set_authorized_keys('authorized_keys/%s' % username)
         except IOError:
             pass
 
         return True
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.create_server(MySSHServer, '', 8022,
                                  server_host_keys=['ssh_host_key'],
                                  process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/scp_client.py` & `asyncssh-2.9.0/examples/sftp_client.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2017-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,14 +18,16 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
-    await asyncssh.scp('localhost:example.txt', '.')
+async def run_client() -> None:
+    async with asyncssh.connect('localhost') as conn:
+        async with conn.start_sftp_client() as sftp:
+            await sftp.get('example.txt')
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SFTP operation failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/local_forwarding_client2.py` & `asyncssh-2.9.0/examples/local_forwarding_client2.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,15 +18,15 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         listener = await conn.forward_local_port('', 0, 'www.google.com', 80)
         print('Listening on port %s...' % listener.get_port())
         await listener.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
```

### Comparing `asyncssh-2.8.1/examples/redirect_input.py` & `asyncssh-2.9.0/examples/set_environment.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,15 +18,17 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        await conn.run('tail -r', input='1\n2\n3\n', stdout='/tmp/stdout')
+        result = await conn.run('env', env={'LANG': 'en_GB',
+                                            'LC_COLLATE': 'C'})
+        print(result.stdout, end='')
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/show_environment.py` & `asyncssh-2.9.0/examples/show_environment.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,26 +25,26 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-async def handle_client(process):
+async def handle_client(process: asyncssh.SSHServerProcess) -> None:
     if process.env:
         keywidth = max(map(len, process.env.keys()))+1
         process.stdout.write('Environment:\n')
         for key, value in process.env.items():
             process.stdout.write('  %-*s %s\n' % (keywidth, key+':', value))
         process.exit(0)
     else:
         process.stderr.write('No environment sent.\n')
         process.exit(1)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/callback_client2.py` & `asyncssh-2.9.0/examples/callback_client2.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,24 +17,25 @@
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
+from typing import Optional
 
 class MySSHClientSession(asyncssh.SSHClientSession):
-    def data_received(self, data, datatype):
+    def data_received(self, data: str, datatype: asyncssh.DataType) -> None:
         print(data, end='')
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         if exc:
             print('SSH session error: ' + str(exc), file=sys.stderr)
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         chan, session = await conn.create_session(MySSHClientSession, 'ls abc')
         await chan.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
```

### Comparing `asyncssh-2.8.1/examples/redirect_local_pipe.py` & `asyncssh-2.9.0/examples/redirect_local_pipe.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,15 +18,15 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, subprocess, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         local_proc = subprocess.Popen(r'echo "1\n2\n3"', shell=True,
                                       stdout=subprocess.PIPE)
         remote_result = await conn.run('tail -r', stdin=local_proc.stdout)
         print(remote_result.stdout, end='')
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/callback_client3.py` & `asyncssh-2.9.0/examples/local_forwarding_client.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,27 +18,16 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-class MySSHClientSession(asyncssh.SSHClientSession):
-    def data_received(self, data, datatype):
-        if datatype == asyncssh.EXTENDED_DATA_STDERR:
-            print(data, end='', file=sys.stderr)
-        else:
-            print(data, end='')
-
-    def connection_lost(self, exc):
-        if exc:
-            print('SSH session error: ' + str(exc), file=sys.stderr)
-
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        chan, session = await conn.create_session(MySSHClientSession, 'ls abc')
-        await chan.wait_closed()
+        listener = await conn.forward_local_port('', 8080, 'www.google.com', 80)
+        await listener.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/chat_server.py` & `asyncssh-2.9.0/examples/chat_server.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2016-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -24,38 +24,42 @@
 # private key in it to use as a server host key. An SSH host certificate
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
+from typing import List, cast
 
 class ChatClient:
-    _clients = []
+    _clients: List['ChatClient'] = []
 
-    def __init__(self, process):
+    def __init__(self, process: asyncssh.SSHServerProcess):
         self._process = process
 
     @classmethod
-    async def handle_client(cls, process):
+    async def handle_client(cls, process: asyncssh.SSHServerProcess):
         await cls(process).run()
 
-    def write(self, msg):
+    async def readline(self) -> str:
+        return cast(str, self._process.stdin.readline())
+
+    def write(self, msg: str) -> None:
         self._process.stdout.write(msg)
 
-    def broadcast(self, msg):
+    def broadcast(self, msg: str) -> None:
         for client in self._clients:
             if client != self:
                 client.write(msg)
 
-    async def run(self):
+    async def run(self) -> None:
         self.write('Welcome to chat!\n\n')
 
         self.write('Enter your name: ')
-        name = (await self._process.stdin.readline()).rstrip('\n')
+        name = (await self.readline()).rstrip('\n')
 
         self.write('\n%d other users are connected.\n\n' % len(self._clients))
 
         self._clients.append(self)
         self.broadcast('*** %s has entered chat ***\n' % name)
 
         try:
@@ -63,15 +67,15 @@
                 self.broadcast('%s: %s' % (name, line))
         except asyncssh.BreakReceived:
             pass
 
         self.broadcast('*** %s has left chat ***\n' % name)
         self._clients.remove(self)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=ChatClient.handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/callback_math_server.py` & `asyncssh-2.9.0/examples/callback_math_server.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -30,48 +30,49 @@
 import asyncio, asyncssh, sys
 
 class MySSHServerSession(asyncssh.SSHServerSession):
     def __init__(self):
         self._input = ''
         self._total = 0
 
-    def connection_made(self, chan):
+    def connection_made(self, chan: asyncssh.SSHServerChannel):
         self._chan = chan
 
-    def shell_requested(self):
+    def shell_requested(self) -> bool:
         return True
 
-    def session_started(self):
+    def session_started(self) -> None:
         self._chan.write('Enter numbers one per line, or EOF when done:\n')
 
-    def data_received(self, data, datatype):
+    def data_received(self, data: str, datatype: asyncssh.DataType) -> None:
         self._input += data
 
         lines = self._input.split('\n')
         for line in lines[:-1]:
             try:
                 if line:
                     self._total += int(line)
             except ValueError:
                 self._chan.write_stderr('Invalid number: %s\n' % line)
 
         self._input = lines[-1]
 
-    def eof_received(self):
+    def eof_received(self) -> bool:
         self._chan.write('Total = %s\n' % self._total)
         self._chan.exit(0)
+        return False
 
-    def break_received(self, msec):
-        self.eof_received()
+    def break_received(self, msec: int) -> bool:
+        return self.eof_received()
 
 class MySSHServer(asyncssh.SSHServer):
-    def session_requested(self):
+    def session_requested(self) -> asyncssh.SSHServerSession:
         return MySSHServerSession()
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.create_server(MySSHServer, '', 8022,
                                  server_host_keys=['ssh_host_key'],
                                  authorized_client_keys='ssh_user_ca')
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/chroot_sftp_server.py` & `asyncssh-2.9.0/examples/chroot_sftp_server.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2016-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -26,20 +26,20 @@
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, os, sys
 
 class MySFTPServer(asyncssh.SFTPServer):
-    def __init__(self, chan):
+    def __init__(self, chan: asyncssh.SSHServerChannel):
         root = '/tmp/sftp/' + chan.get_extra_info('username')
         os.makedirs(root, exist_ok=True)
         super().__init__(chan, chroot=root)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           sftp_factory=MySFTPServer)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/set_terminal.py` & `asyncssh-2.9.0/examples/set_terminal.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,15 +18,15 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         result = await conn.run('echo $TERM; stty size',
                                 term_type='xterm-color',
                                 term_size=(80, 24))
         print(result.stdout, end='')
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/simple_cert_server.py` & `asyncssh-2.9.0/examples/simple_cert_server.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,20 +25,20 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-def handle_client(process):
+def handle_client(process: asyncssh.SSHServerProcess) -> None:
     process.stdout.write('Welcome to my SSH server, %s!\n' %
                          process.get_extra_info('username'))
     process.exit(0)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/redirect_server.py` & `asyncssh-2.9.0/examples/redirect_server.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2017-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2017-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,24 +25,24 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, subprocess, sys
 
-async def handle_client(process):
+async def handle_client(process: asyncssh.SSHServerProcess) -> None:
     bc_proc = subprocess.Popen('bc', shell=True, stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
 
     await process.redirect(stdin=bc_proc.stdin, stdout=bc_proc.stdout,
                            stderr=bc_proc.stderr)
     await process.stdout.drain()
     process.exit(0)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/callback_client.py` & `asyncssh-2.9.0/examples/callback_client.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,31 +17,32 @@
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
+from typing import Optional
 
 class MySSHClientSession(asyncssh.SSHClientSession):
-    def data_received(self, data, datatype):
+    def data_received(self, data: str, datatype: asyncssh.DataType) -> None:
         print(data, end='')
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         if exc:
             print('SSH session error: ' + str(exc), file=sys.stderr)
 
 class MySSHClient(asyncssh.SSHClient):
-    def connection_made(self, conn):
+    def connection_made(self, conn: asyncssh.SSHClientConnection) -> None:
         print('Connection made to %s.' % conn.get_extra_info('peername')[0])
 
-    def auth_completed(self):
+    def auth_completed(self) -> None:
         print('Authentication successful.')
 
-async def run_client():
+async def run_client() -> None:
     conn, client = await asyncssh.create_connection(MySSHClient, 'localhost')
 
     async with conn:
         chan, session = await conn.create_session(MySSHClientSession, 'ls abc')
         await chan.wait_closed()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/stream_listening_client.py` & `asyncssh-2.9.0/examples/stream_listening_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
```

### Comparing `asyncssh-2.8.1/examples/sftp_client.py` & `asyncssh-2.9.0/examples/redirect_input.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2015-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,16 +18,15 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        async with conn.start_sftp_client() as sftp:
-            await sftp.get('example.txt')
+        await conn.run('tail -r', input='1\n2\n3\n', stdout='/tmp/stdout')
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
-    sys.exit('SFTP operation failed: ' + str(exc))
+    sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/listening_client.py` & `asyncssh-2.9.0/examples/listening_client.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -19,31 +19,32 @@
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
 class MySSHTCPSession(asyncssh.SSHTCPSession):
-    def connection_made(self, chan):
+    def connection_made(self, chan: asyncssh.SSHTCPChannel) -> None:
         self._chan = chan
 
-    def data_received(self, data, datatype):
+    def data_received(self, data: bytes, datatype: asyncssh.DataType):
         self._chan.write(data)
 
-def connection_requested(orig_host, orig_port):
+def connection_requested(orig_host: str,
+                         orig_port: int) -> asyncssh.SSHTCPSession:
     print('Connection received from %s, port %s' % (orig_host, orig_port))
     return MySSHTCPSession()
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         server = await conn.create_server(connection_requested, '', 8888,
                                           encoding='utf-8')
 
         if server:
             await server.wait_closed()
         else:
-            print('Listener couldn''t be opened.', file=sys.stderr)
+            print('Listener couldn\'t be opened.', file=sys.stderr)
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/check_exit_status.py` & `asyncssh-2.9.0/examples/check_exit_status.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,22 +18,22 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         result = await conn.run('ls abc')
 
         if result.exit_status == 0:
             print(result.stdout, end='')
         else:
             print(result.stderr, end='', file=sys.stderr)
-            print('Program exited with status %d' % result.exit_status,
+            print(f'Program exited with status {result.exit_status}',
                   file=sys.stderr)
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/direct_server.py` & `asyncssh-2.9.0/examples/simple_sftp_server.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,36 +25,20 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-class MySSHTCPSession(asyncssh.SSHTCPSession):
-    def connection_made(self, chan):
-        self._chan = chan
-
-    def data_received(self, data, datatype):
-        self._chan.write(data)
-
-class MySSHServer(asyncssh.SSHServer):
-    def connection_requested(self, dest_host, dest_port, orig_host, orig_port):
-        if dest_port == 7:
-            return MySSHTCPSession()
-        else:
-            raise asyncssh.ChannelOpenError(
-                      asyncssh.OPEN_ADMINISTRATIVELY_PROHIBITED,
-                      'Only echo connections allowed')
-
-async def start_server():
-    await asyncssh.create_server(MySSHServer, '', 8022,
-                                 server_host_keys=['ssh_host_key'],
-                                 authorized_client_keys='ssh_user_ca')
+async def start_server() -> None:
+    await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
+                          authorized_client_keys='ssh_user_ca',
+                          sftp_factory=True)
 
 loop = asyncio.get_event_loop()
 
 try:
     loop.run_until_complete(start_server())
 except (OSError, asyncssh.Error) as exc:
-    sys.exit('SSH server failed: ' + str(exc))
+    sys.exit('Error starting server: ' + str(exc))
 
 loop.run_forever()
```

### Comparing `asyncssh-2.8.1/examples/show_terminal.py` & `asyncssh-2.9.0/examples/show_terminal.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,15 +25,15 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-async def handle_client(process):
+async def handle_client(process: asyncssh.SSHServerProcess) -> None:
     width, height, pixwidth, pixheight = process.term_size
 
     process.stdout.write('Terminal type: %s, size: %sx%s' %
                          (process.term_type, width, height))
     if pixwidth and pixheight:
         process.stdout.write(' (%sx%s pixels)' % (pixwidth, pixheight))
     process.stdout.write('\nTry resizing your window!\n')
@@ -45,15 +45,15 @@
             process.stdout.write('New window size: %sx%s' %
                                  (exc.width, exc.height))
             if exc.pixwidth and exc.pixheight:
                 process.stdout.write(' (%sx%s pixels)' %
                                      (exc.pixwidth, exc.pixheight))
             process.stdout.write('\n')
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/remote_forwarding_client.py` & `asyncssh-2.9.0/examples/remote_forwarding_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,15 +18,15 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         listener = await conn.forward_remote_port('', 8080, 'localhost', 80)
         await listener.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
```

### Comparing `asyncssh-2.8.1/examples/set_environment.py` & `asyncssh-2.9.0/examples/callback_client3.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,18 +17,29 @@
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
+from typing import Optional
 
-async def run_client():
+class MySSHClientSession(asyncssh.SSHClientSession):
+    def data_received(self, data: str, datatype: asyncssh.DataType) -> None:
+        if datatype == asyncssh.EXTENDED_DATA_STDERR:
+            print(data, end='', file=sys.stderr)
+        else:
+            print(data, end='')
+
+    def connection_lost(self, exc: Optional[Exception]) -> None:
+        if exc:
+            print('SSH session error: ' + str(exc), file=sys.stderr)
+
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        result = await conn.run('env', env={'LANG': 'en_GB',
-                                            'LC_COLLATE': 'C'})
-        print(result.stdout, end='')
+        chan, session = await conn.create_session(MySSHClientSession, 'ls abc')
+        await chan.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/local_forwarding_server.py` & `asyncssh-2.9.0/examples/local_forwarding_server.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -26,23 +26,24 @@
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
 class MySSHServer(asyncssh.SSHServer):
-    def connection_requested(self, dest_host, dest_port, orig_host, orig_port):
+    def connection_requested(self, dest_host: str, dest_port: int,
+                             orig_host: str, orig_port: int) -> bool:
         if dest_port == 80:
             return True
         else:
             raise asyncssh.ChannelOpenError(
                       asyncssh.OPEN_ADMINISTRATIVELY_PROHIBITED,
                       'Only connections to port 80 are allowed')
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.create_server(MySSHServer, '', 8022,
                                  server_host_keys=['ssh_host_key'],
                                  authorized_client_keys='ssh_user_ca')
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/simple_scp_server.py` & `asyncssh-2.9.0/examples/simple_scp_server.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2015-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2015-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,15 +25,15 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           sftp_factory=True, allow_scp=True)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/gather_results.py` & `asyncssh-2.9.0/examples/gather_results.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2016-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,19 +18,19 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh
 
-async def run_client(host, command):
+async def run_client(host, command: str) -> asyncssh.SSHCompletedProcess:
     async with asyncssh.connect(host) as conn:
         return await conn.run(command)
 
-async def run_multiple_clients():
+async def run_multiple_clients() -> None:
     # Put your lists of hosts here
     hosts = 5 * ['localhost']
 
     tasks = (run_client(host, 'ls abc') for host in hosts)
     results = await asyncio.gather(*tasks, return_exceptions=True)
 
     for i, result in enumerate(results, 1):
```

### Comparing `asyncssh-2.8.1/examples/math_client.py` & `asyncssh-2.9.0/examples/redirect_remote_pipe.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2016-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,19 +18,17 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        async with conn.create_process('bc') as process:
-            for op in ['2+2', '1*2*3*4', '2^32']:
-                process.stdin.write(op + '\n')
-                result = await process.stdout.readline()
-                print(op, '=', result, end='')
+        proc1 = await conn.create_process(r'echo "1\n2\n3"')
+        proc2_result = await conn.run('tail -r', stdin=proc1.stdout)
+        print(proc2_result.stdout, end='')
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/stream_direct_client.py` & `asyncssh-2.9.0/examples/stream_direct_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,15 +18,15 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
         reader, writer = await conn.open_connection('www.google.com', 80)
 
         # By default, TCP connections send and receive bytes
         writer.write(b'HEAD / HTTP/1.0\r\n\r\n')
         writer.write_eof()
```

### Comparing `asyncssh-2.8.1/examples/reverse_client.py` & `asyncssh-2.9.0/examples/reverse_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.8
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -29,27 +29,29 @@
 # list of trusted server keys or a cert-authority entry with a public key
 # trusted to sign server keys if certificates are used. This file should
 # be in "authorized_keys" format.
 
 import asyncio, asyncssh, sys
 from asyncio.subprocess import PIPE
 
-async def handle_request(process):
+async def handle_request(process: asyncssh.SSHServerProcess) -> None:
     """Run a command on the client, piping I/O over an SSH session"""
 
+    assert process.command is not None
+
     local_proc = await asyncio.create_subprocess_shell(
         process.command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
 
     await process.redirect(stdin=local_proc.stdin, stdout=local_proc.stdout,
                            stderr=local_proc.stderr)
 
     process.exit(await local_proc.wait())
     await process.wait_closed()
 
-async def run_reverse_client():
+async def run_reverse_client() -> None:
     """Make an outbound connection and then become an SSH server on it"""
 
     conn = await asyncssh.connect_reverse(
         'localhost', 8022, server_host_keys=['client_host_key'],
         authorized_client_keys='trusted_server_keys',
         process_factory=handle_request, encoding=None)
```

### Comparing `asyncssh-2.8.1/examples/simple_server.py` & `asyncssh-2.9.0/examples/simple_server.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -21,47 +21,48 @@
 #     Ron Frederick - initial implementation, API, and documentation
 
 # To run this program, the file ``ssh_host_key`` must exist with an SSH
 # private key in it to use as a server host key. An SSH host certificate
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 
 import asyncio, asyncssh, crypt, sys
+from typing import Optional
 
 passwords = {'guest': '',                 # guest account with no password
              'user123': 'qV2iEadIGV2rw'   # password of 'secretpw'
             }
 
-def handle_client(process):
+def handle_client(process: asyncssh.SSHServerProcess) -> None:
     process.stdout.write('Welcome to my SSH server, %s!\n' %
                          process.get_extra_info('username'))
     process.exit(0)
 
 class MySSHServer(asyncssh.SSHServer):
-    def connection_made(self, conn):
+    def connection_made(self, conn: asyncssh.SSHServerConnection) -> None:
         print('SSH connection received from %s.' %
                   conn.get_extra_info('peername')[0])
 
-    def connection_lost(self, exc):
+    def connection_lost(self, exc: Optional[Exception]) -> None:
         if exc:
             print('SSH connection error: ' + str(exc), file=sys.stderr)
         else:
             print('SSH connection closed.')
 
-    def begin_auth(self, username):
+    def begin_auth(self, username: str) -> bool:
         # If the user's password is the empty string, no auth is required
         return passwords.get(username) != ''
 
-    def password_auth_supported(self):
+    def password_auth_supported(self) -> bool:
         return True
 
-    def validate_password(self, username, password):
+    def validate_password(self, username: str, password: str) -> bool:
         pw = passwords.get(username, '*')
         return crypt.crypt(password, pw) == pw
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.create_server(MySSHServer, '', 8022,
                                  server_host_keys=['ssh_host_key'],
                                  process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/redirect_remote_pipe.py` & `asyncssh-2.9.0/examples/direct_client.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -17,18 +17,33 @@
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
+from typing import Optional
 
-async def run_client():
+class MySSHTCPSession(asyncssh.SSHTCPSession):
+    def data_received(self, data: bytes, datatype: asyncssh.DataType) -> None:
+        # We use sys.stdout.buffer here because we're writing bytes
+        sys.stdout.buffer.write(data)
+
+    def connection_lost(self, exc: Optional[Exception]) -> None:
+        if exc:
+            print('Direct connection error:', str(exc), file=sys.stderr)
+
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        proc1 = await conn.create_process(r'echo "1\n2\n3"')
-        proc2_result = await conn.run('tail -r', stdin=proc1.stdout)
-        print(proc2_result.stdout, end='')
+        chan, session = await conn.create_connection(MySSHTCPSession,
+                                                     'www.google.com', 80)
+
+        # By default, TCP connections send and receive bytes
+        chan.write(b'HEAD / HTTP/1.0\r\n\r\n')
+        chan.write_eof()
+
+        await chan.wait_closed()
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/editor.py` & `asyncssh-2.9.0/examples/editor.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -24,32 +24,35 @@
 # private key in it to use as a server host key. An SSH host certificate
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
+from typing import cast
+
+async def handle_client(process: asyncssh.SSHServerProcess):
+    channel = cast(asyncssh.SSHLineEditorChannel, process.channel)
 
-async def handle_client(process):
     process.stdout.write('Welcome to my SSH server, %s!\n\n' %
                          process.get_extra_info('username'))
 
-    process.channel.set_echo(False)
+    channel.set_echo(False)
     process.stdout.write('Tell me a secret: ')
     secret = await process.stdin.readline()
 
-    process.stdin.channel.set_line_mode(False)
+    channel.set_line_mode(False)
     process.stdout.write('\nYour secret is safe with me! '
                          'Press any key to exit...')
     await process.stdin.read(1)
 
     process.stdout.write('\n')
     process.exit(0)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/local_forwarding_client.py` & `asyncssh-2.9.0/asyncssh/agent_unix.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,8 @@
-#!/usr/bin/env python3.6
-#
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -16,18 +14,27 @@
 #    that license
 #
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
-import asyncio, asyncssh, sys
+"""SSH agent support code for UNIX"""
+
+import asyncio
+import errno
+from typing import TYPE_CHECKING, Optional, Tuple
+
+
+if TYPE_CHECKING:
+    # pylint: disable=cyclic-import
+    from .agent import AgentReader, AgentWriter
+
+
+async def open_agent(agent_path: Optional[str]) -> \
+        Tuple['AgentReader', 'AgentWriter']:
+    """Open a connection to ssh-agent"""
+
+    if not agent_path:
+        raise OSError(errno.ENOENT, 'Agent not found')
 
-async def run_client():
-    async with asyncssh.connect('localhost') as conn:
-        listener = await conn.forward_local_port('', 8080, 'www.google.com', 80)
-        await listener.wait_closed()
-
-try:
-    asyncio.get_event_loop().run_until_complete(run_client())
-except (OSError, asyncssh.Error) as exc:
-    sys.exit('SSH connection failed: ' + str(exc))
+    return await asyncio.open_unix_connection(agent_path)
```

### Comparing `asyncssh-2.8.1/examples/simple_sftp_server.py` & `asyncssh-2.9.0/examples/direct_server.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2015-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,20 +25,38 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-async def start_server():
-    await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
-                          authorized_client_keys='ssh_user_ca',
-                          sftp_factory=True)
+class MySSHTCPSession(asyncssh.SSHTCPSession):
+    def connection_made(self, chan: asyncssh.SSHTCPChannel) -> None:
+        self._chan = chan
+
+    def data_received(self, data: bytes, datatype: asyncssh.DataType) -> None:
+        self._chan.write(data)
+
+class MySSHServer(asyncssh.SSHServer):
+    def connection_requested(self, dest_host: str, dest_port: int,
+                             orig_host: str, orig_port: int) -> \
+            asyncssh.SSHTCPSession:
+        if dest_port == 7:
+            return MySSHTCPSession()
+        else:
+            raise asyncssh.ChannelOpenError(
+                asyncssh.OPEN_ADMINISTRATIVELY_PROHIBITED,
+                'Only echo connections allowed')
+
+async def start_server() -> None:
+    await asyncssh.create_server(MySSHServer, '', 8022,
+                                 server_host_keys=['ssh_host_key'],
+                                 authorized_client_keys='ssh_user_ca')
 
 loop = asyncio.get_event_loop()
 
 try:
     loop.run_until_complete(start_server())
 except (OSError, asyncssh.Error) as exc:
-    sys.exit('Error starting server: ' + str(exc))
+    sys.exit('SSH server failed: ' + str(exc))
 
 loop.run_forever()
```

### Comparing `asyncssh-2.8.1/examples/remote_forwarding_server.py` & `asyncssh-2.9.0/examples/remote_forwarding_server.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -26,18 +26,18 @@
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
 class MySSHServer(asyncssh.SSHServer):
-    def server_requested(self, listen_host, listen_port):
+    def server_requested(self, listen_host: str, listen_port: int) -> bool:
         return listen_port == 8080
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.create_server(MySSHServer, '', 8022,
                                  server_host_keys=['ssh_host_key'],
                                  authorized_client_keys='ssh_user_ca')
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/stream_direct_server.py` & `asyncssh-2.9.0/examples/stream_direct_server.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,35 +25,38 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-async def handle_connection(reader, writer):
+async def handle_connection(reader: asyncssh.SSHReader,
+                            writer: asyncssh.SSHWriter) -> None:
     while not reader.at_eof():
         data = await reader.read(8192)
 
         try:
             writer.write(data)
         except BrokenPipeError:
             break
 
     writer.close()
 
 class MySSHServer(asyncssh.SSHServer):
-    def connection_requested(self, dest_host, dest_port, orig_host, orig_port):
+    def connection_requested(self, dest_host: str, dest_port: int,
+                             orig_host: str, orig_port: int) -> \
+            asyncssh.SSHSocketSessionFactory:
         if dest_port == 7:
             return handle_connection
         else:
             raise asyncssh.ChannelOpenError(
                       asyncssh.OPEN_ADMINISTRATIVELY_PROHIBITED,
                       'Only echo connections allowed')
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.create_server(MySSHServer, '', 8022,
                                  server_host_keys=['ssh_host_key'],
                                  authorized_client_keys='ssh_user_ca')
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/math_server.py` & `asyncssh-2.9.0/examples/math_server.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -25,15 +25,15 @@
 # can optionally be provided in the file ``ssh_host_key-cert.pub``.
 #
 # The file ``ssh_user_ca`` must exist with a cert-authority entry of
 # the certificate authority which can sign valid client certificates.
 
 import asyncio, asyncssh, sys
 
-async def handle_client(process):
+async def handle_client(process: asyncssh.SSHServerProcess) -> None:
     process.stdout.write('Enter numbers one per line, or EOF when done:\n')
 
     total = 0
 
     try:
         async for line in process.stdin:
             line = line.rstrip('\n')
@@ -44,15 +44,15 @@
                     process.stderr.write('Invalid number: %s\n' % line)
     except asyncssh.BreakReceived:
         pass
 
     process.stdout.write('Total = %s\n' % total)
     process.exit(0)
 
-async def start_server():
+async def start_server() -> None:
     await asyncssh.listen('', 8022, server_host_keys=['ssh_host_key'],
                           authorized_client_keys='ssh_user_ca',
                           process_factory=handle_client)
 
 loop = asyncio.get_event_loop()
 
 try:
```

### Comparing `asyncssh-2.8.1/examples/simple_client.py` & `asyncssh-2.9.0/examples/math_client.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.6
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2016-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -18,16 +18,19 @@
 # SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
 #
 # Contributors:
 #     Ron Frederick - initial implementation, API, and documentation
 
 import asyncio, asyncssh, sys
 
-async def run_client():
+async def run_client() -> None:
     async with asyncssh.connect('localhost') as conn:
-        result = await conn.run('ls abc', check=True)
-        print(result.stdout, end='')
+        async with conn.create_process('bc') as process:
+            for op in ['2+2', '1*2*3*4', '2^32']:
+                process.stdin.write(op + '\n')
+                result = await process.stdout.readline()
+                print(op, '=', result, end='')
 
 try:
     asyncio.get_event_loop().run_until_complete(run_client())
 except (OSError, asyncssh.Error) as exc:
     sys.exit('SSH connection failed: ' + str(exc))
```

### Comparing `asyncssh-2.8.1/examples/reverse_server.py` & `asyncssh-2.9.0/examples/reverse_server.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3.8
 #
-# Copyright (c) 2013-2018 by Ron Frederick <ronf@timeheart.net> and others.
+# Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
 #
 # This program and the accompanying materials are made available under
 # the terms of the Eclipse Public License v2.0 which accompanies this
 # distribution and is available at:
 #
 #     http://www.eclipse.org/legal/epl-2.0/
 #
@@ -28,15 +28,15 @@
 # The file trusted_client_host_keys must also exist on the server, containing
 # a list of trusted client host keys or a @cert-authority entry with a public
 # key trusted to sign client host keys if certificates are used. This file
 # should be in "known_hosts" format.
 
 import asyncio, asyncssh, sys
 
-async def run_commands(conn):
+async def run_commands(conn: asyncssh.SSHClientConnection) -> None:
     """Run a series of commands on the client which connected to us"""
 
     commands = ('ls', 'sleep 30 && date', 'sleep 5 && cat /proc/cpuinfo')
 
     async with conn:
         tasks = [conn.run(cmd) for cmd in commands]
 
@@ -46,15 +46,15 @@
             print('Return code:', result.returncode)
             print('Stdout:')
             print(result.stdout, end='')
             print('Stderr:')
             print(result.stderr, end='')
             print(75*'-')
 
-async def start_reverse_server():
+async def start_reverse_server() -> None:
     """Accept inbound connections and then become an SSH client on them"""
 
     await asyncssh.listen_reverse(port=8022, client_keys=['server_key'],
                                   known_hosts='trusted_client_host_keys',
                                   acceptor=run_commands)
 
 loop = asyncio.get_event_loop()
```

### Comparing `asyncssh-2.8.1/tox.ini` & `asyncssh-2.9.0/tox.ini`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/pylintrc` & `asyncssh-2.9.0/pylintrc`

 * *Files 1% similar despite different names*

```diff
@@ -91,15 +91,15 @@
 
 [BASIC]
 
 # List of builtins function names that should not be used, separated by a comma
 bad-functions=map,filter
 
 # Good variable names which should always be accepted, separated by a comma
-good-names=A,B,D,I,a,av,b,c,ca,ch,cn,d,e,f,fd,fp,fs,g,h,i,id,ip,iv,j,k,l,n,p,q,r,rp,s,sa,t,v,x,y,_,_e,_f,_g,_k,_p,_q,_x
+good-names=A,B,D,I,a,av,b,c,ca,ch,cn,d,e,f,fd,fp,fs,g,h,i,id,ip,iv,j,k,l,n,ns,p,q,r,rp,s,sa,t,v,x,y,_,_e,_f,_g,_k,_p,_q,_x
 
 # Bad variable names which should always be refused, separated by a comma
 bad-names=
 
 # Colon-delimited sets of names that determine each other's naming style when
 # the name regexes allow several styles.
 name-group=
@@ -188,15 +188,15 @@
 # else.
 single-line-if-stmt=no
 
 # List of optional constructs for which whitespace checking is disabled
 no-space-check=trailing-comma,dict-separator
 
 # Maximum number of lines in a module
-max-module-lines=7500
+max-module-lines=10000
 
 # String used as indentation unit. This is usually " " (4 spaces) or "\t" (1
 # tab).
 indent-string='    '
 
 # Number of spaces of indent required inside a hanging or continued line.
 indent-after-paren=4
@@ -341,15 +341,15 @@
 # Maximum number of attributes for a class (see R0902).
 max-attributes=150
 
 # Minimum number of public methods for a class (see R0903).
 min-public-methods=0
 
 # Maximum number of public methods for a class (see R0904).
-max-public-methods=50
+max-public-methods=250
 
 
 [IMPORTS]
 
 # Deprecated modules which should not be used, separated by a comma
 deprecated-modules=stringprep,optparse
```

### Comparing `asyncssh-2.8.1/.travis/install.sh` & `asyncssh-2.9.0/.travis/install.sh`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/asyncssh.egg-info/PKG-INFO` & `asyncssh-2.9.0/asyncssh.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: asyncssh
-Version: 2.8.1
+Version: 2.9.0
 Summary: AsyncSSH: Asynchronous SSHv2 client and server library
 Home-page: http://asyncssh.timeheart.net
 Author: Ron Frederick
 Author-email: ronf@timeheart.net
 License: Eclipse Public License v2.0
 Platform: Any
 Classifier: Development Status :: 5 - Production/Stable
@@ -65,14 +65,17 @@
   * Direct and forwarded TCP/IP channels
   * OpenSSH-compatible direct and forwarded UNIX domain socket channels
   * Local and remote TCP/IP port forwarding
   * Local and remote UNIX domain socket forwarding
   * Dynamic TCP/IP port forwarding via SOCKS
   * X11 forwarding support on both the client and the server
   * SFTP protocol version 3 with OpenSSH extensions
+
+    * Experimental support for SFTP versions 4-6, when requested
+
   * SCP protocol support, including third-party remote to remote copies
 
 * Multiple simultaneous sessions on a single SSH connection
 * Multiple SSH connections in a single event loop
 * Byte and string based I/O with settable encoding
 * A variety of `key exchange`__, `encryption`__, and `MAC`__ algorithms
 * Support for `gzip compression`__
@@ -113,15 +116,15 @@
 __ http://asyncssh.readthedocs.io/en/stable/api.html#config-file-support
 
 License
 -------
 
 This package is released under the following terms:
 
-  Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
+  Copyright (c) 2013-2022 by Ron Frederick <ronf@timeheart.net> and others.
 
   This program and the accompanying materials are made available under
   the terms of the Eclipse Public License v2.0 which accompanies this
   distribution and is available at:
 
     http://www.eclipse.org/legal/epl-2.0/
```

### Comparing `asyncssh-2.8.1/asyncssh.egg-info/SOURCES.txt` & `asyncssh-2.9.0/asyncssh.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 .travis.yml
 CONTRIBUTING.rst
 COPYRIGHT
 LICENSE
 MANIFEST.in
 README.rst
 appveyor.yml
+mypy.ini
 pylintrc
 setup.py
 tox.ini
 .travis/install.sh
 asyncssh/__init__.py
 asyncssh/agent.py
 asyncssh/agent_unix.py
@@ -44,14 +45,15 @@
 asyncssh/misc.py
 asyncssh/packet.py
 asyncssh/pattern.py
 asyncssh/pbe.py
 asyncssh/pkcs11.py
 asyncssh/process.py
 asyncssh/public_key.py
+asyncssh/py.typed
 asyncssh/rsa.py
 asyncssh/saslprep.py
 asyncssh/scp.py
 asyncssh/server.py
 asyncssh/session.py
 asyncssh/sftp.py
 asyncssh/sk.py
```

### Comparing `asyncssh-2.8.1/COPYRIGHT` & `asyncssh-2.9.0/COPYRIGHT`

 * *Files identical despite different names*

### Comparing `asyncssh-2.8.1/README.rst` & `asyncssh-2.9.0/README.rst`

 * *Files 2% similar despite different names*

```diff
@@ -33,14 +33,17 @@
   * Direct and forwarded TCP/IP channels
   * OpenSSH-compatible direct and forwarded UNIX domain socket channels
   * Local and remote TCP/IP port forwarding
   * Local and remote UNIX domain socket forwarding
   * Dynamic TCP/IP port forwarding via SOCKS
   * X11 forwarding support on both the client and the server
   * SFTP protocol version 3 with OpenSSH extensions
+
+    * Experimental support for SFTP versions 4-6, when requested
+
   * SCP protocol support, including third-party remote to remote copies
 
 * Multiple simultaneous sessions on a single SSH connection
 * Multiple SSH connections in a single event loop
 * Byte and string based I/O with settable encoding
 * A variety of `key exchange`__, `encryption`__, and `MAC`__ algorithms
 * Support for `gzip compression`__
@@ -81,15 +84,15 @@
 __ http://asyncssh.readthedocs.io/en/stable/api.html#config-file-support
 
 License
 -------
 
 This package is released under the following terms:
 
-  Copyright (c) 2013-2021 by Ron Frederick <ronf@timeheart.net> and others.
+  Copyright (c) 2013-2022 by Ron Frederick <ronf@timeheart.net> and others.
 
   This program and the accompanying materials are made available under
   the terms of the Eclipse Public License v2.0 which accompanies this
   distribution and is available at:
 
     http://www.eclipse.org/legal/epl-2.0/
```

### Comparing `asyncssh-2.8.1/.travis.yml` & `asyncssh-2.9.0/.travis.yml`

 * *Files identical despite different names*

