# Comparing `tmp/frc_apriltags-1.3.0-py3-none-any.whl.zip` & `tmp/frc_apriltags-1.3.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,21 @@
-Zip file size: 24963 bytes, number of entries: 19
--rw-r--r--  2.0 unx     1223 b- defN 23-Apr-17 00:07 frc_apriltags/__init__.py
--rw-r--r--  2.0 unx    10339 b- defN 23-Apr-17 00:07 frc_apriltags/apriltags.py
--rw-r--r--  2.0 unx    10915 b- defN 23-Apr-17 00:07 frc_apriltags/calibration.py
--rw-r--r--  2.0 unx     7561 b- defN 23-Apr-17 00:07 frc_apriltags/camera.py
--rw-r--r--  2.0 unx     2600 b- defN 23-Apr-17 00:07 frc_apriltags/communications.py
--rw-r--r--  2.0 unx     2950 b- defN 23-Apr-17 00:07 frc_apriltags/stream.py
--rw-r--r--  2.0 unx     2633 b- defN 23-Apr-17 00:07 frc_apriltags/Tag_Layouts/2023-chargedup.json
--rw-r--r--  2.0 unx      178 b- defN 23-Apr-17 00:07 frc_apriltags/Tag_Layouts/__init__.py
--rw-r--r--  2.0 unx     3279 b- defN 23-Apr-17 00:07 frc_apriltags/Utilities/AprilTag.py
--rw-r--r--  2.0 unx     5345 b- defN 23-Apr-17 00:07 frc_apriltags/Utilities/AprilTagFieldLayout.py
--rw-r--r--  2.0 unx     1729 b- defN 23-Apr-17 00:07 frc_apriltags/Utilities/Logger.py
--rw-r--r--  2.0 unx     4856 b- defN 23-Apr-17 00:07 frc_apriltags/Utilities/MathUtil.py
--rw-r--r--  2.0 unx     4430 b- defN 23-Apr-17 00:07 frc_apriltags/Utilities/Units.py
--rw-r--r--  2.0 unx      499 b- defN 23-Apr-17 00:07 frc_apriltags/Utilities/__init__.py
--rw-r--r--  2.0 unx     8789 b- defN 23-Apr-17 00:07 frc_apriltags-1.3.0.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx    12823 b- defN 23-Apr-17 00:07 frc_apriltags-1.3.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-17 00:07 frc_apriltags-1.3.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       14 b- defN 23-Apr-17 00:07 frc_apriltags-1.3.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1673 b- defN 23-Apr-17 00:07 frc_apriltags-1.3.0.dist-info/RECORD
-19 files, 81928 bytes uncompressed, 22203 bytes compressed:  72.9%
+Zip file size: 24782 bytes, number of entries: 19
+-rw-r--r--  2.0 unx     1518 b- defN 23-Jun-22 19:36 frc_apriltags/__init__.py
+-rw-r--r--  2.0 unx    10238 b- defN 23-Jun-22 19:36 frc_apriltags/apriltags.py
+-rw-r--r--  2.0 unx    10485 b- defN 23-Jun-22 19:36 frc_apriltags/calibration.py
+-rw-r--r--  2.0 unx     6389 b- defN 23-Jun-22 19:36 frc_apriltags/camera.py
+-rw-r--r--  2.0 unx     2587 b- defN 23-Jun-22 19:36 frc_apriltags/communications.py
+-rw-r--r--  2.0 unx     2937 b- defN 23-Jun-22 19:36 frc_apriltags/stream.py
+-rw-r--r--  2.0 unx     2633 b- defN 23-Jun-22 19:36 frc_apriltags/Tag_Layouts/2023-chargedup.json
+-rw-r--r--  2.0 unx      220 b- defN 23-Jun-22 19:36 frc_apriltags/Tag_Layouts/__init__.py
+-rw-r--r--  2.0 unx     3279 b- defN 23-Jun-22 19:36 frc_apriltags/Utilities/AprilTag.py
+-rw-r--r--  2.0 unx     5268 b- defN 23-Jun-22 19:36 frc_apriltags/Utilities/AprilTagFieldLayout.py
+-rw-r--r--  2.0 unx     1831 b- defN 23-Jun-22 19:36 frc_apriltags/Utilities/Logger.py
+-rw-r--r--  2.0 unx     4856 b- defN 23-Jun-22 19:36 frc_apriltags/Utilities/MathUtil.py
+-rw-r--r--  2.0 unx     4430 b- defN 23-Jun-22 19:36 frc_apriltags/Utilities/Units.py
+-rw-r--r--  2.0 unx      541 b- defN 23-Jun-22 19:36 frc_apriltags/Utilities/__init__.py
+-rw-r--r--  2.0 unx     8789 b- defN 23-Jun-22 19:36 frc_apriltags-1.3.1.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    12823 b- defN 23-Jun-22 19:36 frc_apriltags-1.3.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-22 19:36 frc_apriltags-1.3.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       14 b- defN 23-Jun-22 19:36 frc_apriltags-1.3.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1673 b- defN 23-Jun-22 19:36 frc_apriltags-1.3.1.dist-info/RECORD
+19 files, 80603 bytes uncompressed, 22022 bytes compressed:  72.7%
```

## zipnote {}

```diff
@@ -36,23 +36,23 @@
 
 Filename: frc_apriltags/Utilities/Units.py
 Comment: 
 
 Filename: frc_apriltags/Utilities/__init__.py
 Comment: 
 
-Filename: frc_apriltags-1.3.0.dist-info/LICENSE.txt
+Filename: frc_apriltags-1.3.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: frc_apriltags-1.3.0.dist-info/METADATA
+Filename: frc_apriltags-1.3.1.dist-info/METADATA
 Comment: 
 
-Filename: frc_apriltags-1.3.0.dist-info/WHEEL
+Filename: frc_apriltags-1.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: frc_apriltags-1.3.0.dist-info/top_level.txt
+Filename: frc_apriltags-1.3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: frc_apriltags-1.3.0.dist-info/RECORD
+Filename: frc_apriltags-1.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## frc_apriltags/__init__.py

```diff
@@ -1,9 +1,14 @@
-from importlib_metadata import PackageNotFoundError, version
+# Import libraries
+import time
+import ntcore
+from   networktables import NetworkTablesInstance
+from   importlib_metadata import PackageNotFoundError, version
 
+# Generate the version
 try:
     __version__ = version("frc-apriltags")
 except PackageNotFoundError:
     # Package is not installed
     pass
 
 # Import AprilTag related classes
@@ -19,31 +24,35 @@
     "Detector",
     "Calibrate",
     "NetworkCommunications",
     "USBCamera",
     "Streaming"
 ]
 
+# Starts the NetworkTables
 @staticmethod
 def startNetworkComms(teamNumber: int = 2199):
     """
     Starts an NT4 server and client for a specific team.
 
     :param teamNumber: Your FRC team's number.
     """
-    import time
-    import ntcore
-    from   networktables import NetworkTables
-
+    # Ensures that a team number is a least 4 character long
+    teamStr = str(teamNumber)
+    teamStr.zfill(4)
+ 
     # Waits for the Rio to start
     time.sleep(5)
 
+    # Gets the default NetworkTables instance
+    ntinst = NetworkTablesInstance.getDefault() # Get a NetworkTables Instance
+
     # Initializes the NetworkTables
-    NetworkTables.initialize(server = "roborio-" + str(teamNumber) + "-frc.local")
+    ntinst.initialize(server = "10." + teamStr[:2] + "." + teamStr[2:] + ".2")
 
     # Create the NT4 server and client
     nt = ntcore.NetworkTableInstance.getDefault()
     nt.setServerTeam(teamNumber)
     nt.startClient4(__file__)
 
     # Create the NetworkTables
-    NetworkTables.startClientTeam(teamNumber)
+    ntinst.startClientTeam(teamNumber)
```

## frc_apriltags/apriltags.py

```diff
@@ -3,15 +3,15 @@
 import numpy as np
 import pupil_apriltags
 from   wpilib import Timer
 from   wpimath.geometry import *
 from   frc_apriltags import NetworkCommunications
 
 # Import Utilities
-from frc_apriltags.Utilities import Logger, Units
+from .Utilities import Logger, Units
 
 # Creates the Detector Class
 class Detector:
     """
     Use this class to detect AprilTags from the tag16h5 family.
 
     :param size: The size of the AprilTag in inches.
@@ -23,50 +23,50 @@
         :param size: The size of the AprilTag in inches.
         """
         # Instance creation
         self.timer = Timer()
         self.comms = NetworkCommunications()
 
         # Creates a pupil apriltags detector
-        self.detector = pupil_apriltags.Detector(families = "tag16h5", nthreads = 10, quad_decimate = 1.0, quad_sigma = 0.0, refine_edges = 2.0, decode_sharpening = 1.00)
+        self.detector = pupil_apriltags.Detector(families = "tag16h5")
 
         # Variables
         self.tagSize   = Units.inchesToMeters(size)
         self.logStatus = False
 
         # Update logs
         Logger.logInfo("Detector initialized", True)
 
     def detectTags(self, stream, camera_matrix, vizualization: int = 0):
         """
-        Detects AprilTags in a stream using pupil_apriltags.
+        Detects AprilTags in a stream using ``pupil_apriltags``.
 
-        :param stream: The images generated by reading a VideoCapture.
+        :param stream: The images generated by reading a ``VideoCapture``.
         :param camera_matrix: The camera's intrinsic calibration matrix.
         :param vizualization: 0 - Highlight, 1 - Highlight + Boxes, 2 - Highlight + Axes, 3 - Highlight + Boxes + Axes.
         :return: The detection result.
         :return: The image.
         """
         # If the stream is not grayscale, create a grayscale copy
         if (len(stream.shape) == 3):
             gray = cv.cvtColor(stream, cv.COLOR_BGR2GRAY)
         else:
             gray = stream
 
         # Define the intrinsic parameters of the camera
         intrinsic_properties = (camera_matrix[0, 0], camera_matrix[1, 1], camera_matrix[0, 2], camera_matrix[1, 2])  # fx, fy, cx, cy
 
-        # Detect the AprilTags in the image with Pupil Apriltags
-        detections = self.detector.detect(gray, estimate_tag_pose = True, camera_params = intrinsic_properties, tag_size = self.tagSize)
+        # Detect the AprilTags in the image with pupil_apriltags
+        detections = self.detector.detect(img = gray, estimate_tag_pose = True, camera_params = intrinsic_properties, tag_size = self.tagSize)
 
         # Variables to use in detections
         results = []
         maxError = 1e-3
         maxHamming = 1
-        minConfidence = 30
+        minConfidence = 50
 
         # Variables to use in sorting the data
         best = None
         prevMargin = 0
 
         # Access the 3D pose of all detected tag
         for tag in detections:
@@ -137,15 +137,15 @@
 
         return results, stream
 
     def getPose3D(self, poseMatrix = None):
         """
         Calculates a WPILib ``Pose3d`` from the PupilApriltags matrix.
 
-        :param poseMatrix: A 3x4 ``numpy.ndarray()``.
+        :param poseMatrix: A 3x4 ``numpy.ndarray``.
         :return: A ``Pose3d`` object.
         """
         # Variables
         x, y, z = 0, 0, 0
 
         # Extract the tag data from the detection results
         if (poseMatrix is not None):
```

## frc_apriltags/calibration.py

```diff
@@ -1,15 +1,15 @@
 # Import Libraries
 import os
 import glob
 import cv2   as cv
 import numpy as np
 
 # Import Utilities
-from frc_apriltags.Utilities import Logger
+from .Utilities import Logger
 
 # Defines the dimensions of the chessboard
 CHESSBOARD = (8, 5)  # Number of interior corners (width in squares - 1 x height in squares - 1)
 
 # Default termination criteria
 criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)
 
@@ -45,15 +45,15 @@
         self.objp[0, :, :2] = np.mgrid[0:CHESSBOARD[0], 0:CHESSBOARD[1]].T.reshape(-1, 2) * 27.5
 
         # Arrays to store object and image points from all images
         self.objPoints = []  # 3D point in real world
         self.imgPoints = []  # 2D point in image plane
 
         # Path to calibration images
-        self.PATH = dirPath + "/camera{}-{}x{}-images/".format(self.camNum, self.width, self.height)
+        self.PATH = dirPath + f"/camera{self.camNum}-{self.width}x{self.height}-images/"
 
         # File extension
         self.EXTENSION = ".png"
 
         # Variables
         self.doOver    = False
         self.logStatus = False
@@ -127,33 +127,32 @@
         # Destroys all cached windows
         cv.destroyAllWindows()
 
         # Restarts the calibration if 1/2 of the images cannot be used for calibration
         if (imagesUsed < (self.calibrationImages * 1/2)):
             # Updates log
             Logger.logWarning("Calibration restarted", self.logStatus)
-            Logger.logInfo("Images found: {}".format(imagesUsed), self.logStatus)
+            Logger.logInfo(f"Images found: {imagesUsed}", self.logStatus)
 
             # Sets up for a do over
             self.doOver = True
 
             self.calibrateCamera()
         else:
-            Logger.logInfo("Images found: {}".format(imagesUsed), self.logStatus)
+            Logger.logInfo(f"Images found: {imagesUsed}", self.logStatus)
             self.doOver = False
 
         # Calibrate the camera by passing the value of known 3D points (objPoints) and corresponding pixel coordinates of the detected corners (imgPoints)
         self.ret, self.cameraMatrix, self.distortion, self.rVecs, self.tVecs = cv.calibrateCamera(self.objPoints, self.imgPoints, gray.shape[::-1], None, None)
 
         # Calculates the reprediction error
         repredictError = self.calculateRepredictionError()
 
         # Updates log
-        Logger.logInfo("Camera {} Calibrated".format(self.camNum), self.logStatus)
-        Logger.logInfo("Camera Properties: \nCamera Matrix: \n{}, \nDistortion Matrix: \n{}, \nRotation Vectors: \n{}, \nTranslation Vectors: \n{}, \nAverage Reprediction Value: {}".format(self.cameraMatrix, self.distortion, self.rVecs, self.tVecs, repredictError), self.logStatus)
+        Logger.logInfo(f"Camera {self.camNum} Calibrated", self.logStatus)
 
         # Return calibration results
         return self.ret, self.cameraMatrix, self.distortion, self.rVecs, self.tVecs
 
     def createCalibrationImages(self):
         """
         Creates a number of images to calibrate the camera.
@@ -163,15 +162,15 @@
 
         # Creates the calibration images
         for i in range(0, self.calibrationImages):
             # Seperates the enumeration from the naming
             j = i + 1
 
             # Prints target image
-            print("Attempting to take calibration image {}".format(j))
+            print(f"Attempting to take calibration image {j}")
 
             # Resets imgSelected
             imgSelected = False
 
             # Runs until the user presses p to take a picture
             while (imgSelected == False):
                 # Read the capture
@@ -202,32 +201,31 @@
 
                 # Press p to take a calibration image
                 if ( cv.waitKey(1) == ord("p") ):
                     # Converts the copy back into BGR
                     tempStream = cv.cvtColor(tempStream, cv.COLOR_RGB2BGR)
 
                     # Writes the image
-                    cv.imwrite(self.PATH + "{}".format(j) + self.EXTENSION, tempStream)
+                    cv.imwrite(self.PATH + f"{j}" + self.EXTENSION, tempStream)
 
                     # Prints the status
-                    print("Calibration image {} taken".format(j))
+                    print(f"Calibration image {j} taken")
 
                     # Updates log
-                    Logger.logInfo("Calibration image {} taken".format(j), self.logStatus)
+                    Logger.logInfo(f"Calibration image {j} taken", self.logStatus)
 
                     # Breaks the while loop
                     imgSelected = True
                     break
 
         # Destroys all windows
         cv.destroyAllWindows()
 
         # Updates log
-        Logger.logInfo("Calibration images generated", self.logStatus)
-        Logger.logInfo("Images stored at " +  self.PATH, self.logStatus)
+        Logger.logInfo("Calibration images stored at " +  self.PATH, self.logStatus)
 
     def getPathExistance(self) -> bool:
         """
         Gets the existance of a directory at self.PATH.
 
         :return: Is the directory present?
         """
@@ -235,15 +233,15 @@
         img = None
         pathExists = False
 
         # Attempts to make a directory at self.PATH
         try:
             os.mkdir(self.PATH)
         except Exception as e:
-            Logger.logError("{}".format(e), self.logStatus)
+            Logger.logError(f"{e}", self.logStatus)
 
         # Attempts to read the last callibration image and updates variables accordingly
         img = cv.imread(self.PATH + str(self.calibrationImages) + self.EXTENSION)
 
         # Determines if the calibration imgaes exist
         if (img is not None):
             pathExists = True
```

## frc_apriltags/camera.py

```diff
@@ -1,14 +1,14 @@
 # Import Libraries
 import cv2   as cv
 import numpy as np
 from   frc_apriltags import Calibrate
 
 # Import Utilities
-from frc_apriltags.Utilities import Logger
+from .Utilities import Logger
 
 # Creates the USBCamera class
 class USBCamera:
     """
     Use this class to create a USBCamera.
 
     :param camNumber: The camera number.
@@ -106,76 +106,40 @@
         """
         # Instance creation
         self.calibrate = Calibrate(self.cap, self.camNum, 15, dirPath)
 
         # Get results
         ret, self.camMatrix, self.camdistortion, rvecs, tvecs = self.calibrate.calibrateCamera()
 
-    def undistort(self):
-        """
-        Undistorts an image using cv.undistort().
-
-        :return: The undistorted stream.
-        """
-        # Creates a cameraMatrix
-        newCameraMatrix, roi = cv.getOptimalNewCameraMatrix(self.camMatrix, self.camdistortion, self.resolution, 1, self.resolution)
-
-        # Undistorts the image
-        undistortedStream = cv.undistort(self.getStream(), self.camMatrix, self.camdistortion, None, newCameraMatrix)
-
-        # Crops the image
-        x, y, w, h = roi
-        undistortedStream = undistortedStream[y:y+h, x:x+w]
-
-        return undistortedStream
-
-    def rectify(self):
-        """
-        Undistorts an image using cv.remap().
-
-        :return: The undistorted stream.
-        """
-        # Creates a cameraMatrix
-        newCameraMatrix, roi = cv.getOptimalNewCameraMatrix(self.camMatrix, self.camdistortion, self.resolution, 1, self.resolution)
-
-        # Unpacks the ROI data
-        x, y, w, h = roi
-
-        # Undistorts the image
-        mapx, mapy = cv.initUndistortRectifyMap(self.camMatrix, self.camdistortion, None, newCameraMatrix, (w,h), 5)
-        undistortedStream = cv.remap(self.getStream(), mapx, mapy, cv.INTER_LINEAR)
-
-        # Crop the image
-        undistortedStream = undistortedStream[y:y+h, x:x+w]
-
-        return undistortedStream
-
     def getStream(self):
         """
         Gets the stream from this camera's capture.
 
         :return: The stream.
         """
         # Reads the capture
         __, self.stream = self.cap.read()
 
         return self.stream
 
-    def getUndistortedStream(self, algorithm: int = 1):
+    def getUndistortedStream(self):
         """
         Gets the undistorted stream from this camera's capture.
 
-        :param algorithm: 0 to use ``cv.undistort()``, 1 to use ``cv.remap()``
         :return: The undistorted stream.
         """
-        # Undistorts the stream
-        if (algorithm == 0):
-            self.stream = self.undistort()
-        elif (algorithm == 1): 
-            self.stream = self.rectify()
+        # Creates a cameraMatrix
+        newCameraMatrix, roi = cv.getOptimalNewCameraMatrix(self.camMatrix, self.camdistortion, self.resolution, 1, self.resolution)
+
+        # Undistorts the image
+        undistortedStream = cv.undistort(self.getStream(), self.camMatrix, self.camdistortion, None, newCameraMatrix)
+
+        # Crops the image
+        x, y, w, h = roi
+        self.undistortedStream = undistortedStream[y:y+h, x:x+w]
 
         return self.stream
 
     def getEnd(self):
         """
         Gets if the program should end.
```

## frc_apriltags/communications.py

```diff
@@ -1,12 +1,12 @@
 # Import Libraries
 from networktables import *
 
 # Import Utilities
-from frc_apriltags.Utilities import Logger
+from .Utilities import Logger
 
 # Creates the NetworkCommunications Class
 class NetworkCommunications:
     """
     Use this class to communicate with the RoboRio over NetworkTables.
     """
     def __init__(self) -> None:
```

## frc_apriltags/stream.py

```diff
@@ -1,13 +1,13 @@
 # Import Libraries
 import numpy as np
 from   cscore import CameraServer as CS
 
 # Import Utilities
-from frc_apriltags.Utilities import Logger
+from .Utilities import Logger
 
 # Creates the BasicStreaming Class
 class Streaming():
     """
     Use this class to stream unprocessed images to the driver station.
 
     :param camNum: The camera number.
```

## frc_apriltags/Tag_Layouts/__init__.py

```diff
@@ -1,7 +1,9 @@
+# Import libraries
 from importlib_metadata import PackageNotFoundError, version
 
+# Generate the version
 try:
     __version__ = version("frc-apriltags")
 except PackageNotFoundError:
     # Package is not installed
     pass
```

## frc_apriltags/Utilities/AprilTagFieldLayout.py

```diff
@@ -3,16 +3,15 @@
 import numpy as np
 from   enum import Enum
 from   typing import Sequence
 from   importlib import resources
 from   wpimath.geometry import *
 
 # Import Utilities
-from frc_apriltags.Utilities import Logger
-from frc_apriltags.Utilities import AprilTag
+from Utilities import Logger, AprilTag
 
 # Creates the AprilTagFieldLayout class
 class AprilTagFieldLayout:
     """
     A class to store the positions of all known AprilTags
 
     :param tags: A list of all known tags.
@@ -34,28 +33,28 @@
         ;param isRed: If you are on the red alliance.
         """
         # Localize parameters
         self.fieldLength = fieldLength
         self.fieldWidth = fieldWidth
 
         # Logs the field size
-        Logger.logInfo("Field length: {}, Field width: {}".format(self.fieldLength, self.fieldWidth), True)
+        Logger.logInfo(f"Field length: {self.fieldLength}, Field width: {self.fieldWidth}", True)
 
         # Creates the allTags array
         self.allTags = [Pose3d()] * 9
 
         # Sorts the data from tags into allTags
         for tag in tags:
             id   = tag.getId()
             pose = tag.getPose()
 
             self.allTags[id] = pose
 
             # Logs the tag information
-            Logger.logInfo("Tag {}. Pose: {}".format(id, pose), True)
+            Logger.logInfo(f"Tag {id}. Pose: {pose}", True)
 
         # Variables
         self.m_origin  = None
         self.logStatus = False
 
         # Sets the origin depending on alliance
         if (isRed == True):
@@ -126,15 +125,15 @@
                 Rotation3d(0, 0, np.pi)
             )
         else:
             origin = None
             raise ValueError("Unsupported enumerator value.")
         
         # Logs the origin
-        Logger.logInfo("Origin at {}".format(origin), self.logStatus)
+        Logger.logInfo(f"Origin at {origin}", self.logStatus)
 
     def getTags(self):
         """
         Returns all the created tags
 
         :return: All the tags on the field.
         """
```

## frc_apriltags/Utilities/Logger.py

```diff
@@ -1,26 +1,30 @@
 # Created by Alex Pereira
 
 # Import Libraries
+import time
 import logging
 
 # Start of the Logging class
 class Logger:
     """
     Use this class to log an debug info you generate.
     """
     @staticmethod
     def setLogPath(dirPath: str = "/tmp/"):
         """
         Enables the logger.
 
         :param dirPath: Should be aquired by running ``Path(__file__).absolute().parent.__str__()`` in the script calling this method
         """
+        # Gets the time as a string
+        currTime = time.ctime().replace(" ", "_")[4:]
+
         # Starts a logger
-        logging.basicConfig(filename = dirPath + "/DetectionLog.log", format="%(levelname)s:%(message)s", encoding = "utf-8", level = logging.DEBUG)
+        logging.basicConfig(filename = dirPath + f"/{currTime}.log", format="%(levelname)s:%(message)s", encoding = "utf-8", level = logging.DEBUG)
 
     @staticmethod
     def logDebug(debug: str, logStatus: bool = True):
         """
         Logs a debug statement.
 
         :param debug: The debug message to log
```

## frc_apriltags/Utilities/__init__.py

```diff
@@ -1,9 +1,11 @@
+# Import libraries
 from importlib_metadata import PackageNotFoundError, version
 
+# Generate the version
 try:
     __version__ = version("frc-apriltags")
 except PackageNotFoundError:
     # Package is not installed
     pass
 
 # Import Utility classes
```

## Comparing `frc_apriltags-1.3.0.dist-info/LICENSE.txt` & `frc_apriltags-1.3.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `frc_apriltags-1.3.0.dist-info/METADATA` & `frc_apriltags-1.3.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: frc-apriltags
-Version: 1.3.0
+Version: 1.3.1
 Summary: AprilTag detection for FRC robots
 Author-email: Alex Pereira <robolionsgit@gmail.com>
 Maintainer-email: The Robo-Lions <robolionsgit@gmail.com>
 License: MIT License
         
         Copyright (c) 2022 - 2023 Alex Pereira, the Robo-Lions, and PIE3
```

