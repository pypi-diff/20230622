# Comparing `tmp/gsw-3.6.16.post1-cp39-cp39-win_amd64.whl.zip` & `tmp/gsw-3.6.17-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,34 @@
-Zip file size: 2136339 bytes, number of entries: 31
--rw-rw-rw-  2.0 fat     1934 b- defN 22-Oct-17 12:35 gsw/__init__.py
--rw-rw-rw-  2.0 fat      595 b- defN 22-Oct-17 12:35 gsw/_fixed_wrapped_ufuncs.py
--rw-rw-rw-  2.0 fat  3181568 b- defN 22-Oct-17 12:38 gsw/_gsw_ufuncs.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     8598 b- defN 22-Oct-17 12:35 gsw/_utilities.py
--rw-rw-rw-  2.0 fat       28 b- defN 22-Oct-17 12:38 gsw/_version.py
--rw-rw-rw-  2.0 fat   136273 b- defN 22-Oct-17 12:35 gsw/_wrapped_ufuncs.py
--rw-rw-rw-  2.0 fat     1873 b- defN 22-Oct-17 12:35 gsw/conversions.py
--rw-rw-rw-  2.0 fat      485 b- defN 22-Oct-17 12:35 gsw/density.py
--rw-rw-rw-  2.0 fat      192 b- defN 22-Oct-17 12:35 gsw/energy.py
--rw-rw-rw-  2.0 fat      533 b- defN 22-Oct-17 12:35 gsw/freezing.py
--rw-rw-rw-  2.0 fat    10494 b- defN 22-Oct-17 12:35 gsw/geostrophy.py
--rw-rw-rw-  2.0 fat      951 b- defN 22-Oct-17 12:35 gsw/ice.py
--rw-rw-rw-  2.0 fat     6305 b- defN 22-Oct-17 12:35 gsw/stability.py
--rw-rw-rw-  2.0 fat     2001 b- defN 22-Oct-17 12:35 gsw/utility.py
--rw-rw-rw-  2.0 fat     2880 b- defN 22-Oct-17 12:35 gsw/tests/_WIP_test_ufuncs.py
--rw-rw-rw-  2.0 fat    11630 b- defN 22-Oct-17 12:35 gsw/tests/check_functions.py
--rw-rw-rw-  2.0 fat     1208 b- defN 22-Oct-17 12:35 gsw/tests/geo_strf_dyn_height.npy
--rw-rw-rw-  2.0 fat      848 b- defN 22-Oct-17 12:35 gsw/tests/geo_strf_velocity.npy
--rw-rw-rw-  2.0 fat   116294 b- defN 22-Oct-17 12:35 gsw/tests/gsw_check_functions_save.m
--rw-rw-rw-  2.0 fat   641918 b- defN 22-Oct-17 12:35 gsw/tests/gsw_cv_v3_0.npz
--rw-rw-rw-  2.0 fat     1094 b- defN 22-Oct-17 12:35 gsw/tests/list_check_functions.py
--rw-rw-rw-  2.0 fat     2597 b- defN 22-Oct-17 12:35 gsw/tests/test_check_functions.py
--rw-rw-rw-  2.0 fat     3543 b- defN 22-Oct-17 12:35 gsw/tests/test_geostrophy.py
--rw-rw-rw-  2.0 fat      722 b- defN 22-Oct-17 12:35 gsw/tests/test_utility.py
--rw-rw-rw-  2.0 fat     5095 b- defN 22-Oct-17 12:35 gsw/tests/test_xarray.py
--rw-rw-rw-  2.0 fat     1182 b- defN 22-Oct-17 12:35 gsw/tests/write_geo_npyfiles.py
--rw-rw-rw-  2.0 fat     1885 b- defN 22-Oct-17 12:38 gsw-3.6.16.post1.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     4083 b- defN 22-Oct-17 12:38 gsw-3.6.16.post1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 22-Oct-17 12:38 gsw-3.6.16.post1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 22-Oct-17 12:38 gsw-3.6.16.post1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2493 b- defN 22-Oct-17 12:38 gsw-3.6.16.post1.dist-info/RECORD
-31 files, 4149406 bytes uncompressed, 2132397 bytes compressed:  48.6%
+Zip file size: 2140422 bytes, number of entries: 32
+-rw-rw-rw-  2.0 fat     1876 b- defN 23-Jun-22 15:51 gsw/__init__.py
+-rw-rw-rw-  2.0 fat     1443 b- defN 23-Jun-22 15:51 gsw/_fixed_wrapped_ufuncs.py
+-rw-rw-rw-  2.0 fat  3181568 b- defN 23-Jun-22 15:55 gsw/_gsw_ufuncs.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     9036 b- defN 23-Jun-22 15:51 gsw/_utilities.py
+-rw-rw-rw-  2.0 fat       22 b- defN 23-Jun-22 15:54 gsw/_version.py
+-rw-rw-rw-  2.0 fat   156058 b- defN 23-Jun-22 15:51 gsw/_wrapped_ufuncs.py
+-rw-rw-rw-  2.0 fat     1983 b- defN 23-Jun-22 15:51 gsw/conversions.py
+-rw-rw-rw-  2.0 fat      549 b- defN 23-Jun-22 15:51 gsw/density.py
+-rw-rw-rw-  2.0 fat      192 b- defN 23-Jun-22 15:51 gsw/energy.py
+-rw-rw-rw-  2.0 fat      597 b- defN 23-Jun-22 15:51 gsw/freezing.py
+-rw-rw-rw-  2.0 fat    10375 b- defN 23-Jun-22 15:51 gsw/geostrophy.py
+-rw-rw-rw-  2.0 fat     1083 b- defN 23-Jun-22 15:51 gsw/ice.py
+-rw-rw-rw-  2.0 fat     6305 b- defN 23-Jun-22 15:51 gsw/stability.py
+-rw-rw-rw-  2.0 fat     1981 b- defN 23-Jun-22 15:51 gsw/utility.py
+-rw-rw-rw-  2.0 fat     2873 b- defN 23-Jun-22 15:51 gsw/tests/_WIP_test_ufuncs.py
+-rw-rw-rw-  2.0 fat    11619 b- defN 23-Jun-22 15:51 gsw/tests/check_functions.py
+-rw-rw-rw-  2.0 fat     1208 b- defN 23-Jun-22 15:51 gsw/tests/geo_strf_dyn_height.npy
+-rw-rw-rw-  2.0 fat      848 b- defN 23-Jun-22 15:51 gsw/tests/geo_strf_velocity.npy
+-rw-rw-rw-  2.0 fat   116294 b- defN 23-Jun-22 15:51 gsw/tests/gsw_check_functions_save.m
+-rw-rw-rw-  2.0 fat   641918 b- defN 23-Jun-22 15:51 gsw/tests/gsw_cv_v3_0.npz
+-rw-rw-rw-  2.0 fat     1094 b- defN 23-Jun-22 15:51 gsw/tests/list_check_functions.py
+-rw-rw-rw-  2.0 fat     2597 b- defN 23-Jun-22 15:51 gsw/tests/test_check_functions.py
+-rw-rw-rw-  2.0 fat     3543 b- defN 23-Jun-22 15:51 gsw/tests/test_geostrophy.py
+-rw-rw-rw-  2.0 fat     2730 b- defN 23-Jun-22 15:51 gsw/tests/test_gibbs.py
+-rw-rw-rw-  2.0 fat      720 b- defN 23-Jun-22 15:51 gsw/tests/test_utility.py
+-rw-rw-rw-  2.0 fat     5385 b- defN 23-Jun-22 15:51 gsw/tests/test_xarray.py
+-rw-rw-rw-  2.0 fat     1184 b- defN 23-Jun-22 15:51 gsw/tests/write_geo_npyfiles.py
+-rw-rw-rw-  2.0 fat     1885 b- defN 23-Jun-22 15:55 gsw-3.6.17.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     4321 b- defN 23-Jun-22 15:55 gsw-3.6.17.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Jun-22 15:55 gsw-3.6.17.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-Jun-22 15:54 gsw-3.6.17.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2545 b- defN 23-Jun-22 15:55 gsw-3.6.17.dist-info/RECORD
+32 files, 4173936 bytes uncompressed, 2136418 bytes compressed:  48.8%
```

## zipnote {}

```diff
@@ -63,32 +63,35 @@
 
 Filename: gsw/tests/test_check_functions.py
 Comment: 
 
 Filename: gsw/tests/test_geostrophy.py
 Comment: 
 
+Filename: gsw/tests/test_gibbs.py
+Comment: 
+
 Filename: gsw/tests/test_utility.py
 Comment: 
 
 Filename: gsw/tests/test_xarray.py
 Comment: 
 
 Filename: gsw/tests/write_geo_npyfiles.py
 Comment: 
 
-Filename: gsw-3.6.16.post1.dist-info/LICENSE.txt
+Filename: gsw-3.6.17.dist-info/LICENSE.txt
 Comment: 
 
-Filename: gsw-3.6.16.post1.dist-info/METADATA
+Filename: gsw-3.6.17.dist-info/METADATA
 Comment: 
 
-Filename: gsw-3.6.16.post1.dist-info/WHEEL
+Filename: gsw-3.6.17.dist-info/WHEEL
 Comment: 
 
-Filename: gsw-3.6.16.post1.dist-info/top_level.txt
+Filename: gsw-3.6.17.dist-info/top_level.txt
 Comment: 
 
-Filename: gsw-3.6.16.post1.dist-info/RECORD
+Filename: gsw-3.6.17.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## gsw/__init__.py

```diff
@@ -27,27 +27,18 @@
 - Functions such as `Nsquared` that operate on profiles rather than
   scalars have an `axis` keyword argument to specify the index that
   is incremented along the pressure (depth) axis.
 
 """
 
 
-from ._fixed_wrapped_ufuncs import *
-
-from .stability import *
-from .geostrophy import *
-from .utility import *
-from . import geostrophy
-from . import utility
-from . import stability
-from . import density
-from . import energy
-from . import conversions
-
-from . import ice
-
+from . import conversions, density, energy, geostrophy, ice, stability, utility
+from ._fixed_wrapped_ufuncs import *  # noqa
 from .conversions import t90_from_t68
+from .geostrophy import *  # noqa
+from .stability import *  # noqa
+from .utility import *  # noqa
 
 try:
     from ._version import __version__
 except ImportError:
     __version__ = "unknown"
```

## gsw/_fixed_wrapped_ufuncs.py

```diff
@@ -1,19 +1,41 @@
 """
 Internally import from this, not from _wrapped_ufuncs.
 Users should import only from non-private modules, of course.
 """
 
+import numpy
+
 from ._wrapped_ufuncs import *
 
 _p_from_z = p_from_z
 def p_from_z(z, lat, geo_strf_dyn_height=0, sea_surface_geopotential=0):
     return _p_from_z(z, lat, geo_strf_dyn_height, sea_surface_geopotential)
 p_from_z.__doc__ = _p_from_z.__doc__
 
 _z_from_p = z_from_p
 def z_from_p(p, lat, geo_strf_dyn_height=0, sea_surface_geopotential=0):
     return _z_from_p(p, lat, geo_strf_dyn_height, sea_surface_geopotential)
 z_from_p.__doc__ = _z_from_p.__doc__
 
-
-
+_gibbs = gibbs
+def gibbs(ns, nt, np, SA, t, p):
+    params = {"ns": ns, "nt": nt, "np": np}
+    for k, v in params.items():
+        u = numpy.unique(v)
+        if u.min() < 0 or u.max() > 2 or u.dtype.kind != "i":
+            raise ValueError("ns, nt, np must contain integers 0, 1, or 2;"
+                             f" found {k}={v}")
+    return _gibbs(ns, nt, np, SA, t, p)
+gibbs.__doc__ = _gibbs.__doc__
+
+
+_gibbs_ice = gibbs_ice
+def gibbs_ice(nt, np, t, p):
+    params = {"nt": nt, "np": np}
+    for k, v in params.items():
+        u = numpy.unique(v)
+        if u.min() < 0 or u.max() > 2 or u.dtype.kind != "i":
+            raise ValueError("nt, np must contain integers 0, 1, or 2;"
+                             f" found {k}={v}")
+    return _gibbs_ice(nt, np, t, p)
+gibbs_ice.__doc__ = _gibbs_ice.__doc__
```

## gsw/_utilities.py

```diff
@@ -1,11 +1,12 @@
 from functools import wraps
 
 import numpy as np
 
+
 def masked_to_nan(arg):
     """
     Convert a masked array to a float ndarray with nans; ensure
     other arguments are float arrays or scalars.
     """
     if np.ma.isMaskedArray(arg):
         if arg.dtype.kind == 'f':
@@ -31,29 +32,41 @@
         isduck = [hasattr(a, '__array_ufunc__')
                     and not isinstance(a, np.ndarray) for a in args]
 
         hasarray = np.any(isarray)
         hasmasked = np.any(ismasked)
         hasduck = np.any(isduck)
 
+        # Handle the leading integer arguments in gibbs and gibbs_ice.
+        # Wrapped ufuncs are constructed with the "types" attribute from the
+        # underlying ufunc.
+        if hasattr(f, "types"):
+            argtypes = f.types[0].split("->")[0]
+            first_double = argtypes.index("d")
+        else:
+            first_double = 0
+
+
         def fixup(ret):
             if hasduck:
                 return ret
             if hasmasked:
                 ret = np.ma.masked_invalid(ret)
             if not hasarray and isinstance(ret, np.ndarray) and ret.size == 1:
                 try:
                     ret = ret[0]
                 except IndexError:
                     pass
             return ret
 
         newargs = []
         for i, arg in enumerate(args):
-            if ismasked[i]:
+            if i < first_double:
+                newargs.append(arg)  # for gibbs and gibbs_ice
+            elif ismasked[i]:
                 newargs.append(masked_to_nan(arg))
             elif isduck[i]:
                 newargs.append(arg)
             else:
                 newargs.append(np.asarray(arg, dtype=float))
 
         if p is not None:
@@ -100,15 +113,15 @@
     kmax = np.prod(ind_shape)
 
     if order == 'C':
         index_position = list(reversed(range(ndim)))
     else:
         index_position = list(range(ndim))
 
-    for k in range(kmax):
+    for _k in range(kmax):
         yield tuple(inds)
 
         for i in index_position:
             if ind_shape[i] == 1:
                 continue
             inds[i] += 1
             if inds[i] == ind_shape[i]:
@@ -154,16 +167,16 @@
         for arg in args:
             self.update(arg)
         self.update(kwargs)
 
     def __getattr__(self, name):
         try:
             return self[name]
-        except KeyError:
-            raise AttributeError("'Bunch' object has no attribute '%s'" % name)
+        except KeyError as err:
+            raise AttributeError(f"'Bunch' object has no attribute {name}. {err}")
 
     def __setattr__(self, name, value):
         self[name] = value
 
     def __str__(self):
         return self.formatted()
 
@@ -204,15 +217,15 @@
         """
         Read in variables from a python code file.
         """
         # We can't simply exec the code directly, because in
         # Python 3 the scoping for list comprehensions would
         # lead to a NameError.  Wrapping the code in a function
         # fixes this.
-        d = dict()
+        d = {}
         lines = ["def _temp_func():\n"]
         with open(filename) as f:
             lines.extend(["    " + line for line in f])
         lines.extend(["\n    return(locals())\n",
                       "_temp_out = _temp_func()\n",
                       "del(_temp_func)\n"])
         codetext = "".join(lines)
@@ -228,40 +241,40 @@
         taking precedence.
 
         One reserved optional kwarg is "strict".  If present and
         True, then any attempt to update with keys that are not
         already in the Bunch instance will raise a KeyError.
         """
         strict = kw.pop("strict", False)
-        newkw = dict()
+        newkw = {}
         for d in args:
             newkw.update(d)
         newkw.update(kw)
         self._check_strict(strict, newkw)
-        dsub = dict([(k, v) for (k, v) in newkw.items() if k in self])
+        dsub = {k: v for (k, v) in newkw.items() if k in self}
         self.update(dsub)
 
     def update_None(self, *args, **kw):
         """
         Similar to update_values, except that an existing value
         will be updated only if it is None.
         """
         strict = kw.pop("strict", False)
-        newkw = dict()
+        newkw = {}
         for d in args:
             newkw.update(d)
         newkw.update(kw)
         self._check_strict(strict, newkw)
-        dsub = dict([(k, v) for (k, v) in newkw.items()
-                                if k in self and self[k] is None])
+        dsub = {k: v for (k, v) in newkw.items()
+                                if k in self and self[k] is None}
         self.update(dsub)
 
     def _check_strict(self, strict, kw):
         if strict:
             bad = set(kw.keys()) - set(self.keys())
             if bad:
                 bk = list(bad)
                 bk.sort()
                 ek = list(self.keys())
                 ek.sort()
                 raise KeyError(
-                    "Update keys %s don't match existing keys %s" % (bk, ek))
+                    f"Update keys {bk} don't match existing keys {ek}")
```

## gsw/_version.py

```diff
@@ -1 +1 @@
-__version__ = "3.6.16.post1"
+__version__ = '3.6.17'
```

## gsw/_wrapped_ufuncs.py

```diff
@@ -3,15 +3,14 @@
 Auto-generated wrapper for C ufunc extension; do not edit!
 """
 
 from . import _gsw_ufuncs
 from ._utilities import match_args_return
 
 
-@match_args_return
 def adiabatic_lapse_rate_from_CT(SA, CT, p):
     """
     Calculates the adiabatic lapse rate of sea water from Conservative
     Temperature.
 
     Parameters
     ----------
@@ -26,16 +25,17 @@
     -------
     adiabatic_lapse_rate : array-like, K/Pa
         adiabatic lapse rate
 
 
     """
     return _gsw_ufuncs.adiabatic_lapse_rate_from_ct(SA, CT, p)
+adiabatic_lapse_rate_from_CT.types = _gsw_ufuncs.adiabatic_lapse_rate_from_ct.types
+adiabatic_lapse_rate_from_CT = match_args_return(adiabatic_lapse_rate_from_CT)
 
-@match_args_return
 def adiabatic_lapse_rate_ice(t, p):
     """
     Calculates the adiabatic lapse rate of ice.
 
     Parameters
     ----------
     t : array-like
@@ -47,16 +47,17 @@
     -------
     adiabatic_lapse_rate_ice : array-like, K/Pa
         adiabatic lapse rate
 
 
     """
     return _gsw_ufuncs.adiabatic_lapse_rate_ice(t, p)
+adiabatic_lapse_rate_ice.types = _gsw_ufuncs.adiabatic_lapse_rate_ice.types
+adiabatic_lapse_rate_ice = match_args_return(adiabatic_lapse_rate_ice)
 
-@match_args_return
 def alpha(SA, CT, p):
     """
     Calculates the thermal expansion coefficient of seawater with respect to
     Conservative Temperature using the computationally-efficient expression
     for specific volume in terms of SA, CT and p (Roquet et al., 2015).
 
     Parameters
@@ -73,16 +74,17 @@
     alpha : array-like, 1/K
         thermal expansion coefficient
         with respect to Conservative Temperature
 
 
     """
     return _gsw_ufuncs.alpha(SA, CT, p)
+alpha.types = _gsw_ufuncs.alpha.types
+alpha = match_args_return(alpha)
 
-@match_args_return
 def alpha_on_beta(SA, CT, p):
     """
     Calculates alpha divided by beta, where alpha is the thermal expansion
     coefficient and beta is the saline contraction coefficient of seawater
     from Absolute Salinity and Conservative Temperature.  This function uses
     the computationally-efficient expression for specific volume in terms of
     SA, CT and p (Roquet et al., 2015).
@@ -94,25 +96,26 @@
     CT : array-like
         Conservative Temperature (ITS-90), degrees C
     p : array-like
         Sea pressure (absolute pressure minus 10.1325 dbar), dbar
 
     Returns
     -------
-    alpha_on_beta : array-like, kg g^-1 K^-1
+    alpha_on_beta : array-like, g kg^-1 K^-1
         thermal expansion coefficient with respect to
         Conservative Temperature divided by the saline
         contraction coefficient at constant Conservative
         Temperature
 
 
     """
     return _gsw_ufuncs.alpha_on_beta(SA, CT, p)
+alpha_on_beta.types = _gsw_ufuncs.alpha_on_beta.types
+alpha_on_beta = match_args_return(alpha_on_beta)
 
-@match_args_return
 def alpha_wrt_t_exact(SA, t, p):
     """
     Calculates the thermal expansion coefficient of seawater with respect to
     in-situ temperature.
 
     Parameters
     ----------
@@ -128,16 +131,17 @@
     alpha_wrt_t_exact : array-like, 1/K
         thermal expansion coefficient
         with respect to in-situ temperature
 
 
     """
     return _gsw_ufuncs.alpha_wrt_t_exact(SA, t, p)
+alpha_wrt_t_exact.types = _gsw_ufuncs.alpha_wrt_t_exact.types
+alpha_wrt_t_exact = match_args_return(alpha_wrt_t_exact)
 
-@match_args_return
 def alpha_wrt_t_ice(t, p):
     """
     Calculates the thermal expansion coefficient of ice with respect to
     in-situ temperature.
 
     Parameters
     ----------
@@ -151,16 +155,17 @@
     alpha_wrt_t_ice : array-like, 1/K
         thermal expansion coefficient of ice with respect
         to in-situ temperature
 
 
     """
     return _gsw_ufuncs.alpha_wrt_t_ice(t, p)
+alpha_wrt_t_ice.types = _gsw_ufuncs.alpha_wrt_t_ice.types
+alpha_wrt_t_ice = match_args_return(alpha_wrt_t_ice)
 
-@match_args_return
 def beta(SA, CT, p):
     """
     Calculates the saline (i.e. haline) contraction coefficient of seawater
     at constant Conservative Temperature using the computationally-efficient
     75-term expression for specific volume in terms of SA, CT and p
     (Roquet et al., 2015).
 
@@ -178,16 +183,17 @@
     beta : array-like, kg/g
         saline contraction coefficient
         at constant Conservative Temperature
 
 
     """
     return _gsw_ufuncs.beta(SA, CT, p)
+beta.types = _gsw_ufuncs.beta.types
+beta = match_args_return(beta)
 
-@match_args_return
 def beta_const_t_exact(SA, t, p):
     """
     Calculates the saline (i.e. haline) contraction coefficient of seawater
     at constant in-situ temperature.
 
     Parameters
     ----------
@@ -203,16 +209,17 @@
     beta_const_t_exact : array-like, kg/g
         saline contraction coefficient
         at constant in-situ temperature
 
 
     """
     return _gsw_ufuncs.beta_const_t_exact(SA, t, p)
+beta_const_t_exact.types = _gsw_ufuncs.beta_const_t_exact.types
+beta_const_t_exact = match_args_return(beta_const_t_exact)
 
-@match_args_return
 def C_from_SP(SP, t, p):
     """
     Calculates conductivity, C, from (SP,t,p) using PSS-78 in the range
     2 < SP < 42.  If the input Practical Salinity is less than 2 then a
     modified form of the Hill et al. (1986) formula is used for Practical
     Salinity.  The modification of the Hill et al. (1986) expression is to
     ensure that it is exactly consistent with PSS-78 at SP = 2.
@@ -230,16 +237,17 @@
     -------
     C : array-like, mS/cm
         conductivity
 
 
     """
     return _gsw_ufuncs.c_from_sp(SP, t, p)
+C_from_SP.types = _gsw_ufuncs.c_from_sp.types
+C_from_SP = match_args_return(C_from_SP)
 
-@match_args_return
 def cabbeling(SA, CT, p):
     """
     Calculates the cabbeling coefficient of seawater with respect to
     Conservative Temperature.  This function uses the computationally-
     efficient expression for specific volume in terms of SA, CT and p
     (Roquet et al., 2015).
 
@@ -257,16 +265,17 @@
     cabbeling : array-like, 1/K^2
         cabbeling coefficient with respect to
         Conservative Temperature.
 
 
     """
     return _gsw_ufuncs.cabbeling(SA, CT, p)
+cabbeling.types = _gsw_ufuncs.cabbeling.types
+cabbeling = match_args_return(cabbeling)
 
-@match_args_return
 def chem_potential_water_ice(t, p):
     """
     Calculates the chemical potential of water in ice from in-situ
     temperature and pressure.
 
     Parameters
     ----------
@@ -279,16 +288,17 @@
     -------
     chem_potential_water_ice : array-like, J/kg
         chemical potential of ice
 
 
     """
     return _gsw_ufuncs.chem_potential_water_ice(t, p)
+chem_potential_water_ice.types = _gsw_ufuncs.chem_potential_water_ice.types
+chem_potential_water_ice = match_args_return(chem_potential_water_ice)
 
-@match_args_return
 def chem_potential_water_t_exact(SA, t, p):
     """
     Calculates the chemical potential of water in seawater.
 
     Parameters
     ----------
     SA : array-like
@@ -302,19 +312,20 @@
     -------
     chem_potential_water_t_exact : array-like, J/g
         chemical potential of water in seawater
 
 
     """
     return _gsw_ufuncs.chem_potential_water_t_exact(SA, t, p)
+chem_potential_water_t_exact.types = _gsw_ufuncs.chem_potential_water_t_exact.types
+chem_potential_water_t_exact = match_args_return(chem_potential_water_t_exact)
 
-@match_args_return
 def cp_ice(t, p):
     """
-    Calculates the isobaric heat capacity of seawater.
+    Calculates the isobaric heat capacity of ice.
 
     Parameters
     ----------
     t : array-like
         In-situ temperature (ITS-90), degrees C
     p : array-like
         Sea pressure (absolute pressure minus 10.1325 dbar), dbar
@@ -323,16 +334,17 @@
     -------
     cp_ice : array-like, J kg^-1 K^-1
         heat capacity of ice
 
 
     """
     return _gsw_ufuncs.cp_ice(t, p)
+cp_ice.types = _gsw_ufuncs.cp_ice.types
+cp_ice = match_args_return(cp_ice)
 
-@match_args_return
 def cp_t_exact(SA, t, p):
     """
     Calculates the isobaric heat capacity of seawater.
 
     Parameters
     ----------
     SA : array-like
@@ -346,16 +358,17 @@
     -------
     cp_t_exact : array-like, J/(kg*K)
         heat capacity of seawater
 
 
     """
     return _gsw_ufuncs.cp_t_exact(SA, t, p)
+cp_t_exact.types = _gsw_ufuncs.cp_t_exact.types
+cp_t_exact = match_args_return(cp_t_exact)
 
-@match_args_return
 def CT_first_derivatives(SA, pt):
     """
     Calculates the following two derivatives of Conservative Temperature
     (1) CT_SA, the derivative with respect to Absolute Salinity at
     constant potential temperature (with pr = 0 dbar), and
     2) CT_pt, the derivative with respect to potential temperature
     (the regular potential temperature which is referenced to 0 dbar)
@@ -379,16 +392,17 @@
         The derivative of Conservative Temperature with respect to
         potential temperature (the regular one with pr = 0 dbar)
         at constant SA. CT_pt is dimensionless.
 
 
     """
     return _gsw_ufuncs.ct_first_derivatives(SA, pt)
+CT_first_derivatives.types = _gsw_ufuncs.ct_first_derivatives.types
+CT_first_derivatives = match_args_return(CT_first_derivatives)
 
-@match_args_return
 def CT_first_derivatives_wrt_t_exact(SA, t, p):
     """
     Calculates the following three derivatives of Conservative Temperature.
     These derivatives are done with respect to in-situ temperature t (in the
     case of CT_T_wrt_t) or at constant in-situ tempertature (in the cases of
     CT_SA_wrt_t and CT_P_wrt_t).
     (1) CT_SA_wrt_t, the derivative of CT with respect to Absolute Salinity
@@ -419,16 +433,17 @@
     CT_P_wrt_t : array-like, K/Pa
         The first derivative of Conservative Temperature with
         respect to pressure P (in Pa) at constant SA and t.
 
 
     """
     return _gsw_ufuncs.ct_first_derivatives_wrt_t_exact(SA, t, p)
+CT_first_derivatives_wrt_t_exact.types = _gsw_ufuncs.ct_first_derivatives_wrt_t_exact.types
+CT_first_derivatives_wrt_t_exact = match_args_return(CT_first_derivatives_wrt_t_exact)
 
-@match_args_return
 def CT_freezing(SA, p, saturation_fraction):
     """
     Calculates the Conservative Temperature at which seawater freezes.  The
     Conservative Temperature freezing point is calculated from the exact
     in-situ freezing temperature which is found by a modified Newton-Raphson
     iteration (McDougall and Wotherspoon, 2014) of the equality of the
     chemical potentials of water in seawater and in ice.
@@ -448,16 +463,17 @@
         Conservative Temperature at freezing of seawater
         That is, the freezing temperature expressed in terms of
         Conservative Temperature (ITS-90).
 
 
     """
     return _gsw_ufuncs.ct_freezing(SA, p, saturation_fraction)
+CT_freezing.types = _gsw_ufuncs.ct_freezing.types
+CT_freezing = match_args_return(CT_freezing)
 
-@match_args_return
 def CT_freezing_first_derivatives(SA, p, saturation_fraction):
     """
     Calculates the first derivatives of the Conservative Temperature at
     which seawater freezes, with respect to Absolute Salinity SA and
     pressure P (in Pa).
 
     Parameters
@@ -479,16 +495,17 @@
         the derivative of the Conservative Temperature at
         freezing (ITS-90) with respect to pressure (in Pa) at
         fixed Absolute Salinity
 
 
     """
     return _gsw_ufuncs.ct_freezing_first_derivatives(SA, p, saturation_fraction)
+CT_freezing_first_derivatives.types = _gsw_ufuncs.ct_freezing_first_derivatives.types
+CT_freezing_first_derivatives = match_args_return(CT_freezing_first_derivatives)
 
-@match_args_return
 def CT_freezing_first_derivatives_poly(SA, p, saturation_fraction):
     """
     Calculates the first derivatives of the Conservative Temperature at
     which seawater freezes, with respect to Absolute Salinity SA and
     pressure P (in Pa) of the comptationally efficient polynomial fit of the
     freezing temperature (McDougall et al., 2014).
 
@@ -511,16 +528,17 @@
         the derivative of the Conservative Temperature at
         freezing (ITS-90) with respect to pressure (in Pa) at
         fixed Absolute Salinity
 
 
     """
     return _gsw_ufuncs.ct_freezing_first_derivatives_poly(SA, p, saturation_fraction)
+CT_freezing_first_derivatives_poly.types = _gsw_ufuncs.ct_freezing_first_derivatives_poly.types
+CT_freezing_first_derivatives_poly = match_args_return(CT_freezing_first_derivatives_poly)
 
-@match_args_return
 def CT_freezing_poly(SA, p, saturation_fraction):
     """
     Calculates the Conservative Temperature at which seawater freezes.
     The error of this fit ranges between -5e-4 K and 6e-4 K when compared
     with the Conservative Temperature calculated from the exact in-situ
     freezing temperature which is found by a Newton-Raphson iteration of the
     equality of the chemical potentials of water in seawater and in ice.
@@ -542,16 +560,17 @@
         Conservative Temperature at freezing of seawater
         That is, the freezing temperature expressed in
         terms of Conservative Temperature (ITS-90).
 
 
     """
     return _gsw_ufuncs.ct_freezing_poly(SA, p, saturation_fraction)
+CT_freezing_poly.types = _gsw_ufuncs.ct_freezing_poly.types
+CT_freezing_poly = match_args_return(CT_freezing_poly)
 
-@match_args_return
 def CT_from_enthalpy(SA, h, p):
     """
     Calculates the Conservative Temperature of seawater, given the Absolute
     Salinity, specific enthalpy, h, and pressure p.  The specific enthalpy
     input is the one calculated from the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -569,16 +588,17 @@
     -------
     CT : array-like, deg C
         Conservative Temperature ( ITS-90)
 
 
     """
     return _gsw_ufuncs.ct_from_enthalpy(SA, h, p)
+CT_from_enthalpy.types = _gsw_ufuncs.ct_from_enthalpy.types
+CT_from_enthalpy = match_args_return(CT_from_enthalpy)
 
-@match_args_return
 def CT_from_enthalpy_exact(SA, h, p):
     """
     Calculates the Conservative Temperature of seawater, given the Absolute
     Salinity, SA, specific enthalpy, h, and pressure p.  The specific
     enthalpy input is calculated from the full Gibbs function of seawater,
     gsw_enthalpy_t_exact.
 
@@ -595,16 +615,17 @@
     -------
     CT : array-like, deg C
         Conservative Temperature ( ITS-90)
 
 
     """
     return _gsw_ufuncs.ct_from_enthalpy_exact(SA, h, p)
+CT_from_enthalpy_exact.types = _gsw_ufuncs.ct_from_enthalpy_exact.types
+CT_from_enthalpy_exact = match_args_return(CT_from_enthalpy_exact)
 
-@match_args_return
 def CT_from_entropy(SA, entropy):
     """
     Calculates Conservative Temperature with entropy as an input variable.
 
     Parameters
     ----------
     SA : array-like
@@ -616,16 +637,17 @@
     -------
     CT : array-like, deg C
         Conservative Temperature (ITS-90)
 
 
     """
     return _gsw_ufuncs.ct_from_entropy(SA, entropy)
+CT_from_entropy.types = _gsw_ufuncs.ct_from_entropy.types
+CT_from_entropy = match_args_return(CT_from_entropy)
 
-@match_args_return
 def CT_from_pt(SA, pt):
     """
     Calculates Conservative Temperature of seawater from potential
     temperature (whose reference sea pressure is zero dbar).
 
     Parameters
     ----------
@@ -638,16 +660,17 @@
     -------
     CT : array-like, deg C
         Conservative Temperature (ITS-90)
 
 
     """
     return _gsw_ufuncs.ct_from_pt(SA, pt)
+CT_from_pt.types = _gsw_ufuncs.ct_from_pt.types
+CT_from_pt = match_args_return(CT_from_pt)
 
-@match_args_return
 def CT_from_rho(rho, SA, p):
     """
     Calculates the Conservative Temperature of a seawater sample, for given
     values of its density, Absolute Salinity and sea pressure (in dbar),
     using the computationally-efficient expression for specific volume in
     terms of SA, CT and p (Roquet et al., 2015).
 
@@ -666,16 +689,17 @@
         Conservative Temperature  (ITS-90)
     CT_multiple : array-like, deg C
         Conservative Temperature  (ITS-90)
 
 
     """
     return _gsw_ufuncs.ct_from_rho(rho, SA, p)
+CT_from_rho.types = _gsw_ufuncs.ct_from_rho.types
+CT_from_rho = match_args_return(CT_from_rho)
 
-@match_args_return
 def CT_from_t(SA, t, p):
     """
     Calculates Conservative Temperature of seawater from in-situ
     temperature.
 
     Parameters
     ----------
@@ -690,16 +714,17 @@
     -------
     CT : array-like, deg C
         Conservative Temperature (ITS-90)
 
 
     """
     return _gsw_ufuncs.ct_from_t(SA, t, p)
+CT_from_t.types = _gsw_ufuncs.ct_from_t.types
+CT_from_t = match_args_return(CT_from_t)
 
-@match_args_return
 def CT_maxdensity(SA, p):
     """
     Calculates the Conservative Temperature of maximum density of seawater.
     This function returns the Conservative temperature at which the density
     of seawater is a maximum, at given Absolute Salinity, SA, and sea
     pressure, p (in dbar).  This function uses the computationally-efficient
     expression for specific volume in terms of SA, CT and p
@@ -718,16 +743,17 @@
         Conservative Temperature at which
         the density of seawater is a maximum for
         given Absolute Salinity and pressure.
 
 
     """
     return _gsw_ufuncs.ct_maxdensity(SA, p)
+CT_maxdensity.types = _gsw_ufuncs.ct_maxdensity.types
+CT_maxdensity = match_args_return(CT_maxdensity)
 
-@match_args_return
 def CT_second_derivatives(SA, pt):
     """
     Calculates the following three, second-order derivatives of Conservative
     Temperature
     (1) CT_SA_SA, the second derivative with respect to Absolute Salinity
     at constant potential temperature (with p_ref = 0 dbar),
     (2) CT_SA_pt, the derivative with respect to potential temperature
@@ -761,16 +787,17 @@
         respect to potential temperature (the regular one with
     p_ref : array-like, 1/K
         0 dbar) at constant SA.
 
 
     """
     return _gsw_ufuncs.ct_second_derivatives(SA, pt)
+CT_second_derivatives.types = _gsw_ufuncs.ct_second_derivatives.types
+CT_second_derivatives = match_args_return(CT_second_derivatives)
 
-@match_args_return
 def deltaSA_atlas(p, lon, lat):
     """
     Calculates the Absolute Salinity Anomaly atlas value, SA - SR, in
     the open ocean by spatially interpolating the global reference data set
     of deltaSA_atlas to the location of the seawater sample.
 
     Parameters
@@ -786,16 +813,17 @@
     -------
     deltaSA_atlas : array-like, g/kg
         Absolute Salinity Anomaly atlas value
 
 
     """
     return _gsw_ufuncs.deltasa_atlas(p, lon, lat)
+deltaSA_atlas.types = _gsw_ufuncs.deltasa_atlas.types
+deltaSA_atlas = match_args_return(deltaSA_atlas)
 
-@match_args_return
 def deltaSA_from_SP(SP, p, lon, lat):
     """
     Calculates Absolute Salinity Anomaly from Practical Salinity.  Since SP
     is non-negative by definition, this function changes any negative input
     values of SP to be zero.
 
     Parameters
@@ -813,16 +841,17 @@
     -------
     deltaSA : array-like, g/kg
         Absolute Salinity Anomaly
 
 
     """
     return _gsw_ufuncs.deltasa_from_sp(SP, p, lon, lat)
+deltaSA_from_SP.types = _gsw_ufuncs.deltasa_from_sp.types
+deltaSA_from_SP = match_args_return(deltaSA_from_SP)
 
-@match_args_return
 def dilution_coefficient_t_exact(SA, t, p):
     """
     Calculates the dilution coefficient of seawater.  The dilution
     coefficient of seawater is defined as the Absolute Salinity times the
     second derivative of the Gibbs function with respect to Absolute
     Salinity, that is, SA.*g_SA_SA.
 
@@ -839,16 +868,17 @@
     -------
     dilution_coefficient_t_exact : array-like, (J/kg)(kg/g)
         dilution coefficient
 
 
     """
     return _gsw_ufuncs.dilution_coefficient_t_exact(SA, t, p)
+dilution_coefficient_t_exact.types = _gsw_ufuncs.dilution_coefficient_t_exact.types
+dilution_coefficient_t_exact = match_args_return(dilution_coefficient_t_exact)
 
-@match_args_return
 def dynamic_enthalpy(SA, CT, p):
     """
     Calculates dynamic enthalpy of seawater using the computationally-
     efficient expression for specific volume in terms of SA, CT and p
     (Roquet et al., 2015).  Dynamic enthalpy is defined as enthalpy minus
     potential enthalpy (Young, 2010).
 
@@ -865,16 +895,17 @@
     -------
     dynamic_enthalpy : array-like, J/kg
         dynamic enthalpy
 
 
     """
     return _gsw_ufuncs.dynamic_enthalpy(SA, CT, p)
+dynamic_enthalpy.types = _gsw_ufuncs.dynamic_enthalpy.types
+dynamic_enthalpy = match_args_return(dynamic_enthalpy)
 
-@match_args_return
 def enthalpy(SA, CT, p):
     """
     Calculates specific enthalpy of seawater using the computationally-
     efficient expression for specific volume in terms of SA, CT and p
     (Roquet et al., 2015).
 
     Parameters
@@ -890,16 +921,17 @@
     -------
     enthalpy : array-like, J/kg
         specific enthalpy
 
 
     """
     return _gsw_ufuncs.enthalpy(SA, CT, p)
+enthalpy.types = _gsw_ufuncs.enthalpy.types
+enthalpy = match_args_return(enthalpy)
 
-@match_args_return
 def enthalpy_CT_exact(SA, CT, p):
     """
     Calculates specific enthalpy of seawater from Absolute Salinity and
     Conservative Temperature and pressure.
 
     Parameters
     ----------
@@ -914,16 +946,17 @@
     -------
     enthalpy_CT_exact : array-like, J/kg
         specific enthalpy
 
 
     """
     return _gsw_ufuncs.enthalpy_ct_exact(SA, CT, p)
+enthalpy_CT_exact.types = _gsw_ufuncs.enthalpy_ct_exact.types
+enthalpy_CT_exact = match_args_return(enthalpy_CT_exact)
 
-@match_args_return
 def enthalpy_diff(SA, CT, p_shallow, p_deep):
     """
     Calculates the difference of the specific enthalpy of seawater between
     two different pressures, p_deep (the deeper pressure) and p_shallow
     (the shallower pressure), at the same values of SA and CT.  This
     function uses the computationally-efficient expression for specific
     volume in terms of SA, CT and p (Roquet et al., 2015).  The output
@@ -946,16 +979,17 @@
     enthalpy_diff : array-like, J/kg
         difference of specific enthalpy
         (deep minus shallow)
 
 
     """
     return _gsw_ufuncs.enthalpy_diff(SA, CT, p_shallow, p_deep)
+enthalpy_diff.types = _gsw_ufuncs.enthalpy_diff.types
+enthalpy_diff = match_args_return(enthalpy_diff)
 
-@match_args_return
 def enthalpy_first_derivatives(SA, CT, p):
     """
     Calculates the following two derivatives of specific enthalpy (h) of
     seawater using the computationally-efficient expression for
     specific volume in terms of SA, CT and p (Roquet et al., 2015).
     (1) h_SA, the derivative with respect to Absolute Salinity at
     constant CT and p, and
@@ -981,16 +1015,17 @@
     h_CT : array-like, J/(kg K)
         The first derivative of specific enthalpy with respect to
         CT at constant SA and p.
 
 
     """
     return _gsw_ufuncs.enthalpy_first_derivatives(SA, CT, p)
+enthalpy_first_derivatives.types = _gsw_ufuncs.enthalpy_first_derivatives.types
+enthalpy_first_derivatives = match_args_return(enthalpy_first_derivatives)
 
-@match_args_return
 def enthalpy_first_derivatives_CT_exact(SA, CT, p):
     """
     Calculates the following two derivatives of specific enthalpy, h,
     (1) h_SA, the derivative with respect to Absolute Salinity at
     constant CT and p, and
     (2) h_CT, derivative with respect to CT at constant SA and p.
     Note that h_P is specific volume, v, it can be calculated by calling
@@ -1014,16 +1049,17 @@
     h_CT : array-like, J/(kg K)
         The first derivative of specific enthalpy with respect to
         CT at constant SA and p.
 
 
     """
     return _gsw_ufuncs.enthalpy_first_derivatives_ct_exact(SA, CT, p)
+enthalpy_first_derivatives_CT_exact.types = _gsw_ufuncs.enthalpy_first_derivatives_ct_exact.types
+enthalpy_first_derivatives_CT_exact = match_args_return(enthalpy_first_derivatives_CT_exact)
 
-@match_args_return
 def enthalpy_ice(t, p):
     """
     Calculates the specific enthalpy of ice (h_Ih).
 
     Parameters
     ----------
     t : array-like
@@ -1035,16 +1071,17 @@
     -------
     enthalpy_ice : array-like, J/kg
         specific enthalpy of ice
 
 
     """
     return _gsw_ufuncs.enthalpy_ice(t, p)
+enthalpy_ice.types = _gsw_ufuncs.enthalpy_ice.types
+enthalpy_ice = match_args_return(enthalpy_ice)
 
-@match_args_return
 def enthalpy_second_derivatives(SA, CT, p):
     """
     Calculates the following three second-order derivatives of specific
     enthalpy (h),using the computationally-efficient expression for
     specific volume in terms of SA, CT and p (Roquet et al., 2015).
     (1) h_SA_SA, second-order derivative with respect to Absolute Salinity
     at constant CT & p.
@@ -1073,16 +1110,17 @@
     h_CT_CT : array-like, J/(kg K^2)
         The second derivative of specific enthalpy with respect to
         CT at constant SA and p.
 
 
     """
     return _gsw_ufuncs.enthalpy_second_derivatives(SA, CT, p)
+enthalpy_second_derivatives.types = _gsw_ufuncs.enthalpy_second_derivatives.types
+enthalpy_second_derivatives = match_args_return(enthalpy_second_derivatives)
 
-@match_args_return
 def enthalpy_second_derivatives_CT_exact(SA, CT, p):
     """
     Calculates the following three second-order derivatives of specific
     enthalpy (h),
     (1) h_SA_SA, second-order derivative with respect to Absolute Salinity
     at constant CT & p.
     (2) h_SA_CT, second-order derivative with respect to SA & CT at
@@ -1110,16 +1148,17 @@
     h_CT_CT : array-like, J/(kg K^2)
         The second derivative of specific enthalpy with respect to
         CT at constant SA and p.
 
 
     """
     return _gsw_ufuncs.enthalpy_second_derivatives_ct_exact(SA, CT, p)
+enthalpy_second_derivatives_CT_exact.types = _gsw_ufuncs.enthalpy_second_derivatives_ct_exact.types
+enthalpy_second_derivatives_CT_exact = match_args_return(enthalpy_second_derivatives_CT_exact)
 
-@match_args_return
 def enthalpy_t_exact(SA, t, p):
     """
     Calculates the specific enthalpy of seawater.
 
     Parameters
     ----------
     SA : array-like
@@ -1133,16 +1172,17 @@
     -------
     enthalpy_t_exact : array-like, J/kg
         specific enthalpy
 
 
     """
     return _gsw_ufuncs.enthalpy_t_exact(SA, t, p)
+enthalpy_t_exact.types = _gsw_ufuncs.enthalpy_t_exact.types
+enthalpy_t_exact = match_args_return(enthalpy_t_exact)
 
-@match_args_return
 def entropy_first_derivatives(SA, CT):
     """
     Calculates the following two partial derivatives of specific entropy
     (eta)
     (1) eta_SA, the derivative with respect to Absolute Salinity at
     constant Conservative Temperature, and
     (2) eta_CT, the derivative with respect to Conservative Temperature at
@@ -1164,16 +1204,17 @@
     eta_CT : array-like, J/(kg K^2)
         The derivative of specific entropy with respect to
         Conservative Temperature at constant Absolute Salinity.
 
 
     """
     return _gsw_ufuncs.entropy_first_derivatives(SA, CT)
+entropy_first_derivatives.types = _gsw_ufuncs.entropy_first_derivatives.types
+entropy_first_derivatives = match_args_return(entropy_first_derivatives)
 
-@match_args_return
 def entropy_from_CT(SA, CT):
     """
     Calculates specific entropy of seawater from Conservative Temperature.
 
     Parameters
     ----------
     SA : array-like
@@ -1185,16 +1226,17 @@
     -------
     entropy : array-like, J/(kg*K)
         specific entropy
 
 
     """
     return _gsw_ufuncs.entropy_from_ct(SA, CT)
+entropy_from_CT.types = _gsw_ufuncs.entropy_from_ct.types
+entropy_from_CT = match_args_return(entropy_from_CT)
 
-@match_args_return
 def entropy_from_pt(SA, pt):
     """
     Calculates specific entropy of seawater as a function of potential
     temperature.
 
     Parameters
     ----------
@@ -1207,16 +1249,17 @@
     -------
     entropy : array-like, J/(kg*K)
         specific entropy
 
 
     """
     return _gsw_ufuncs.entropy_from_pt(SA, pt)
+entropy_from_pt.types = _gsw_ufuncs.entropy_from_pt.types
+entropy_from_pt = match_args_return(entropy_from_pt)
 
-@match_args_return
 def entropy_from_t(SA, t, p):
     """
     Calculates specific entropy of seawater from in-situ temperature.
 
     Parameters
     ----------
     SA : array-like
@@ -1230,16 +1273,17 @@
     -------
     entropy : array-like, J/(kg*K)
         specific entropy
 
 
     """
     return _gsw_ufuncs.entropy_from_t(SA, t, p)
+entropy_from_t.types = _gsw_ufuncs.entropy_from_t.types
+entropy_from_t = match_args_return(entropy_from_t)
 
-@match_args_return
 def entropy_ice(t, p):
     """
     Calculates specific entropy of ice.
 
     Parameters
     ----------
     t : array-like
@@ -1251,16 +1295,17 @@
     -------
     ice_entropy : array-like, J kg^-1 K^-1
         specific entropy of ice
 
 
     """
     return _gsw_ufuncs.entropy_ice(t, p)
+entropy_ice.types = _gsw_ufuncs.entropy_ice.types
+entropy_ice = match_args_return(entropy_ice)
 
-@match_args_return
 def entropy_second_derivatives(SA, CT):
     """
     Calculates the following three second-order partial derivatives of
     specific entropy (eta)
     (1) eta_SA_SA, the second derivative with respect to Absolute
     Salinity at constant Conservative Temperature, and
     (2) eta_SA_CT, the derivative with respect to Absolute Salinity and
@@ -1287,16 +1332,17 @@
     eta_CT_CT : array-like, J/(kg K^3)
         The second derivative of specific entropy with respect
         to Conservative Temperature at constant Absolute
 
 
     """
     return _gsw_ufuncs.entropy_second_derivatives(SA, CT)
+entropy_second_derivatives.types = _gsw_ufuncs.entropy_second_derivatives.types
+entropy_second_derivatives = match_args_return(entropy_second_derivatives)
 
-@match_args_return
 def Fdelta(p, lon, lat):
     """
     Calculates Fdelta from the Absolute Salinity Anomaly Ratio (SAAR).  It
     finds SAAR by calling the function "gsw_SAAR(p,long,lat)" and then
     simply calculates Fdelta from
 
     Parameters
@@ -1312,16 +1358,17 @@
     -------
     Fdelta : array-like, unitless
         ratio of SA to Sstar, minus 1
 
 
     """
     return _gsw_ufuncs.fdelta(p, lon, lat)
+Fdelta.types = _gsw_ufuncs.fdelta.types
+Fdelta = match_args_return(Fdelta)
 
-@match_args_return
 def frazil_properties(SA_bulk, h_bulk, p):
     """
     Calculates the mass fraction of ice (mass of ice divided by mass of ice
     plus seawater), w_Ih_final, which results from given values of the bulk
     Absolute Salinity, SA_bulk, bulk enthalpy, h_bulk, occurring at pressure
     p.  The final values of Absolute Salinity, SA_final, and Conservative
     Temperature, CT_final, of the interstitial seawater phase are also
@@ -1353,16 +1400,17 @@
         zero there is no ice in the final state which consists
         only of seawater which is warmer than the freezing
         temperature.
 
 
     """
     return _gsw_ufuncs.frazil_properties(SA_bulk, h_bulk, p)
+frazil_properties.types = _gsw_ufuncs.frazil_properties.types
+frazil_properties = match_args_return(frazil_properties)
 
-@match_args_return
 def frazil_properties_potential(SA_bulk, h_pot_bulk, p):
     """
     Calculates the mass fraction of ice (mass of ice divided by mass of ice
     plus seawater), w_Ih_eq, which results from given values of the bulk
     Absolute Salinity, SA_bulk, bulk potential enthalpy, h_pot_bulk,
     occurring at pressure p.  The final equilibrium values of Absolute
     Salinity, SA_eq, and Conservative Temperature, CT_eq, of the
@@ -1394,16 +1442,17 @@
         zero there is no ice in the final state which consists
         only of seawater which is warmer than the freezing
         temperature.
 
 
     """
     return _gsw_ufuncs.frazil_properties_potential(SA_bulk, h_pot_bulk, p)
+frazil_properties_potential.types = _gsw_ufuncs.frazil_properties_potential.types
+frazil_properties_potential = match_args_return(frazil_properties_potential)
 
-@match_args_return
 def frazil_properties_potential_poly(SA_bulk, h_pot_bulk, p):
     """
     Calculates the mass fraction of ice (mass of ice divided by mass of ice
     plus seawater), w_Ih_eq, which results from given values of the bulk
     Absolute Salinity, SA_bulk, bulk potential enthalpy, h_pot_bulk,
     occurring at pressure p.  The final equilibrium values of Absolute
     Salinity, SA_eq, and Conservative Temperature, CT_eq, of the
@@ -1435,16 +1484,17 @@
         zero there is no ice in the final state which consists
         only of seawater which is warmer than the freezing
         temperature.
 
 
     """
     return _gsw_ufuncs.frazil_properties_potential_poly(SA_bulk, h_pot_bulk, p)
+frazil_properties_potential_poly.types = _gsw_ufuncs.frazil_properties_potential_poly.types
+frazil_properties_potential_poly = match_args_return(frazil_properties_potential_poly)
 
-@match_args_return
 def frazil_ratios_adiabatic(SA, p, w_Ih):
     """
     Calculates the ratios of SA, CT and P changes when frazil ice forms or
     melts in response to an adiabatic change in pressure of a mixture of
     seawater and frazil ice crystals.
 
     Parameters
@@ -1468,16 +1518,17 @@
     dCT_dP_frazil : array-like, K/Pa
         the ratio of the changes in Conservative Temperature
         to that of pressure (in Pa)
 
 
     """
     return _gsw_ufuncs.frazil_ratios_adiabatic(SA, p, w_Ih)
+frazil_ratios_adiabatic.types = _gsw_ufuncs.frazil_ratios_adiabatic.types
+frazil_ratios_adiabatic = match_args_return(frazil_ratios_adiabatic)
 
-@match_args_return
 def frazil_ratios_adiabatic_poly(SA, p, w_Ih):
     """
     Calculates the ratios of SA, CT and P changes when frazil ice forms or
     melts in response to an adiabatic change in pressure of a mixture of
     seawater and frazil ice crystals.
 
     Parameters
@@ -1501,16 +1552,91 @@
     dCT_dP_frazil : array-like, K/Pa
         the ratio of the changes in Conservative Temperature
         to that of pressure (in Pa)
 
 
     """
     return _gsw_ufuncs.frazil_ratios_adiabatic_poly(SA, p, w_Ih)
+frazil_ratios_adiabatic_poly.types = _gsw_ufuncs.frazil_ratios_adiabatic_poly.types
+frazil_ratios_adiabatic_poly = match_args_return(frazil_ratios_adiabatic_poly)
+
+def gibbs(ns, nt, np, SA, t, p):
+    """
+    Calculates specific Gibbs energy and its derivatives up to order 3 for
+    seawater.  The Gibbs function for seawater is that of TEOS-10
+    (IOC et al., 2010), being the sum of IAPWS-08 for the saline part and
+    IAPWS-09 for the pure water part.  These IAPWS releases are the
+    officially blessed IAPWS descriptions of Feistel (2008) and the pure
+    water part of Feistel (2003).  Absolute Salinity, SA, in all of the GSW
+    routines is expressed on the Reference-Composition Salinity Scale of
+    2008 (RCSS-08) of Millero et al. (2008).
+
+    Parameters
+    ----------
+    ns : array-like
+        order of SA derivative, integer in (0, 1, 2)
+    nt : array-like
+        order of t derivative, integer in (0, 1, 2)
+    np : array-like
+        order of p derivative, integer in (0, 1, 2)
+    SA : array-like
+        Absolute Salinity, g/kg
+    t : array-like
+        In-situ temperature (ITS-90), degrees C
+    p : array-like
+        Sea pressure (absolute pressure minus 10.1325 dbar), dbar
+
+    Returns
+    -------
+    gibbs : array-like
+        Specific Gibbs energy or its derivatives.
+        The Gibbs energy (when ns = nt = np = 0) has units of J/kg.
+        The Absolute Salinity derivatives are output in units of (J/kg) (g/kg)^(-ns).
+        The temperature derivatives are output in units of (J/kg) (K)^(-nt).
+        The pressure derivatives are output in units of (J/kg) (Pa)^(-np).
+        The mixed derivatives are output in units of (J/kg) (g/kg)^(-ns) (K)^(-nt) (Pa)^(-np).
+        Note: The derivatives are taken with respect to pressure in Pa, not
+        withstanding that the pressure input into this routine is in dbar.
+
+    """
+    return _gsw_ufuncs.gibbs(ns, nt, np, SA, t, p)
+gibbs.types = _gsw_ufuncs.gibbs.types
+gibbs = match_args_return(gibbs)
+
+def gibbs_ice(nt, np, t, p):
+    """
+    Ice specific Gibbs energy and derivatives up to order 2.
+
+    Parameters
+    ----------
+    nt : array-like
+        order of t derivative, integer in (0, 1, 2)
+    np : array-like
+        order of p derivative, integer in (0, 1, 2)
+    t : array-like
+        In-situ temperature (ITS-90), degrees C
+    p : array-like
+        Sea pressure (absolute pressure minus 10.1325 dbar), dbar
+
+    Returns
+    -------
+    gibbs_ice : array-like
+        Specific Gibbs energy of ice or its derivatives.
+        The Gibbs energy (when nt = np = 0) has units of J/kg.
+        The temperature derivatives are output in units of (J/kg) (K)^(-nt).
+        The pressure derivatives are output in units of (J/kg) (Pa)^(-np).
+        The mixed derivatives are output in units of (J/kg) (K)^(-nt) (Pa)^(-np).
+        Note. The derivatives are taken with respect to pressure in Pa, not
+        withstanding that the pressure input into this routine is in dbar.
+
+    """
+    return _gsw_ufuncs.gibbs_ice(nt, np, t, p)
+gibbs_ice.types = _gsw_ufuncs.gibbs_ice.types
+gibbs_ice = match_args_return(gibbs_ice)
 
-@match_args_return
 def gibbs_ice_part_t(t, p):
     """
     part of the first temperature derivative of Gibbs energy of ice
     that is the output is gibbs_ice(1,0,t,p) + S0
 
     Parameters
     ----------
@@ -1523,16 +1649,17 @@
     -------
     gibbs_ice_part_t : array-like, J kg^-1 K^-1
         part of temperature derivative
 
 
     """
     return _gsw_ufuncs.gibbs_ice_part_t(t, p)
+gibbs_ice_part_t.types = _gsw_ufuncs.gibbs_ice_part_t.types
+gibbs_ice_part_t = match_args_return(gibbs_ice_part_t)
 
-@match_args_return
 def gibbs_ice_pt0(pt0):
     """
     part of the first temperature derivative of Gibbs energy of ice
     that is the output is "gibbs_ice(1,0,pt0,0) + s0"
 
     Parameters
     ----------
@@ -1543,16 +1670,17 @@
     -------
     gibbs_ice_part_pt0 : array-like, J kg^-1 K^-1
         part of temperature derivative
 
 
     """
     return _gsw_ufuncs.gibbs_ice_pt0(pt0)
+gibbs_ice_pt0.types = _gsw_ufuncs.gibbs_ice_pt0.types
+gibbs_ice_pt0 = match_args_return(gibbs_ice_pt0)
 
-@match_args_return
 def gibbs_ice_pt0_pt0(pt0):
     """
     The second temperature derivative of Gibbs energy of ice at the
     potential temperature with reference sea pressure of zero dbar.  That is
     the output is gibbs_ice(2,0,pt0,0).
 
     Parameters
@@ -1564,16 +1692,17 @@
     -------
     gibbs_ice_pt0_pt0 : array-like, J kg^-1 K^-2
         temperature second derivative at pt0
 
 
     """
     return _gsw_ufuncs.gibbs_ice_pt0_pt0(pt0)
+gibbs_ice_pt0_pt0.types = _gsw_ufuncs.gibbs_ice_pt0_pt0.types
+gibbs_ice_pt0_pt0 = match_args_return(gibbs_ice_pt0_pt0)
 
-@match_args_return
 def grav(lat, p):
     """
     Calculates acceleration due to gravity as a function of latitude and as
     a function of pressure in the ocean.
 
     Parameters
     ----------
@@ -1586,16 +1715,17 @@
     -------
     grav : array-like, m s^-2
         gravitational acceleration
 
 
     """
     return _gsw_ufuncs.grav(lat, p)
+grav.types = _gsw_ufuncs.grav.types
+grav = match_args_return(grav)
 
-@match_args_return
 def Helmholtz_energy_ice(t, p):
     """
     Calculates the Helmholtz energy of ice.
 
     Parameters
     ----------
     t : array-like
@@ -1607,16 +1737,17 @@
     -------
     Helmholtz_energy_ice : array-like, J/kg
         Helmholtz energy of ice
 
 
     """
     return _gsw_ufuncs.helmholtz_energy_ice(t, p)
+Helmholtz_energy_ice.types = _gsw_ufuncs.helmholtz_energy_ice.types
+Helmholtz_energy_ice = match_args_return(Helmholtz_energy_ice)
 
-@match_args_return
 def Hill_ratio_at_SP2(t):
     """
     Calculates the Hill ratio, which is the adjustment needed to apply for
     Practical Salinities smaller than 2.  This ratio is defined at a
     Practical Salinity = 2 and in-situ temperature, t using PSS-78. The Hill
     ratio is the ratio of 2 to the output of the Hill et al. (1986) formula
     for Practical Salinity at the conductivity ratio, Rt, at which Practical
@@ -1631,16 +1762,17 @@
     -------
     Hill_ratio : array-like, unitless
         Hill ratio at SP of 2
 
 
     """
     return _gsw_ufuncs.hill_ratio_at_sp2(t)
+Hill_ratio_at_SP2.types = _gsw_ufuncs.hill_ratio_at_sp2.types
+Hill_ratio_at_SP2 = match_args_return(Hill_ratio_at_SP2)
 
-@match_args_return
 def ice_fraction_to_freeze_seawater(SA, CT, p, t_Ih):
     """
     Calculates the mass fraction of ice (mass of ice divided by mass of ice
     plus seawater), which, when melted into seawater having (SA,CT,p) causes
     the final dilute seawater to be at the freezing temperature.  The other
     outputs are the Absolute Salinity and Conservative Temperature of the
     final diluted seawater.
@@ -1673,16 +1805,17 @@
         which, when melted into seawater at (SA,CT,p) leads to the
         final diluted seawater being at the freezing temperature.
         This output must be between 0 and 1.
 
 
     """
     return _gsw_ufuncs.ice_fraction_to_freeze_seawater(SA, CT, p, t_Ih)
+ice_fraction_to_freeze_seawater.types = _gsw_ufuncs.ice_fraction_to_freeze_seawater.types
+ice_fraction_to_freeze_seawater = match_args_return(ice_fraction_to_freeze_seawater)
 
-@match_args_return
 def internal_energy(SA, CT, p):
     """
     Calculates specific internal energy of seawater using the
     computationally-efficient expression for specific volume in terms of SA,
     CT and p (Roquet et al., 2015).
 
     Parameters
@@ -1698,16 +1831,17 @@
     -------
     internal_energy : array-like, J/kg
         specific internal energy
 
 
     """
     return _gsw_ufuncs.internal_energy(SA, CT, p)
+internal_energy.types = _gsw_ufuncs.internal_energy.types
+internal_energy = match_args_return(internal_energy)
 
-@match_args_return
 def internal_energy_ice(t, p):
     """
     Calculates the specific internal energy of ice.
 
     Parameters
     ----------
     t : array-like
@@ -1719,16 +1853,17 @@
     -------
     internal_energy_ice : array-like, J/kg
         specific internal energy (u)
 
 
     """
     return _gsw_ufuncs.internal_energy_ice(t, p)
+internal_energy_ice.types = _gsw_ufuncs.internal_energy_ice.types
+internal_energy_ice = match_args_return(internal_energy_ice)
 
-@match_args_return
 def kappa(SA, CT, p):
     """
     Calculates the isentropic compressibility of seawater.  This function
     has inputs of Absolute Salinity and Conservative Temperature.  This
     function uses the computationally-efficient expression for
     specific volume in terms of SA, CT and p (Roquet et al., 2015).
 
@@ -1745,16 +1880,17 @@
     -------
     kappa : array-like, 1/Pa
         isentropic compressibility of seawater
 
 
     """
     return _gsw_ufuncs.kappa(SA, CT, p)
+kappa.types = _gsw_ufuncs.kappa.types
+kappa = match_args_return(kappa)
 
-@match_args_return
 def kappa_const_t_ice(t, p):
     """
     Calculates isothermal compressibility of ice.
     Note. This is the compressibility of ice AT CONSTANT IN-SITU
     TEMPERATURE
 
     Parameters
@@ -1768,16 +1904,17 @@
     -------
     kappa_const_t_ice : array-like, 1/Pa
         isothermal compressibility
 
 
     """
     return _gsw_ufuncs.kappa_const_t_ice(t, p)
+kappa_const_t_ice.types = _gsw_ufuncs.kappa_const_t_ice.types
+kappa_const_t_ice = match_args_return(kappa_const_t_ice)
 
-@match_args_return
 def kappa_ice(t, p):
     """
     Calculates the isentropic compressibility of ice.
 
     Parameters
     ----------
     t : array-like
@@ -1789,16 +1926,17 @@
     -------
     kappa_ice : array-like, 1/Pa
         isentropic compressibility
 
 
     """
     return _gsw_ufuncs.kappa_ice(t, p)
+kappa_ice.types = _gsw_ufuncs.kappa_ice.types
+kappa_ice = match_args_return(kappa_ice)
 
-@match_args_return
 def kappa_t_exact(SA, t, p):
     """
     Calculates the isentropic compressibility of seawater.
 
     Parameters
     ----------
     SA : array-like
@@ -1812,16 +1950,17 @@
     -------
     kappa_t_exact : array-like, 1/Pa
         isentropic compressibility
 
 
     """
     return _gsw_ufuncs.kappa_t_exact(SA, t, p)
+kappa_t_exact.types = _gsw_ufuncs.kappa_t_exact.types
+kappa_t_exact = match_args_return(kappa_t_exact)
 
-@match_args_return
 def latentheat_evap_CT(SA, CT):
     """
     Calculates latent heat, or enthalpy, of evaporation at p = 0 (the
     surface).  It is defined as a function of Absolute Salinity, SA, and
     Conservative Temperature, CT, and is valid in the ranges
     0 < SA < 42 g/kg and 0 < CT < 40 deg C.  The errors range between
     -0.4 and 0.6 J/kg.
@@ -1837,16 +1976,17 @@
     -------
     latentheat_evap : array-like, J/kg
         latent heat of evaporation
 
 
     """
     return _gsw_ufuncs.latentheat_evap_ct(SA, CT)
+latentheat_evap_CT.types = _gsw_ufuncs.latentheat_evap_ct.types
+latentheat_evap_CT = match_args_return(latentheat_evap_CT)
 
-@match_args_return
 def latentheat_evap_t(SA, t):
     """
     Calculates latent heat, or enthalpy, of evaporation at p = 0 (the
     surface).  It is defined as a function of Absolute Salinity, SA, and
     in-situ temperature, t, and is valid in the ranges 0 < SA < 40 g/kg
     and 0 < CT < 42 deg C. The errors range between -0.4 and 0.6 J/kg.
 
@@ -1861,16 +2001,17 @@
     -------
     latentheat_evap : array-like, J/kg
         latent heat of evaporation
 
 
     """
     return _gsw_ufuncs.latentheat_evap_t(SA, t)
+latentheat_evap_t.types = _gsw_ufuncs.latentheat_evap_t.types
+latentheat_evap_t = match_args_return(latentheat_evap_t)
 
-@match_args_return
 def latentheat_melting(SA, p):
     """
     Calculates latent heat, or enthalpy, of melting.  It is defined in terms
     of Absolute Salinity, SA, and sea pressure, p, and is valid in the
     ranges 0 < SA < 42 g kg^-1 and 0 < p < 10,000 dbar.  This is based on
     the IAPWS Releases IAPWS-09 (for pure water), IAPWS-08 (for the saline
     compoonent of seawater and IAPWS-06 for ice Ih.
@@ -1886,16 +2027,17 @@
     -------
     latentheat_melting : array-like, J/kg
         latent heat of melting
 
 
     """
     return _gsw_ufuncs.latentheat_melting(SA, p)
+latentheat_melting.types = _gsw_ufuncs.latentheat_melting.types
+latentheat_melting = match_args_return(latentheat_melting)
 
-@match_args_return
 def melting_ice_equilibrium_SA_CT_ratio(SA, p):
     """
     Calculates the ratio of SA to CT changes when ice melts into seawater
     with both the seawater and the seaice temperatures being almost equal to
     the equilibrium freezing temperature.  It is assumed that a small mass
     of ice melts into an infinite mass of seawater.  If indeed the
     temperature of the seawater and the ice were both equal to the freezing
@@ -1918,16 +2060,17 @@
         changes when ice melts into seawater, with
         the seawater and seaice being close to the
         freezing temperature.
 
 
     """
     return _gsw_ufuncs.melting_ice_equilibrium_sa_ct_ratio(SA, p)
+melting_ice_equilibrium_SA_CT_ratio.types = _gsw_ufuncs.melting_ice_equilibrium_sa_ct_ratio.types
+melting_ice_equilibrium_SA_CT_ratio = match_args_return(melting_ice_equilibrium_SA_CT_ratio)
 
-@match_args_return
 def melting_ice_equilibrium_SA_CT_ratio_poly(SA, p):
     """
     Calculates the ratio of SA to CT changes when ice melts into seawater
     with both the seawater and the seaice temperatures being almost equal to
     the equilibrium freezing temperature.  It is assumed that a small mass
     of ice melts into an infinite mass of seawater.  If indeed the
     temperature of the seawater and the ice were both equal to the freezing
@@ -1950,16 +2093,17 @@
         changes when ice melts into seawater, with
         the seawater and seaice being close to the
         freezing temperature.
 
 
     """
     return _gsw_ufuncs.melting_ice_equilibrium_sa_ct_ratio_poly(SA, p)
+melting_ice_equilibrium_SA_CT_ratio_poly.types = _gsw_ufuncs.melting_ice_equilibrium_sa_ct_ratio_poly.types
+melting_ice_equilibrium_SA_CT_ratio_poly = match_args_return(melting_ice_equilibrium_SA_CT_ratio_poly)
 
-@match_args_return
 def melting_ice_into_seawater(SA, CT, p, w_Ih, t_Ih):
     """
     Calculates the final Absolute Salinity, final Conservative Temperature
     and final ice mass fraction that results when a given mass fraction of
     ice melts and is mixed into seawater whose properties are (SA,CT,p).
     This code takes the seawater to contain no dissolved air.
 
@@ -1992,16 +2136,17 @@
         zero there is no ice in the final state which consists
         only of seawater which is warmer than the freezing
         temperature.
 
 
     """
     return _gsw_ufuncs.melting_ice_into_seawater(SA, CT, p, w_Ih, t_Ih)
+melting_ice_into_seawater.types = _gsw_ufuncs.melting_ice_into_seawater.types
+melting_ice_into_seawater = match_args_return(melting_ice_into_seawater)
 
-@match_args_return
 def melting_ice_SA_CT_ratio(SA, CT, p, t_Ih):
     """
     Calculates the ratio of SA to CT changes when ice melts into seawater.
     It is assumed that a small mass of ice melts into an infinite mass of
     seawater.  Because of the infinite mass of seawater, the ice will always
     melt.
 
@@ -2021,16 +2166,17 @@
     melting_ice_SA_CT_ratio : array-like, g kg^-1 K^-1
         the ratio of SA to CT changes when ice melts
         into a large mass of seawater
 
 
     """
     return _gsw_ufuncs.melting_ice_sa_ct_ratio(SA, CT, p, t_Ih)
+melting_ice_SA_CT_ratio.types = _gsw_ufuncs.melting_ice_sa_ct_ratio.types
+melting_ice_SA_CT_ratio = match_args_return(melting_ice_SA_CT_ratio)
 
-@match_args_return
 def melting_ice_SA_CT_ratio_poly(SA, CT, p, t_Ih):
     """
     Calculates the ratio of SA to CT changes when ice melts into seawater.
     It is assumed that a small mass of ice melts into an infinite mass of
     seawater.  Because of the infinite mass of seawater, the ice will always
     melt.
 
@@ -2050,16 +2196,17 @@
     melting_ice_SA_CT_ratio : array-like, g kg^-1 K^-1
         the ratio of SA to CT changes when ice melts
         into a large mass of seawater
 
 
     """
     return _gsw_ufuncs.melting_ice_sa_ct_ratio_poly(SA, CT, p, t_Ih)
+melting_ice_SA_CT_ratio_poly.types = _gsw_ufuncs.melting_ice_sa_ct_ratio_poly.types
+melting_ice_SA_CT_ratio_poly = match_args_return(melting_ice_SA_CT_ratio_poly)
 
-@match_args_return
 def melting_seaice_equilibrium_SA_CT_ratio(SA, p):
     """
     Calculates the ratio of SA to CT changes when sea ice melts into
     seawater with both the seawater and the sea ice temperatures being
     almost equal to the equilibrium freezing temperature.  It is assumed
     that a small mass of seaice melts into an infinite mass of seawater.  If
     indeed the temperature of the seawater and the sea ice were both equal
@@ -2083,16 +2230,17 @@
         changes when sea ice melts into seawater, with
         the seawater and sea ice being close to the
         freezing temperature.
 
 
     """
     return _gsw_ufuncs.melting_seaice_equilibrium_sa_ct_ratio(SA, p)
+melting_seaice_equilibrium_SA_CT_ratio.types = _gsw_ufuncs.melting_seaice_equilibrium_sa_ct_ratio.types
+melting_seaice_equilibrium_SA_CT_ratio = match_args_return(melting_seaice_equilibrium_SA_CT_ratio)
 
-@match_args_return
 def melting_seaice_equilibrium_SA_CT_ratio_poly(SA, p):
     """
     Calculates the ratio of SA to CT changes when sea ice melts into
     seawater with both the seawater and the sea ice temperatures being
     almost equal to the equilibrium freezing temperature.  It is assumed
     that a small mass of seaice melts into an infinite mass of seawater.  If
     indeed the temperature of the seawater and the sea ice were both equal
@@ -2116,16 +2264,17 @@
         changes when sea ice melts into seawater, with
         the seawater and sea ice being close to the
         freezing temperature.
 
 
     """
     return _gsw_ufuncs.melting_seaice_equilibrium_sa_ct_ratio_poly(SA, p)
+melting_seaice_equilibrium_SA_CT_ratio_poly.types = _gsw_ufuncs.melting_seaice_equilibrium_sa_ct_ratio_poly.types
+melting_seaice_equilibrium_SA_CT_ratio_poly = match_args_return(melting_seaice_equilibrium_SA_CT_ratio_poly)
 
-@match_args_return
 def melting_seaice_into_seawater(SA, CT, p, w_seaice, SA_seaice, t_seaice):
     """
     Calculates the Absolute Salinity and Conservative Temperature that
     results when a given mass of sea ice (or ice) melts and is mixed into a
     known mass of seawater (whose properties are (SA,CT,p)).
 
     Parameters
@@ -2153,16 +2302,17 @@
     CT_final : array-like, deg C
         Conservative Temperature of the mixture of the melted
         sea ice (or ice) and the original seawater
 
 
     """
     return _gsw_ufuncs.melting_seaice_into_seawater(SA, CT, p, w_seaice, SA_seaice, t_seaice)
+melting_seaice_into_seawater.types = _gsw_ufuncs.melting_seaice_into_seawater.types
+melting_seaice_into_seawater = match_args_return(melting_seaice_into_seawater)
 
-@match_args_return
 def melting_seaice_SA_CT_ratio(SA, CT, p, SA_seaice, t_seaice):
     """
     Calculates the ratio of SA to CT changes when sea ice melts into
     seawater.  It is assumed that a small mass of sea ice melts into an
     infinite mass of seawater.  Because of the infinite mass of seawater,
     the sea ice will always melt.
 
@@ -2185,16 +2335,17 @@
     melting_seaice_SA_CT_ratio : array-like, g/(kg K)
         the ratio dSA/dCT of SA to CT changes when
         sea ice melts into a large mass of seawater
 
 
     """
     return _gsw_ufuncs.melting_seaice_sa_ct_ratio(SA, CT, p, SA_seaice, t_seaice)
+melting_seaice_SA_CT_ratio.types = _gsw_ufuncs.melting_seaice_sa_ct_ratio.types
+melting_seaice_SA_CT_ratio = match_args_return(melting_seaice_SA_CT_ratio)
 
-@match_args_return
 def melting_seaice_SA_CT_ratio_poly(SA, CT, p, SA_seaice, t_seaice):
     """
     Calculates the ratio of SA to CT changes when sea ice melts into
     seawater.  It is assumed that a small mass of sea ice melts into an
     infinite mass of seawater.  Because of the infinite mass of seawater,
     the sea ice will always melt.
 
@@ -2217,16 +2368,17 @@
     melting_seaice_SA_CT_ratio : array-like, g/(kg K)
         the ratio dSA/dCT of SA to CT changes when
         sea ice melts into a large mass of seawater
 
 
     """
     return _gsw_ufuncs.melting_seaice_sa_ct_ratio_poly(SA, CT, p, SA_seaice, t_seaice)
+melting_seaice_SA_CT_ratio_poly.types = _gsw_ufuncs.melting_seaice_sa_ct_ratio_poly.types
+melting_seaice_SA_CT_ratio_poly = match_args_return(melting_seaice_SA_CT_ratio_poly)
 
-@match_args_return
 def O2sol(SA, CT, p, lon, lat):
     """
     Calculates the oxygen concentration expected at equilibrium with air at
     an Absolute Pressure of 101325 Pa (sea pressure of 0 dbar) including
     saturated water vapor.  This function uses the solubility coefficients
     derived from the data of Benson and Krause (1984), as fitted by Garcia
     and Gordon (1992, 1993).
@@ -2248,16 +2400,17 @@
     -------
     O2sol : array-like, umol/kg
         solubility of oxygen in micro-moles per kg
 
 
     """
     return _gsw_ufuncs.o2sol(SA, CT, p, lon, lat)
+O2sol.types = _gsw_ufuncs.o2sol.types
+O2sol = match_args_return(O2sol)
 
-@match_args_return
 def O2sol_SP_pt(SP, pt):
     """
     Calculates the oxygen concentration expected at equilibrium with air at
     an Absolute Pressure of 101325 Pa (sea pressure of 0 dbar) including
     saturated water vapor.  This function uses the solubility coefficients
     derived from the data of Benson and Krause (1984), as fitted by Garcia
     and Gordon (1992, 1993).
@@ -2273,16 +2426,17 @@
     -------
     O2sol : array-like, umol/kg
         solubility of oxygen in micro-moles per kg
 
 
     """
     return _gsw_ufuncs.o2sol_sp_pt(SP, pt)
+O2sol_SP_pt.types = _gsw_ufuncs.o2sol_sp_pt.types
+O2sol_SP_pt = match_args_return(O2sol_SP_pt)
 
-@match_args_return
 def p_from_z(z, lat, geo_strf_dyn_height, sea_surface_geopotential):
     """
     Calculates sea pressure from height using computationally-efficient
     75-term expression for density, in terms of SA, CT and p (Roquet et al.,
     2015).  Dynamic height anomaly, geo_strf_dyn_height, if provided,
     must be computed with its p_ref = 0 (the surface). Also if provided,
     sea_surface_geopotental is the geopotential at zero sea pressure. This
@@ -2306,16 +2460,17 @@
     p : array-like, dbar
         sea pressure
         ( i.e. absolute pressure - 10.1325 dbar )
 
 
     """
     return _gsw_ufuncs.p_from_z(z, lat, geo_strf_dyn_height, sea_surface_geopotential)
+p_from_z.types = _gsw_ufuncs.p_from_z.types
+p_from_z = match_args_return(p_from_z)
 
-@match_args_return
 def pot_enthalpy_from_pt_ice(pt0_ice):
     """
     Calculates the potential enthalpy of ice from potential temperature of
     ice (whose reference sea pressure is zero dbar).
 
     Parameters
     ----------
@@ -2326,16 +2481,17 @@
     -------
     pot_enthalpy_ice : array-like, J/kg
         potential enthalpy of ice
 
 
     """
     return _gsw_ufuncs.pot_enthalpy_from_pt_ice(pt0_ice)
+pot_enthalpy_from_pt_ice.types = _gsw_ufuncs.pot_enthalpy_from_pt_ice.types
+pot_enthalpy_from_pt_ice = match_args_return(pot_enthalpy_from_pt_ice)
 
-@match_args_return
 def pot_enthalpy_from_pt_ice_poly(pt0_ice):
     """
     Calculates the potential enthalpy of ice from potential temperature of
     ice (whose reference sea pressure is zero dbar).  This is a
     compuationally efficient polynomial fit to the potential enthalpy of
     ice.
 
@@ -2348,16 +2504,17 @@
     -------
     pot_enthalpy_ice : array-like, J/kg
         potential enthalpy of ice
 
 
     """
     return _gsw_ufuncs.pot_enthalpy_from_pt_ice_poly(pt0_ice)
+pot_enthalpy_from_pt_ice_poly.types = _gsw_ufuncs.pot_enthalpy_from_pt_ice_poly.types
+pot_enthalpy_from_pt_ice_poly = match_args_return(pot_enthalpy_from_pt_ice_poly)
 
-@match_args_return
 def pot_enthalpy_ice_freezing(SA, p):
     """
     Calculates the potential enthalpy of ice at which seawater freezes.
 
     Parameters
     ----------
     SA : array-like
@@ -2370,16 +2527,17 @@
     pot_enthalpy_ice_freezing : array-like, J/kg
         potential enthalpy of ice at freezing
         of seawater
 
 
     """
     return _gsw_ufuncs.pot_enthalpy_ice_freezing(SA, p)
+pot_enthalpy_ice_freezing.types = _gsw_ufuncs.pot_enthalpy_ice_freezing.types
+pot_enthalpy_ice_freezing = match_args_return(pot_enthalpy_ice_freezing)
 
-@match_args_return
 def pot_enthalpy_ice_freezing_first_derivatives(SA, p):
     """
     Calculates the first derivatives of the potential enthalpy of ice at
     which seawater freezes, with respect to Absolute Salinity SA and
     pressure P (in Pa).
 
     Parameters
@@ -2399,21 +2557,22 @@
         the derivative of the potential enthalpy
         of ice at freezing (ITS-90) with respect to pressure
         (in Pa) at fixed Absolute Salinity
 
 
     """
     return _gsw_ufuncs.pot_enthalpy_ice_freezing_first_derivatives(SA, p)
+pot_enthalpy_ice_freezing_first_derivatives.types = _gsw_ufuncs.pot_enthalpy_ice_freezing_first_derivatives.types
+pot_enthalpy_ice_freezing_first_derivatives = match_args_return(pot_enthalpy_ice_freezing_first_derivatives)
 
-@match_args_return
 def pot_enthalpy_ice_freezing_first_derivatives_poly(SA, p):
     """
     Calculates the first derivatives of the potential enthalpy of ice Ih at
     which ice melts into seawater with Absolute Salinity SA and at pressure
-    p.  This code uses the comptationally efficient polynomial fit of the
+    p.  This code uses the computationally efficient polynomial fit of the
     freezing potential enthalpy of ice Ih (McDougall et al., 2015).
 
     Parameters
     ----------
     SA : array-like
         Absolute Salinity, g/kg
     p : array-like
@@ -2429,16 +2588,17 @@
         the derivative of the potential enthalpy
         of ice at freezing (ITS-90) with respect to pressure
         (in Pa) at fixed Absolute Salinity
 
 
     """
     return _gsw_ufuncs.pot_enthalpy_ice_freezing_first_derivatives_poly(SA, p)
+pot_enthalpy_ice_freezing_first_derivatives_poly.types = _gsw_ufuncs.pot_enthalpy_ice_freezing_first_derivatives_poly.types
+pot_enthalpy_ice_freezing_first_derivatives_poly = match_args_return(pot_enthalpy_ice_freezing_first_derivatives_poly)
 
-@match_args_return
 def pot_enthalpy_ice_freezing_poly(SA, p):
     """
     Calculates the potential enthalpy of ice at which seawater freezes.
     The error of this fit ranges between -2.5 and 1 J/kg with an rms of
     1.07, between SA of 0 and 120 g/kg and p between 0 and 10,000 dbar (the
     error in the fit is between -0.7 and 0.7 with an rms of
     0.3, between SA of 0 and 120 g/kg and p between 0 and 5,000 dbar) when
@@ -2460,16 +2620,17 @@
     pot_enthalpy_ice_freezing : array-like, J/kg
         potential enthalpy of ice at freezing
         of seawater
 
 
     """
     return _gsw_ufuncs.pot_enthalpy_ice_freezing_poly(SA, p)
+pot_enthalpy_ice_freezing_poly.types = _gsw_ufuncs.pot_enthalpy_ice_freezing_poly.types
+pot_enthalpy_ice_freezing_poly = match_args_return(pot_enthalpy_ice_freezing_poly)
 
-@match_args_return
 def pot_rho_t_exact(SA, t, p, p_ref):
     """
     Calculates potential density of seawater.  Note. This function outputs
     potential density, not potential density anomaly; that is, 1000 kg/m^3
     is not subtracted.
 
     Parameters
@@ -2487,16 +2648,17 @@
     -------
     pot_rho_t_exact : array-like, kg/m^3
         potential density (not potential density anomaly)
 
 
     """
     return _gsw_ufuncs.pot_rho_t_exact(SA, t, p, p_ref)
+pot_rho_t_exact.types = _gsw_ufuncs.pot_rho_t_exact.types
+pot_rho_t_exact = match_args_return(pot_rho_t_exact)
 
-@match_args_return
 def pressure_coefficient_ice(t, p):
     """
     Calculates pressure coefficient of ice.
 
     Parameters
     ----------
     t : array-like
@@ -2508,16 +2670,17 @@
     -------
     pressure_coefficient_ice : array-like, Pa/K
         pressure coefficient of ice
 
 
     """
     return _gsw_ufuncs.pressure_coefficient_ice(t, p)
+pressure_coefficient_ice.types = _gsw_ufuncs.pressure_coefficient_ice.types
+pressure_coefficient_ice = match_args_return(pressure_coefficient_ice)
 
-@match_args_return
 def pressure_freezing_CT(SA, CT, saturation_fraction):
     """
     Calculates the pressure (in dbar) of seawater at the freezing
     temperature.  That is, the output is the pressure at which seawater,
     with Absolute Salinity SA, Conservative Temperature CT, and with
     saturation_fraction of dissolved air, freezes.  If the input values are
     such that there is no value of pressure in the range between 0 dbar and
@@ -2538,16 +2701,17 @@
     pressure_freezing : array-like, dbar
         sea pressure at which the seawater freezes
         ( i.e. absolute pressure - 10.1325 dbar )
 
 
     """
     return _gsw_ufuncs.pressure_freezing_ct(SA, CT, saturation_fraction)
+pressure_freezing_CT.types = _gsw_ufuncs.pressure_freezing_ct.types
+pressure_freezing_CT = match_args_return(pressure_freezing_CT)
 
-@match_args_return
 def pt0_from_t(SA, t, p):
     """
     Calculates potential temperature with reference pressure, p_ref = 0 dbar.
     The present routine is computationally faster than the more general
     function "gsw_pt_from_t(SA,t,p,p_ref)" which can be used for any
     reference pressure value.
     This subroutine calls "gsw_entropy_part(SA,t,p)",
@@ -2567,16 +2731,17 @@
     pt0 : array-like, deg C
         potential temperature
         with reference sea pressure (p_ref) = 0 dbar.
 
 
     """
     return _gsw_ufuncs.pt0_from_t(SA, t, p)
+pt0_from_t.types = _gsw_ufuncs.pt0_from_t.types
+pt0_from_t = match_args_return(pt0_from_t)
 
-@match_args_return
 def pt0_from_t_ice(t, p):
     """
     Calculates potential temperature of ice Ih with a reference pressure of
     0 dbar, from in-situ temperature, t.
 
     Parameters
     ----------
@@ -2590,16 +2755,17 @@
     pt0_ice : array-like, deg C
         potential temperature of ice Ih with reference pressure of
         zero dbar (ITS-90)
 
 
     """
     return _gsw_ufuncs.pt0_from_t_ice(t, p)
+pt0_from_t_ice.types = _gsw_ufuncs.pt0_from_t_ice.types
+pt0_from_t_ice = match_args_return(pt0_from_t_ice)
 
-@match_args_return
 def pt_first_derivatives(SA, CT):
     """
     Calculates the following two partial derivatives of potential
     temperature (the regular potential temperature whose reference sea
     pressure is 0 dbar)
     (1) pt_SA, the derivative with respect to Absolute Salinity at
     constant Conservative Temperature, and
@@ -2622,16 +2788,17 @@
         The derivative of potential temperature with respect to
         Conservative Temperature at constant Absolute Salinity.
         pt_CT is dimensionless.
 
 
     """
     return _gsw_ufuncs.pt_first_derivatives(SA, CT)
+pt_first_derivatives.types = _gsw_ufuncs.pt_first_derivatives.types
+pt_first_derivatives = match_args_return(pt_first_derivatives)
 
-@match_args_return
 def pt_from_CT(SA, CT):
     """
     Calculates potential temperature (with a reference sea pressure of
     zero dbar) from Conservative Temperature.  This function uses 1.5
     iterations through a modified Newton-Raphson (N-R) iterative solution
     procedure, starting from a rational-function-based initial condition
     for both pt and dCT_dpt.
@@ -2648,16 +2815,17 @@
     pt : array-like, deg C
         potential temperature referenced to a sea pressure
         of zero dbar (ITS-90)
 
 
     """
     return _gsw_ufuncs.pt_from_ct(SA, CT)
+pt_from_CT.types = _gsw_ufuncs.pt_from_ct.types
+pt_from_CT = match_args_return(pt_from_CT)
 
-@match_args_return
 def pt_from_entropy(SA, entropy):
     """
     Calculates potential temperature with reference pressure p_ref = 0 dbar
     and with entropy as an input variable.
 
     Parameters
     ----------
@@ -2671,16 +2839,17 @@
     pt : array-like, deg C
         potential temperature
         with reference sea pressure (p_ref) = 0 dbar.
 
 
     """
     return _gsw_ufuncs.pt_from_entropy(SA, entropy)
+pt_from_entropy.types = _gsw_ufuncs.pt_from_entropy.types
+pt_from_entropy = match_args_return(pt_from_entropy)
 
-@match_args_return
 def pt_from_pot_enthalpy_ice(pot_enthalpy_ice):
     """
     Calculates the potential temperature of ice from the potential enthalpy
     of ice.  The reference sea pressure of both the potential temperature
     and the potential enthalpy is zero dbar.
 
     Parameters
@@ -2692,16 +2861,17 @@
     -------
     pt0_ice : array-like, deg C
         potential temperature of ice (ITS-90)
 
 
     """
     return _gsw_ufuncs.pt_from_pot_enthalpy_ice(pot_enthalpy_ice)
+pt_from_pot_enthalpy_ice.types = _gsw_ufuncs.pt_from_pot_enthalpy_ice.types
+pt_from_pot_enthalpy_ice = match_args_return(pt_from_pot_enthalpy_ice)
 
-@match_args_return
 def pt_from_pot_enthalpy_ice_poly(pot_enthalpy_ice):
     """
     Calculates the potential temperature of ice (whose reference sea
     pressure is zero dbar) from the potential enthalpy of ice.  This is a
     compuationally efficient polynomial fit to the potential enthalpy of
     ice.
 
@@ -2714,16 +2884,17 @@
     -------
     pt0_ice : array-like, deg C
         potential temperature of ice (ITS-90)
 
 
     """
     return _gsw_ufuncs.pt_from_pot_enthalpy_ice_poly(pot_enthalpy_ice)
+pt_from_pot_enthalpy_ice_poly.types = _gsw_ufuncs.pt_from_pot_enthalpy_ice_poly.types
+pt_from_pot_enthalpy_ice_poly = match_args_return(pt_from_pot_enthalpy_ice_poly)
 
-@match_args_return
 def pt_from_t(SA, t, p, p_ref):
     """
     Calculates potential temperature with the general reference pressure,
     p_ref, from in-situ temperature, t.  This function calls
     "gsw_entropy_part" which evaluates entropy except for the parts which
     are a function of Absolute Salinity alone.
     A faster gsw routine exists if p_ref is indeed zero dbar.  This routine
@@ -2745,16 +2916,17 @@
     pt : array-like, deg C
         potential temperature with reference pressure, p_ref, on the
         ITS-90 temperature scale
 
 
     """
     return _gsw_ufuncs.pt_from_t(SA, t, p, p_ref)
+pt_from_t.types = _gsw_ufuncs.pt_from_t.types
+pt_from_t = match_args_return(pt_from_t)
 
-@match_args_return
 def pt_from_t_ice(t, p, p_ref):
     """
     Calculates potential temperature of ice Ih with the general reference
     pressure, p_ref, from in-situ temperature, t.
 
     Parameters
     ----------
@@ -2770,16 +2942,17 @@
     pt_ice : array-like, deg C
         potential temperature of ice Ih with reference pressure,
         p_ref, on the ITS-90 temperature scale
 
 
     """
     return _gsw_ufuncs.pt_from_t_ice(t, p, p_ref)
+pt_from_t_ice.types = _gsw_ufuncs.pt_from_t_ice.types
+pt_from_t_ice = match_args_return(pt_from_t_ice)
 
-@match_args_return
 def pt_second_derivatives(SA, CT):
     """
     Calculates the following three second-order derivatives of potential
     temperature (the regular potential temperature which has a reference
     sea pressure of 0 dbar),
     (1) pt_SA_SA, the second derivative with respect to Absolute Salinity
     at constant Conservative Temperature,
@@ -2809,16 +2982,17 @@
         The second derivative of potential temperature (the
         regular one with p_ref = 0 dbar) with respect to
         Conservative Temperature at constant SA.
 
 
     """
     return _gsw_ufuncs.pt_second_derivatives(SA, CT)
+pt_second_derivatives.types = _gsw_ufuncs.pt_second_derivatives.types
+pt_second_derivatives = match_args_return(pt_second_derivatives)
 
-@match_args_return
 def rho(SA, CT, p):
     """
     Calculates in-situ density from Absolute Salinity and Conservative
     Temperature, using the computationally-efficient expression for
     specific volume in terms of SA, CT and p  (Roquet et al., 2015).
 
     Parameters
@@ -2834,16 +3008,17 @@
     -------
     rho : array-like, kg/m
         in-situ density
 
 
     """
     return _gsw_ufuncs.rho(SA, CT, p)
+rho.types = _gsw_ufuncs.rho.types
+rho = match_args_return(rho)
 
-@match_args_return
 def rho_alpha_beta(SA, CT, p):
     """
     Calculates in-situ density, the appropriate thermal expansion coefficient
     and the appropriate saline contraction coefficient of seawater from
     Absolute Salinity and Conservative Temperature.  This function uses the
     computationally-efficient expression for specific volume in terms of
     SA, CT and p (Roquet et al., 2015).
@@ -2867,16 +3042,17 @@
     beta : array-like, kg/g
         saline (i.e. haline) contraction
         coefficient at constant Conservative Temperature
 
 
     """
     return _gsw_ufuncs.rho_alpha_beta(SA, CT, p)
+rho_alpha_beta.types = _gsw_ufuncs.rho_alpha_beta.types
+rho_alpha_beta = match_args_return(rho_alpha_beta)
 
-@match_args_return
 def rho_first_derivatives(SA, CT, p):
     """
     Calculates the three (3) partial derivatives of in-situ density with
     respect to Absolute Salinity, Conservative Temperature and pressure.
     Note that the pressure derivative is done with respect to pressure in
     Pa, not dbar.  This function uses the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
@@ -2902,48 +3078,49 @@
     rho_P : array-like, kg/(m^3 Pa)
         partial derivative of density
         with respect to pressure in Pa
 
 
     """
     return _gsw_ufuncs.rho_first_derivatives(SA, CT, p)
+rho_first_derivatives.types = _gsw_ufuncs.rho_first_derivatives.types
+rho_first_derivatives = match_args_return(rho_first_derivatives)
 
-@match_args_return
 def rho_first_derivatives_wrt_enthalpy(SA, CT, p):
     """
-    Calculates the following two first-order derivatives of specific
-    volume (v),
-    (1) rho_SA, first-order derivative with respect to Absolute Salinity
-    at constant CT & p.
-    (2) rho_h, first-order derivative with respect to SA & CT at
-    constant p.
+    Calculates the following two first-order derivatives of rho,
+    (1) rho_SA_wrt_h, first-order derivative with respect to Absolute
+    Salinity at constant h & p.
+    (2) rho_h, first-order derivative with respect to h at
+    constant SA & p.
 
     Parameters
     ----------
     SA : array-like
         Absolute Salinity, g/kg
     CT : array-like
         Conservative Temperature (ITS-90), degrees C
     p : array-like
         Sea pressure (absolute pressure minus 10.1325 dbar), dbar
 
     Returns
     -------
-    rho_SA : array-like, J/(kg (g/kg)^2)
+    rho_SA_wrt_h : array-like, ((kg/m^3)(g/kg)^-1
         The first derivative of rho with respect to
         Absolute Salinity at constant CT & p.
-    rho_h : array-like, J/(kg K(g/kg))
+    rho_h : array-like, (m^3/kg)(J/kg)^-1
         The first derivative of rho with respect to
         SA and CT at constant p.
 
 
     """
     return _gsw_ufuncs.rho_first_derivatives_wrt_enthalpy(SA, CT, p)
+rho_first_derivatives_wrt_enthalpy.types = _gsw_ufuncs.rho_first_derivatives_wrt_enthalpy.types
+rho_first_derivatives_wrt_enthalpy = match_args_return(rho_first_derivatives_wrt_enthalpy)
 
-@match_args_return
 def rho_ice(t, p):
     """
     Calculates in-situ density of ice from in-situ temperature and pressure.
     Note that the output, rho_ice, is density, not density anomaly;  that
     is, 1000 kg/m^3 is not subtracted from it.
 
     Parameters
@@ -2957,16 +3134,17 @@
     -------
     rho_ice : array-like, kg/m^3
         in-situ density of ice (not density anomaly)
 
 
     """
     return _gsw_ufuncs.rho_ice(t, p)
+rho_ice.types = _gsw_ufuncs.rho_ice.types
+rho_ice = match_args_return(rho_ice)
 
-@match_args_return
 def rho_second_derivatives(SA, CT, p):
     """
     Calculates the following five second-order derivatives of rho,
     (1) rho_SA_SA, second-order derivative with respect to Absolute
     Salinity at constant CT & p.
     (2) rho_SA_CT, second-order derivative with respect to SA & CT at
     constant p.
@@ -3003,16 +3181,17 @@
     rho_CT_P : array-like, (kg/m^3) K^-1 Pa^-1
         The second-order derivative with respect to CT & P at
         constant SA.
 
 
     """
     return _gsw_ufuncs.rho_second_derivatives(SA, CT, p)
+rho_second_derivatives.types = _gsw_ufuncs.rho_second_derivatives.types
+rho_second_derivatives = match_args_return(rho_second_derivatives)
 
-@match_args_return
 def rho_second_derivatives_wrt_enthalpy(SA, CT, p):
     """
     Calculates the following three second-order derivatives of rho with
     respect to enthalpy,
     (1) rho_SA_SA, second-order derivative with respect to Absolute Salinity
     at constant h & p.
     (2) rho_SA_h, second-order derivative with respect to SA & h at
@@ -3027,29 +3206,30 @@
     CT : array-like
         Conservative Temperature (ITS-90), degrees C
     p : array-like
         Sea pressure (absolute pressure minus 10.1325 dbar), dbar
 
     Returns
     -------
-    rho_SA_SA : array-like, J/(kg (g/kg)^2)
+    rho_SA_SA : array-like, (kg/m^3)(g/kg)^-2
         The second-order derivative of rho with respect to
         Absolute Salinity at constant h & p.
     rho_SA_h : array-like, J/(kg K(g/kg))
         The second-order derivative of rho with respect to
         SA and h at constant p.
     rho_h_h : array-like,
         The second-order derivative of rho with respect to h at
         constant SA & p
 
 
     """
     return _gsw_ufuncs.rho_second_derivatives_wrt_enthalpy(SA, CT, p)
+rho_second_derivatives_wrt_enthalpy.types = _gsw_ufuncs.rho_second_derivatives_wrt_enthalpy.types
+rho_second_derivatives_wrt_enthalpy = match_args_return(rho_second_derivatives_wrt_enthalpy)
 
-@match_args_return
 def rho_t_exact(SA, t, p):
     """
     Calculates in-situ density of seawater from Absolute Salinity and
     in-situ temperature.  Note that the output, rho, is density,
     not density anomaly; that is, 1000 kg/m^3 is not subtracted from it.
 
     Parameters
@@ -3065,16 +3245,17 @@
     -------
     rho_t_exact : array-like, kg/m^3
         in-situ density (not density anomaly)
 
 
     """
     return _gsw_ufuncs.rho_t_exact(SA, t, p)
+rho_t_exact.types = _gsw_ufuncs.rho_t_exact.types
+rho_t_exact = match_args_return(rho_t_exact)
 
-@match_args_return
 def SA_freezing_from_CT(CT, p, saturation_fraction):
     """
     Calculates the Absolute Salinity of seawater at the freezing temperature.
     That is, the output is the Absolute Salinity of seawater, with
     Conservative Temperature CT, pressure p and the fraction
     saturation_fraction of dissolved air, that is in equilibrium
     with ice at the same in situ temperature and pressure.  If the input
@@ -3096,16 +3277,17 @@
         Absolute Salinity of seawater when it freezes, for
         given input values of its Conservative Temperature,
         pressure and air saturation fraction.
 
 
     """
     return _gsw_ufuncs.sa_freezing_from_ct(CT, p, saturation_fraction)
+SA_freezing_from_CT.types = _gsw_ufuncs.sa_freezing_from_ct.types
+SA_freezing_from_CT = match_args_return(SA_freezing_from_CT)
 
-@match_args_return
 def SA_freezing_from_CT_poly(CT, p, saturation_fraction):
     """
     Calculates the Absolute Salinity of seawater at the freezing temperature.
     That is, the output is the Absolute Salinity of seawater, with the
     fraction saturation_fraction of dissolved air, that is in equilibrium
     with ice at Conservative Temperature CT and pressure p.  If the input
     values are such that there is no positive value of Absolute Salinity for
@@ -3126,16 +3308,17 @@
         Absolute Salinity of seawater when it freezes, for
         given input values of Conservative Temperature
         pressure and air saturation fraction.
 
 
     """
     return _gsw_ufuncs.sa_freezing_from_ct_poly(CT, p, saturation_fraction)
+SA_freezing_from_CT_poly.types = _gsw_ufuncs.sa_freezing_from_ct_poly.types
+SA_freezing_from_CT_poly = match_args_return(SA_freezing_from_CT_poly)
 
-@match_args_return
 def SA_freezing_from_t(t, p, saturation_fraction):
     """
     Calculates the Absolute Salinity of seawater at the freezing temperature.
     That is, the output is the Absolute Salinity of seawater, with the
     fraction saturation_fraction of dissolved air, that is in equilibrium
     with ice at in-situ temperature t and pressure p.  If the input values
     are such that there is no positive value of Absolute Salinity for which
@@ -3156,16 +3339,17 @@
         Absolute Salinity of seawater when it freezes, for
         given input values of in situ temperature, pressure and
         air saturation fraction.
 
 
     """
     return _gsw_ufuncs.sa_freezing_from_t(t, p, saturation_fraction)
+SA_freezing_from_t.types = _gsw_ufuncs.sa_freezing_from_t.types
+SA_freezing_from_t = match_args_return(SA_freezing_from_t)
 
-@match_args_return
 def SA_freezing_from_t_poly(t, p, saturation_fraction):
     """
     Calculates the Absolute Salinity of seawater at the freezing temperature.
     That is, the output is the Absolute Salinity of seawater, with the
     fraction saturation_fraction of dissolved air, that is in equilibrium
     with ice at in-situ temperature t and pressure p.  If the input values
     are such that there is no positive value of Absolute Salinity for which
@@ -3186,16 +3370,17 @@
         Absolute Salinity of seawater when it freezes, for
         given input values of in situ temperature, pressure and
         air saturation fraction.
 
 
     """
     return _gsw_ufuncs.sa_freezing_from_t_poly(t, p, saturation_fraction)
+SA_freezing_from_t_poly.types = _gsw_ufuncs.sa_freezing_from_t_poly.types
+SA_freezing_from_t_poly = match_args_return(SA_freezing_from_t_poly)
 
-@match_args_return
 def SA_from_rho(rho, CT, p):
     """
     Calculates the Absolute Salinity of a seawater sample, for given values
     of its density, Conservative Temperature and sea pressure (in dbar).
     This function uses the computationally-efficient 75-term expression for
     specific volume in terms of SA, CT and p (Roquet et al., 2015).
 
@@ -3212,16 +3397,17 @@
     -------
     SA : array-like, g/kg
         Absolute Salinity.
 
 
     """
     return _gsw_ufuncs.sa_from_rho(rho, CT, p)
+SA_from_rho.types = _gsw_ufuncs.sa_from_rho.types
+SA_from_rho = match_args_return(SA_from_rho)
 
-@match_args_return
 def SA_from_SP(SP, p, lon, lat):
     """
     Calculates Absolute Salinity from Practical Salinity.  Since SP is
     non-negative by definition, this function changes any negative input
     values of SP to be zero.
 
     Parameters
@@ -3239,16 +3425,17 @@
     -------
     SA : array-like, g/kg
         Absolute Salinity
 
 
     """
     return _gsw_ufuncs.sa_from_sp(SP, p, lon, lat)
+SA_from_SP.types = _gsw_ufuncs.sa_from_sp.types
+SA_from_SP = match_args_return(SA_from_SP)
 
-@match_args_return
 def SA_from_SP_Baltic(SP, lon, lat):
     """
     Calculates Absolute Salinity in the Baltic Sea, from Practical Salinity.
     Since SP is non-negative by definition, this function changes any
     negative input values of SP to be zero.
     Note. This programme will only produce Absolute Salinity values for the
     Baltic Sea.
@@ -3266,16 +3453,17 @@
     -------
     SA_baltic : array-like, g kg^-1
         Absolute Salinity in the Baltic Sea
 
 
     """
     return _gsw_ufuncs.sa_from_sp_baltic(SP, lon, lat)
+SA_from_SP_Baltic.types = _gsw_ufuncs.sa_from_sp_baltic.types
+SA_from_SP_Baltic = match_args_return(SA_from_SP_Baltic)
 
-@match_args_return
 def SA_from_Sstar(Sstar, p, lon, lat):
     """
     Calculates Absolute Salinity from Preformed Salinity.
 
     Parameters
     ----------
     Sstar : array-like
@@ -3291,16 +3479,17 @@
     -------
     SA : array-like, g/kg
         Absolute Salinity
 
 
     """
     return _gsw_ufuncs.sa_from_sstar(Sstar, p, lon, lat)
+SA_from_Sstar.types = _gsw_ufuncs.sa_from_sstar.types
+SA_from_Sstar = match_args_return(SA_from_Sstar)
 
-@match_args_return
 def SAAR(p, lon, lat):
     """
     Calculates the Absolute Salinity Anomaly Ratio, SAAR, in the open ocean
     by spatially interpolating the global reference data set of SAAR to the
     location of the seawater sample.
 
     Parameters
@@ -3316,16 +3505,17 @@
     -------
     SAAR : array-like, unitless
         Absolute Salinity Anomaly Ratio
 
 
     """
     return _gsw_ufuncs.saar(p, lon, lat)
+SAAR.types = _gsw_ufuncs.saar.types
+SAAR = match_args_return(SAAR)
 
-@match_args_return
 def seaice_fraction_to_freeze_seawater(SA, CT, p, SA_seaice, t_seaice):
     """
     Calculates the mass fraction of sea ice (mass of sea ice divided by mass
     of sea ice plus seawater), which, when melted into seawater having the
     properties (SA,CT,p) causes the final seawater to be at the freezing
     temperature.  The other outputs are the Absolute Salinity and
     Conservative Temperature of the final seawater.
@@ -3361,16 +3551,17 @@
         which, when melted into seawater at (SA,CT,p) leads to the
         final mixed seawater being at the freezing temperature.
         This output is between 0 and 1.
 
 
     """
     return _gsw_ufuncs.seaice_fraction_to_freeze_seawater(SA, CT, p, SA_seaice, t_seaice)
+seaice_fraction_to_freeze_seawater.types = _gsw_ufuncs.seaice_fraction_to_freeze_seawater.types
+seaice_fraction_to_freeze_seawater = match_args_return(seaice_fraction_to_freeze_seawater)
 
-@match_args_return
 def sigma0(SA, CT):
     """
     Calculates potential density anomaly with reference pressure of 0 dbar,
     this being this particular potential density minus 1000 kg/m^3.  This
     function has inputs of Absolute Salinity and Conservative Temperature.
     This function uses the computationally-efficient expression for
     specific volume in terms of SA, CT and p (Roquet et al., 2015).
@@ -3388,16 +3579,17 @@
         potential density anomaly with
         respect to a reference pressure of 0 dbar,
         that is, this potential density - 1000 kg/m^3.
 
 
     """
     return _gsw_ufuncs.sigma0(SA, CT)
+sigma0.types = _gsw_ufuncs.sigma0.types
+sigma0 = match_args_return(sigma0)
 
-@match_args_return
 def sigma1(SA, CT):
     """
     Calculates potential density anomaly with reference pressure of 1000
     dbar, this being this particular potential density minus 1000 kg/m^3.
     This function has inputs of Absolute Salinity and Conservative
     Temperature.  This function uses the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
@@ -3416,16 +3608,17 @@
         potential density anomaly with
         respect to a reference pressure of 1000 dbar,
         that is, this potential density - 1000 kg/m^3.
 
 
     """
     return _gsw_ufuncs.sigma1(SA, CT)
+sigma1.types = _gsw_ufuncs.sigma1.types
+sigma1 = match_args_return(sigma1)
 
-@match_args_return
 def sigma2(SA, CT):
     """
     Calculates potential density anomaly with reference pressure of 2000
     dbar, this being this particular potential density minus 1000 kg/m^3.
     Temperature.  This function uses the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -3443,16 +3636,17 @@
         potential density anomaly with
         respect to a reference pressure of 2000 dbar,
         that is, this potential density - 1000 kg/m^3.
 
 
     """
     return _gsw_ufuncs.sigma2(SA, CT)
+sigma2.types = _gsw_ufuncs.sigma2.types
+sigma2 = match_args_return(sigma2)
 
-@match_args_return
 def sigma3(SA, CT):
     """
     Calculates potential density anomaly with reference pressure of 3000
     dbar, this being this particular potential density minus 1000 kg/m^3.
     Temperature.  This function uses the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -3470,16 +3664,17 @@
         potential density anomaly with
         respect to a reference pressure of 3000 dbar,
         that is, this potential density - 1000 kg/m^3.
 
 
     """
     return _gsw_ufuncs.sigma3(SA, CT)
+sigma3.types = _gsw_ufuncs.sigma3.types
+sigma3 = match_args_return(sigma3)
 
-@match_args_return
 def sigma4(SA, CT):
     """
     Calculates potential density anomaly with reference pressure of 4000
     dbar, this being this particular potential density minus 1000 kg/m^3.
     Temperature.  This function uses the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -3497,16 +3692,17 @@
         potential density anomaly with
         respect to a reference pressure of 4000 dbar,
         that is, this potential density - 1000 kg/m^3.
 
 
     """
     return _gsw_ufuncs.sigma4(SA, CT)
+sigma4.types = _gsw_ufuncs.sigma4.types
+sigma4 = match_args_return(sigma4)
 
-@match_args_return
 def sound_speed(SA, CT, p):
     """
     Calculates the speed of sound in seawater.  This function has inputs of
     Absolute Salinity and Conservative Temperature.  This function uses the
     computationally-efficient expression for specific volume in terms of SA,
     CT and p (Roquet et al., 2015).
 
@@ -3523,16 +3719,17 @@
     -------
     sound_speed : array-like, m/s
         speed of sound in seawater
 
 
     """
     return _gsw_ufuncs.sound_speed(SA, CT, p)
+sound_speed.types = _gsw_ufuncs.sound_speed.types
+sound_speed = match_args_return(sound_speed)
 
-@match_args_return
 def sound_speed_ice(t, p):
     """
     Calculates the compression speed of sound in ice.
 
     Parameters
     ----------
     t : array-like
@@ -3544,16 +3741,17 @@
     -------
     sound_speed_ice : array-like, m/s
         compression speed of sound in ice
 
 
     """
     return _gsw_ufuncs.sound_speed_ice(t, p)
+sound_speed_ice.types = _gsw_ufuncs.sound_speed_ice.types
+sound_speed_ice = match_args_return(sound_speed_ice)
 
-@match_args_return
 def sound_speed_t_exact(SA, t, p):
     """
     Calculates the speed of sound in seawater.
 
     Parameters
     ----------
     SA : array-like
@@ -3567,16 +3765,17 @@
     -------
     sound_speed_t_exact : array-like, m/s
         speed of sound in seawater
 
 
     """
     return _gsw_ufuncs.sound_speed_t_exact(SA, t, p)
+sound_speed_t_exact.types = _gsw_ufuncs.sound_speed_t_exact.types
+sound_speed_t_exact = match_args_return(sound_speed_t_exact)
 
-@match_args_return
 def SP_from_C(C, t, p):
     """
     Calculates Practical Salinity, SP, from conductivity, C, primarily using
     the PSS-78 algorithm.  Note that the PSS-78 algorithm for Practical
     Salinity is only valid in the range 2 < SP < 42.  If the PSS-78
     algorithm produces a Practical Salinity that is less than 2 then the
     Practical Salinity is recalculated with a modified form of the Hill et
@@ -3598,16 +3797,17 @@
     -------
     SP : array-like, unitless
         Practical Salinity on the PSS-78 scale
 
 
     """
     return _gsw_ufuncs.sp_from_c(C, t, p)
+SP_from_C.types = _gsw_ufuncs.sp_from_c.types
+SP_from_C = match_args_return(SP_from_C)
 
-@match_args_return
 def SP_from_SA(SA, p, lon, lat):
     """
     Calculates Practical Salinity from Absolute Salinity.
 
     Parameters
     ----------
     SA : array-like
@@ -3623,16 +3823,17 @@
     -------
     SP : array-like, unitless
         Practical Salinity  (PSS-78)
 
 
     """
     return _gsw_ufuncs.sp_from_sa(SA, p, lon, lat)
+SP_from_SA.types = _gsw_ufuncs.sp_from_sa.types
+SP_from_SA = match_args_return(SP_from_SA)
 
-@match_args_return
 def SP_from_SA_Baltic(SA, lon, lat):
     """
     Calculates Practical Salinity for the Baltic Sea, from a value computed
     analytically from Absolute Salinity.
     Note. This programme will only produce Practical Salinty values for the
     Baltic Sea.
 
@@ -3649,16 +3850,17 @@
     -------
     SP_baltic : array-like, unitless
         Practical Salinity
 
 
     """
     return _gsw_ufuncs.sp_from_sa_baltic(SA, lon, lat)
+SP_from_SA_Baltic.types = _gsw_ufuncs.sp_from_sa_baltic.types
+SP_from_SA_Baltic = match_args_return(SP_from_SA_Baltic)
 
-@match_args_return
 def SP_from_SK(SK):
     """
     Calculates Practical Salinity from Knudsen Salinity.
 
     Parameters
     ----------
     SK : array-like
@@ -3668,16 +3870,17 @@
     -------
     SP : array-like, unitless
         Practical Salinity  (PSS-78)
 
 
     """
     return _gsw_ufuncs.sp_from_sk(SK)
+SP_from_SK.types = _gsw_ufuncs.sp_from_sk.types
+SP_from_SK = match_args_return(SP_from_SK)
 
-@match_args_return
 def SP_from_SR(SR):
     """
     Calculates Practical Salinity from Reference Salinity.
 
     Parameters
     ----------
     SR : array-like
@@ -3687,16 +3890,17 @@
     -------
     SP : array-like, unitless
         Practical Salinity  (PSS-78)
 
 
     """
     return _gsw_ufuncs.sp_from_sr(SR)
+SP_from_SR.types = _gsw_ufuncs.sp_from_sr.types
+SP_from_SR = match_args_return(SP_from_SR)
 
-@match_args_return
 def SP_from_Sstar(Sstar, p, lon, lat):
     """
     Calculates Practical Salinity from Preformed Salinity.
 
     Parameters
     ----------
     Sstar : array-like
@@ -3712,16 +3916,17 @@
     -------
     SP : array-like, unitless
         Practical Salinity  (PSS-78)
 
 
     """
     return _gsw_ufuncs.sp_from_sstar(Sstar, p, lon, lat)
+SP_from_Sstar.types = _gsw_ufuncs.sp_from_sstar.types
+SP_from_Sstar = match_args_return(SP_from_Sstar)
 
-@match_args_return
 def SP_salinometer(Rt, t):
     """
     Calculates Practical Salinity SP from a salinometer, primarily using the
     PSS-78 algorithm.  Note that the PSS-78 algorithm for Practical Salinity
     is only valid in the range 2 < SP < 42.  If the PSS-78 algorithm
     produces a Practical Salinity that is less than 2 then the Practical
     Salinity is recalculated with a modified form of the Hill et al. (1986)
@@ -3740,16 +3945,17 @@
     SP : array-like, unitless
         Practical Salinity on the PSS-78 scale
         t may have dimensions 1x1 or Mx1 or 1xN or MxN, where Rt is MxN.
 
 
     """
     return _gsw_ufuncs.sp_salinometer(Rt, t)
+SP_salinometer.types = _gsw_ufuncs.sp_salinometer.types
+SP_salinometer = match_args_return(SP_salinometer)
 
-@match_args_return
 def specvol(SA, CT, p):
     """
     Calculates specific volume from Absolute Salinity, Conservative
     Temperature and pressure, using the computationally-efficient 75-term
     polynomial expression for specific volume (Roquet et al., 2015).
 
     Parameters
@@ -3765,16 +3971,17 @@
     -------
     specvol : array-like, m^3/kg
         specific volume
 
 
     """
     return _gsw_ufuncs.specvol(SA, CT, p)
+specvol.types = _gsw_ufuncs.specvol.types
+specvol = match_args_return(specvol)
 
-@match_args_return
 def specvol_alpha_beta(SA, CT, p):
     """
     Calculates specific volume, the appropriate thermal expansion coefficient
     and the appropriate saline contraction coefficient of seawater from
     Absolute Salinity and Conservative Temperature.  This function uses the
     computationally-efficient expression for specific volume in terms of
     SA, CT and p (Roquet et al., 2015).
@@ -3798,16 +4005,17 @@
     beta : array-like, kg/g
         saline (i.e. haline) contraction
         coefficient at constant Conservative Temperature
 
 
     """
     return _gsw_ufuncs.specvol_alpha_beta(SA, CT, p)
+specvol_alpha_beta.types = _gsw_ufuncs.specvol_alpha_beta.types
+specvol_alpha_beta = match_args_return(specvol_alpha_beta)
 
-@match_args_return
 def specvol_anom_standard(SA, CT, p):
     """
     Calculates specific volume anomaly from Absolute Salinity, Conservative
     Temperature and pressure. It uses the computationally-efficient
     expression for specific volume as a function of SA, CT and p (Roquet
     et al., 2015).  The reference value to which the anomaly is calculated
     has an Absolute Salinity of SSO and Conservative Temperature equal to
@@ -3826,16 +4034,17 @@
     -------
     specvol_anom : array-like, m^3/kg
         specific volume anomaly
 
 
     """
     return _gsw_ufuncs.specvol_anom_standard(SA, CT, p)
+specvol_anom_standard.types = _gsw_ufuncs.specvol_anom_standard.types
+specvol_anom_standard = match_args_return(specvol_anom_standard)
 
-@match_args_return
 def specvol_first_derivatives(SA, CT, p):
     """
     Calculates the following three first-order derivatives of specific
     volume (v),
     (1) v_SA, first-order derivative with respect to Absolute Salinity
     at constant CT & p.
     (2) v_CT, first-order derivative with respect to CT at
@@ -3863,16 +4072,17 @@
     v_P : array-like, m^3/(Pa kg)
         The first derivative of specific volume with respect to
         P at constant SA and CT.
 
 
     """
     return _gsw_ufuncs.specvol_first_derivatives(SA, CT, p)
+specvol_first_derivatives.types = _gsw_ufuncs.specvol_first_derivatives.types
+specvol_first_derivatives = match_args_return(specvol_first_derivatives)
 
-@match_args_return
 def specvol_first_derivatives_wrt_enthalpy(SA, CT, p):
     """
     Calculates the following two first-order derivatives of specific
     volume (v),
     (1) v_SA_wrt_h, first-order derivative with respect to Absolute Salinity
     at constant h & p.
     (2) v_h, first-order derivative with respect to h at
@@ -3885,26 +4095,27 @@
     CT : array-like
         Conservative Temperature (ITS-90), degrees C
     p : array-like
         Sea pressure (absolute pressure minus 10.1325 dbar), dbar
 
     Returns
     -------
-    v_SA_wrt_h : array-like, (m^3/kg)(g/kg)^-1 (J/kg)^-1
+    v_SA_wrt_h : array-like, (m^3/kg)(g/kg)^-1
         The first derivative of specific volume with respect to
         Absolute Salinity at constant CT & p.
     v_h : array-like, (m^3/kg)(J/kg)^-1
         The first derivative of specific volume with respect to
         SA and CT at constant p.
 
 
     """
     return _gsw_ufuncs.specvol_first_derivatives_wrt_enthalpy(SA, CT, p)
+specvol_first_derivatives_wrt_enthalpy.types = _gsw_ufuncs.specvol_first_derivatives_wrt_enthalpy.types
+specvol_first_derivatives_wrt_enthalpy = match_args_return(specvol_first_derivatives_wrt_enthalpy)
 
-@match_args_return
 def specvol_ice(t, p):
     """
     Calculates the specific volume of ice.
 
     Parameters
     ----------
     t : array-like
@@ -3916,16 +4127,17 @@
     -------
     specvol_ice : array-like, m^3/kg
         specific volume
 
 
     """
     return _gsw_ufuncs.specvol_ice(t, p)
+specvol_ice.types = _gsw_ufuncs.specvol_ice.types
+specvol_ice = match_args_return(specvol_ice)
 
-@match_args_return
 def specvol_second_derivatives(SA, CT, p):
     """
     Calculates the following five second-order derivatives of specific
     volume (v),
     (1) v_SA_SA, second-order derivative with respect to Absolute Salinity
     at constant CT & p.
     (2) v_SA_CT, second-order derivative with respect to SA & CT at
@@ -3953,26 +4165,27 @@
         Absolute Salinity at constant CT & p.
     v_SA_CT : array-like, (m^3/kg)(g/kg)^-1 K^-1
         The second derivative of specific volume with respect to
         SA and CT at constant p.
     v_CT_CT : array-like, (m^3/kg) K^-2)
         The second derivative of specific volume with respect to
         CT at constant SA and p.
-    v_SA_P : array-like, (m^3/kg) Pa^-1
+    v_SA_P : array-like, (m^3/kg)(g/kg)^-1 Pa^-1
         The second derivative of specific volume with respect to
         SA and P at constant CT.
     v_CT_P : array-like, (m^3/kg) K^-1 Pa^-1
         The second derivative of specific volume with respect to
         CT and P at constant SA.
 
 
     """
     return _gsw_ufuncs.specvol_second_derivatives(SA, CT, p)
+specvol_second_derivatives.types = _gsw_ufuncs.specvol_second_derivatives.types
+specvol_second_derivatives = match_args_return(specvol_second_derivatives)
 
-@match_args_return
 def specvol_second_derivatives_wrt_enthalpy(SA, CT, p):
     """
     Calculates the following three first-order derivatives of specific
     volume (v) with respect to enthalpy,
     (1) v_SA_SA_wrt_h, second-order derivative with respect to Absolute Salinity
     at constant h & p.
     (2) v_SA_h, second-order derivative with respect to SA & h at
@@ -3987,29 +4200,30 @@
     CT : array-like
         Conservative Temperature (ITS-90), degrees C
     p : array-like
         Sea pressure (absolute pressure minus 10.1325 dbar), dbar
 
     Returns
     -------
-    v_SA_SA_wrt_h : array-like, (m^3/kg)(g/kg)^-2 (J/kg)^-1
+    v_SA_SA_wrt_h : array-like, (m^3/kg)(g/kg)^-2
         The second-order derivative of specific volume with
         respect to Absolute Salinity at constant h & p.
     v_SA_h : array-like, (m^3/kg)(g/kg)^-1 (J/kg)^-1
         The second-order derivative of specific volume with respect to
         SA and h at constant p.
     v_h_h : array-like, (m^3/kg)(J/kg)^-2
         The second-order derivative with respect to h at
         constant SA & p.
 
 
     """
     return _gsw_ufuncs.specvol_second_derivatives_wrt_enthalpy(SA, CT, p)
+specvol_second_derivatives_wrt_enthalpy.types = _gsw_ufuncs.specvol_second_derivatives_wrt_enthalpy.types
+specvol_second_derivatives_wrt_enthalpy = match_args_return(specvol_second_derivatives_wrt_enthalpy)
 
-@match_args_return
 def specvol_t_exact(SA, t, p):
     """
     Calculates the specific volume of seawater.
 
     Parameters
     ----------
     SA : array-like
@@ -4023,16 +4237,17 @@
     -------
     specvol_t_exact : array-like, m^3/kg
         specific volume
 
 
     """
     return _gsw_ufuncs.specvol_t_exact(SA, t, p)
+specvol_t_exact.types = _gsw_ufuncs.specvol_t_exact.types
+specvol_t_exact = match_args_return(specvol_t_exact)
 
-@match_args_return
 def spiciness0(SA, CT):
     """
     Calculates spiciness from Absolute Salinity and Conservative
     Temperature at a pressure of 0 dbar, as described by McDougall and
     Krzysik (2015).  This routine is based on the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -4049,16 +4264,17 @@
     spiciness0 : array-like, kg/m^3
         spiciness referenced to a pressure of 0 dbar,
         i.e. the surface
 
 
     """
     return _gsw_ufuncs.spiciness0(SA, CT)
+spiciness0.types = _gsw_ufuncs.spiciness0.types
+spiciness0 = match_args_return(spiciness0)
 
-@match_args_return
 def spiciness1(SA, CT):
     """
     Calculates spiciness from Absolute Salinity and Conservative
     Temperature at a pressure of 1000 dbar, as described by McDougall and
     Krzysik (2015).  This routine is based on the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -4074,16 +4290,17 @@
     -------
     spiciness1 : array-like, kg/m^3
         spiciness referenced to a pressure of 1000 dbar
 
 
     """
     return _gsw_ufuncs.spiciness1(SA, CT)
+spiciness1.types = _gsw_ufuncs.spiciness1.types
+spiciness1 = match_args_return(spiciness1)
 
-@match_args_return
 def spiciness2(SA, CT):
     """
     Calculates spiciness from Absolute Salinity and Conservative
     Temperature at a pressure of 2000 dbar, as described by McDougall and
     Krzysik (2015).  This routine is based on the computationally-efficient
     expression for specific volume in terms of SA, CT and p (Roquet et al.,
     2015).
@@ -4099,16 +4316,17 @@
     -------
     spiciness2 : array-like, kg/m^3
         spiciness referenced to a pressure of 2000 dbar
 
 
     """
     return _gsw_ufuncs.spiciness2(SA, CT)
+spiciness2.types = _gsw_ufuncs.spiciness2.types
+spiciness2 = match_args_return(spiciness2)
 
-@match_args_return
 def SR_from_SP(SP):
     """
     Calculates Reference Salinity from Practical Salinity.
 
     Parameters
     ----------
     SP : array-like
@@ -4118,16 +4336,17 @@
     -------
     SR : array-like, g/kg
         Reference Salinity
 
 
     """
     return _gsw_ufuncs.sr_from_sp(SP)
+SR_from_SP.types = _gsw_ufuncs.sr_from_sp.types
+SR_from_SP = match_args_return(SR_from_SP)
 
-@match_args_return
 def Sstar_from_SA(SA, p, lon, lat):
     """
     Converts Preformed Salinity from Absolute Salinity.
 
     Parameters
     ----------
     SA : array-like
@@ -4143,16 +4362,17 @@
     -------
     Sstar : array-like, g/kg
         Preformed Salinity
 
 
     """
     return _gsw_ufuncs.sstar_from_sa(SA, p, lon, lat)
+Sstar_from_SA.types = _gsw_ufuncs.sstar_from_sa.types
+Sstar_from_SA = match_args_return(Sstar_from_SA)
 
-@match_args_return
 def Sstar_from_SP(SP, p, lon, lat):
     """
     Calculates Preformed Salinity from Absolute Salinity.
     Since SP is non-negative by definition, this function changes any
     negative input values of SP to be zero.
 
     Parameters
@@ -4170,16 +4390,17 @@
     -------
     Sstar : array-like, g/kg
         Preformed Salinity
 
 
     """
     return _gsw_ufuncs.sstar_from_sp(SP, p, lon, lat)
+Sstar_from_SP.types = _gsw_ufuncs.sstar_from_sp.types
+Sstar_from_SP = match_args_return(Sstar_from_SP)
 
-@match_args_return
 def t_deriv_chem_potential_water_t_exact(SA, t, p):
     """
     Calculates the temperature derivative of the chemical potential of water
     in seawater so that it is valid at exactly SA = 0.
 
     Parameters
     ----------
@@ -4195,16 +4416,17 @@
     chem_potential_water_dt : array-like, J g^-1 K^-1
         temperature derivative of the chemical
         potential of water in seawater
 
 
     """
     return _gsw_ufuncs.t_deriv_chem_potential_water_t_exact(SA, t, p)
+t_deriv_chem_potential_water_t_exact.types = _gsw_ufuncs.t_deriv_chem_potential_water_t_exact.types
+t_deriv_chem_potential_water_t_exact = match_args_return(t_deriv_chem_potential_water_t_exact)
 
-@match_args_return
 def t_freezing(SA, p, saturation_fraction):
     """
     Calculates the in-situ temperature at which seawater freezes. The
     in-situ temperature freezing point is calculated from the exact
     in-situ freezing temperature which is found by a modified Newton-Raphson
     iteration (McDougall and Wotherspoon, 2013) of the equality of the
     chemical potentials of water in seawater and in ice.
@@ -4223,16 +4445,17 @@
     t_freezing : array-like, deg C
         in-situ temperature at which seawater freezes.
         (ITS-90)
 
 
     """
     return _gsw_ufuncs.t_freezing(SA, p, saturation_fraction)
+t_freezing.types = _gsw_ufuncs.t_freezing.types
+t_freezing = match_args_return(t_freezing)
 
-@match_args_return
 def t_freezing_first_derivatives(SA, p, saturation_fraction):
     """
     Calculates the first derivatives of the in-situ temperature at which
     seawater freezes with respect to Absolute Salinity SA and pressure P (in
     Pa).  These expressions come from differentiating the expression that
     defines the freezing temperature, namely the equality between the
     chemical potentials of water in seawater and in ice.
@@ -4256,16 +4479,17 @@
         the derivative of the in-situ freezing temperature
         (ITS-90) with respect to pressure (in Pa) at fixed
         Absolute Salinity
 
 
     """
     return _gsw_ufuncs.t_freezing_first_derivatives(SA, p, saturation_fraction)
+t_freezing_first_derivatives.types = _gsw_ufuncs.t_freezing_first_derivatives.types
+t_freezing_first_derivatives = match_args_return(t_freezing_first_derivatives)
 
-@match_args_return
 def t_freezing_first_derivatives_poly(SA, p, saturation_fraction):
     """
     Calculates the first derivatives of the in-situ temperature at which
     seawater freezes with respect to Absolute Salinity SA and pressure P (in
     Pa).  These expressions come from differentiating the expression that
     defines the freezing temperature, namely the equality between the
     chemical potentials of water in seawater and in ice.
@@ -4289,16 +4513,17 @@
         the derivative of the in-situ freezing temperature
         (ITS-90) with respect to pressure (in Pa) at fixed
         Absolute Salinity
 
 
     """
     return _gsw_ufuncs.t_freezing_first_derivatives_poly(SA, p, saturation_fraction)
+t_freezing_first_derivatives_poly.types = _gsw_ufuncs.t_freezing_first_derivatives_poly.types
+t_freezing_first_derivatives_poly = match_args_return(t_freezing_first_derivatives_poly)
 
-@match_args_return
 def t_freezing_poly(SA, p, saturation_fraction):
     """
     Calculates the in-situ temperature at which seawater freezes from a
     comptationally efficient polynomial.
 
     Parameters
     ----------
@@ -4314,16 +4539,17 @@
     t_freezing : array-like, deg C
         in-situ temperature at which seawater freezes.
         (ITS-90)
 
 
     """
     return _gsw_ufuncs.t_freezing_poly(SA, p, saturation_fraction)
+t_freezing_poly.types = _gsw_ufuncs.t_freezing_poly.types
+t_freezing_poly = match_args_return(t_freezing_poly)
 
-@match_args_return
 def t_from_CT(SA, CT, p):
     """
     Calculates in-situ temperature from the Conservative Temperature of
     seawater.
 
     Parameters
     ----------
@@ -4338,16 +4564,17 @@
     -------
     t : array-like, deg C
         in-situ temperature (ITS-90)
 
 
     """
     return _gsw_ufuncs.t_from_ct(SA, CT, p)
+t_from_CT.types = _gsw_ufuncs.t_from_ct.types
+t_from_CT = match_args_return(t_from_CT)
 
-@match_args_return
 def t_from_pt0_ice(pt0_ice, p):
     """
     Calculates in-situ temperature from the potential temperature of ice Ih
     with reference pressure, p_ref, of 0 dbar (the surface), and the
     in-situ pressure.
 
     Parameters
@@ -4361,16 +4588,17 @@
     -------
     t : array-like, deg C
         in-situ temperature (ITS-90)
 
 
     """
     return _gsw_ufuncs.t_from_pt0_ice(pt0_ice, p)
+t_from_pt0_ice.types = _gsw_ufuncs.t_from_pt0_ice.types
+t_from_pt0_ice = match_args_return(t_from_pt0_ice)
 
-@match_args_return
 def thermobaric(SA, CT, p):
     """
     Calculates the thermobaric coefficient of seawater with respect to
     Conservative Temperature.  This routine is based on the
     computationally-efficient expression for specific volume in terms of
     SA, CT and p (Roquet et al., 2015).
 
@@ -4388,16 +4616,17 @@
     thermobaric : array-like, 1/(K Pa)
         thermobaric coefficient with
         respect to Conservative Temperature.
 
 
     """
     return _gsw_ufuncs.thermobaric(SA, CT, p)
+thermobaric.types = _gsw_ufuncs.thermobaric.types
+thermobaric = match_args_return(thermobaric)
 
-@match_args_return
 def z_from_p(p, lat, geo_strf_dyn_height, sea_surface_geopotential):
     """
     Calculates height from sea pressure using the computationally-efficient
     75-term expression for specific volume in terms of SA, CT and p
     (Roquet et al., 2015).  Dynamic height anomaly, geo_strf_dyn_height, if
     provided, must be computed with its p_ref = 0 (the surface).  Also if
     provided, sea_surface_geopotental is the geopotential at zero sea
@@ -4420,7 +4649,9 @@
     -------
     z : array-like, m
         height
 
 
     """
     return _gsw_ufuncs.z_from_p(p, lat, geo_strf_dyn_height, sea_surface_geopotential)
+z_from_p.types = _gsw_ufuncs.z_from_p.types
+z_from_p = match_args_return(z_from_p)
```

## gsw/conversions.py

```diff
@@ -39,46 +39,45 @@
             'Sstar_from_SA',
             'Sstar_from_SP',
             't_from_CT',
             'p_from_z',
             'z_from_p',
             ]
 
-from ._utilities import match_args_return
-
 from ._fixed_wrapped_ufuncs import (
-adiabatic_lapse_rate_from_CT,
-C_from_SP,
-CT_from_enthalpy,
-CT_from_entropy,
-CT_from_pt,
-CT_from_rho,
-CT_from_t,
-deltaSA_from_SP,
-entropy_from_pt,
-entropy_from_t,
-pt0_from_t,
-pt_from_CT,
-pt_from_entropy,
-pt_from_t,
-SA_from_rho,
-SA_from_SP,
-SA_from_Sstar,
-SP_from_C,
-SP_from_SA,
-SP_from_SK,
-SP_from_SR,
-SP_from_Sstar,
-SR_from_SP,
-Sstar_from_SA,
-Sstar_from_SP,
-t_from_CT,
-p_from_z,
-z_from_p,
+    C_from_SP,
+    CT_from_enthalpy,
+    CT_from_entropy,
+    CT_from_pt,
+    CT_from_rho,
+    CT_from_t,
+    SA_from_rho,
+    SA_from_SP,
+    SA_from_Sstar,
+    SP_from_C,
+    SP_from_SA,
+    SP_from_SK,
+    SP_from_SR,
+    SP_from_Sstar,
+    SR_from_SP,
+    Sstar_from_SA,
+    Sstar_from_SP,
+    adiabatic_lapse_rate_from_CT,
+    deltaSA_from_SP,
+    entropy_from_pt,
+    entropy_from_t,
+    p_from_z,
+    pt0_from_t,
+    pt_from_CT,
+    pt_from_entropy,
+    pt_from_t,
+    t_from_CT,
+    z_from_p,
 )
+from ._utilities import match_args_return
 
 
 @match_args_return
 def t90_from_t68(t68):
     """
     ITS-90 temperature from IPTS-68 temperature
```

## gsw/density.py

```diff
@@ -4,24 +4,24 @@
 These are a subset of the TEOS-10 table category
 "specific volume, density, and enthalpy".
 
 We are grouping the functions related to enthalpy and internal energy
 in their own "energy" module.
 """
 from ._wrapped_ufuncs import (
-specvol,
-alpha,
-beta,
-alpha_on_beta,
-specvol_alpha_beta,
-specvol_anom_standard,
-rho,
-rho_alpha_beta,
-rho_t_exact,
-sigma0,
-sigma1,
-sigma2,
-sigma3,
-sigma4,
-sound_speed,
-kappa,
+    alpha,
+    alpha_on_beta,
+    beta,
+    kappa,
+    rho,
+    rho_alpha_beta,
+    rho_t_exact,
+    sigma0,
+    sigma1,
+    sigma2,
+    sigma3,
+    sigma4,
+    sound_speed,
+    specvol,
+    specvol_alpha_beta,
+    specvol_anom_standard,
 )
```

## gsw/freezing.py

```diff
@@ -1,22 +1,22 @@
 """
 Freezing-point functions.
 """
 
 from ._wrapped_ufuncs import (
-CT_freezing,
-CT_freezing_first_derivatives,
-CT_freezing_first_derivatives_poly,
-CT_freezing_poly,
-pot_enthalpy_ice_freezing,
-pot_enthalpy_ice_freezing_first_derivatives,
-pot_enthalpy_ice_freezing_first_derivatives_poly,
-pot_enthalpy_ice_freezing_poly,
-pressure_freezing_CT,
-SA_freezing_from_CT,
-SA_freezing_from_CT_poly,
-SA_freezing_from_t,
-SA_freezing_from_t_poly,
-t_freezing,
-t_freezing_first_derivatives,
-t_freezing_first_derivatives_poly,
+    CT_freezing,
+    CT_freezing_first_derivatives,
+    CT_freezing_first_derivatives_poly,
+    CT_freezing_poly,
+    SA_freezing_from_CT,
+    SA_freezing_from_CT_poly,
+    SA_freezing_from_t,
+    SA_freezing_from_t_poly,
+    pot_enthalpy_ice_freezing,
+    pot_enthalpy_ice_freezing_first_derivatives,
+    pot_enthalpy_ice_freezing_first_derivatives_poly,
+    pot_enthalpy_ice_freezing_poly,
+    pressure_freezing_CT,
+    t_freezing,
+    t_freezing_first_derivatives,
+    t_freezing_first_derivatives_poly,
 )
```

## gsw/geostrophy.py

```diff
@@ -1,15 +1,15 @@
 """
 Functions for calculating geostrophic currents.
 """
 
 import numpy as np
 
 from . import _gsw_ufuncs
-from ._utilities import match_args_return, indexer
+from ._utilities import indexer, match_args_return
 from .conversions import z_from_p
 
 __all__ = ['geo_strf_dyn_height',
            'distance',
            'f',
            'geostrophic_velocity',
            ]
@@ -46,24 +46,23 @@
         to pressure, from each pressure in p to the specified
         reference pressure.  It is the geostrophic streamfunction
         in an isobaric surface, relative to the reference surface.
 
     """
     interp_methods = {'pchip' : 2, 'linear' : 1}
     if interp_method not in interp_methods:
-        raise ValueError('interp_method must be one of %s'
-                         % (interp_methods.keys(),))
+        raise ValueError(f'interp_method must be one of {interp_methods.keys()}')
     if SA.shape != CT.shape:
-        raise ValueError('Shapes of SA and CT must match; found %s and %s'
-                         % (SA.shape, CT.shape))
+        raise ValueError(f'Shapes of SA and CT must match; found {SA.shape} and {CT.shape}')
     if p.ndim == 1 and SA.ndim > 1:
         if len(p) != SA.shape[axis]:
-            raise ValueError('With 1-D p, len(p) must be SA.shape[axis];\n'
-                             ' found %d versus %d on specified axis, %d'
-                             % (len(p), SA.shape[axis], axis))
+            raise ValueError(
+                f'With 1-D p, len(p) must be SA.shape[axis];\n'
+                f' found {len(p)} versus {SA.shape[axis]} on specified axis, {axis}'
+                )
         ind = [np.newaxis] * SA.ndim
         ind[axis] = slice(None)
         p = p[tuple(ind)]
     p_ref = float(p_ref)
     with np.errstate(invalid='ignore'):
         # The need for this context seems to be a bug in np.ma.any.
         if np.ma.any(np.ma.diff(np.ma.masked_invalid(p), axis=axis) <= 0):
@@ -74,15 +73,16 @@
     dh.fill(np.nan)
 
     try:
         order = 'F' if SA.flags.fortran else 'C'
     except AttributeError:
         order = 'C'  # e.g., xarray DataArray doesn't have flags
     for ind in indexer(SA.shape, axis, order=order):
-        igood = goodmask[ind]
+        # this is needed to support xarray inputs for numpy < 1.23
+        igood = np.asarray(goodmask[ind])
         # If p_ref is below the deepest value, skip the profile.
         pgood = p[ind][igood]
         if  len(pgood) > 1 and pgood[-1] >= p_ref:
             sa = SA[ind][igood]
             ct = CT[ind][igood]
             # Temporarily add a top (typically surface) point and mixed layer
             # if p_ref is above the shallowest pressure.
@@ -172,20 +172,18 @@
     distance : 1-D or 2-D array
         distance in meters between adjacent points.
 
     """
     earth_radius = 6371e3
 
     if not lon.shape == lat.shape:
-        raise ValueError('lon, lat shapes must match; found %s, %s'
-                          % (lon.shape, lat.shape))
+        raise ValueError(f'lon, lat shapes must match; found {lon.shape}, {lat.shape}')
     if not (lon.ndim in (1, 2) and lon.shape[axis] > 1):
         raise ValueError('lon, lat must be 1-D or 2-D with more than one point'
-                         ' along axis; found shape %s and axis %s'
-                          % (lon.shape, axis))
+                         ' along axis; found shape {} and axis {}'.format(lon.shape, axis))
     if lon.ndim == 1:
         one_d = True
         # xarray requires expand_dims() rather than [newaxis, :]
         lon = np.expand_dims(lon, 0)
         lat = np.expand_dims(lat, 0)
         axis = -1
     else:
@@ -289,20 +287,18 @@
     Only :func:`geo_strf_dyn_height` is presently implemented
     in GSW-Python.
 
     """
     lon = unwrap(lon)
 
     if lon.shape != lat.shape or lon.ndim != 1:
-        raise ValueError('lon, lat must be 1-D and matching; found shapes'
-                         ' %s and %s' % (lon.shape, lat.shape))
+        raise ValueError(f'lon, lat must be 1-D and matching; found shapes {lon.shape} and {lat.shape}')
 
     if geo_strf.ndim not in (1, 2):
-        raise ValueError('geo_strf must be 1-D or 2-d; found shape %s'
-                         % (geo_strf.shape,))
+        raise ValueError(f'geo_strf must be 1-D or 2-d; found shape {geo_strf.shape}')
 
     laxis = 0 if axis else -1
 
     ds = distance(lon, lat, p)
 
     mid_lon = 0.5 * (lon[:-1] + lon[1:])
     mid_lat = 0.5 * (lat[:-1] + lat[1:])
```

## gsw/ice.py

```diff
@@ -1,39 +1,39 @@
 """
 Functions about ice and melting, but not the freezing point.
 """
 
 from ._wrapped_ufuncs import (
-adiabatic_lapse_rate_ice,
-alpha_wrt_t_ice,
-chem_potential_water_ice,
-cp_ice,
-enthalpy_ice,
-entropy_ice,
-Helmholtz_energy_ice,
-ice_fraction_to_freeze_seawater,
-internal_energy_ice,
-kappa_const_t_ice,
-kappa_ice,
-melting_ice_equilibrium_SA_CT_ratio,
-melting_ice_equilibrium_SA_CT_ratio_poly,
-melting_ice_into_seawater,
-melting_ice_SA_CT_ratio,
-melting_ice_SA_CT_ratio_poly,
-melting_seaice_equilibrium_SA_CT_ratio,
-melting_seaice_equilibrium_SA_CT_ratio_poly,
-melting_seaice_into_seawater,
-melting_seaice_SA_CT_ratio,
-melting_seaice_SA_CT_ratio_poly,
-pot_enthalpy_from_pt_ice,
-pot_enthalpy_from_pt_ice_poly,
-pressure_coefficient_ice,
-pt0_from_t_ice,
-pt_from_pot_enthalpy_ice,
-pt_from_pot_enthalpy_ice_poly,
-pt_from_t_ice,
-rho_ice,
-seaice_fraction_to_freeze_seawater,
-sound_speed_ice,
-specvol_ice,
-t_from_pt0_ice,
+    Helmholtz_energy_ice,
+    adiabatic_lapse_rate_ice,
+    alpha_wrt_t_ice,
+    chem_potential_water_ice,
+    cp_ice,
+    enthalpy_ice,
+    entropy_ice,
+    ice_fraction_to_freeze_seawater,
+    internal_energy_ice,
+    kappa_const_t_ice,
+    kappa_ice,
+    melting_ice_equilibrium_SA_CT_ratio,
+    melting_ice_equilibrium_SA_CT_ratio_poly,
+    melting_ice_into_seawater,
+    melting_ice_SA_CT_ratio,
+    melting_ice_SA_CT_ratio_poly,
+    melting_seaice_equilibrium_SA_CT_ratio,
+    melting_seaice_equilibrium_SA_CT_ratio_poly,
+    melting_seaice_into_seawater,
+    melting_seaice_SA_CT_ratio,
+    melting_seaice_SA_CT_ratio_poly,
+    pot_enthalpy_from_pt_ice,
+    pot_enthalpy_from_pt_ice_poly,
+    pressure_coefficient_ice,
+    pt0_from_t_ice,
+    pt_from_pot_enthalpy_ice,
+    pt_from_pot_enthalpy_ice_poly,
+    pt_from_t_ice,
+    rho_ice,
+    seaice_fraction_to_freeze_seawater,
+    sound_speed_ice,
+    specvol_ice,
+    t_from_pt0_ice,
 )
```

## gsw/stability.py

```diff
@@ -12,16 +12,16 @@
 an automated mechanism.
 
 """
 
 
 import numpy as np
 
-from ._utilities import match_args_return, axis_slicer
 from ._gsw_ufuncs import grav, specvol_alpha_beta
+from ._utilities import axis_slicer, match_args_return
 
 __all__ = ['Nsquared',
            'Turner_Rsubrho',
            'IPV_vs_fNsquared_ratio',
            ]
 
 # In the following, axis=0 matches the Matlab behavior.
```

## gsw/utility.py

```diff
@@ -1,15 +1,16 @@
 """
 Functions not specific to the TEOS-10 realm of variables.
 """
 
 import numpy as np
 
 from . import _gsw_ufuncs
-from ._utilities import match_args_return, indexer
+from ._utilities import indexer, match_args_return
+
 
 @match_args_return
 def pchip_interp(x, y, xi, axis=0):
     """
     Interpolate using Piecewise Cubic Hermite Interpolating Polynomial
 
     This is a shape-preserving algorithm; it does not introduce new local
@@ -40,15 +41,14 @@
     """
 
     xi = np.array(xi, dtype=float, copy=False, order='C', ndmin=1)
     if xi.ndim > 1:
         raise ValueError('xi must be no more than 1-dimensional')
     nxi = xi.size
     x, y = np.broadcast_arrays(x, y)
-    shape0 = x.shape
     out_shape = list(x.shape)
     out_shape[axis] = nxi
     yi = np.empty(out_shape, dtype=float)
     yi.fill(np.nan)
 
     goodmask = ~(np.isnan(x) | np.isnan(y))
```

## gsw/tests/_WIP_test_ufuncs.py

```diff
@@ -1,17 +1,16 @@
 """
 Tests for the unwrapped ufuncs.
 
 This is a WIP; it doesn't work yet for all cases, and might not be a good
 approach anyway.  For now, test_check_functions is adequate, handling the
 wrapped ufuncs via check_functions "eval" and "exec" machinery.
 """
-import pytest
-
 import numpy as np
+import pytest
 from numpy.testing import assert_allclose
 
 import gsw
 from gsw._utilities import Bunch
 from gsw.tests.check_functions import parse_check_functions
 
 cv = Bunch(np.load('gsw_cv_v3_0.npz'))
@@ -40,15 +39,15 @@
         else:
             raise ValueError("Can't find cf. or cv. in %s" % vname)
     def set_from_name(vname, value):
         b, name = vname.split('.')
         if b == 'cf':
             cf[name] = value
         else:
-            raise ValueError("attempting to set value in %s" % (b,))
+            raise ValueError(f"attempting to set value in {b}")
 
     func = getattr(gsw._gsw_ufuncs, mfunc.name)
     args = [eval(a) for a in mfunc.argstrings]
     #print("<<%s>>" % (args,))
     out = func(*args)
     #print("<<<%s>>>" % (out,))
     if isinstance(out, tuple):
```

## gsw/tests/check_functions.py

```diff
@@ -21,20 +21,20 @@
 
 This module is also imported by test_check_functions.py, which
 is run by py.test.
 
 """
 
 import os
-import sys
 import re
+import sys
 
 import numpy as np
 
-from gsw import *
+from gsw import *  # noqa
 from gsw._utilities import Bunch
 
 # If we switch to using the logging module, uncomment:
 # import logging
 # log = logging.getLogger()
 # logging.basicConfig()
 
@@ -73,15 +73,15 @@
     head = line[:i0]
     tail = line[i0:]
     parts = tail.replace('|', ') | (')
     new = head + '(' + parts + ')'
     return new
 
 
-class FunctionCheck(object):
+class FunctionCheck:
     """
     Parse the line-pair for checks in gsw_check_functions.
     """
     def __init__(self, linepair):
         """
         *linepair* is the sequence of two lines; the first runs
         the function and assigns the output, and the second
@@ -162,33 +162,33 @@
             target, calculated = LHS.split('-')
             part.checkval = eval(target, *evalargs)
             part.val = eval(calculated, *evalargs)
             parts.append(part)
 
         self.details = parts
 
-    def run(self, locals=None):
+    def run(self, locals_=None):
         try:
-            if locals is not None:
+            if locals_ is not None:
                 _globals = globals() #dict(**globals())
-                _globals.update(locals)
+                _globals.update(locals_)
                 evalargs = (_globals,)
             else:
-                evalargs = tuple()
+                evalargs = ()
 
             # The following is needed for melting_ice_into_seawater.
             if len(self.outstrings) > 1:
                 rl_ind = '[:%d]' % len(self.outstrings)
             else:
                 rl_ind = ''
 
             exec(self.runline + rl_ind, *evalargs)
             if len(self.outstrings) == 1:
                 if isinstance(eval(self.outstr, *evalargs), tuple):
-                    exec("%s = %s[0]" % (self.outstr, self.outstr), *evalargs)
+                    exec(f"{self.outstr} = {self.outstr}[0]", *evalargs)
             self.outlist = [eval(s, *evalargs) for s in self.outstrings]
 
             exec(self.testline, *evalargs)
             self.result = eval(self.resultstr, *evalargs)
 
             self.passed = (len(self.result) == 0)
             # The following has trouble with CT_first_derivatives
@@ -226,15 +226,15 @@
     return arglists
 
 def parse_check_functions(mfile):
     """
     Return a list of FunctionCheck instances from gsw_check_functions.m
     """
 
-    with open(mfile, 'rt') as fid:
+    with open(mfile) as fid:
         mfilelines = fid.readlines()
 
     first_pass = []
 
     concat = False
     for line in mfilelines:
         line = line.strip()
@@ -317,15 +317,15 @@
 
     passes = [f for f in checks if f.passed]
     failures = [f for f in checks if f.passed is False]
 
     run_problems = [f for f in checks if f.exception is not None]
 
     etypes = [NameError, UnboundLocalError, TypeError, AttributeError]
-    ex_dict = dict()
+    ex_dict = {}
     for exc in etypes:
         elist = [(f.name, f.exception) for f in checks if
                  isinstance(f.exception, exc)]
         ex_dict[exc] = elist
 
     print("\n%s tests were translated from gsw_check_functions.m" % len(checks))
     print("\n%s tests ran with no error and with correct output" % len(passes))
@@ -347,12 +347,12 @@
                 print('')
 
         print('')
 
     print("\n%s exceptions were raised as follows:" % len(run_problems))
     for exc in etypes:
         print("  ", exc.__name__)
-        strings = ["     %s : %s" % e for e in ex_dict[exc]]
+        strings = ["     {} : {}".format(*e) for e in ex_dict[exc]]
         print("\n".join(strings))
         print("")
 
     checkbunch = Bunch([(c.name, c) for c in checks])
```

## gsw/tests/list_check_functions.py

 * *Ordering differences only*

```diff
@@ -2,17 +2,17 @@
 Lists functions checked by test_check_functions, and functions
 that are in gsw_check_functions but are not in gsw.
 """
 
 import os
 
 import numpy as np
+from check_functions import parse_check_functions
 
 import gsw
-from check_functions import parse_check_functions
 
 root_path = os.path.abspath(os.path.dirname(__file__))
 
 # Function checks that we can't handle automatically yet.
 blacklist = ['deltaSA_atlas',  # the test is complicated; doesn't fit the pattern.
              ]
```

## gsw/tests/test_check_functions.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
 """
 Tests functions with pytest, using the machinery from check_functions.py
 """
 
 import os
-import pytest
 
 import numpy as np
+import pytest
+from check_functions import parse_check_functions
 from numpy.testing import assert_allclose
 
 import gsw
 from gsw._utilities import Bunch
-from check_functions import parse_check_functions
 
 # Most of the tests have some nan values, so we need to suppress the warning.
 # Any more careful fix would likely require considerable effort.
 np.seterr(invalid='ignore')
 
 root_path = os.path.abspath(os.path.dirname(__file__))
```

## gsw/tests/test_geostrophy.py

```diff
@@ -1,11 +1,11 @@
 import os
 
 import numpy as np
-from numpy.testing import assert_array_equal, assert_almost_equal
+from numpy.testing import assert_almost_equal, assert_array_equal
 
 import gsw
 from gsw._utilities import Bunch
 
 root_path = os.path.abspath(os.path.dirname(__file__))
 
 cv = Bunch(np.load(os.path.join(root_path, 'gsw_cv_v3_0.npz')))
```

## gsw/tests/test_utility.py

```diff
@@ -1,10 +1,9 @@
-import pytest
-
 import numpy as np
+import pytest
 
 import gsw
 
 nx, ny, nz = 2, 3, 10
 y = np.arange(nx*ny*nz, dtype=float).reshape((nx, ny, nz))
 y += y**1.5
 z = np.arange(nz, dtype=float)
```

## gsw/tests/test_xarray.py

```diff
@@ -5,22 +5,23 @@
 an import of xarray, and conversion of the 3 main check cast arrays
 into DataArray objects.
 
 An additional xarray-dask test is added.
 """
 
 import os
-import pytest
 
 import numpy as np
+import pandas as pd
+import pytest
+from check_functions import parse_check_functions
 from numpy.testing import assert_allclose
 
 import gsw
 from gsw._utilities import Bunch
-from check_functions import parse_check_functions
 
 xr = pytest.importorskip('xarray')
 
 # Most of the tests have some nan values, so we need to suppress the warning.
 # Any more careful fix would likely require considerable effort.
 np.seterr(invalid='ignore')
 
@@ -137,7 +138,17 @@
 
     # Broadcasting along dimension required (dimensions unknown/exclusive)
     expected = gsw.z_from_p(p_vals[:, np.newaxis], lat_vals[np.newaxis, :])
     xarray = gsw.z_from_p(p, lat)
     chunked = gsw.z_from_p(p,lat_chunk)
     assert_allclose(xarray, expected)
     assert_allclose(chunked, expected)
+
+def test_pandas_20():
+    df = pd.DataFrame(
+        {
+            "pressure": [0, 10, 20],
+            "latitude": [70, 70, 70],
+        }
+    )
+    depth = -1 * gsw.z_from_p(df["pressure"], df["latitude"])
+    assert isinstance(depth, pd.core.series.Series)
```

## gsw/tests/write_geo_npyfiles.py

```diff
@@ -9,14 +9,15 @@
 This is a minimal script for that purpose, to be run in
 the tests directory in which it lives.  It should be run
 only if we change to a different calculation algorithm,
 or we update the cast input and general check value file.
 """
 
 import numpy as np
+
 import gsw
 from gsw._utilities import Bunch
 
 cv = Bunch(np.load('gsw_cv_v3_0.npz'))
 
 dyn_height = gsw.geo_strf_dyn_height(cv.SA_chck_cast,
                                      cv.CT_chck_cast,
```

## Comparing `gsw-3.6.16.post1.dist-info/LICENSE.txt` & `gsw-3.6.17.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `gsw-3.6.16.post1.dist-info/METADATA` & `gsw-3.6.17.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,93 +1,94 @@
-Metadata-Version: 2.1
-Name: gsw
-Version: 3.6.16.post1
-Summary: Gibbs Seawater Oceanographic Package of TEOS-10
-Home-page: https://github.com/TEOS-10/GSW-python
-Author: Eric Firing, Filipe Fernandes
-Author-email: efiring@hawaii.edu
-License: BSD
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Intended Audience :: Science/Research
-Classifier: Operating System :: OS Independent
-Classifier: License :: OSI Approved :: BSD License
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE.txt
-Requires-Dist: numpy
-
-# GSW-Python
-
-[![Tests](https://github.com/TEOS-10/GSW-Python/actions/workflows/tests.yml/badge.svg)](https://github.com/TEOS-10/GSW-Python/actions/workflows/tests.yml)
-[![Wheels](https://github.com/TEOS-10/GSW-Python/actions/workflows/cibuildwheel.yml/badge.svg)](https://github.com/TEOS-10/GSW-Python/actions/workflows/cibuildwheel.yml)
-[![DOI](https://zenodo.org/badge/86503067.svg)](https://zenodo.org/badge/latestdoi/86503067)
-
-
-This Python implementation of the Thermodynamic Equation of Seawater 2010 (TEOS-10) is based primarily on numpy ufunc wrappers of the GSW-C implementation.
-This library replaces the original [python-gsw](https://github.com/TEOS-10/python-gsw) pure-python implementation..
-The primary reasons for this change are that by building on the C implementation we reduce code duplication and we gain an immediate update to the 75-term equation.  
-Additional benefits include a major increase in speed,
-a reduction in memory usage,
-and the inclusion of more functions.
-The penalty is that a C (or MSVC C++ for Windows) compiler is required to build the package from source.
-
-**Warning: this is for Python >=3.8 only.**
-
-Documentation is provided at https://teos-10.github.io/GSW-Python/.
-
-For the core functionality, we use an auto-generated C extension
-module to wrap the C functions as numpy [ufuncs](https://docs.scipy.org/doc/numpy/reference/ufuncs.html),
-and then use an autogenerated Python module to add docstrings and handle masked arrays.
-165 scalar C functions with only double-precision arguments and return values are wrapped as ufuncs,
-and 158 of these are exposed in the ``gsw`` namespace with an additional wrapper in Python.
-
-A hand-written wrapper is used for one C function, and others are re-implemented directly in Python instead of being wrapped.
-Additional functions present in GSW-Matlab but not in GSW-C may be re-implemented in Python,
-but there is no expectation that all such functions will be provided.
-
-## Installation
-
-Pip users can install the pre-built wheels with:
-
-```shell
-pip install gsw
-```
-
-conda users will find binaries on conda-forge,
-
-```shell
-conda install gsw --channel conda-forge
-```
-
-The development version of the package can be installed from a clone of the repo using
-
-```shell
-pip install .
-```
-
-It is neither necessary nor recommended to run the code generators,
-and no instructions are provided for them;
-their output is included in the repo.
-You will need a suitable compiler:
-gcc or clang for unix-like systems,
-or the MSVC compiler set used for Python itself on Windows.
-For Windows, some of the source code has been modified to C++ because the MSVC C compiler does not support the
-C99 complex data type used in original GSW-C.
-
-To test, after installation, run "pytest" from the source directory.
-
-## Note for xarray users
-
-A wrapper around gsw called [gsw-xarray](https://github.com/DocOtak/gsw-xarray) exists for xarray.
-It adds CF compliant attributes when possible, units, and name.
-
-## Note on generating the docstrings
-
-The autogenerated docstrings are checked with codespell in the CIs.
-when autogenerating them we need to run ``pre-commit run --all-files`` and fix the documentation issues found.
+Metadata-Version: 2.1
+Name: gsw
+Version: 3.6.17
+Summary: Gibbs Seawater Oceanographic Package of TEOS-10
+Author-email: "Eric Firing, Filipe Fernandes" <efiring@hawaii.edu>
+License: BSD-3-Clause
+Project-URL: documentation, https://teos-10.github.io/GSW-Python/
+Project-URL: homepage, https://www.teos-10.org/
+Project-URL: repository, https://github.com/TEOS-10/GSW-python
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Topic :: Scientific/Engineering
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+Requires-Dist: numpy (>=1.21)
+
+# GSW-Python
+
+[![Tests](https://github.com/TEOS-10/GSW-Python/actions/workflows/tests.yml/badge.svg)](https://github.com/TEOS-10/GSW-Python/actions/workflows/tests.yml)
+[![Wheels](https://github.com/TEOS-10/GSW-Python/actions/workflows/cibuildwheel.yml/badge.svg)](https://github.com/TEOS-10/GSW-Python/actions/workflows/cibuildwheel.yml)
+[![DOI](https://zenodo.org/badge/86503067.svg)](https://zenodo.org/badge/latestdoi/86503067)
+
+
+This Python implementation of the Thermodynamic Equation of Seawater 2010 (TEOS-10) is based primarily on numpy ufunc wrappers of the GSW-C implementation.
+This library replaces the original [python-gsw](https://github.com/TEOS-10/python-gsw) pure-python implementation..
+The primary reasons for this change are that by building on the C implementation we reduce code duplication and we gain an immediate update to the 75-term equation.  
+Additional benefits include a major increase in speed,
+a reduction in memory usage,
+and the inclusion of more functions.
+The penalty is that a C (or MSVC C++ for Windows) compiler is required to build the package from source.
+
+**Warning: this is for Python >=3.8 only.**
+
+Documentation is provided at https://teos-10.github.io/GSW-Python/.
+
+For the core functionality, we use an auto-generated C extension
+module to wrap the C functions as numpy [ufuncs](https://docs.scipy.org/doc/numpy/reference/ufuncs.html),
+and then use an autogenerated Python module to add docstrings and handle masked arrays.
+165 scalar C functions with only double-precision arguments and return values are wrapped as ufuncs,
+and 158 of these are exposed in the ``gsw`` namespace with an additional wrapper in Python.
+
+A hand-written wrapper is used for one C function, and others are re-implemented directly in Python instead of being wrapped.
+Additional functions present in GSW-Matlab but not in GSW-C may be re-implemented in Python,
+but there is no expectation that all such functions will be provided.
+
+## Installation
+
+Pip users can install the pre-built wheels with:
+
+```shell
+pip install gsw
+```
+
+conda users will find binaries on conda-forge,
+
+```shell
+conda install gsw --channel conda-forge
+```
+
+The development version of the package can be installed from a clone of the repo using
+
+```shell
+pip install .
+```
+
+It is neither necessary nor recommended to run the code generators,
+and no instructions are provided for them;
+their output is included in the repo.
+You will need a suitable compiler:
+gcc or clang for unix-like systems,
+or the MSVC compiler set used for Python itself on Windows.
+For Windows, some of the source code has been modified to C++ because the MSVC C compiler does not support the
+C99 complex data type used in original GSW-C.
+
+To test, after installation, run "pytest" from the source directory.
+
+## Note for xarray users
+
+A wrapper around gsw called [gsw-xarray](https://github.com/DocOtak/gsw-xarray) exists for xarray.
+It adds CF compliant attributes when possible, units, and name.
+
+## Note on generating the docstrings
+
+The autogenerated docstrings are checked with codespell in the CIs.
+when autogenerating them we need to run ``pre-commit run --all-files`` and fix the documentation issues found.
```

## Comparing `gsw-3.6.16.post1.dist-info/RECORD` & `gsw-3.6.17.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,31 +1,32 @@
-gsw/__init__.py,sha256=Mq6o_b6wJaNcNczRzjDbE1ujRHPAVNcm8Zhf4noFrMQ,1934
-gsw/_fixed_wrapped_ufuncs.py,sha256=wEJp2H3DU7FxcArGjULq_1Nz648BP5qgWy9bNzahrpE,595
-gsw/_gsw_ufuncs.cp39-win_amd64.pyd,sha256=aSH93VYLCXN2ZnKNORoaPtbZV7zpM47KJJ5gdF7BKOU,3181568
-gsw/_utilities.py,sha256=KqrRRtdnGGTWQ07B1O56udLRofypBJ3Ikh9v1gsT5_g,8598
-gsw/_version.py,sha256=aocxCSGTPF0r0qOR5qbeLZqH4ZmdDQliiMjkguEEO3Q,28
-gsw/_wrapped_ufuncs.py,sha256=uSCHmveHO89KVc5s1uW42FMyd1Bn0EcxsE2QID097Xw,136273
-gsw/conversions.py,sha256=ITsCOmCCSgf2ZqQfSLUCEMFpoX_vzc4fgqtPm3DXCTE,1873
-gsw/density.py,sha256=84-msb2Znfab3G3BGA6OjVrUeoW9eZJabBOHWlAECYg,485
+gsw/__init__.py,sha256=BVtaklKiYB_TQLaaFulqDZV1TUC3xqTiVQV1UqhdiYM,1876
+gsw/_fixed_wrapped_ufuncs.py,sha256=BGAjTpEi36OMLJ1X-BEaCIGQcIIcBoJq7g6TJHqlYBM,1443
+gsw/_gsw_ufuncs.cp39-win_amd64.pyd,sha256=Piv91NeJqtE1qAFrYT_EiT11d2c280ovBNWBPmh-Bsc,3181568
+gsw/_utilities.py,sha256=k0PM6HXwM6_Rg2fQpJTI30e5335-V8fXk7g9fcCtUxE,9036
+gsw/_version.py,sha256=33GrQX-ZTcvSkf_wt8ofhGQl9xXFZsrANps-GY3HnzQ,22
+gsw/_wrapped_ufuncs.py,sha256=gV6mJ_8vgySQwJ4llWYDTZdcgtVjM0q9Rmo9_1eFLJM,156058
+gsw/conversions.py,sha256=WkpDaJ5eK7lukbejdBVavtNCPmu8dIWaSLmpUnnW6p4,1983
+gsw/density.py,sha256=ZlMDew9ZHLJFQavh3W1oaX4_BYKQB1dnGZwUAVtIwP4,549
 gsw/energy.py,sha256=2V9BMUK0xXxg6IkMPgPj30sCZOd2Q4DvVNLcSnPL8jQ,192
-gsw/freezing.py,sha256=Bk_Afmx_uCLEKGzG8DPKDXjpDLXpqhjO_-ksCK5vymU,533
-gsw/geostrophy.py,sha256=j_55_6gSM_rYfGdDSO_HyUuypUnRD1YsNShxc8tVhHE,10494
-gsw/ice.py,sha256=Ot861v0Mrtv_kc7p_DPGV6-MZhZEaLuqUuC7vVaYlQ0,951
-gsw/stability.py,sha256=B4sY1A3vv0fvndMZTWv2D0lDUUNrKOJsAzwvSt6o7SQ,6305
-gsw/utility.py,sha256=-COndGFTF-nwIQVps5GbN0wl1a19Wcp74vf2HqkRO3A,2001
-gsw/tests/_WIP_test_ufuncs.py,sha256=QVXEPEFo736qTbhuw5GtakfigWbtMGkEYo5DDNGuYAw,2880
-gsw/tests/check_functions.py,sha256=QsDyXaytk71C5rkVXM8X6rhD84SYvsvNR7OHis1XrKA,11630
+gsw/freezing.py,sha256=rZO4JpYGcSqsZp9k-vUmgJCmdbUU-DCIzBeNhSgBCNM,597
+gsw/geostrophy.py,sha256=M-3QYQ66vEbzYE4E4rZZJSKvZjyF88cqRVpZHPWrS2Q,10375
+gsw/ice.py,sha256=XPTicuWxGuW5p_Nc5aXynkkdsVYljZGeTghD0eKLPTY,1083
+gsw/stability.py,sha256=4E4A6pjp_5bkO5GDoRh6eTbaaUhYtVPeKqLskG9T_GU,6305
+gsw/utility.py,sha256=zNAdu9jCIcTe9uXxtsZVWAxx8M8Nrygnnzom6hqo7ec,1981
+gsw/tests/_WIP_test_ufuncs.py,sha256=-G9brNXcQwoFmmCuV6A-2hk0qs_WIHHBKV4N9zC4sSg,2873
+gsw/tests/check_functions.py,sha256=Qsvb2FsNv3bFzgBx_ulkBDhhVhFyxQXu_UGcp6Cxce4,11619
 gsw/tests/geo_strf_dyn_height.npy,sha256=_g_XE-BksZ9jmDbLt7_picIwpqYI6NiREHMrEz-6T28,1208
 gsw/tests/geo_strf_velocity.npy,sha256=QJzDLTxk2sqy5SCF7orUy1wiCq3Jw0dFH4ZS5J7KLJs,848
 gsw/tests/gsw_check_functions_save.m,sha256=zVdYibVVPmsqbFuA69Me77tcX8L3NtSsoeGenB_WVus,116294
 gsw/tests/gsw_cv_v3_0.npz,sha256=QC2apKztRXtTQCg5cIpA69n3ry98AmBKSvTOV_faoe4,641918
-gsw/tests/list_check_functions.py,sha256=mQvpfSuQ_7Qvqpl9irTGVgEjuqUzVermQJdRA9s6klo,1094
-gsw/tests/test_check_functions.py,sha256=FNJwIQoaLAtiXvUbwcaHeeEB6bLx7Jf3J37ACsR7Ywc,2597
-gsw/tests/test_geostrophy.py,sha256=5_9_VUjy3Gbz8oHSNb191h0YQM-6SknrT6QmakjBhZ0,3543
-gsw/tests/test_utility.py,sha256=lleDzwKQ-pP741h0Lx6IV5__n8ZMG8rvd63TNyavJHs,722
-gsw/tests/test_xarray.py,sha256=nDmRSyCVDVJFGfsNY4a-X3lIDD99CC5ONu6nXLAQ8Ls,5095
-gsw/tests/write_geo_npyfiles.py,sha256=OGEuuhMrXJtNbPpejC-BCjd5R3bGSNr9H9MgwkJjECA,1182
-gsw-3.6.16.post1.dist-info/LICENSE.txt,sha256=UEJGpNIisA5KO4FrcYDSIycKGxiSXHm80rJ_pBvD57k,1885
-gsw-3.6.16.post1.dist-info/METADATA,sha256=eWajtr-oeRsAOZeBUggSwC34eFLgvRc2gKHehGaMbsE,4083
-gsw-3.6.16.post1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
-gsw-3.6.16.post1.dist-info/top_level.txt,sha256=WNVgoXPc8oGq7Pq3hqjy39r9KgVM0F2qz3ckmDBJJSE,4
-gsw-3.6.16.post1.dist-info/RECORD,,
+gsw/tests/list_check_functions.py,sha256=2DzAKXbbNg7lLha4CGE839hRpoLUZMbB6kJqi7yivGI,1094
+gsw/tests/test_check_functions.py,sha256=nFotArB-1P_MQQ_4noAseCXO2euOfZc7vCykfhvIwKY,2597
+gsw/tests/test_geostrophy.py,sha256=9HD3zTRqnIuCH5B3slXSUWZalDiFY-sj0eN7mBdVpr0,3543
+gsw/tests/test_gibbs.py,sha256=vko066UXuxm2dNTnJDZJT-C_WLr04Eqsu8jNbDHjq4s,2730
+gsw/tests/test_utility.py,sha256=Ac-I7-fQtTlyibmAqn12HoaDZnlk1YwrLyoYL5_kjdI,720
+gsw/tests/test_xarray.py,sha256=YUBIoebzok1NcXS1EBhl5jc8FFxx4DpF_3vFa86AJi8,5385
+gsw/tests/write_geo_npyfiles.py,sha256=JG7Xiw-brkmP6Z5AfNIYfhA9hKWCP7wtIuCEB7k4pVY,1184
+gsw-3.6.17.dist-info/LICENSE.txt,sha256=UEJGpNIisA5KO4FrcYDSIycKGxiSXHm80rJ_pBvD57k,1885
+gsw-3.6.17.dist-info/METADATA,sha256=W9GGJnl1w8-KESj_zW9QC37xSdwHB64pm1sSDQbEckk,4321
+gsw-3.6.17.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
+gsw-3.6.17.dist-info/top_level.txt,sha256=WNVgoXPc8oGq7Pq3hqjy39r9KgVM0F2qz3ckmDBJJSE,4
+gsw-3.6.17.dist-info/RECORD,,
```

